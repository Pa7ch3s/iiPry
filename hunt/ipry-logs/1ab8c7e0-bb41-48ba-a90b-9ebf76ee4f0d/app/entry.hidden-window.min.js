"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// config/config.json
var config_default;
var init_config = __esm({
  "config/config.json"() {
    config_default = {
      name: "insomnia",
      appId: "com.insomnia.app",
      userDataFolder: "Insomnia",
      productName: "Insomnia",
      synopsis: "The Collaborative API Client and Design Tool",
      icon: "https://github.com/kong/insomnia/blob/develop/packages/insomnia/src/icons/icon.ico?raw=true",
      theme: "default",
      lightTheme: "studio-light",
      darkTheme: "default",
      githubOrg: "Kong",
      githubRepo: "insomnia",
      segmentWriteKeys: {
        development: "rTOCSvGV23cHGJyb3HI9EUQDNA6ar7ay",
        production: "4l7QUfACrIcqvC913hiIwAA2BDYP2OJ1"
      },
      bundlePlugins: [
        {
          name: "@kong/insomnia-plugin-external-vault"
        },
        {
          name: "@kong/insomnia-plugin-ai"
        }
      ],
      sentryDsn: "https://aaec2e800e644070a8daba5b7ad02c16@o1147619.ingest.sentry.io/6311804"
    };
  }
});

// package.json
var version;
var init_package = __esm({
  "package.json"() {
    version = "12.1.0";
  }
});

// src/common/constants.ts
var ENV, env, INSOMNIA_GITLAB_REDIRECT_URI, INSOMNIA_GITLAB_CLIENT_ID, INSOMNIA_GITLAB_API_URL, PLAYWRIGHT, getAppVersion, getAppPlatform, isMac, getAppEnvironment, getSentryDsn, STATUS_CODE_PLUGIN_ERROR, CHECK_FOR_UPDATES_INTERVAL, MNEMONIC_SYM, PREVIEW_MODE_FRIENDLY, PREVIEW_MODE_SOURCE, PREVIEW_MODE_RAW, previewModeMap, PREVIEW_MODES, CONTENT_TYPE_JSON, CONTENT_TYPE_PLAINTEXT, CONTENT_TYPE_XML, CONTENT_TYPE_YAML, CONTENT_TYPE_EDN, CONTENT_TYPE_FORM_URLENCODED, CONTENT_TYPE_FORM_DATA, CONTENT_TYPE_FILE, CONTENT_TYPE_GRAPHQL, CONTENT_TYPE_OTHER, contentTypesMap, RESPONSE_CODE_DESCRIPTIONS, RESPONSE_CODE_REASONS;
var init_constants = __esm({
  "src/common/constants.ts"() {
    "use strict";
    init_config();
    init_package();
    ENV = "env";
    env = process[ENV];
    INSOMNIA_GITLAB_REDIRECT_URI = env.INSOMNIA_GITLAB_REDIRECT_URI;
    INSOMNIA_GITLAB_CLIENT_ID = env.INSOMNIA_GITLAB_CLIENT_ID;
    INSOMNIA_GITLAB_API_URL = env.INSOMNIA_GITLAB_API_URL;
    PLAYWRIGHT = env.PLAYWRIGHT;
    getAppVersion = () => version;
    getAppPlatform = () => process.platform;
    isMac = () => getAppPlatform() === "darwin";
    getAppEnvironment = () => process.env.INSOMNIA_ENV || "production";
    getSentryDsn = () => config_default.sentryDsn;
    STATUS_CODE_PLUGIN_ERROR = -222;
    CHECK_FOR_UPDATES_INTERVAL = 1e3 * 60 * 60 * 24;
    MNEMONIC_SYM = isMac() ? "" : "&";
    PREVIEW_MODE_FRIENDLY = "friendly";
    PREVIEW_MODE_SOURCE = "source";
    PREVIEW_MODE_RAW = "raw";
    previewModeMap = {
      [PREVIEW_MODE_FRIENDLY]: ["Preview", "Visual Preview"],
      [PREVIEW_MODE_SOURCE]: ["Source", "Source Code"],
      [PREVIEW_MODE_RAW]: ["Raw", "Raw Data"]
    };
    PREVIEW_MODES = Object.keys(previewModeMap);
    CONTENT_TYPE_JSON = "application/json";
    CONTENT_TYPE_PLAINTEXT = "text/plain";
    CONTENT_TYPE_XML = "application/xml";
    CONTENT_TYPE_YAML = "application/yaml";
    CONTENT_TYPE_EDN = "application/edn";
    CONTENT_TYPE_FORM_URLENCODED = "application/x-www-form-urlencoded";
    CONTENT_TYPE_FORM_DATA = "multipart/form-data";
    CONTENT_TYPE_FILE = "application/octet-stream";
    CONTENT_TYPE_GRAPHQL = "application/graphql";
    CONTENT_TYPE_OTHER = "";
    contentTypesMap = {
      [CONTENT_TYPE_EDN]: ["EDN", "EDN"],
      [CONTENT_TYPE_FILE]: ["File", "Binary File"],
      [CONTENT_TYPE_FORM_DATA]: ["Multipart", "Multipart Form"],
      [CONTENT_TYPE_FORM_URLENCODED]: ["Form", "Form URL Encoded"],
      [CONTENT_TYPE_GRAPHQL]: ["GraphQL", "GraphQL Query"],
      [CONTENT_TYPE_JSON]: ["JSON", "JSON"],
      [CONTENT_TYPE_OTHER]: ["Other", "Other"],
      [CONTENT_TYPE_PLAINTEXT]: ["Plain", "Plain"],
      [CONTENT_TYPE_XML]: ["XML", "XML"],
      [CONTENT_TYPE_YAML]: ["YAML", "YAML"]
    };
    RESPONSE_CODE_DESCRIPTIONS = {
      // Special
      [STATUS_CODE_PLUGIN_ERROR]: "An Insomnia plugin threw an error which prevented the request from sending",
      // 100s
      100: "This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.",
      101: "This code is sent in response to an Upgrade: request header by the client and indicates the protocol the server is switching to.",
      // 200s
      200: "The request has succeeded.",
      201: "The request has succeeded and a new resource has been created as a result. This is typically the response sent after POST requests, or some PUT requests.",
      202: "The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.",
      203: "This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.",
      204: "There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.",
      205: "This response code is sent after accomplishing request to tell user agent reset document view which sent this request.",
      206: "This response code is used because of range header sent by the client to separate download into multiple streams.",
      207: "A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.",
      208: "Used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly.",
      226: "The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.",
      // 300s
      300: "The request has more than one possible responses. User-agent or user should choose one of them. There is no standardized way to choose one of the responses.",
      301: "This response code means that URI of requested resource has been changed. Probably, new URI would be given in the response.",
      302: "This response code means that URI of requested resource has been changed temporarily. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.",
      303: "Server sent this response to directing client to get requested resource to another URI with an GET request.",
      304: "This is used for caching purposes. It is telling to client that response has not been modified. So, client can continue to use same cached version of response.",
      305: "This means requested response must be accessed by a proxy. This response code is not largely supported because of security reasons.",
      306: "This response code is no longer used and is just reserved currently. It was used in a previous version of the HTTP 1.1 specification.",
      307: "Server sent this response to directing client to get requested resource to another URI with same method that used prior request. This has the same semantic than the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.",
      308: "This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.",
      // 400s
      400: "This response means that the server could not understand the request due to invalid syntax.",
      401: "Authentication is needed to get the requested response. This is similar to 403, but is different in that authentication is possible.",
      402: "This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems, but it is not used currently.",
      403: "Client does not have access rights to the content, so the server is rejecting to give proper response.",
      404: "Server cannot find requested resource. This response code is probably the most famous one due to how frequently it occurs on the web.",
      405: "The request method is known by the server but has been disabled and cannot be used.",
      406: "This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content following the criteria given by the user agent.",
      407: "This is similar to 401 but authentication is needed to be done by a proxy.",
      408: "This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome or IE9, use HTTP pre-connection mechanisms to speed up surfing (see bug 881804, which tracks the future implementation of such a mechanism in Firefox). Also, note that some servers merely shut down the connection without sending this message.",
      409: "This response is sent when a request conflicts with the current state of the server.",
      410: "This response is sent when the requested content has been deleted from the server.",
      411: "Server rejected the request because the Content-Length header field is not defined and the server requires it.",
      412: "The client has indicated preconditions in its headers which the server does not meet.",
      413: "Request entity is larger than limits defined by the server; the server might close the connection or return a Retry-After header field.",
      414: "The URI requested by the client is longer than the server is willing to interpret.",
      415: "The media format of the requested data is not supported by the server, so the server is rejecting the request.",
      416: "The range specified by the Range header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.",
      417: "This response code means the expectation indicated by the Expect request header field can't be met by the server.",
      418: `Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout.`,
      421: "The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.",
      422: "The request was well-formed but was unable to be followed due to semantic errors.",
      423: "The resource that is being accessed is locked.",
      424: "The request failed due to failure of a previous request.",
      426: "The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 6.7 of [RFC7230]).",
      428: `The origin server requires the request to be conditional. Intended to prevent "the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict."`,
      429: 'The user has sent too many requests in a given amount of time ("rate limiting").',
      431: "The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.",
      451: "The user requests an illegal resource, such as a web page censored by a government.",
      // 500s
      500: "The server has encountered a situation it doesn't know how to handle.",
      501: "The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD.",
      502: "This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.",
      503: "The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the Retry-After: HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.",
      504: "This error response is given when the server is acting as a gateway and cannot get a response in time.",
      505: "The HTTP version used in the request is not supported by the server.",
      506: "The server has an internal configuration error: transparent content negotiation for the request results in a circular reference.",
      507: "The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.",
      508: "The server detected an infinite loop while processing the request.",
      509: "The server has exceeded the bandwidth specified by the server administrator; this is often used by shared hosting providers to limit the bandwidth of customers.",
      510: "Further extensions to the request are required for the server to fulfill it.",
      511: "The 511 status code indicates that the client needs to authenticate to gain network access.",
      598: "Used by some HTTP proxies to signal a network read timeout behind the proxy to a client in front of the proxy.",
      599: "An error used by some HTTP proxies to signal a network connect timeout behind the proxy to a client in front of the proxy."
    };
    RESPONSE_CODE_REASONS = {
      // Special
      [STATUS_CODE_PLUGIN_ERROR]: "Plugin Error",
      // 100s
      100: "Continue",
      101: "Switching Protocols",
      // 200s
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      208: "Already Reported",
      226: "IM Used",
      // 300s
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      306: "Switch Proxy",
      307: "Temporary Redirect",
      308: "Permanent Redirect",
      // 400s
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Payload Too Large",
      414: "URI Too Long",
      415: "Unsupported Media Type",
      416: "Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a Teapot",
      421: "Misdirected Request",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Too Early",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      451: "Unavailable For Legal Reasons",
      // 500s
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      508: "Loop Detected",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required",
      598: "Network read timeout error",
      599: "Network Connect Timeout Error"
    };
  }
});

// ../../node_modules/clone/clone.js
var require_clone = __commonJS({
  "../../node_modules/clone/clone.js"(exports2, module2) {
    var clone5 = (function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_2) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_2) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_2) {
        nativePromise = function() {
        };
      }
      function clone6(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject2) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject2(_clone(err, depth2 - 1));
              });
            });
          } else if (clone6.__isArray(parent2)) {
            child = [];
          } else if (clone6.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone6.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i2 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i2);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i2] = _clone(parent2[i2], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              var symbol = symbols[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
              var propertyName = allPropertyNames[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone6.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o2) {
        return Object.prototype.toString.call(o2);
      }
      clone6.__objToStr = __objToStr;
      function __isDate(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
      }
      clone6.__isDate = __isDate;
      function __isArray(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
      }
      clone6.__isArray = __isArray;
      function __isRegExp(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
      }
      clone6.__isRegExp = __isRegExp;
      function __getRegExpFlags(re3) {
        var flags = "";
        if (re3.global) flags += "g";
        if (re3.ignoreCase) flags += "i";
        if (re3.multiline) flags += "m";
        return flags;
      }
      clone6.__getRegExpFlags = __getRegExpFlags;
      return clone6;
    })();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone5;
    }
  }
});

// ../../node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments2(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../../node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has2 = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o2) {
        var ctor = o2.constructor;
        return ctor && ctor.prototype === o2;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = (function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k2 in window) {
          try {
            if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
              try {
                equalsConstructorPrototype(window[k2]);
              } catch (e2) {
                return true;
              }
            }
          } catch (e2) {
            return true;
          }
        }
        return false;
      })();
      equalsConstructorPrototypeIfNotBuggy = function(o2) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o2);
        }
        try {
          return equalsConstructorPrototype(o2);
        } catch (e2) {
          return false;
        }
      };
      keysShim = function keys2(object) {
        var isObject2 = object !== null && typeof object === "object";
        var isFunction3 = toStr.call(object) === "[object Function]";
        var isArguments2 = isArgs(object);
        var isString3 = isObject2 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject2 && !isFunction3 && !isArguments2) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction3;
        if (isString3 && object.length > 0 && !has2.call(object, 0)) {
          for (var i2 = 0; i2 < object.length; ++i2) {
            theKeys.push(String(i2));
          }
        }
        if (isArguments2 && object.length > 0) {
          for (var j3 = 0; j3 < object.length; ++j3) {
            theKeys.push(String(j3));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has2.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k2 = 0; k2 < dontEnums.length; ++k2) {
            if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object, dontEnums[k2])) {
              theKeys.push(dontEnums[k2]);
            }
          }
        }
        return theKeys;
      };
    }
    var has2;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// ../../node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "../../node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice2 = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys2(o2) {
      return origKeys(o2);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = (function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        })(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys2(object) {
            if (isArgs(object)) {
              return originalKeys(slice2.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e2) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// ../../node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../../node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property2, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property2 !== "string" && typeof property2 !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property2);
      if ($defineProperty) {
        $defineProperty(obj, property2, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property2] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// ../../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e2) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../../node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys2 = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat2 = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction3 = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction3(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map2) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys2(map2);
      if (hasSymbols) {
        props = concat2.call(props, Object.getOwnPropertySymbols(map2));
      }
      for (var i2 = 0; i2 < props.length; i2 += 1) {
        defineProperty(object, props[i2], map2[props[i2]], predicates[props[i2]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN3(a2) {
      return a2 !== a2;
    };
  }
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _2 in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max2 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a2, b2) {
      var arr = [];
      for (var i2 = 0; i2 < a2.length; i2 += 1) {
        arr[i2] = a2[i2];
      }
      for (var j3 = 0; j3 < b2.length; j3 += 1) {
        arr[j3 + a2.length] = b2[j3];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i2 = offset || 0, j3 = 0; i2 < arrLike.length; i2 += 1, j3 += 1) {
        arr[j3] = arrLike[i2];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        str += arr[i2];
        if (i2 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max2(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs[i2] = "$" + i2;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind2.call($call, $apply);
  }
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind2, $call, args);
    };
  }
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e2) {
      if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
        throw e2;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O3) {
      return reflectGetProto(O3);
    } : originalGetProto ? function getProto(O3) {
      if (!O3 || typeof O3 !== "object" && typeof O3 !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O3);
    } : getDunderProto ? function getProto(O3) {
      return getDunderProto(O3);
    } : null;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module2.exports = bind2.call(call, $hasOwn);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor2 = require_floor();
    var max2 = require_max();
    var min2 = require_min();
    var pow = require_pow();
    var round2 = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e2) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor2,
      "%Math.max%": max2,
      "%Math.min%": min2,
      "%Math.pow%": pow,
      "%Math.round%": round2,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind2.call($call, Array.prototype.concat);
    var $spliceApply = bind2.call($apply, Array.prototype.splice);
    var $replace = bind2.call($call, String.prototype.replace);
    var $strSlice = bind2.call($call, String.prototype.slice);
    var $exec = bind2.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last3 = $strSlice(string, -1);
      if (first === "%" && last3 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last3 === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result2 = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result2;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last3 = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last3 === '"' || last3 === "'" || last3 === "`")) && first !== last3) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../../node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// ../../node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "../../node_modules/call-bind-apply-helpers/applyBind.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module2.exports = function applyBind() {
      return actualApply(bind2, $apply, arguments);
    };
  }
});

// ../../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module2.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "../../node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// ../../node_modules/object.assign/implementation.js
var require_implementation3 = __commonJS({
  "../../node_modules/object.assign/implementation.js"(exports2, module2) {
    "use strict";
    var objectKeys = require_object_keys();
    var hasSymbols = require_shams()();
    var callBound = require_call_bound();
    var $Object = require_es_object_atoms();
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;
    module2.exports = function assign2(target, source1) {
      if (target == null) {
        throw new TypeError("target must be an object");
      }
      var to = $Object(target);
      if (arguments.length === 1) {
        return to;
      }
      for (var s2 = 1; s2 < arguments.length; ++s2) {
        var from = $Object(arguments[s2]);
        var keys2 = objectKeys(from);
        var getSymbols2 = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols2) {
          var syms = getSymbols2(from);
          for (var j3 = 0; j3 < syms.length; ++j3) {
            var key = syms[j3];
            if ($propIsEnumerable(from, key)) {
              $push(keys2, key);
            }
          }
        }
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          var nextKey = keys2[i2];
          if ($propIsEnumerable(from, nextKey)) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    };
  }
});

// ../../node_modules/object.assign/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/object.assign/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    var lacksProperEnumerationOrder = function() {
      if (!Object.assign) {
        return false;
      }
      var str = "abcdefghijklmnopqrst";
      var letters = str.split("");
      var map2 = {};
      for (var i2 = 0; i2 < letters.length; ++i2) {
        map2[letters[i2]] = letters[i2];
      }
      var obj = Object.assign({}, map2);
      var actual = "";
      for (var k2 in obj) {
        actual += k2;
      }
      return str !== actual;
    };
    var assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions) {
        return false;
      }
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e2) {
        return thrower[1] === "y";
      }
      return false;
    };
    module2.exports = function getPolyfill() {
      if (!Object.assign) {
        return implementation;
      }
      if (lacksProperEnumerationOrder()) {
        return implementation;
      }
      if (assignHasPendingExceptions()) {
        return implementation;
      }
      return Object.assign;
    };
  }
});

// ../../node_modules/object.assign/shim.js
var require_shim = __commonJS({
  "../../node_modules/object.assign/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill();
    module2.exports = function shimAssign() {
      var polyfill = getPolyfill();
      define2(
        Object,
        { assign: polyfill },
        { assign: function() {
          return Object.assign !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// ../../node_modules/object.assign/index.js
var require_object = __commonJS({
  "../../node_modules/object.assign/index.js"(exports2, module2) {
    "use strict";
    var defineProperties = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind.apply(getPolyfill());
    var bound = function assign2(target, source1) {
      return polyfill(Object, arguments);
    };
    defineProperties(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});

// ../../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// ../../node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "../../node_modules/functions-have-names/index.js"(exports2, module2) {
    "use strict";
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f3() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e2) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f3() {
      }.bind().name !== "";
    };
    module2.exports = functionsHaveNames;
  }
});

// ../../node_modules/set-function-name/index.js
var require_set_function_name = __commonJS({
  "../../node_modules/set-function-name/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $TypeError = require_type();
    module2.exports = function setFunctionName(fn, name) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      if (!loose || functionsHaveConfigurableNames) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "name",
            name,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "name",
            name
          );
        }
      }
      return fn;
    };
  }
});

// ../../node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "../../node_modules/regexp.prototype.flags/implementation.js"(exports2, module2) {
    "use strict";
    var setFunctionName = require_set_function_name();
    var $TypeError = require_type();
    var $Object = Object;
    module2.exports = setFunctionName(function flags() {
      if (this == null || this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result2 = "";
      if (this.hasIndices) {
        result2 += "d";
      }
      if (this.global) {
        result2 += "g";
      }
      if (this.ignoreCase) {
        result2 += "i";
      }
      if (this.multiline) {
        result2 += "m";
      }
      if (this.dotAll) {
        result2 += "s";
      }
      if (this.unicode) {
        result2 += "u";
      }
      if (this.unicodeSets) {
        result2 += "v";
      }
      if (this.sticky) {
        result2 += "y";
      }
      return result2;
    }, "get flags", true);
  }
});

// ../../node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "../../node_modules/regexp.prototype.flags/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module2.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && "dotAll" in RegExp.prototype && "hasIndices" in RegExp.prototype) {
          var calls = "";
          var o2 = {};
          Object.defineProperty(o2, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o2, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          descriptor.get.call(o2);
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// ../../node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "../../node_modules/regexp.prototype.flags/shim.js"(exports2, module2) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = require_gopd();
    var defineProperty = Object.defineProperty;
    var $TypeError = require_es_errors();
    var getProto = require_get_proto();
    var regex = /a/;
    module2.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new $TypeError("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// ../../node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "../../node_modules/regexp.prototype.flags/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(getPolyfill());
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = flagsBound;
  }
});

// ../../node_modules/es-get-iterator/node.js
var require_node = __commonJS({
  "../../node_modules/es-get-iterator/node.js"(exports2, module2) {
    "use strict";
    var $iterator = Symbol.iterator;
    module2.exports = function getIterator(iterable) {
      if (iterable != null && typeof iterable[$iterator] !== "undefined") {
        return iterable[$iterator]();
      }
    };
  }
});

// ../../node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "../../node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    module2.exports = require("util").inspect;
  }
});

// ../../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString2 = Object.prototype.toString;
    var functionToString2 = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O3) {
      return O3.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol3(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has2(opts, "quoteStyle") && !has2(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has2(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf2(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has2(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp4(obj)) {
        var name = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol3(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement3(obj)) {
        var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i2 = 0; i2 < attrs.length; i2++) {
          s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
        }
        s2 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s2 += "...";
        }
        s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s2;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError3(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap3(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet3(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap3(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet3(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString3(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate4(obj) && !isRegExp4(obj)) {
        var ys2 = arrObjKeys(obj, inspect);
        var isPlainObject4 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag2 = !isPlainObject4 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject4 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
        if (ys2.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys2, indent) + "}";
        }
        return tag + "{ " + $join.call(ys2, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s2, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s2 + quoteChar;
    }
    function quote(s2) {
      return $replace.call(String(s2), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate4(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp4(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError3(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString3(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol3(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has2(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString2.call(obj);
    }
    function nameOf(f3) {
      if (f3.name) {
        return f3.name;
      }
      var m3 = $match.call(functionToString2.call(f3), /^function\s*([\w$]+)/);
      if (m3) {
        return m3[1];
      }
      return null;
    }
    function indexOf2(xs, x3) {
      if (xs.indexOf) {
        return xs.indexOf(x3);
      }
      for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
        if (xs[i2] === x3) {
          return i2;
        }
      }
      return -1;
    }
    function isMap3(x3) {
      if (!mapSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        mapSize.call(x3);
        try {
          setSize.call(x3);
        } catch (s2) {
          return true;
        }
        return x3 instanceof Map;
      } catch (e2) {
      }
      return false;
    }
    function isWeakMap3(x3) {
      if (!weakMapHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x3, weakMapHas);
        try {
          weakSetHas.call(x3, weakSetHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakMap;
      } catch (e2) {
      }
      return false;
    }
    function isWeakRef(x3) {
      if (!weakRefDeref || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x3);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isSet3(x3) {
      if (!setSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        setSize.call(x3);
        try {
          mapSize.call(x3);
        } catch (m3) {
          return true;
        }
        return x3 instanceof Set;
      } catch (e2) {
      }
      return false;
    }
    function isWeakSet3(x3) {
      if (!weakSetHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x3, weakSetHas);
        try {
          weakMapHas.call(x3, weakMapHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakSet;
      } catch (e2) {
      }
      return false;
    }
    function isElement3(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x3 instanceof HTMLElement) {
        return true;
      }
      return typeof x3.nodeName === "string" && typeof x3.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s2 = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s2, "single", opts);
    }
    function lowbyte(c2) {
      var n2 = c2.charCodeAt(0);
      var x3 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n2];
      if (x3) {
        return "\\" + x3;
      }
      return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size2, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size2 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i2 = 0; i2 < xs.length; i2++) {
        if (indexOf2(xs[i2], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i2 = 0; i2 < obj.length; i2++) {
          xs[i2] = has2(obj, i2) ? inspect(obj[i2], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k2 = 0; k2 < syms.length; k2++) {
          symMap["$" + syms[k2]] = syms[k2];
        }
      }
      for (var key in obj) {
        if (!has2(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j3 = 0; j3 < syms.length; j3++) {
          if (isEnumerable.call(obj, syms[j3])) {
            xs.push("[" + inspect(syms[j3]) + "]: " + inspect(obj[syms[j3]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../../node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "../../node_modules/side-channel-list/index.js"(exports2, module2) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node3 = listGetNode(objects, key);
      return node3 && node3.value;
    };
    var listSet = function(objects, key, value) {
      var node3 = listGetNode(objects, key);
      if (node3) {
        node3.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    };
    var listDelete = function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    };
    module2.exports = function getSideChannelList() {
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        },
        get: function(key) {
          return listGet($o, key);
        },
        has: function(key) {
          return listHas($o, key);
        },
        set: function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }
      };
      return channel;
    };
  }
});

// ../../node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "../../node_modules/side-channel-map/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module2.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    function getSideChannelMap() {
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($m) {
            var result2 = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result2;
          }
          return false;
        },
        get: function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        },
        has: function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        },
        set: function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }
      };
      return channel;
    };
  }
});

// ../../node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "../../node_modules/side-channel-weakmap/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module2.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          "delete": function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }
        };
        return channel;
      }
    ) : getSideChannelMap;
  }
});

// ../../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module2.exports = function getSideChannel() {
      var $channelData;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          return !!$channelData && $channelData["delete"](key);
        },
        get: function(key) {
          return $channelData && $channelData.get(key);
        },
        has: function(key) {
          return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }
      };
      return channel;
    };
  }
});

// ../../node_modules/object-is/implementation.js
var require_implementation5 = __commonJS({
  "../../node_modules/object-is/implementation.js"(exports2, module2) {
    "use strict";
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module2.exports = function is(a2, b2) {
      if (a2 === 0 && b2 === 0) {
        return 1 / a2 === 1 / b2;
      }
      if (a2 === b2) {
        return true;
      }
      if (numberIsNaN(a2) && numberIsNaN(b2)) {
        return true;
      }
      return false;
    };
  }
});

// ../../node_modules/object-is/polyfill.js
var require_polyfill3 = __commonJS({
  "../../node_modules/object-is/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation5();
    module2.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// ../../node_modules/object-is/shim.js
var require_shim3 = __commonJS({
  "../../node_modules/object-is/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill3();
    var define2 = require_define_properties();
    module2.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../../node_modules/object-is/index.js
var require_object_is = __commonJS({
  "../../node_modules/object-is/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim3();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "../../node_modules/is-arguments/index.js"(exports2, module2) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_call_bound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments2(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments2(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = (function() {
      return isStandardArguments(arguments);
    })();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// ../../node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../node_modules/isarray/index.js"(exports2, module2) {
    var toString2 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/is-array-buffer/index.js
var require_is_array_buffer = __commonJS({
  "../../node_modules/is-array-buffer/index.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var GetIntrinsic = require_get_intrinsic();
    var $ArrayBuffer = GetIntrinsic("%ArrayBuffer%", true);
    var $byteLength = callBound("ArrayBuffer.prototype.byteLength", true);
    var $toString = callBound("Object.prototype.toString");
    var abSlice = !!$ArrayBuffer && !$byteLength && new $ArrayBuffer(0).slice;
    var $abSlice = !!abSlice && callBind(abSlice);
    module2.exports = $byteLength || $abSlice ? function isArrayBuffer3(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      try {
        if ($byteLength) {
          $byteLength(obj);
        } else {
          $abSlice(obj, 0);
        }
        return true;
      } catch (e2) {
        return false;
      }
    } : $ArrayBuffer ? function isArrayBuffer3(obj) {
      return $toString(obj) === "[object ArrayBuffer]";
    } : function isArrayBuffer3(obj) {
      return false;
    };
  }
});

// ../../node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "../../node_modules/is-date-object/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var getDay = callBound("Date.prototype.getDay");
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var toStr = callBound("Object.prototype.toString");
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr(value) === dateClass;
    };
  }
});

// ../../node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "../../node_modules/is-regex/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var gOPD = require_gopd();
    var fn;
    if (hasToStringTag) {
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
      fn = function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = (
          /** @type {NonNullable<typeof gOPD>} */
          gOPD(
            /** @type {{ lastIndex?: unknown }} */
            value,
            "lastIndex"
          )
        );
        var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(
            value,
            /** @type {string} */
            /** @type {unknown} */
            badStringifier
          );
        } catch (e2) {
          return e2 === isRegexMarker;
        }
      };
    } else {
      $toString = callBound("Object.prototype.toString");
      regexClass = "[object RegExp]";
      fn = function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
    var $exec;
    var isRegexMarker;
    var throwRegexMarker;
    var badStringifier;
    var $toString;
    var regexClass;
    module2.exports = fn;
  }
});

// ../../node_modules/is-shared-array-buffer/index.js
var require_is_shared_array_buffer = __commonJS({
  "../../node_modules/is-shared-array-buffer/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var $byteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
    module2.exports = $byteLength ? function isSharedArrayBuffer(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      try {
        $byteLength(obj);
        return true;
      } catch (e2) {
        return false;
      }
    } : function isSharedArrayBuffer(_obj) {
      return false;
    };
  }
});

// ../../node_modules/is-string/index.js
var require_is_string = __commonJS({
  "../../node_modules/is-string/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var $strValueOf = callBound("String.prototype.valueOf");
    var tryStringObject = function tryStringObject2(value) {
      try {
        $strValueOf(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var $toString = callBound("Object.prototype.toString");
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isString3(value) {
      if (typeof value === "string") {
        return true;
      }
      if (!value || typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : $toString(value) === strClass;
    };
  }
});

// ../../node_modules/is-number-object/index.js
var require_is_number_object = __commonJS({
  "../../node_modules/is-number-object/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var $numToStr = callBound("Number.prototype.toString");
    var tryNumberObject = function tryNumberObject2(value) {
      try {
        $numToStr(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var $toString = callBound("Object.prototype.toString");
    var numClass = "[object Number]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isNumberObject(value) {
      if (typeof value === "number") {
        return true;
      }
      if (!value || typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryNumberObject(value) : $toString(value) === numClass;
    };
  }
});

// ../../node_modules/is-boolean-object/index.js
var require_is_boolean_object = __commonJS({
  "../../node_modules/is-boolean-object/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var $boolToStr = callBound("Boolean.prototype.toString");
    var $toString = callBound("Object.prototype.toString");
    var tryBooleanObject = function booleanBrandCheck(value) {
      try {
        $boolToStr(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var boolClass = "[object Boolean]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isBoolean2(value) {
      if (typeof value === "boolean") {
        return true;
      }
      if (value === null || typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryBooleanObject(value) : $toString(value) === boolClass;
    };
  }
});

// ../../node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS({
  "../../node_modules/safe-regex-test/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module2.exports = function regexTester(regex) {
      if (!isRegex(regex)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return function test2(s2) {
        return $exec(regex, s2) !== null;
      };
    };
  }
});

// ../../node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "../../node_modules/is-symbol/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var $toString = callBound("Object.prototype.toString");
    var hasSymbols = require_has_symbols()();
    var safeRegexTest = require_safe_regex_test();
    if (hasSymbols) {
      $symToStr = callBound("Symbol.prototype.toString");
      isSymString = safeRegexTest(/^Symbol\(.*\)$/);
      isSymbolObject = function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return isSymString($symToStr(value));
      };
      module2.exports = function isSymbol3(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (!value || typeof value !== "object" || $toString(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e2) {
          return false;
        }
      };
    } else {
      module2.exports = function isSymbol3(value) {
        return false;
      };
    }
    var $symToStr;
    var isSymString;
    var isSymbolObject;
  }
});

// ../../node_modules/has-bigints/index.js
var require_has_bigints = __commonJS({
  "../../node_modules/has-bigints/index.js"(exports2, module2) {
    "use strict";
    var $BigInt = typeof BigInt !== "undefined" && BigInt;
    module2.exports = function hasNativeBigInts() {
      return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
    };
  }
});

// ../../node_modules/is-bigint/index.js
var require_is_bigint = __commonJS({
  "../../node_modules/is-bigint/index.js"(exports2, module2) {
    "use strict";
    var hasBigInts = require_has_bigints()();
    if (hasBigInts) {
      bigIntValueOf = BigInt.prototype.valueOf;
      tryBigInt = function tryBigIntObject(value) {
        try {
          bigIntValueOf.call(value);
          return true;
        } catch (e2) {
        }
        return false;
      };
      module2.exports = function isBigInt(value) {
        if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
          return false;
        }
        if (typeof value === "bigint") {
          return true;
        }
        return tryBigInt(value);
      };
    } else {
      module2.exports = function isBigInt(value) {
        return false;
      };
    }
    var bigIntValueOf;
    var tryBigInt;
  }
});

// ../../node_modules/which-boxed-primitive/index.js
var require_which_boxed_primitive = __commonJS({
  "../../node_modules/which-boxed-primitive/index.js"(exports2, module2) {
    "use strict";
    var isString3 = require_is_string();
    var isNumber2 = require_is_number_object();
    var isBoolean2 = require_is_boolean_object();
    var isSymbol3 = require_is_symbol();
    var isBigInt = require_is_bigint();
    module2.exports = function whichBoxedPrimitive(value) {
      if (value == null || typeof value !== "object" && typeof value !== "function") {
        return null;
      }
      if (isString3(value)) {
        return "String";
      }
      if (isNumber2(value)) {
        return "Number";
      }
      if (isBoolean2(value)) {
        return "Boolean";
      }
      if (isSymbol3(value)) {
        return "Symbol";
      }
      if (isBigInt(value)) {
        return "BigInt";
      }
    };
  }
});

// ../../node_modules/is-map/index.js
var require_is_map = __commonJS({
  "../../node_modules/is-map/index.js"(exports2, module2) {
    "use strict";
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) {
      exported = function isMap3(x3) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isMap3(x3) {
        return false;
      };
    }
    module2.exports = exported || function isMap3(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x3);
        if ($setHas) {
          try {
            $setHas.call(x3);
          } catch (e2) {
            return true;
          }
        }
        return x3 instanceof $Map;
      } catch (e2) {
      }
      return false;
    };
  }
});

// ../../node_modules/is-set/index.js
var require_is_set = __commonJS({
  "../../node_modules/is-set/index.js"(exports2, module2) {
    "use strict";
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Set) {
      exported = function isSet3(x3) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$setHas) {
      exported = function isSet3(x3) {
        return false;
      };
    }
    module2.exports = exported || function isSet3(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        $setHas.call(x3);
        if ($mapHas) {
          try {
            $mapHas.call(x3);
          } catch (e2) {
            return true;
          }
        }
        return x3 instanceof $Set;
      } catch (e2) {
      }
      return false;
    };
  }
});

// ../../node_modules/is-weakmap/index.js
var require_is_weakmap = __commonJS({
  "../../node_modules/is-weakmap/index.js"(exports2, module2) {
    "use strict";
    var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
    var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
    var exported;
    if (!$WeakMap) {
      exported = function isWeakMap3(x3) {
        return false;
      };
    }
    var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
    var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isWeakMap3(x3) {
        return false;
      };
    }
    module2.exports = exported || function isWeakMap3(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        $mapHas.call(x3, $mapHas);
        if ($setHas) {
          try {
            $setHas.call(x3, $setHas);
          } catch (e2) {
            return true;
          }
        }
        return x3 instanceof $WeakMap;
      } catch (e2) {
      }
      return false;
    };
  }
});

// ../../node_modules/is-weakset/index.js
var require_is_weakset = __commonJS({
  "../../node_modules/is-weakset/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var $WeakSet = GetIntrinsic("%WeakSet%", true);
    var $setHas = callBound("WeakSet.prototype.has", true);
    if ($setHas) {
      $mapHas = callBound("WeakMap.prototype.has", true);
      module2.exports = function isWeakSet3(x3) {
        if (!x3 || typeof x3 !== "object") {
          return false;
        }
        try {
          $setHas(x3, $setHas);
          if ($mapHas) {
            try {
              $mapHas(x3, $mapHas);
            } catch (e2) {
              return true;
            }
          }
          return x3 instanceof $WeakSet;
        } catch (e2) {
        }
        return false;
      };
    } else {
      module2.exports = function isWeakSet3(x3) {
        return false;
      };
    }
    var $mapHas;
  }
});

// ../../node_modules/which-collection/index.js
var require_which_collection = __commonJS({
  "../../node_modules/which-collection/index.js"(exports2, module2) {
    "use strict";
    var isMap3 = require_is_map();
    var isSet3 = require_is_set();
    var isWeakMap3 = require_is_weakmap();
    var isWeakSet3 = require_is_weakset();
    module2.exports = function whichCollection(value) {
      if (value && typeof value === "object") {
        if (isMap3(value)) {
          return "Map";
        }
        if (isSet3(value)) {
          return "Set";
        }
        if (isWeakMap3(value)) {
          return "WeakMap";
        }
        if (isWeakSet3(value)) {
          return "WeakSet";
        }
      }
      return false;
    };
  }
});

// ../../node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "../../node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_2) {
        if (_2 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e2) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e2) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e2) {
        if (e2 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// ../../node_modules/for-each/index.js
var require_for_each = __commonJS({
  "../../node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i2 = 0, len = array.length; i2 < len; i2++) {
        if (hasOwnProperty.call(array, i2)) {
          if (receiver == null) {
            iterator(array[i2], i2, array);
          } else {
            iterator.call(receiver, array[i2], i2, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i2 = 0, len = string.length; i2 < len; i2++) {
        if (receiver == null) {
          iterator(string.charAt(i2), i2, string);
        } else {
          iterator.call(receiver, string.charAt(i2), i2, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k2 in object) {
        if (hasOwnProperty.call(object, k2)) {
          if (receiver == null) {
            iterator(object[k2], k2, object);
          } else {
            iterator.call(receiver, object[k2], k2, object);
          }
        }
      }
    };
    function isArray2(x3) {
      return toStr.call(x3) === "[object Array]";
    }
    module2.exports = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray2(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// ../../node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "../../node_modules/possible-typed-array-names/index.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// ../../node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "../../node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g2 = typeof globalThis === "undefined" ? global : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i2 = 0; i2 < possibleNames.length; i2++) {
        if (typeof g2[possibleNames[i2]] === "function") {
          out[out.length] = possibleNames[i2];
        }
      }
      return out;
    };
  }
});

// ../../node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "../../node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g2 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf2(array, value) {
      for (var i2 = 0; i2 < array.length; i2 += 1) {
        if (array[i2] === value) {
          return i2;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g2[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g2[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e2) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e2) {
            }
          }
        }
      );
      return found;
    };
    module2.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// ../../node_modules/array-buffer-byte-length/index.js
var require_array_buffer_byte_length = __commonJS({
  "../../node_modules/array-buffer-byte-length/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_call_bound();
    var $byteLength = callBound("ArrayBuffer.prototype.byteLength", true);
    var isArrayBuffer3 = require_is_array_buffer();
    module2.exports = function byteLength(ab) {
      if (!isArrayBuffer3(ab)) {
        return NaN;
      }
      return $byteLength ? $byteLength(ab) : ab.byteLength;
    };
  }
});

// ../insomnia-scripting-environment/node_modules/deep-equal/index.js
var require_deep_equal = __commonJS({
  "../insomnia-scripting-environment/node_modules/deep-equal/index.js"(exports2, module2) {
    "use strict";
    var assign2 = require_object();
    var callBound = require_callBound();
    var flags = require_regexp_prototype();
    var GetIntrinsic = require_get_intrinsic();
    var getIterator = require_node();
    var getSideChannel = require_side_channel();
    var is = require_object_is();
    var isArguments2 = require_is_arguments();
    var isArray2 = require_isarray();
    var isArrayBuffer3 = require_is_array_buffer();
    var isDate4 = require_is_date_object();
    var isRegex = require_is_regex();
    var isSharedArrayBuffer = require_is_shared_array_buffer();
    var objectKeys = require_object_keys();
    var whichBoxedPrimitive = require_which_boxed_primitive();
    var whichCollection = require_which_collection();
    var whichTypedArray = require_which_typed_array();
    var byteLength = require_array_buffer_byte_length();
    var sabByteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
    var $getTime = callBound("Date.prototype.getTime");
    var gPO = Object.getPrototypeOf;
    var $objToString = callBound("Object.prototype.toString");
    var $Set = GetIntrinsic("%Set%", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSize = callBound("Map.prototype.size", true);
    var $setAdd = callBound("Set.prototype.add", true);
    var $setDelete = callBound("Set.prototype.delete", true);
    var $setHas = callBound("Set.prototype.has", true);
    var $setSize = callBound("Set.prototype.size", true);
    function setHasEqualElement(set2, val1, opts, channel) {
      var i2 = getIterator(set2);
      var result2;
      while ((result2 = i2.next()) && !result2.done) {
        if (internalDeepEqual(val1, result2.value, opts, channel)) {
          $setDelete(set2, result2.value);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      if (typeof prim === "undefined") {
        return null;
      }
      if (typeof prim === "object") {
        return void 0;
      }
      if (typeof prim === "symbol") {
        return false;
      }
      if (typeof prim === "string" || typeof prim === "number") {
        return +prim === +prim;
      }
      return true;
    }
    function mapMightHaveLoosePrim(a2, b2, prim, item, opts, channel) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = $mapGet(b2, altValue);
      var looseOpts = assign2({}, opts, { strict: false });
      if (typeof curB === "undefined" && !$mapHas(b2, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
        return false;
      }
      return !$mapHas(a2, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
    }
    function setMightHaveLoosePrim(a2, b2, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      return $setHas(b2, altValue) && !$setHas(a2, altValue);
    }
    function mapHasEqualEntry(set2, map2, key1, item1, opts, channel) {
      var i2 = getIterator(set2);
      var result2;
      var key2;
      while ((result2 = i2.next()) && !result2.done) {
        key2 = result2.value;
        if (
          // eslint-disable-next-line no-use-before-define
          internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map2, key2), opts, channel)
        ) {
          $setDelete(set2, key2);
          return true;
        }
      }
      return false;
    }
    function internalDeepEqual(actual, expected, options, channel) {
      var opts = options || {};
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }
      var actualBoxed = whichBoxedPrimitive(actual);
      var expectedBoxed = whichBoxedPrimitive(expected);
      if (actualBoxed !== expectedBoxed) {
        return false;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is(actual, expected) : actual == expected;
      }
      var hasActual = channel.has(actual);
      var hasExpected = channel.has(expected);
      var sentinel;
      if (hasActual && hasExpected) {
        if (channel.get(actual) === channel.get(expected)) {
          return true;
        }
      } else {
        sentinel = {};
      }
      if (!hasActual) {
        channel.set(actual, sentinel);
      }
      if (!hasExpected) {
        channel.set(expected, sentinel);
      }
      return objEquiv(actual, expected, opts, channel);
    }
    function isBuffer3(x3) {
      if (!x3 || typeof x3 !== "object" || typeof x3.length !== "number") {
        return false;
      }
      if (typeof x3.copy !== "function" || typeof x3.slice !== "function") {
        return false;
      }
      if (x3.length > 0 && typeof x3[0] !== "number") {
        return false;
      }
      return !!(x3.constructor && x3.constructor.isBuffer && x3.constructor.isBuffer(x3));
    }
    function setEquiv(a2, b2, opts, channel) {
      if ($setSize(a2) !== $setSize(b2)) {
        return false;
      }
      var iA = getIterator(a2);
      var iB = getIterator(b2);
      var resultA;
      var resultB;
      var set2;
      while ((resultA = iA.next()) && !resultA.done) {
        if (resultA.value && typeof resultA.value === "object") {
          if (!set2) {
            set2 = new $Set();
          }
          $setAdd(set2, resultA.value);
        } else if (!$setHas(b2, resultA.value)) {
          if (opts.strict) {
            return false;
          }
          if (!setMightHaveLoosePrim(a2, b2, resultA.value)) {
            return false;
          }
          if (!set2) {
            set2 = new $Set();
          }
          $setAdd(set2, resultA.value);
        }
      }
      if (set2) {
        while ((resultB = iB.next()) && !resultB.done) {
          if (resultB.value && typeof resultB.value === "object") {
            if (!setHasEqualElement(set2, resultB.value, opts.strict, channel)) {
              return false;
            }
          } else if (!opts.strict && !$setHas(a2, resultB.value) && !setHasEqualElement(set2, resultB.value, opts.strict, channel)) {
            return false;
          }
        }
        return $setSize(set2) === 0;
      }
      return true;
    }
    function mapEquiv(a2, b2, opts, channel) {
      if ($mapSize(a2) !== $mapSize(b2)) {
        return false;
      }
      var iA = getIterator(a2);
      var iB = getIterator(b2);
      var resultA;
      var resultB;
      var set2;
      var key;
      var item1;
      var item2;
      while ((resultA = iA.next()) && !resultA.done) {
        key = resultA.value[0];
        item1 = resultA.value[1];
        if (key && typeof key === "object") {
          if (!set2) {
            set2 = new $Set();
          }
          $setAdd(set2, key);
        } else {
          item2 = $mapGet(b2, key);
          if (typeof item2 === "undefined" && !$mapHas(b2, key) || !internalDeepEqual(item1, item2, opts, channel)) {
            if (opts.strict) {
              return false;
            }
            if (!mapMightHaveLoosePrim(a2, b2, key, item1, opts, channel)) {
              return false;
            }
            if (!set2) {
              set2 = new $Set();
            }
            $setAdd(set2, key);
          }
        }
      }
      if (set2) {
        while ((resultB = iB.next()) && !resultB.done) {
          key = resultB.value[0];
          item2 = resultB.value[1];
          if (key && typeof key === "object") {
            if (!mapHasEqualEntry(set2, a2, key, item2, opts, channel)) {
              return false;
            }
          } else if (!opts.strict && (!a2.has(key) || !internalDeepEqual($mapGet(a2, key), item2, opts, channel)) && !mapHasEqualEntry(set2, a2, key, item2, assign2({}, opts, { strict: false }), channel)) {
            return false;
          }
        }
        return $setSize(set2) === 0;
      }
      return true;
    }
    function objEquiv(a2, b2, opts, channel) {
      var i2, key;
      if (typeof a2 !== typeof b2) {
        return false;
      }
      if (a2 == null || b2 == null) {
        return false;
      }
      if ($objToString(a2) !== $objToString(b2)) {
        return false;
      }
      if (isArguments2(a2) !== isArguments2(b2)) {
        return false;
      }
      var aIsArray = isArray2(a2);
      var bIsArray = isArray2(b2);
      if (aIsArray !== bIsArray) {
        return false;
      }
      var aIsError = a2 instanceof Error;
      var bIsError = b2 instanceof Error;
      if (aIsError !== bIsError) {
        return false;
      }
      if (aIsError || bIsError) {
        if (a2.name !== b2.name || a2.message !== b2.message) {
          return false;
        }
      }
      var aIsRegex = isRegex(a2);
      var bIsRegex = isRegex(b2);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if ((aIsRegex || bIsRegex) && (a2.source !== b2.source || flags(a2) !== flags(b2))) {
        return false;
      }
      var aIsDate = isDate4(a2);
      var bIsDate = isDate4(b2);
      if (aIsDate !== bIsDate) {
        return false;
      }
      if (aIsDate || bIsDate) {
        if ($getTime(a2) !== $getTime(b2)) {
          return false;
        }
      }
      if (opts.strict && gPO && gPO(a2) !== gPO(b2)) {
        return false;
      }
      var aWhich = whichTypedArray(a2);
      var bWhich = whichTypedArray(b2);
      if (aWhich !== bWhich) {
        return false;
      }
      if (aWhich || bWhich) {
        if (a2.length !== b2.length) {
          return false;
        }
        for (i2 = 0; i2 < a2.length; i2++) {
          if (a2[i2] !== b2[i2]) {
            return false;
          }
        }
        return true;
      }
      var aIsBuffer = isBuffer3(a2);
      var bIsBuffer = isBuffer3(b2);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a2.length !== b2.length) {
          return false;
        }
        for (i2 = 0; i2 < a2.length; i2++) {
          if (a2[i2] !== b2[i2]) {
            return false;
          }
        }
        return true;
      }
      var aIsArrayBuffer = isArrayBuffer3(a2);
      var bIsArrayBuffer = isArrayBuffer3(b2);
      if (aIsArrayBuffer !== bIsArrayBuffer) {
        return false;
      }
      if (aIsArrayBuffer || bIsArrayBuffer) {
        if (byteLength(a2) !== byteLength(b2)) {
          return false;
        }
        return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a2), new Uint8Array(b2), opts, channel);
      }
      var aIsSAB = isSharedArrayBuffer(a2);
      var bIsSAB = isSharedArrayBuffer(b2);
      if (aIsSAB !== bIsSAB) {
        return false;
      }
      if (aIsSAB || bIsSAB) {
        if (sabByteLength(a2) !== sabByteLength(b2)) {
          return false;
        }
        return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a2), new Uint8Array(b2), opts, channel);
      }
      if (typeof a2 !== typeof b2) {
        return false;
      }
      var ka2 = objectKeys(a2);
      var kb = objectKeys(b2);
      if (ka2.length !== kb.length) {
        return false;
      }
      ka2.sort();
      kb.sort();
      for (i2 = ka2.length - 1; i2 >= 0; i2--) {
        if (ka2[i2] != kb[i2]) {
          return false;
        }
      }
      for (i2 = ka2.length - 1; i2 >= 0; i2--) {
        key = ka2[i2];
        if (!internalDeepEqual(a2[key], b2[key], opts, channel)) {
          return false;
        }
      }
      var aCollection = whichCollection(a2);
      var bCollection = whichCollection(b2);
      if (aCollection !== bCollection) {
        return false;
      }
      if (aCollection === "Set" || bCollection === "Set") {
        return setEquiv(a2, b2, opts, channel);
      }
      if (aCollection === "Map") {
        return mapEquiv(a2, b2, opts, channel);
      }
      return true;
    }
    module2.exports = function deepEqual2(a2, b2, opts) {
      return internalDeepEqual(a2, b2, opts, getSideChannel());
    };
  }
});

// ../../node_modules/nunjucks/src/lib.js
var require_lib = __commonJS({
  "../../node_modules/nunjucks/src/lib.js"(exports2, module2) {
    "use strict";
    var ArrayProto = Array.prototype;
    var ObjProto = Object.prototype;
    var escapeMap2 = {
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "\\": "&#92;"
    };
    var escapeRegex2 = /[&"'<>\\]/g;
    var _exports = module2.exports = {};
    function hasOwnProp(obj, k2) {
      return ObjProto.hasOwnProperty.call(obj, k2);
    }
    _exports.hasOwnProp = hasOwnProp;
    function lookupEscape(ch) {
      return escapeMap2[ch];
    }
    function _prettifyError(path4, withInternals, err) {
      if (!err.Update) {
        err = new _exports.TemplateError(err);
      }
      err.Update(path4);
      if (!withInternals) {
        var old = err;
        err = new Error(old.message);
        err.name = old.name;
      }
      return err;
    }
    _exports._prettifyError = _prettifyError;
    function TemplateError(message, lineno, colno) {
      var err;
      var cause;
      if (message instanceof Error) {
        cause = message;
        message = cause.name + ": " + cause.message;
      }
      if (Object.setPrototypeOf) {
        err = new Error(message);
        Object.setPrototypeOf(err, TemplateError.prototype);
      } else {
        err = this;
        Object.defineProperty(err, "message", {
          enumerable: false,
          writable: true,
          value: message
        });
      }
      Object.defineProperty(err, "name", {
        value: "Template render error"
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(err, this.constructor);
      }
      var getStack;
      if (cause) {
        var stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
        getStack = stackDescriptor && (stackDescriptor.get || function() {
          return stackDescriptor.value;
        });
        if (!getStack) {
          getStack = function getStack2() {
            return cause.stack;
          };
        }
      } else {
        var stack = new Error(message).stack;
        getStack = function getStack2() {
          return stack;
        };
      }
      Object.defineProperty(err, "stack", {
        get: function get2() {
          return getStack.call(err);
        }
      });
      Object.defineProperty(err, "cause", {
        value: cause
      });
      err.lineno = lineno;
      err.colno = colno;
      err.firstUpdate = true;
      err.Update = function Update(path4) {
        var msg = "(" + (path4 || "unknown path") + ")";
        if (this.firstUpdate) {
          if (this.lineno && this.colno) {
            msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
          } else if (this.lineno) {
            msg += " [Line " + this.lineno + "]";
          }
        }
        msg += "\n ";
        if (this.firstUpdate) {
          msg += " ";
        }
        this.message = msg + (this.message || "");
        this.firstUpdate = false;
        return this;
      };
      return err;
    }
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
    } else {
      TemplateError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: TemplateError
        }
      });
    }
    _exports.TemplateError = TemplateError;
    function escape4(val) {
      return val.replace(escapeRegex2, lookupEscape);
    }
    _exports.escape = escape4;
    function isFunction3(obj) {
      return ObjProto.toString.call(obj) === "[object Function]";
    }
    _exports.isFunction = isFunction3;
    function isArray2(obj) {
      return ObjProto.toString.call(obj) === "[object Array]";
    }
    _exports.isArray = isArray2;
    function isString3(obj) {
      return ObjProto.toString.call(obj) === "[object String]";
    }
    _exports.isString = isString3;
    function isObject2(obj) {
      return ObjProto.toString.call(obj) === "[object Object]";
    }
    _exports.isObject = isObject2;
    function _prepareAttributeParts(attr) {
      if (!attr) {
        return [];
      }
      if (typeof attr === "string") {
        return attr.split(".");
      }
      return [attr];
    }
    function getAttrGetter(attribute) {
      var parts = _prepareAttributeParts(attribute);
      return function attrGetter(item) {
        var _item = item;
        for (var i2 = 0; i2 < parts.length; i2++) {
          var part = parts[i2];
          if (hasOwnProp(_item, part)) {
            _item = _item[part];
          } else {
            return void 0;
          }
        }
        return _item;
      };
    }
    _exports.getAttrGetter = getAttrGetter;
    function groupBy3(obj, val, throwOnUndefined) {
      var result2 = {};
      var iterator = isFunction3(val) ? val : getAttrGetter(val);
      for (var i2 = 0; i2 < obj.length; i2++) {
        var value = obj[i2];
        var key = iterator(value, i2);
        if (key === void 0 && throwOnUndefined === true) {
          throw new TypeError('groupby: attribute "' + val + '" resolved to undefined');
        }
        (result2[key] || (result2[key] = [])).push(value);
      }
      return result2;
    }
    _exports.groupBy = groupBy3;
    function toArray3(obj) {
      return Array.prototype.slice.call(obj);
    }
    _exports.toArray = toArray3;
    function without3(array) {
      var result2 = [];
      if (!array) {
        return result2;
      }
      var length = array.length;
      var contains = toArray3(arguments).slice(1);
      var index = -1;
      while (++index < length) {
        if (indexOf2(contains, array[index]) === -1) {
          result2.push(array[index]);
        }
      }
      return result2;
    }
    _exports.without = without3;
    function repeat2(char_, n2) {
      var str = "";
      for (var i2 = 0; i2 < n2; i2++) {
        str += char_;
      }
      return str;
    }
    _exports.repeat = repeat2;
    function each(obj, func, context) {
      if (obj == null) {
        return;
      }
      if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
        obj.forEach(func, context);
      } else if (obj.length === +obj.length) {
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          func.call(context, obj[i2], i2, obj);
        }
      }
    }
    _exports.each = each;
    function map2(obj, func) {
      var results = [];
      if (obj == null) {
        return results;
      }
      if (ArrayProto.map && obj.map === ArrayProto.map) {
        return obj.map(func);
      }
      for (var i2 = 0; i2 < obj.length; i2++) {
        results[results.length] = func(obj[i2], i2);
      }
      if (obj.length === +obj.length) {
        results.length = obj.length;
      }
      return results;
    }
    _exports.map = map2;
    function asyncIter(arr, iter, cb) {
      var i2 = -1;
      function next() {
        i2++;
        if (i2 < arr.length) {
          iter(arr[i2], i2, next, cb);
        } else {
          cb();
        }
      }
      next();
    }
    _exports.asyncIter = asyncIter;
    function asyncFor(obj, iter, cb) {
      var keys2 = keys_(obj || {});
      var len = keys2.length;
      var i2 = -1;
      function next() {
        i2++;
        var k2 = keys2[i2];
        if (i2 < len) {
          iter(k2, obj[k2], i2, len, next);
        } else {
          cb();
        }
      }
      next();
    }
    _exports.asyncFor = asyncFor;
    function indexOf2(arr, searchElement, fromIndex) {
      return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
    }
    _exports.indexOf = indexOf2;
    function keys_(obj) {
      var arr = [];
      for (var k2 in obj) {
        if (hasOwnProp(obj, k2)) {
          arr.push(k2);
        }
      }
      return arr;
    }
    _exports.keys = keys_;
    function _entries(obj) {
      return keys_(obj).map(function(k2) {
        return [k2, obj[k2]];
      });
    }
    _exports._entries = _entries;
    function _values(obj) {
      return keys_(obj).map(function(k2) {
        return obj[k2];
      });
    }
    _exports._values = _values;
    function extend(obj1, obj2) {
      obj1 = obj1 || {};
      keys_(obj2).forEach(function(k2) {
        obj1[k2] = obj2[k2];
      });
      return obj1;
    }
    _exports._assign = _exports.extend = extend;
    function inOperator(key, val) {
      if (isArray2(val) || isString3(val)) {
        return val.indexOf(key) !== -1;
      } else if (isObject2(val)) {
        return key in val;
      }
      throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
    }
    _exports.inOperator = inOperator;
  }
});

// ../../node_modules/asap/raw.js
var require_raw = __commonJS({
  "../../node_modules/asap/raw.js"(exports2, module2) {
    "use strict";
    var domain;
    var hasSetImmediate = typeof setImmediate === "function";
    module2.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var index = 0;
    var capacity = 1024;
    function flush2() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    rawAsap.requestFlush = requestFlush;
    function requestFlush() {
      var parentDomain = process.domain;
      if (parentDomain) {
        if (!domain) {
          domain = require("domain");
        }
        domain.active = process.domain = null;
      }
      if (flushing && hasSetImmediate) {
        setImmediate(flush2);
      } else {
        process.nextTick(flush2);
      }
      if (parentDomain) {
        domain.active = process.domain = parentDomain;
      }
    }
  }
});

// ../../node_modules/asap/asap.js
var require_asap = __commonJS({
  "../../node_modules/asap/asap.js"(exports2, module2) {
    "use strict";
    var rawAsap = require_raw();
    var freeTasks = [];
    module2.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawTask.domain = process.domain;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
      this.domain = null;
    }
    RawTask.prototype.call = function() {
      if (this.domain) {
        this.domain.enter();
      }
      var threw = true;
      try {
        this.task.call();
        threw = false;
        if (this.domain) {
          this.domain.exit();
        }
      } finally {
        if (threw) {
          rawAsap.requestFlush();
        }
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
      }
    };
  }
});

// ../../node_modules/a-sync-waterfall/index.js
var require_a_sync_waterfall = __commonJS({
  "../../node_modules/a-sync-waterfall/index.js"(exports2, module2) {
    (function(globals) {
      "use strict";
      var executeSync = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "function") {
          args[0].apply(null, args.splice(1));
        }
      };
      var executeAsync = function(fn) {
        if (typeof setImmediate === "function") {
          setImmediate(fn);
        } else if (typeof process !== "undefined" && process.nextTick) {
          process.nextTick(fn);
        } else {
          setTimeout(fn, 0);
        }
      };
      var makeIterator = function(tasks) {
        var makeCallback = function(index) {
          var fn = function() {
            if (tasks.length) {
              tasks[index].apply(null, arguments);
            }
            return fn.next();
          };
          fn.next = function() {
            return index < tasks.length - 1 ? makeCallback(index + 1) : null;
          };
          return fn;
        };
        return makeCallback(0);
      };
      var _isArray = Array.isArray || function(maybeArray) {
        return Object.prototype.toString.call(maybeArray) === "[object Array]";
      };
      var waterfall = function(tasks, callback, forceAsync) {
        var nextTick = forceAsync ? executeAsync : executeSync;
        callback = callback || function() {
        };
        if (!_isArray(tasks)) {
          var err = new Error("First argument to waterfall must be an array of functions");
          return callback(err);
        }
        if (!tasks.length) {
          return callback();
        }
        var wrapIterator = function(iterator) {
          return function(err2) {
            if (err2) {
              callback.apply(null, arguments);
              callback = function() {
              };
            } else {
              var args = Array.prototype.slice.call(arguments, 1);
              var next = iterator.next();
              if (next) {
                args.push(wrapIterator(next));
              } else {
                args.push(callback);
              }
              nextTick(function() {
                iterator.apply(null, args);
              });
            }
          };
        };
        wrapIterator(makeIterator(tasks))();
      };
      if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return waterfall;
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = waterfall;
      } else {
        globals.waterfall = waterfall;
      }
    })(exports2);
  }
});

// ../../node_modules/nunjucks/src/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/nunjucks/src/lexer.js"(exports2, module2) {
    "use strict";
    var lib = require_lib();
    var whitespaceChars = " \n	\r\xA0";
    var delimChars = "()[]{}%*-+~/#,:|.<>=!";
    var intChars = "0123456789";
    var BLOCK_START = "{%";
    var BLOCK_END = "%}";
    var VARIABLE_START = "{{";
    var VARIABLE_END = "}}";
    var COMMENT_START = "{#";
    var COMMENT_END = "#}";
    var TOKEN_STRING = "string";
    var TOKEN_WHITESPACE = "whitespace";
    var TOKEN_DATA = "data";
    var TOKEN_BLOCK_START = "block-start";
    var TOKEN_BLOCK_END = "block-end";
    var TOKEN_VARIABLE_START = "variable-start";
    var TOKEN_VARIABLE_END = "variable-end";
    var TOKEN_COMMENT = "comment";
    var TOKEN_LEFT_PAREN = "left-paren";
    var TOKEN_RIGHT_PAREN = "right-paren";
    var TOKEN_LEFT_BRACKET = "left-bracket";
    var TOKEN_RIGHT_BRACKET = "right-bracket";
    var TOKEN_LEFT_CURLY = "left-curly";
    var TOKEN_RIGHT_CURLY = "right-curly";
    var TOKEN_OPERATOR = "operator";
    var TOKEN_COMMA = "comma";
    var TOKEN_COLON = "colon";
    var TOKEN_TILDE = "tilde";
    var TOKEN_PIPE = "pipe";
    var TOKEN_INT = "int";
    var TOKEN_FLOAT = "float";
    var TOKEN_BOOLEAN = "boolean";
    var TOKEN_NONE = "none";
    var TOKEN_SYMBOL = "symbol";
    var TOKEN_SPECIAL = "special";
    var TOKEN_REGEX = "regex";
    function token(type, value, lineno, colno) {
      return {
        type,
        value,
        lineno,
        colno
      };
    }
    var Tokenizer = /* @__PURE__ */ (function() {
      function Tokenizer2(str, opts) {
        this.str = str;
        this.index = 0;
        this.len = str.length;
        this.lineno = 0;
        this.colno = 0;
        this.in_code = false;
        opts = opts || {};
        var tags = opts.tags || {};
        this.tags = {
          BLOCK_START: tags.blockStart || BLOCK_START,
          BLOCK_END: tags.blockEnd || BLOCK_END,
          VARIABLE_START: tags.variableStart || VARIABLE_START,
          VARIABLE_END: tags.variableEnd || VARIABLE_END,
          COMMENT_START: tags.commentStart || COMMENT_START,
          COMMENT_END: tags.commentEnd || COMMENT_END
        };
        this.trimBlocks = !!opts.trimBlocks;
        this.lstripBlocks = !!opts.lstripBlocks;
      }
      var _proto = Tokenizer2.prototype;
      _proto.nextToken = function nextToken() {
        var lineno = this.lineno;
        var colno = this.colno;
        var tok;
        if (this.in_code) {
          var cur = this.current();
          if (this.isFinished()) {
            return null;
          } else if (cur === '"' || cur === "'") {
            return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
          } else if (tok = this._extract(whitespaceChars)) {
            return token(TOKEN_WHITESPACE, tok, lineno, colno);
          } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
            this.in_code = false;
            if (this.trimBlocks) {
              cur = this.current();
              if (cur === "\n") {
                this.forward();
              } else if (cur === "\r") {
                this.forward();
                cur = this.current();
                if (cur === "\n") {
                  this.forward();
                } else {
                  this.back();
                }
              }
            }
            return token(TOKEN_BLOCK_END, tok, lineno, colno);
          } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
            this.in_code = false;
            return token(TOKEN_VARIABLE_END, tok, lineno, colno);
          } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
            this.forwardN(2);
            var regexBody = "";
            while (!this.isFinished()) {
              if (this.current() === "/" && this.previous() !== "\\") {
                this.forward();
                break;
              } else {
                regexBody += this.current();
                this.forward();
              }
            }
            var POSSIBLE_FLAGS = ["g", "i", "m", "y"];
            var regexFlags = "";
            while (!this.isFinished()) {
              var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
              if (isCurrentAFlag) {
                regexFlags += this.current();
                this.forward();
              } else {
                break;
              }
            }
            return token(TOKEN_REGEX, {
              body: regexBody,
              flags: regexFlags
            }, lineno, colno);
          } else if (delimChars.indexOf(cur) !== -1) {
            this.forward();
            var complexOps = ["==", "===", "!=", "!==", "<=", ">=", "//", "**"];
            var curComplex = cur + this.current();
            var type;
            if (lib.indexOf(complexOps, curComplex) !== -1) {
              this.forward();
              cur = curComplex;
              if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
                cur = curComplex + this.current();
                this.forward();
              }
            }
            switch (cur) {
              case "(":
                type = TOKEN_LEFT_PAREN;
                break;
              case ")":
                type = TOKEN_RIGHT_PAREN;
                break;
              case "[":
                type = TOKEN_LEFT_BRACKET;
                break;
              case "]":
                type = TOKEN_RIGHT_BRACKET;
                break;
              case "{":
                type = TOKEN_LEFT_CURLY;
                break;
              case "}":
                type = TOKEN_RIGHT_CURLY;
                break;
              case ",":
                type = TOKEN_COMMA;
                break;
              case ":":
                type = TOKEN_COLON;
                break;
              case "~":
                type = TOKEN_TILDE;
                break;
              case "|":
                type = TOKEN_PIPE;
                break;
              default:
                type = TOKEN_OPERATOR;
            }
            return token(type, cur, lineno, colno);
          } else {
            tok = this._extractUntil(whitespaceChars + delimChars);
            if (tok.match(/^[-+]?[0-9]+$/)) {
              if (this.current() === ".") {
                this.forward();
                var dec = this._extract(intChars);
                return token(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
              } else {
                return token(TOKEN_INT, tok, lineno, colno);
              }
            } else if (tok.match(/^(true|false)$/)) {
              return token(TOKEN_BOOLEAN, tok, lineno, colno);
            } else if (tok === "none") {
              return token(TOKEN_NONE, tok, lineno, colno);
            } else if (tok === "null") {
              return token(TOKEN_NONE, tok, lineno, colno);
            } else if (tok) {
              return token(TOKEN_SYMBOL, tok, lineno, colno);
            } else {
              throw new Error("Unexpected value while parsing: " + tok);
            }
          }
        } else {
          var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
          if (this.isFinished()) {
            return null;
          } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
            this.in_code = true;
            return token(TOKEN_BLOCK_START, tok, lineno, colno);
          } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
            this.in_code = true;
            return token(TOKEN_VARIABLE_START, tok, lineno, colno);
          } else {
            tok = "";
            var data;
            var inComment = false;
            if (this._matches(this.tags.COMMENT_START)) {
              inComment = true;
              tok = this._extractString(this.tags.COMMENT_START);
            }
            while ((data = this._extractUntil(beginChars)) !== null) {
              tok += data;
              if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                  var lastLine = tok.slice(-this.colno);
                  if (/^\s+$/.test(lastLine)) {
                    tok = tok.slice(0, -this.colno);
                    if (!tok.length) {
                      return this.nextToken();
                    }
                  }
                }
                break;
              } else if (this._matches(this.tags.COMMENT_END)) {
                if (!inComment) {
                  throw new Error("unexpected end of comment");
                }
                tok += this._extractString(this.tags.COMMENT_END);
                break;
              } else {
                tok += this.current();
                this.forward();
              }
            }
            if (data === null && inComment) {
              throw new Error("expected end of comment, got end of file");
            }
            return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
          }
        }
      };
      _proto._parseString = function _parseString(delimiter) {
        this.forward();
        var str = "";
        while (!this.isFinished() && this.current() !== delimiter) {
          var cur = this.current();
          if (cur === "\\") {
            this.forward();
            switch (this.current()) {
              case "n":
                str += "\n";
                break;
              case "t":
                str += "	";
                break;
              case "r":
                str += "\r";
                break;
              default:
                str += this.current();
            }
            this.forward();
          } else {
            str += cur;
            this.forward();
          }
        }
        this.forward();
        return str;
      };
      _proto._matches = function _matches(str) {
        if (this.index + str.length > this.len) {
          return null;
        }
        var m3 = this.str.slice(this.index, this.index + str.length);
        return m3 === str;
      };
      _proto._extractString = function _extractString(str) {
        if (this._matches(str)) {
          this.forwardN(str.length);
          return str;
        }
        return null;
      };
      _proto._extractUntil = function _extractUntil(charString) {
        return this._extractMatching(true, charString || "");
      };
      _proto._extract = function _extract(charString) {
        return this._extractMatching(false, charString);
      };
      _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
        if (this.isFinished()) {
          return null;
        }
        var first = charString.indexOf(this.current());
        if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
          var t2 = this.current();
          this.forward();
          var idx = charString.indexOf(this.current());
          while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
            t2 += this.current();
            this.forward();
            idx = charString.indexOf(this.current());
          }
          return t2;
        }
        return "";
      };
      _proto._extractRegex = function _extractRegex(regex) {
        var matches2 = this.currentStr().match(regex);
        if (!matches2) {
          return null;
        }
        this.forwardN(matches2[0].length);
        return matches2;
      };
      _proto.isFinished = function isFinished() {
        return this.index >= this.len;
      };
      _proto.forwardN = function forwardN(n2) {
        for (var i2 = 0; i2 < n2; i2++) {
          this.forward();
        }
      };
      _proto.forward = function forward() {
        this.index++;
        if (this.previous() === "\n") {
          this.lineno++;
          this.colno = 0;
        } else {
          this.colno++;
        }
      };
      _proto.backN = function backN(n2) {
        for (var i2 = 0; i2 < n2; i2++) {
          this.back();
        }
      };
      _proto.back = function back() {
        this.index--;
        if (this.current() === "\n") {
          this.lineno--;
          var idx = this.src.lastIndexOf("\n", this.index - 1);
          if (idx === -1) {
            this.colno = this.index;
          } else {
            this.colno = this.index - idx;
          }
        } else {
          this.colno--;
        }
      };
      _proto.current = function current() {
        if (!this.isFinished()) {
          return this.str.charAt(this.index);
        }
        return "";
      };
      _proto.currentStr = function currentStr() {
        if (!this.isFinished()) {
          return this.str.substr(this.index);
        }
        return "";
      };
      _proto.previous = function previous() {
        return this.str.charAt(this.index - 1);
      };
      return Tokenizer2;
    })();
    module2.exports = {
      lex: function lex(src, opts) {
        return new Tokenizer(src, opts);
      },
      TOKEN_STRING,
      TOKEN_WHITESPACE,
      TOKEN_DATA,
      TOKEN_BLOCK_START,
      TOKEN_BLOCK_END,
      TOKEN_VARIABLE_START,
      TOKEN_VARIABLE_END,
      TOKEN_COMMENT,
      TOKEN_LEFT_PAREN,
      TOKEN_RIGHT_PAREN,
      TOKEN_LEFT_BRACKET,
      TOKEN_RIGHT_BRACKET,
      TOKEN_LEFT_CURLY,
      TOKEN_RIGHT_CURLY,
      TOKEN_OPERATOR,
      TOKEN_COMMA,
      TOKEN_COLON,
      TOKEN_TILDE,
      TOKEN_PIPE,
      TOKEN_INT,
      TOKEN_FLOAT,
      TOKEN_BOOLEAN,
      TOKEN_NONE,
      TOKEN_SYMBOL,
      TOKEN_SPECIAL,
      TOKEN_REGEX
    };
  }
});

// ../../node_modules/nunjucks/src/object.js
var require_object2 = __commonJS({
  "../../node_modules/nunjucks/src/object.js"(exports2, module2) {
    "use strict";
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var EventEmitter = require("events");
    var lib = require_lib();
    function parentWrap(parent, prop) {
      if (typeof parent !== "function" || typeof prop !== "function") {
        return prop;
      }
      return function wrap3() {
        var tmp = this.parent;
        this.parent = parent;
        var res = prop.apply(this, arguments);
        this.parent = tmp;
        return res;
      };
    }
    function extendClass(cls, name, props) {
      props = props || {};
      lib.keys(props).forEach(function(k2) {
        props[k2] = parentWrap(cls.prototype[k2], props[k2]);
      });
      var subclass = /* @__PURE__ */ (function(_cls) {
        _inheritsLoose(subclass2, _cls);
        function subclass2() {
          return _cls.apply(this, arguments) || this;
        }
        _createClass(subclass2, [{
          key: "typename",
          get: function get2() {
            return name;
          }
        }]);
        return subclass2;
      })(cls);
      lib._assign(subclass.prototype, props);
      return subclass;
    }
    var Obj = /* @__PURE__ */ (function() {
      function Obj2() {
        this.init.apply(this, arguments);
      }
      var _proto = Obj2.prototype;
      _proto.init = function init4() {
      };
      Obj2.extend = function extend(name, props) {
        if (typeof name === "object") {
          props = name;
          name = "anonymous";
        }
        return extendClass(this, name, props);
      };
      _createClass(Obj2, [{
        key: "typename",
        get: function get2() {
          return this.constructor.name;
        }
      }]);
      return Obj2;
    })();
    var EmitterObj = /* @__PURE__ */ (function(_EventEmitter) {
      _inheritsLoose(EmitterObj2, _EventEmitter);
      function EmitterObj2() {
        var _this2;
        var _this;
        _this = _EventEmitter.call(this) || this;
        (_this2 = _this).init.apply(_this2, arguments);
        return _this;
      }
      var _proto2 = EmitterObj2.prototype;
      _proto2.init = function init4() {
      };
      EmitterObj2.extend = function extend(name, props) {
        if (typeof name === "object") {
          props = name;
          name = "anonymous";
        }
        return extendClass(this, name, props);
      };
      _createClass(EmitterObj2, [{
        key: "typename",
        get: function get2() {
          return this.constructor.name;
        }
      }]);
      return EmitterObj2;
    })(EventEmitter);
    module2.exports = {
      Obj,
      EmitterObj
    };
  }
});

// ../../node_modules/nunjucks/src/nodes.js
var require_nodes = __commonJS({
  "../../node_modules/nunjucks/src/nodes.js"(exports2, module2) {
    "use strict";
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var _require = require_object2();
    var Obj = _require.Obj;
    function traverseAndCheck(obj, type, results) {
      if (obj instanceof type) {
        results.push(obj);
      }
      if (obj instanceof Node) {
        obj.findAll(type, results);
      }
    }
    var Node = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Node2, _Obj);
      function Node2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto = Node2.prototype;
      _proto.init = function init4(lineno, colno) {
        var _arguments = arguments, _this = this;
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        this.lineno = lineno;
        this.colno = colno;
        this.fields.forEach(function(field, i2) {
          var val = _arguments[i2 + 2];
          if (val === void 0) {
            val = null;
          }
          _this[field] = val;
        });
      };
      _proto.findAll = function findAll(type, results) {
        var _this2 = this;
        results = results || [];
        if (this instanceof NodeList) {
          this.children.forEach(function(child) {
            return traverseAndCheck(child, type, results);
          });
        } else {
          this.fields.forEach(function(field) {
            return traverseAndCheck(_this2[field], type, results);
          });
        }
        return results;
      };
      _proto.iterFields = function iterFields(func) {
        var _this3 = this;
        this.fields.forEach(function(field) {
          func(_this3[field], field);
        });
      };
      return Node2;
    })(Obj);
    var Value = /* @__PURE__ */ (function(_Node) {
      _inheritsLoose(Value2, _Node);
      function Value2() {
        return _Node.apply(this, arguments) || this;
      }
      _createClass(Value2, [{
        key: "typename",
        get: function get2() {
          return "Value";
        }
      }, {
        key: "fields",
        get: function get2() {
          return ["value"];
        }
      }]);
      return Value2;
    })(Node);
    var NodeList = /* @__PURE__ */ (function(_Node2) {
      _inheritsLoose(NodeList2, _Node2);
      function NodeList2() {
        return _Node2.apply(this, arguments) || this;
      }
      var _proto2 = NodeList2.prototype;
      _proto2.init = function init4(lineno, colno, nodes) {
        _Node2.prototype.init.call(this, lineno, colno, nodes || []);
      };
      _proto2.addChild = function addChild(node3) {
        this.children.push(node3);
      };
      _createClass(NodeList2, [{
        key: "typename",
        get: function get2() {
          return "NodeList";
        }
      }, {
        key: "fields",
        get: function get2() {
          return ["children"];
        }
      }]);
      return NodeList2;
    })(Node);
    var Root = NodeList.extend("Root");
    var Literal = Value.extend("Literal");
    var _Symbol = Value.extend("Symbol");
    var Group = NodeList.extend("Group");
    var ArrayNode = NodeList.extend("Array");
    var Pair = Node.extend("Pair", {
      fields: ["key", "value"]
    });
    var Dict = NodeList.extend("Dict");
    var LookupVal = Node.extend("LookupVal", {
      fields: ["target", "val"]
    });
    var If = Node.extend("If", {
      fields: ["cond", "body", "else_"]
    });
    var IfAsync = If.extend("IfAsync");
    var InlineIf = Node.extend("InlineIf", {
      fields: ["cond", "body", "else_"]
    });
    var For = Node.extend("For", {
      fields: ["arr", "name", "body", "else_"]
    });
    var AsyncEach = For.extend("AsyncEach");
    var AsyncAll = For.extend("AsyncAll");
    var Macro = Node.extend("Macro", {
      fields: ["name", "args", "body"]
    });
    var Caller = Macro.extend("Caller");
    var Import = Node.extend("Import", {
      fields: ["template", "target", "withContext"]
    });
    var FromImport = /* @__PURE__ */ (function(_Node3) {
      _inheritsLoose(FromImport2, _Node3);
      function FromImport2() {
        return _Node3.apply(this, arguments) || this;
      }
      var _proto3 = FromImport2.prototype;
      _proto3.init = function init4(lineno, colno, template2, names, withContext) {
        _Node3.prototype.init.call(this, lineno, colno, template2, names || new NodeList(), withContext);
      };
      _createClass(FromImport2, [{
        key: "typename",
        get: function get2() {
          return "FromImport";
        }
      }, {
        key: "fields",
        get: function get2() {
          return ["template", "names", "withContext"];
        }
      }]);
      return FromImport2;
    })(Node);
    var FunCall = Node.extend("FunCall", {
      fields: ["name", "args"]
    });
    var Filter = FunCall.extend("Filter");
    var FilterAsync = Filter.extend("FilterAsync", {
      fields: ["name", "args", "symbol"]
    });
    var KeywordArgs = Dict.extend("KeywordArgs");
    var Block = Node.extend("Block", {
      fields: ["name", "body"]
    });
    var Super = Node.extend("Super", {
      fields: ["blockName", "symbol"]
    });
    var TemplateRef = Node.extend("TemplateRef", {
      fields: ["template"]
    });
    var Extends = TemplateRef.extend("Extends");
    var Include = Node.extend("Include", {
      fields: ["template", "ignoreMissing"]
    });
    var Set2 = Node.extend("Set", {
      fields: ["targets", "value"]
    });
    var Switch = Node.extend("Switch", {
      fields: ["expr", "cases", "default"]
    });
    var Case = Node.extend("Case", {
      fields: ["cond", "body"]
    });
    var Output = NodeList.extend("Output");
    var Capture = Node.extend("Capture", {
      fields: ["body"]
    });
    var TemplateData = Literal.extend("TemplateData");
    var UnaryOp = Node.extend("UnaryOp", {
      fields: ["target"]
    });
    var BinOp = Node.extend("BinOp", {
      fields: ["left", "right"]
    });
    var In = BinOp.extend("In");
    var Is = BinOp.extend("Is");
    var Or2 = BinOp.extend("Or");
    var And = BinOp.extend("And");
    var Not = UnaryOp.extend("Not");
    var Add = BinOp.extend("Add");
    var Concat = BinOp.extend("Concat");
    var Sub = BinOp.extend("Sub");
    var Mul = BinOp.extend("Mul");
    var Div = BinOp.extend("Div");
    var FloorDiv = BinOp.extend("FloorDiv");
    var Mod = BinOp.extend("Mod");
    var Pow = BinOp.extend("Pow");
    var Neg = UnaryOp.extend("Neg");
    var Pos = UnaryOp.extend("Pos");
    var Compare = Node.extend("Compare", {
      fields: ["expr", "ops"]
    });
    var CompareOperand = Node.extend("CompareOperand", {
      fields: ["expr", "type"]
    });
    var CallExtension = Node.extend("CallExtension", {
      init: function init4(ext, prop, args, contentArgs) {
        this.parent();
        this.extName = ext.__name || ext;
        this.prop = prop;
        this.args = args || new NodeList();
        this.contentArgs = contentArgs || [];
        this.autoescape = ext.autoescape;
      },
      fields: ["extName", "prop", "args", "contentArgs"]
    });
    var CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
    function print(str, indent, inline) {
      var lines = str.split("\n");
      lines.forEach(function(line, i2) {
        if (line && (inline && i2 > 0 || !inline)) {
          process.stdout.write(" ".repeat(indent));
        }
        var nl = i2 === lines.length - 1 ? "" : "\n";
        process.stdout.write("" + line + nl);
      });
    }
    function printNodes(node3, indent) {
      indent = indent || 0;
      print(node3.typename + ": ", indent);
      if (node3 instanceof NodeList) {
        print("\n");
        node3.children.forEach(function(n2) {
          printNodes(n2, indent + 2);
        });
      } else if (node3 instanceof CallExtension) {
        print(node3.extName + "." + node3.prop + "\n");
        if (node3.args) {
          printNodes(node3.args, indent + 2);
        }
        if (node3.contentArgs) {
          node3.contentArgs.forEach(function(n2) {
            printNodes(n2, indent + 2);
          });
        }
      } else {
        var nodes = [];
        var props = null;
        node3.iterFields(function(val, fieldName) {
          if (val instanceof Node) {
            nodes.push([fieldName, val]);
          } else {
            props = props || {};
            props[fieldName] = val;
          }
        });
        if (props) {
          print(JSON.stringify(props, null, 2) + "\n", null, true);
        } else {
          print("\n");
        }
        nodes.forEach(function(_ref) {
          var fieldName = _ref[0], n2 = _ref[1];
          print("[" + fieldName + "] =>", indent + 2);
          printNodes(n2, indent + 4);
        });
      }
    }
    module2.exports = {
      Node,
      Root,
      NodeList,
      Value,
      Literal,
      Symbol: _Symbol,
      Group,
      Array: ArrayNode,
      Pair,
      Dict,
      Output,
      Capture,
      TemplateData,
      If,
      IfAsync,
      InlineIf,
      For,
      AsyncEach,
      AsyncAll,
      Macro,
      Caller,
      Import,
      FromImport,
      FunCall,
      Filter,
      FilterAsync,
      KeywordArgs,
      Block,
      Super,
      Extends,
      Include,
      Set: Set2,
      Switch,
      Case,
      LookupVal,
      BinOp,
      In,
      Is,
      Or: Or2,
      And,
      Not,
      Add,
      Concat,
      Sub,
      Mul,
      Div,
      FloorDiv,
      Mod,
      Pow,
      Neg,
      Pos,
      Compare,
      CompareOperand,
      CallExtension,
      CallExtensionAsync,
      printNodes
    };
  }
});

// ../../node_modules/nunjucks/src/parser.js
var require_parser = __commonJS({
  "../../node_modules/nunjucks/src/parser.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var lexer = require_lexer();
    var nodes = require_nodes();
    var Obj = require_object2().Obj;
    var lib = require_lib();
    var Parser = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Parser2, _Obj);
      function Parser2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto = Parser2.prototype;
      _proto.init = function init4(tokens) {
        this.tokens = tokens;
        this.peeked = null;
        this.breakOnBlocks = null;
        this.dropLeadingWhitespace = false;
        this.extensions = [];
      };
      _proto.nextToken = function nextToken(withWhitespace) {
        var tok;
        if (this.peeked) {
          if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
            this.peeked = null;
          } else {
            tok = this.peeked;
            this.peeked = null;
            return tok;
          }
        }
        tok = this.tokens.nextToken();
        if (!withWhitespace) {
          while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
            tok = this.tokens.nextToken();
          }
        }
        return tok;
      };
      _proto.peekToken = function peekToken() {
        this.peeked = this.peeked || this.nextToken();
        return this.peeked;
      };
      _proto.pushToken = function pushToken(tok) {
        if (this.peeked) {
          throw new Error("pushToken: can only push one token on between reads");
        }
        this.peeked = tok;
      };
      _proto.error = function error(msg, lineno, colno) {
        if (lineno === void 0 || colno === void 0) {
          var tok = this.peekToken() || {};
          lineno = tok.lineno;
          colno = tok.colno;
        }
        if (lineno !== void 0) {
          lineno += 1;
        }
        if (colno !== void 0) {
          colno += 1;
        }
        return new lib.TemplateError(msg, lineno, colno);
      };
      _proto.fail = function fail(msg, lineno, colno) {
        throw this.error(msg, lineno, colno);
      };
      _proto.skip = function skip2(type) {
        var tok = this.nextToken();
        if (!tok || tok.type !== type) {
          this.pushToken(tok);
          return false;
        }
        return true;
      };
      _proto.expect = function expect2(type) {
        var tok = this.nextToken();
        if (tok.type !== type) {
          this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
        }
        return tok;
      };
      _proto.skipValue = function skipValue(type, val) {
        var tok = this.nextToken();
        if (!tok || tok.type !== type || tok.value !== val) {
          this.pushToken(tok);
          return false;
        }
        return true;
      };
      _proto.skipSymbol = function skipSymbol(val) {
        return this.skipValue(lexer.TOKEN_SYMBOL, val);
      };
      _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
        var tok;
        if (!name) {
          tok = this.peekToken();
          if (!tok) {
            this.fail("unexpected end of file");
          }
          if (tok.type !== lexer.TOKEN_SYMBOL) {
            this.fail("advanceAfterBlockEnd: expected symbol token or explicit name to be passed");
          }
          name = this.nextToken().value;
        }
        tok = this.nextToken();
        if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
          if (tok.value.charAt(0) === "-") {
            this.dropLeadingWhitespace = true;
          }
        } else {
          this.fail("expected block end in " + name + " statement");
        }
        return tok;
      };
      _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
        var tok = this.nextToken();
        if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
          this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
        } else {
          this.pushToken(tok);
          this.fail("expected variable end");
        }
      };
      _proto.parseFor = function parseFor() {
        var forTok = this.peekToken();
        var node3;
        var endBlock;
        if (this.skipSymbol("for")) {
          node3 = new nodes.For(forTok.lineno, forTok.colno);
          endBlock = "endfor";
        } else if (this.skipSymbol("asyncEach")) {
          node3 = new nodes.AsyncEach(forTok.lineno, forTok.colno);
          endBlock = "endeach";
        } else if (this.skipSymbol("asyncAll")) {
          node3 = new nodes.AsyncAll(forTok.lineno, forTok.colno);
          endBlock = "endall";
        } else {
          this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
        }
        node3.name = this.parsePrimary();
        if (!(node3.name instanceof nodes.Symbol)) {
          this.fail("parseFor: variable name expected for loop");
        }
        var type = this.peekToken().type;
        if (type === lexer.TOKEN_COMMA) {
          var key = node3.name;
          node3.name = new nodes.Array(key.lineno, key.colno);
          node3.name.addChild(key);
          while (this.skip(lexer.TOKEN_COMMA)) {
            var prim = this.parsePrimary();
            node3.name.addChild(prim);
          }
        }
        if (!this.skipSymbol("in")) {
          this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
        }
        node3.arr = this.parseExpression();
        this.advanceAfterBlockEnd(forTok.value);
        node3.body = this.parseUntilBlocks(endBlock, "else");
        if (this.skipSymbol("else")) {
          this.advanceAfterBlockEnd("else");
          node3.else_ = this.parseUntilBlocks(endBlock);
        }
        this.advanceAfterBlockEnd();
        return node3;
      };
      _proto.parseMacro = function parseMacro() {
        var macroTok = this.peekToken();
        if (!this.skipSymbol("macro")) {
          this.fail("expected macro");
        }
        var name = this.parsePrimary(true);
        var args = this.parseSignature();
        var node3 = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
        this.advanceAfterBlockEnd(macroTok.value);
        node3.body = this.parseUntilBlocks("endmacro");
        this.advanceAfterBlockEnd();
        return node3;
      };
      _proto.parseCall = function parseCall() {
        var callTok = this.peekToken();
        if (!this.skipSymbol("call")) {
          this.fail("expected call");
        }
        var callerArgs = this.parseSignature(true) || new nodes.NodeList();
        var macroCall = this.parsePrimary();
        this.advanceAfterBlockEnd(callTok.value);
        var body = this.parseUntilBlocks("endcall");
        this.advanceAfterBlockEnd();
        var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, "caller");
        var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
        var args = macroCall.args.children;
        if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
          args.push(new nodes.KeywordArgs());
        }
        var kwargs = args[args.length - 1];
        kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
        return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
      };
      _proto.parseWithContext = function parseWithContext() {
        var tok = this.peekToken();
        var withContext = null;
        if (this.skipSymbol("with")) {
          withContext = true;
        } else if (this.skipSymbol("without")) {
          withContext = false;
        }
        if (withContext !== null) {
          if (!this.skipSymbol("context")) {
            this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
          }
        }
        return withContext;
      };
      _proto.parseImport = function parseImport() {
        var importTok = this.peekToken();
        if (!this.skipSymbol("import")) {
          this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
        }
        var template2 = this.parseExpression();
        if (!this.skipSymbol("as")) {
          this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
        }
        var target = this.parseExpression();
        var withContext = this.parseWithContext();
        var node3 = new nodes.Import(importTok.lineno, importTok.colno, template2, target, withContext);
        this.advanceAfterBlockEnd(importTok.value);
        return node3;
      };
      _proto.parseFrom = function parseFrom() {
        var fromTok = this.peekToken();
        if (!this.skipSymbol("from")) {
          this.fail("parseFrom: expected from");
        }
        var template2 = this.parseExpression();
        if (!this.skipSymbol("import")) {
          this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
        }
        var names = new nodes.NodeList();
        var withContext;
        while (1) {
          var nextTok = this.peekToken();
          if (nextTok.type === lexer.TOKEN_BLOCK_END) {
            if (!names.children.length) {
              this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
            }
            if (nextTok.value.charAt(0) === "-") {
              this.dropLeadingWhitespace = true;
            }
            this.nextToken();
            break;
          }
          if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
            this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
          }
          var name = this.parsePrimary();
          if (name.value.charAt(0) === "_") {
            this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
          }
          if (this.skipSymbol("as")) {
            var alias = this.parsePrimary();
            names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
          } else {
            names.addChild(name);
          }
          withContext = this.parseWithContext();
        }
        return new nodes.FromImport(fromTok.lineno, fromTok.colno, template2, names, withContext);
      };
      _proto.parseBlock = function parseBlock() {
        var tag = this.peekToken();
        if (!this.skipSymbol("block")) {
          this.fail("parseBlock: expected block", tag.lineno, tag.colno);
        }
        var node3 = new nodes.Block(tag.lineno, tag.colno);
        node3.name = this.parsePrimary();
        if (!(node3.name instanceof nodes.Symbol)) {
          this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
        }
        this.advanceAfterBlockEnd(tag.value);
        node3.body = this.parseUntilBlocks("endblock");
        this.skipSymbol("endblock");
        this.skipSymbol(node3.name.value);
        var tok = this.peekToken();
        if (!tok) {
          this.fail("parseBlock: expected endblock, got end of file");
        }
        this.advanceAfterBlockEnd(tok.value);
        return node3;
      };
      _proto.parseExtends = function parseExtends() {
        var tagName = "extends";
        var tag = this.peekToken();
        if (!this.skipSymbol(tagName)) {
          this.fail("parseTemplateRef: expected " + tagName);
        }
        var node3 = new nodes.Extends(tag.lineno, tag.colno);
        node3.template = this.parseExpression();
        this.advanceAfterBlockEnd(tag.value);
        return node3;
      };
      _proto.parseInclude = function parseInclude() {
        var tagName = "include";
        var tag = this.peekToken();
        if (!this.skipSymbol(tagName)) {
          this.fail("parseInclude: expected " + tagName);
        }
        var node3 = new nodes.Include(tag.lineno, tag.colno);
        node3.template = this.parseExpression();
        if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
          node3.ignoreMissing = true;
        }
        this.advanceAfterBlockEnd(tag.value);
        return node3;
      };
      _proto.parseIf = function parseIf() {
        var tag = this.peekToken();
        var node3;
        if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
          node3 = new nodes.If(tag.lineno, tag.colno);
        } else if (this.skipSymbol("ifAsync")) {
          node3 = new nodes.IfAsync(tag.lineno, tag.colno);
        } else {
          this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
        }
        node3.cond = this.parseExpression();
        this.advanceAfterBlockEnd(tag.value);
        node3.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
        var tok = this.peekToken();
        switch (tok && tok.value) {
          case "elseif":
          case "elif":
            node3.else_ = this.parseIf();
            break;
          case "else":
            this.advanceAfterBlockEnd();
            node3.else_ = this.parseUntilBlocks("endif");
            this.advanceAfterBlockEnd();
            break;
          case "endif":
            node3.else_ = null;
            this.advanceAfterBlockEnd();
            break;
          default:
            this.fail("parseIf: expected elif, else, or endif, got end of file");
        }
        return node3;
      };
      _proto.parseSet = function parseSet() {
        var tag = this.peekToken();
        if (!this.skipSymbol("set")) {
          this.fail("parseSet: expected set", tag.lineno, tag.colno);
        }
        var node3 = new nodes.Set(tag.lineno, tag.colno, []);
        var target;
        while (target = this.parsePrimary()) {
          node3.targets.push(target);
          if (!this.skip(lexer.TOKEN_COMMA)) {
            break;
          }
        }
        if (!this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
          if (!this.skip(lexer.TOKEN_BLOCK_END)) {
            this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
          } else {
            node3.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
            node3.value = null;
            this.advanceAfterBlockEnd();
          }
        } else {
          node3.value = this.parseExpression();
          this.advanceAfterBlockEnd(tag.value);
        }
        return node3;
      };
      _proto.parseSwitch = function parseSwitch() {
        var switchStart = "switch";
        var switchEnd = "endswitch";
        var caseStart = "case";
        var caseDefault = "default";
        var tag = this.peekToken();
        if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
          this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
        }
        var expr = this.parseExpression();
        this.advanceAfterBlockEnd(switchStart);
        this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
        var tok = this.peekToken();
        var cases = [];
        var defaultCase;
        do {
          this.skipSymbol(caseStart);
          var cond2 = this.parseExpression();
          this.advanceAfterBlockEnd(switchStart);
          var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
          cases.push(new nodes.Case(tok.line, tok.col, cond2, body));
          tok = this.peekToken();
        } while (tok && tok.value === caseStart);
        switch (tok.value) {
          case caseDefault:
            this.advanceAfterBlockEnd();
            defaultCase = this.parseUntilBlocks(switchEnd);
            this.advanceAfterBlockEnd();
            break;
          case switchEnd:
            this.advanceAfterBlockEnd();
            break;
          default:
            this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
        }
        return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
      };
      _proto.parseStatement = function parseStatement() {
        var tok = this.peekToken();
        var node3;
        if (tok.type !== lexer.TOKEN_SYMBOL) {
          this.fail("tag name expected", tok.lineno, tok.colno);
        }
        if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
          return null;
        }
        switch (tok.value) {
          case "raw":
            return this.parseRaw();
          case "verbatim":
            return this.parseRaw("verbatim");
          case "if":
          case "ifAsync":
            return this.parseIf();
          case "for":
          case "asyncEach":
          case "asyncAll":
            return this.parseFor();
          case "block":
            return this.parseBlock();
          case "extends":
            return this.parseExtends();
          case "include":
            return this.parseInclude();
          case "set":
            return this.parseSet();
          case "macro":
            return this.parseMacro();
          case "call":
            return this.parseCall();
          case "import":
            return this.parseImport();
          case "from":
            return this.parseFrom();
          case "filter":
            return this.parseFilterStatement();
          case "switch":
            return this.parseSwitch();
          default:
            if (this.extensions.length) {
              for (var i2 = 0; i2 < this.extensions.length; i2++) {
                var ext = this.extensions[i2];
                if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                  return ext.parse(this, nodes, lexer);
                }
              }
            }
            this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
        }
        return node3;
      };
      _proto.parseRaw = function parseRaw(tagName) {
        tagName = tagName || "raw";
        var endTagName = "end" + tagName;
        var rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
        var rawLevel = 1;
        var str = "";
        var matches2 = null;
        var begun = this.advanceAfterBlockEnd();
        while ((matches2 = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
          var all = matches2[0];
          var pre = matches2[1];
          var blockName = matches2[2];
          if (blockName === tagName) {
            rawLevel += 1;
          } else if (blockName === endTagName) {
            rawLevel -= 1;
          }
          if (rawLevel === 0) {
            str += pre;
            this.tokens.backN(all.length - pre.length);
          } else {
            str += all;
          }
        }
        return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
      };
      _proto.parsePostfix = function parsePostfix(node3) {
        var lookup2;
        var tok = this.peekToken();
        while (tok) {
          if (tok.type === lexer.TOKEN_LEFT_PAREN) {
            node3 = new nodes.FunCall(tok.lineno, tok.colno, node3, this.parseSignature());
          } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
            lookup2 = this.parseAggregate();
            if (lookup2.children.length > 1) {
              this.fail("invalid index");
            }
            node3 = new nodes.LookupVal(tok.lineno, tok.colno, node3, lookup2.children[0]);
          } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === ".") {
            this.nextToken();
            var val = this.nextToken();
            if (val.type !== lexer.TOKEN_SYMBOL) {
              this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
            }
            lookup2 = new nodes.Literal(val.lineno, val.colno, val.value);
            node3 = new nodes.LookupVal(tok.lineno, tok.colno, node3, lookup2);
          } else {
            break;
          }
          tok = this.peekToken();
        }
        return node3;
      };
      _proto.parseExpression = function parseExpression() {
        var node3 = this.parseInlineIf();
        return node3;
      };
      _proto.parseInlineIf = function parseInlineIf() {
        var node3 = this.parseOr();
        if (this.skipSymbol("if")) {
          var condNode = this.parseOr();
          var bodyNode = node3;
          node3 = new nodes.InlineIf(node3.lineno, node3.colno);
          node3.body = bodyNode;
          node3.cond = condNode;
          if (this.skipSymbol("else")) {
            node3.else_ = this.parseOr();
          } else {
            node3.else_ = null;
          }
        }
        return node3;
      };
      _proto.parseOr = function parseOr() {
        var node3 = this.parseAnd();
        while (this.skipSymbol("or")) {
          var node22 = this.parseAnd();
          node3 = new nodes.Or(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseAnd = function parseAnd() {
        var node3 = this.parseNot();
        while (this.skipSymbol("and")) {
          var node22 = this.parseNot();
          node3 = new nodes.And(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseNot = function parseNot() {
        var tok = this.peekToken();
        if (this.skipSymbol("not")) {
          return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
        }
        return this.parseIn();
      };
      _proto.parseIn = function parseIn() {
        var node3 = this.parseIs();
        while (1) {
          var tok = this.nextToken();
          if (!tok) {
            break;
          }
          var invert3 = tok.type === lexer.TOKEN_SYMBOL && tok.value === "not";
          if (!invert3) {
            this.pushToken(tok);
          }
          if (this.skipSymbol("in")) {
            var node22 = this.parseIs();
            node3 = new nodes.In(node3.lineno, node3.colno, node3, node22);
            if (invert3) {
              node3 = new nodes.Not(node3.lineno, node3.colno, node3);
            }
          } else {
            if (invert3) {
              this.pushToken(tok);
            }
            break;
          }
        }
        return node3;
      };
      _proto.parseIs = function parseIs() {
        var node3 = this.parseCompare();
        if (this.skipSymbol("is")) {
          var not = this.skipSymbol("not");
          var node22 = this.parseCompare();
          node3 = new nodes.Is(node3.lineno, node3.colno, node3, node22);
          if (not) {
            node3 = new nodes.Not(node3.lineno, node3.colno, node3);
          }
        }
        return node3;
      };
      _proto.parseCompare = function parseCompare() {
        var compareOps = ["==", "===", "!=", "!==", "<", ">", "<=", ">="];
        var expr = this.parseConcat();
        var ops = [];
        while (1) {
          var tok = this.nextToken();
          if (!tok) {
            break;
          } else if (compareOps.indexOf(tok.value) !== -1) {
            ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
          } else {
            this.pushToken(tok);
            break;
          }
        }
        if (ops.length) {
          return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
        } else {
          return expr;
        }
      };
      _proto.parseConcat = function parseConcat() {
        var node3 = this.parseAdd();
        while (this.skipValue(lexer.TOKEN_TILDE, "~")) {
          var node22 = this.parseAdd();
          node3 = new nodes.Concat(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseAdd = function parseAdd() {
        var node3 = this.parseSub();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
          var node22 = this.parseSub();
          node3 = new nodes.Add(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseSub = function parseSub() {
        var node3 = this.parseMul();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
          var node22 = this.parseMul();
          node3 = new nodes.Sub(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseMul = function parseMul() {
        var node3 = this.parseDiv();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "*")) {
          var node22 = this.parseDiv();
          node3 = new nodes.Mul(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseDiv = function parseDiv() {
        var node3 = this.parseFloorDiv();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "/")) {
          var node22 = this.parseFloorDiv();
          node3 = new nodes.Div(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseFloorDiv = function parseFloorDiv() {
        var node3 = this.parseMod();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "//")) {
          var node22 = this.parseMod();
          node3 = new nodes.FloorDiv(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseMod = function parseMod() {
        var node3 = this.parsePow();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "%")) {
          var node22 = this.parsePow();
          node3 = new nodes.Mod(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parsePow = function parsePow() {
        var node3 = this.parseUnary();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "**")) {
          var node22 = this.parseUnary();
          node3 = new nodes.Pow(node3.lineno, node3.colno, node3, node22);
        }
        return node3;
      };
      _proto.parseUnary = function parseUnary(noFilters) {
        var tok = this.peekToken();
        var node3;
        if (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
          node3 = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
        } else if (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
          node3 = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
        } else {
          node3 = this.parsePrimary();
        }
        if (!noFilters) {
          node3 = this.parseFilter(node3);
        }
        return node3;
      };
      _proto.parsePrimary = function parsePrimary(noPostfix) {
        var tok = this.nextToken();
        var val;
        var node3 = null;
        if (!tok) {
          this.fail("expected expression, got end of file");
        } else if (tok.type === lexer.TOKEN_STRING) {
          val = tok.value;
        } else if (tok.type === lexer.TOKEN_INT) {
          val = parseInt(tok.value, 10);
        } else if (tok.type === lexer.TOKEN_FLOAT) {
          val = parseFloat(tok.value);
        } else if (tok.type === lexer.TOKEN_BOOLEAN) {
          if (tok.value === "true") {
            val = true;
          } else if (tok.value === "false") {
            val = false;
          } else {
            this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
          }
        } else if (tok.type === lexer.TOKEN_NONE) {
          val = null;
        } else if (tok.type === lexer.TOKEN_REGEX) {
          val = new RegExp(tok.value.body, tok.value.flags);
        }
        if (val !== void 0) {
          node3 = new nodes.Literal(tok.lineno, tok.colno, val);
        } else if (tok.type === lexer.TOKEN_SYMBOL) {
          node3 = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
        } else {
          this.pushToken(tok);
          node3 = this.parseAggregate();
        }
        if (!noPostfix) {
          node3 = this.parsePostfix(node3);
        }
        if (node3) {
          return node3;
        } else {
          throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
        }
      };
      _proto.parseFilterName = function parseFilterName() {
        var tok = this.expect(lexer.TOKEN_SYMBOL);
        var name = tok.value;
        while (this.skipValue(lexer.TOKEN_OPERATOR, ".")) {
          name += "." + this.expect(lexer.TOKEN_SYMBOL).value;
        }
        return new nodes.Symbol(tok.lineno, tok.colno, name);
      };
      _proto.parseFilterArgs = function parseFilterArgs(node3) {
        if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
          var call = this.parsePostfix(node3);
          return call.args.children;
        }
        return [];
      };
      _proto.parseFilter = function parseFilter(node3) {
        while (this.skip(lexer.TOKEN_PIPE)) {
          var name = this.parseFilterName();
          node3 = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node3].concat(this.parseFilterArgs(node3))));
        }
        return node3;
      };
      _proto.parseFilterStatement = function parseFilterStatement() {
        var filterTok = this.peekToken();
        if (!this.skipSymbol("filter")) {
          this.fail("parseFilterStatement: expected filter");
        }
        var name = this.parseFilterName();
        var args = this.parseFilterArgs(name);
        this.advanceAfterBlockEnd(filterTok.value);
        var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
        this.advanceAfterBlockEnd();
        var node3 = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
        return new nodes.Output(name.lineno, name.colno, [node3]);
      };
      _proto.parseAggregate = function parseAggregate() {
        var tok = this.nextToken();
        var node3;
        switch (tok.type) {
          case lexer.TOKEN_LEFT_PAREN:
            node3 = new nodes.Group(tok.lineno, tok.colno);
            break;
          case lexer.TOKEN_LEFT_BRACKET:
            node3 = new nodes.Array(tok.lineno, tok.colno);
            break;
          case lexer.TOKEN_LEFT_CURLY:
            node3 = new nodes.Dict(tok.lineno, tok.colno);
            break;
          default:
            return null;
        }
        while (1) {
          var type = this.peekToken().type;
          if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
            this.nextToken();
            break;
          }
          if (node3.children.length > 0) {
            if (!this.skip(lexer.TOKEN_COMMA)) {
              this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
            }
          }
          if (node3 instanceof nodes.Dict) {
            var key = this.parsePrimary();
            if (!this.skip(lexer.TOKEN_COLON)) {
              this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
            }
            var value = this.parseExpression();
            node3.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
          } else {
            var expr = this.parseExpression();
            node3.addChild(expr);
          }
        }
        return node3;
      };
      _proto.parseSignature = function parseSignature(tolerant, noParens) {
        var tok = this.peekToken();
        if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
          if (tolerant) {
            return null;
          } else {
            this.fail("expected arguments", tok.lineno, tok.colno);
          }
        }
        if (tok.type === lexer.TOKEN_LEFT_PAREN) {
          tok = this.nextToken();
        }
        var args = new nodes.NodeList(tok.lineno, tok.colno);
        var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
        var checkComma = false;
        while (1) {
          tok = this.peekToken();
          if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
            this.nextToken();
            break;
          } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
            break;
          }
          if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
            this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
          } else {
            var arg = this.parseExpression();
            if (this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
              kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
            } else {
              args.addChild(arg);
            }
          }
          checkComma = true;
        }
        if (kwargs.children.length) {
          args.addChild(kwargs);
        }
        return args;
      };
      _proto.parseUntilBlocks = function parseUntilBlocks() {
        var prev = this.breakOnBlocks;
        for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
          blockNames[_key] = arguments[_key];
        }
        this.breakOnBlocks = blockNames;
        var ret = this.parse();
        this.breakOnBlocks = prev;
        return ret;
      };
      _proto.parseNodes = function parseNodes() {
        var tok;
        var buf = [];
        while (tok = this.nextToken()) {
          if (tok.type === lexer.TOKEN_DATA) {
            var data = tok.value;
            var nextToken = this.peekToken();
            var nextVal = nextToken && nextToken.value;
            if (this.dropLeadingWhitespace) {
              data = data.replace(/^\s*/, "");
              this.dropLeadingWhitespace = false;
            }
            if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
              data = data.replace(/\s*$/, "");
            }
            buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
          } else if (tok.type === lexer.TOKEN_BLOCK_START) {
            this.dropLeadingWhitespace = false;
            var n2 = this.parseStatement();
            if (!n2) {
              break;
            }
            buf.push(n2);
          } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
            var e2 = this.parseExpression();
            this.dropLeadingWhitespace = false;
            this.advanceAfterVariableEnd();
            buf.push(new nodes.Output(tok.lineno, tok.colno, [e2]));
          } else if (tok.type === lexer.TOKEN_COMMENT) {
            this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
          } else {
            this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
          }
        }
        return buf;
      };
      _proto.parse = function parse() {
        return new nodes.NodeList(0, 0, this.parseNodes());
      };
      _proto.parseAsRoot = function parseAsRoot() {
        return new nodes.Root(0, 0, this.parseNodes());
      };
      return Parser2;
    })(Obj);
    module2.exports = {
      parse: function parse(src, extensions, opts) {
        var p3 = new Parser(lexer.lex(src, opts));
        if (extensions !== void 0) {
          p3.extensions = extensions;
        }
        return p3.parseAsRoot();
      },
      Parser
    };
  }
});

// ../../node_modules/nunjucks/src/transformer.js
var require_transformer = __commonJS({
  "../../node_modules/nunjucks/src/transformer.js"(exports2, module2) {
    "use strict";
    var nodes = require_nodes();
    var lib = require_lib();
    var sym = 0;
    function gensym() {
      return "hole_" + sym++;
    }
    function mapCOW(arr, func) {
      var res = null;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = func(arr[i2]);
        if (item !== arr[i2]) {
          if (!res) {
            res = arr.slice();
          }
          res[i2] = item;
        }
      }
      return res || arr;
    }
    function walk(ast, func, depthFirst) {
      if (!(ast instanceof nodes.Node)) {
        return ast;
      }
      if (!depthFirst) {
        var astT = func(ast);
        if (astT && astT !== ast) {
          return astT;
        }
      }
      if (ast instanceof nodes.NodeList) {
        var children = mapCOW(ast.children, function(node3) {
          return walk(node3, func, depthFirst);
        });
        if (children !== ast.children) {
          ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
        }
      } else if (ast instanceof nodes.CallExtension) {
        var args = walk(ast.args, func, depthFirst);
        var contentArgs = mapCOW(ast.contentArgs, function(node3) {
          return walk(node3, func, depthFirst);
        });
        if (args !== ast.args || contentArgs !== ast.contentArgs) {
          ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
        }
      } else {
        var props = ast.fields.map(function(field) {
          return ast[field];
        });
        var propsT = mapCOW(props, function(prop) {
          return walk(prop, func, depthFirst);
        });
        if (propsT !== props) {
          ast = new nodes[ast.typename](ast.lineno, ast.colno);
          propsT.forEach(function(prop, i2) {
            ast[ast.fields[i2]] = prop;
          });
        }
      }
      return depthFirst ? func(ast) || ast : ast;
    }
    function depthWalk(ast, func) {
      return walk(ast, func, true);
    }
    function _liftFilters(node3, asyncFilters, prop) {
      var children = [];
      var walked = depthWalk(prop ? node3[prop] : node3, function(descNode) {
        var symbol;
        if (descNode instanceof nodes.Block) {
          return descNode;
        } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
          symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
          children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
        }
        return symbol;
      });
      if (prop) {
        node3[prop] = walked;
      } else {
        node3 = walked;
      }
      if (children.length) {
        children.push(node3);
        return new nodes.NodeList(node3.lineno, node3.colno, children);
      } else {
        return node3;
      }
    }
    function liftFilters(ast, asyncFilters) {
      return depthWalk(ast, function(node3) {
        if (node3 instanceof nodes.Output) {
          return _liftFilters(node3, asyncFilters);
        } else if (node3 instanceof nodes.Set) {
          return _liftFilters(node3, asyncFilters, "value");
        } else if (node3 instanceof nodes.For) {
          return _liftFilters(node3, asyncFilters, "arr");
        } else if (node3 instanceof nodes.If) {
          return _liftFilters(node3, asyncFilters, "cond");
        } else if (node3 instanceof nodes.CallExtension) {
          return _liftFilters(node3, asyncFilters, "args");
        } else {
          return void 0;
        }
      });
    }
    function liftSuper(ast) {
      return walk(ast, function(blockNode) {
        if (!(blockNode instanceof nodes.Block)) {
          return;
        }
        var hasSuper = false;
        var symbol = gensym();
        blockNode.body = walk(blockNode.body, function(node3) {
          if (node3 instanceof nodes.FunCall && node3.name.value === "super") {
            hasSuper = true;
            return new nodes.Symbol(node3.lineno, node3.colno, symbol);
          }
        });
        if (hasSuper) {
          blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
        }
      });
    }
    function convertStatements(ast) {
      return depthWalk(ast, function(node3) {
        if (!(node3 instanceof nodes.If) && !(node3 instanceof nodes.For)) {
          return void 0;
        }
        var async = false;
        walk(node3, function(child) {
          if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
            async = true;
            return child;
          }
          return void 0;
        });
        if (async) {
          if (node3 instanceof nodes.If) {
            return new nodes.IfAsync(node3.lineno, node3.colno, node3.cond, node3.body, node3.else_);
          } else if (node3 instanceof nodes.For && !(node3 instanceof nodes.AsyncAll)) {
            return new nodes.AsyncEach(node3.lineno, node3.colno, node3.arr, node3.name, node3.body, node3.else_);
          }
        }
        return void 0;
      });
    }
    function cps(ast, asyncFilters) {
      return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
    }
    function transform2(ast, asyncFilters) {
      return cps(ast, asyncFilters || []);
    }
    module2.exports = {
      transform: transform2
    };
  }
});

// ../../node_modules/nunjucks/src/runtime.js
var require_runtime = __commonJS({
  "../../node_modules/nunjucks/src/runtime.js"(exports2, module2) {
    "use strict";
    var lib = require_lib();
    var arrayFrom = Array.from;
    var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
    var Frame = /* @__PURE__ */ (function() {
      function Frame2(parent, isolateWrites) {
        this.variables = /* @__PURE__ */ Object.create(null);
        this.parent = parent;
        this.topLevel = false;
        this.isolateWrites = isolateWrites;
      }
      var _proto = Frame2.prototype;
      _proto.set = function set2(name, val, resolveUp) {
        var parts = name.split(".");
        var obj = this.variables;
        var frame = this;
        if (resolveUp) {
          if (frame = this.resolve(parts[0], true)) {
            frame.set(name, val);
            return;
          }
        }
        for (var i2 = 0; i2 < parts.length - 1; i2++) {
          var id = parts[i2];
          if (!obj[id]) {
            obj[id] = {};
          }
          obj = obj[id];
        }
        obj[parts[parts.length - 1]] = val;
      };
      _proto.get = function get2(name) {
        var val = this.variables[name];
        if (val !== void 0) {
          return val;
        }
        return null;
      };
      _proto.lookup = function lookup2(name) {
        var p3 = this.parent;
        var val = this.variables[name];
        if (val !== void 0) {
          return val;
        }
        return p3 && p3.lookup(name);
      };
      _proto.resolve = function resolve(name, forWrite) {
        var p3 = forWrite && this.isolateWrites ? void 0 : this.parent;
        var val = this.variables[name];
        if (val !== void 0) {
          return this;
        }
        return p3 && p3.resolve(name);
      };
      _proto.push = function push(isolateWrites) {
        return new Frame2(this, isolateWrites);
      };
      _proto.pop = function pop() {
        return this.parent;
      };
      return Frame2;
    })();
    function makeMacro(argNames, kwargNames, func) {
      return function macro() {
        for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
          macroArgs[_key] = arguments[_key];
        }
        var argCount = numArgs(macroArgs);
        var args;
        var kwargs = getKeywordArgs(macroArgs);
        if (argCount > argNames.length) {
          args = macroArgs.slice(0, argNames.length);
          macroArgs.slice(args.length, argCount).forEach(function(val, i3) {
            if (i3 < kwargNames.length) {
              kwargs[kwargNames[i3]] = val;
            }
          });
          args.push(kwargs);
        } else if (argCount < argNames.length) {
          args = macroArgs.slice(0, argCount);
          for (var i2 = argCount; i2 < argNames.length; i2++) {
            var arg = argNames[i2];
            args.push(kwargs[arg]);
            delete kwargs[arg];
          }
          args.push(kwargs);
        } else {
          args = macroArgs;
        }
        return func.apply(this, args);
      };
    }
    function makeKeywordArgs(obj) {
      obj.__keywords = true;
      return obj;
    }
    function isKeywordArgs(obj) {
      return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
    }
    function getKeywordArgs(args) {
      var len = args.length;
      if (len) {
        var lastArg = args[len - 1];
        if (isKeywordArgs(lastArg)) {
          return lastArg;
        }
      }
      return {};
    }
    function numArgs(args) {
      var len = args.length;
      if (len === 0) {
        return 0;
      }
      var lastArg = args[len - 1];
      if (isKeywordArgs(lastArg)) {
        return len - 1;
      } else {
        return len;
      }
    }
    function SafeString(val) {
      if (typeof val !== "string") {
        return val;
      }
      this.val = val;
      this.length = val.length;
    }
    SafeString.prototype = Object.create(String.prototype, {
      length: {
        writable: true,
        configurable: true,
        value: 0
      }
    });
    SafeString.prototype.valueOf = function valueOf() {
      return this.val;
    };
    SafeString.prototype.toString = function toString2() {
      return this.val;
    };
    function copySafeness(dest, target) {
      if (dest instanceof SafeString) {
        return new SafeString(target);
      }
      return target.toString();
    }
    function markSafe(val) {
      var type = typeof val;
      if (type === "string") {
        return new SafeString(val);
      } else if (type !== "function") {
        return val;
      } else {
        return function wrapSafe(args) {
          var ret = val.apply(this, arguments);
          if (typeof ret === "string") {
            return new SafeString(ret);
          }
          return ret;
        };
      }
    }
    function suppressValue(val, autoescape) {
      val = val !== void 0 && val !== null ? val : "";
      if (autoescape && !(val instanceof SafeString)) {
        val = lib.escape(val.toString());
      }
      return val;
    }
    function ensureDefined(val, lineno, colno) {
      if (val === null || val === void 0) {
        throw new lib.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
      }
      return val;
    }
    function memberLookup(obj, val) {
      if (obj === void 0 || obj === null) {
        return void 0;
      }
      if (typeof obj[val] === "function") {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return obj[val].apply(obj, args);
        };
      }
      return obj[val];
    }
    function callWrap(obj, name, context, args) {
      if (!obj) {
        throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
      } else if (typeof obj !== "function") {
        throw new Error("Unable to call `" + name + "`, which is not a function");
      }
      return obj.apply(context, args);
    }
    function contextOrFrameLookup(context, frame, name) {
      var val = frame.lookup(name);
      return val !== void 0 ? val : context.lookup(name);
    }
    function handleError(error, lineno, colno) {
      if (error.lineno) {
        return error;
      } else {
        return new lib.TemplateError(error, lineno, colno);
      }
    }
    function asyncEach(arr, dimen, iter, cb) {
      if (lib.isArray(arr)) {
        var len = arr.length;
        lib.asyncIter(arr, function iterCallback(item, i2, next) {
          switch (dimen) {
            case 1:
              iter(item, i2, len, next);
              break;
            case 2:
              iter(item[0], item[1], i2, len, next);
              break;
            case 3:
              iter(item[0], item[1], item[2], i2, len, next);
              break;
            default:
              item.push(i2, len, next);
              iter.apply(this, item);
          }
        }, cb);
      } else {
        lib.asyncFor(arr, function iterCallback(key, val, i2, len2, next) {
          iter(key, val, i2, len2, next);
        }, cb);
      }
    }
    function asyncAll(arr, dimen, func, cb) {
      var finished = 0;
      var len;
      var outputArr;
      function done(i3, output) {
        finished++;
        outputArr[i3] = output;
        if (finished === len) {
          cb(null, outputArr.join(""));
        }
      }
      if (lib.isArray(arr)) {
        len = arr.length;
        outputArr = new Array(len);
        if (len === 0) {
          cb(null, "");
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            var item = arr[i2];
            switch (dimen) {
              case 1:
                func(item, i2, len, done);
                break;
              case 2:
                func(item[0], item[1], i2, len, done);
                break;
              case 3:
                func(item[0], item[1], item[2], i2, len, done);
                break;
              default:
                item.push(i2, len, done);
                func.apply(this, item);
            }
          }
        }
      } else {
        var keys2 = lib.keys(arr || {});
        len = keys2.length;
        outputArr = new Array(len);
        if (len === 0) {
          cb(null, "");
        } else {
          for (var _i = 0; _i < keys2.length; _i++) {
            var k2 = keys2[_i];
            func(k2, arr[k2], _i, len, done);
          }
        }
      }
    }
    function fromIterator(arr) {
      if (typeof arr !== "object" || arr === null || lib.isArray(arr)) {
        return arr;
      } else if (supportsIterators && Symbol.iterator in arr) {
        return arrayFrom(arr);
      } else {
        return arr;
      }
    }
    module2.exports = {
      Frame,
      makeMacro,
      makeKeywordArgs,
      numArgs,
      suppressValue,
      ensureDefined,
      memberLookup,
      contextOrFrameLookup,
      callWrap,
      handleError,
      isArray: lib.isArray,
      keys: lib.keys,
      SafeString,
      copySafeness,
      markSafe,
      asyncEach,
      asyncAll,
      inOperator: lib.inOperator,
      fromIterator
    };
  }
});

// ../../node_modules/nunjucks/src/compiler.js
var require_compiler = __commonJS({
  "../../node_modules/nunjucks/src/compiler.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var parser = require_parser();
    var transformer = require_transformer();
    var nodes = require_nodes();
    var _require = require_lib();
    var TemplateError = _require.TemplateError;
    var _require2 = require_runtime();
    var Frame = _require2.Frame;
    var _require3 = require_object2();
    var Obj = _require3.Obj;
    var compareOps = {
      "==": "==",
      "===": "===",
      "!=": "!=",
      "!==": "!==",
      "<": "<",
      ">": ">",
      "<=": "<=",
      ">=": ">="
    };
    var Compiler = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Compiler2, _Obj);
      function Compiler2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto = Compiler2.prototype;
      _proto.init = function init4(templateName, throwOnUndefined) {
        this.templateName = templateName;
        this.codebuf = [];
        this.lastId = 0;
        this.buffer = null;
        this.bufferStack = [];
        this._scopeClosers = "";
        this.inBlock = false;
        this.throwOnUndefined = throwOnUndefined;
      };
      _proto.fail = function fail(msg, lineno, colno) {
        if (lineno !== void 0) {
          lineno += 1;
        }
        if (colno !== void 0) {
          colno += 1;
        }
        throw new TemplateError(msg, lineno, colno);
      };
      _proto._pushBuffer = function _pushBuffer() {
        var id = this._tmpid();
        this.bufferStack.push(this.buffer);
        this.buffer = id;
        this._emit("var " + this.buffer + ' = "";');
        return id;
      };
      _proto._popBuffer = function _popBuffer() {
        this.buffer = this.bufferStack.pop();
      };
      _proto._emit = function _emit(code) {
        this.codebuf.push(code);
      };
      _proto._emitLine = function _emitLine(code) {
        this._emit(code + "\n");
      };
      _proto._emitLines = function _emitLines() {
        var _this = this;
        for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
          lines[_key] = arguments[_key];
        }
        lines.forEach(function(line) {
          return _this._emitLine(line);
        });
      };
      _proto._emitFuncBegin = function _emitFuncBegin(node3, name) {
        this.buffer = "output";
        this._scopeClosers = "";
        this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");
        this._emitLine("var lineno = " + node3.lineno + ";");
        this._emitLine("var colno = " + node3.colno + ";");
        this._emitLine("var " + this.buffer + ' = "";');
        this._emitLine("try {");
      };
      _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
        if (!noReturn) {
          this._emitLine("cb(null, " + this.buffer + ");");
        }
        this._closeScopeLevels();
        this._emitLine("} catch (e) {");
        this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
        this._emitLine("}");
        this._emitLine("}");
        this.buffer = null;
      };
      _proto._addScopeLevel = function _addScopeLevel() {
        this._scopeClosers += "})";
      };
      _proto._closeScopeLevels = function _closeScopeLevels() {
        this._emitLine(this._scopeClosers + ";");
        this._scopeClosers = "";
      };
      _proto._withScopedSyntax = function _withScopedSyntax(func) {
        var _scopeClosers = this._scopeClosers;
        this._scopeClosers = "";
        func.call(this);
        this._closeScopeLevels();
        this._scopeClosers = _scopeClosers;
      };
      _proto._makeCallback = function _makeCallback(res) {
        var err = this._tmpid();
        return "function(" + err + (res ? "," + res : "") + ") {\nif(" + err + ") { cb(" + err + "); return; }";
      };
      _proto._tmpid = function _tmpid() {
        this.lastId++;
        return "t_" + this.lastId;
      };
      _proto._templateName = function _templateName() {
        return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
      };
      _proto._compileChildren = function _compileChildren(node3, frame) {
        var _this2 = this;
        node3.children.forEach(function(child) {
          _this2.compile(child, frame);
        });
      };
      _proto._compileAggregate = function _compileAggregate(node3, frame, startChar, endChar) {
        var _this3 = this;
        if (startChar) {
          this._emit(startChar);
        }
        node3.children.forEach(function(child, i2) {
          if (i2 > 0) {
            _this3._emit(",");
          }
          _this3.compile(child, frame);
        });
        if (endChar) {
          this._emit(endChar);
        }
      };
      _proto._compileExpression = function _compileExpression(node3, frame) {
        this.assertType(node3, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
        this.compile(node3, frame);
      };
      _proto.assertType = function assertType(node3) {
        for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          types[_key2 - 1] = arguments[_key2];
        }
        if (!types.some(function(t2) {
          return node3 instanceof t2;
        })) {
          this.fail("assertType: invalid type: " + node3.typename, node3.lineno, node3.colno);
        }
      };
      _proto.compileCallExtension = function compileCallExtension(node3, frame, async) {
        var _this4 = this;
        var args = node3.args;
        var contentArgs = node3.contentArgs;
        var autoescape = typeof node3.autoescape === "boolean" ? node3.autoescape : true;
        if (!async) {
          this._emit(this.buffer + " += runtime.suppressValue(");
        }
        this._emit('env.getExtension("' + node3.extName + '")["' + node3.prop + '"](');
        this._emit("context");
        if (args || contentArgs) {
          this._emit(",");
        }
        if (args) {
          if (!(args instanceof nodes.NodeList)) {
            this.fail("compileCallExtension: arguments must be a NodeList, use `parser.parseSignature`");
          }
          args.children.forEach(function(arg, i2) {
            _this4._compileExpression(arg, frame);
            if (i2 !== args.children.length - 1 || contentArgs.length) {
              _this4._emit(",");
            }
          });
        }
        if (contentArgs.length) {
          contentArgs.forEach(function(arg, i2) {
            if (i2 > 0) {
              _this4._emit(",");
            }
            if (arg) {
              _this4._emitLine("function(cb) {");
              _this4._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
              var id = _this4._pushBuffer();
              _this4._withScopedSyntax(function() {
                _this4.compile(arg, frame);
                _this4._emitLine("cb(null, " + id + ");");
              });
              _this4._popBuffer();
              _this4._emitLine("return " + id + ";");
              _this4._emitLine("}");
            } else {
              _this4._emit("null");
            }
          });
        }
        if (async) {
          var res = this._tmpid();
          this._emitLine(", " + this._makeCallback(res));
          this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");
          this._addScopeLevel();
        } else {
          this._emit(")");
          this._emit(", " + autoescape + " && env.opts.autoescape);\n");
        }
      };
      _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node3, frame) {
        this.compileCallExtension(node3, frame, true);
      };
      _proto.compileNodeList = function compileNodeList(node3, frame) {
        this._compileChildren(node3, frame);
      };
      _proto.compileLiteral = function compileLiteral(node3) {
        if (typeof node3.value === "string") {
          var val = node3.value.replace(/\\/g, "\\\\");
          val = val.replace(/"/g, '\\"');
          val = val.replace(/\n/g, "\\n");
          val = val.replace(/\r/g, "\\r");
          val = val.replace(/\t/g, "\\t");
          val = val.replace(/\u2028/g, "\\u2028");
          this._emit('"' + val + '"');
        } else if (node3.value === null) {
          this._emit("null");
        } else {
          this._emit(node3.value.toString());
        }
      };
      _proto.compileSymbol = function compileSymbol(node3, frame) {
        var name = node3.value;
        var v3 = frame.lookup(name);
        if (v3) {
          this._emit(v3);
        } else {
          this._emit('runtime.contextOrFrameLookup(context, frame, "' + name + '")');
        }
      };
      _proto.compileGroup = function compileGroup(node3, frame) {
        this._compileAggregate(node3, frame, "(", ")");
      };
      _proto.compileArray = function compileArray(node3, frame) {
        this._compileAggregate(node3, frame, "[", "]");
      };
      _proto.compileDict = function compileDict(node3, frame) {
        this._compileAggregate(node3, frame, "{", "}");
      };
      _proto.compilePair = function compilePair(node3, frame) {
        var key = node3.key;
        var val = node3.value;
        if (key instanceof nodes.Symbol) {
          key = new nodes.Literal(key.lineno, key.colno, key.value);
        } else if (!(key instanceof nodes.Literal && typeof key.value === "string")) {
          this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
        }
        this.compile(key, frame);
        this._emit(": ");
        this._compileExpression(val, frame);
      };
      _proto.compileInlineIf = function compileInlineIf(node3, frame) {
        this._emit("(");
        this.compile(node3.cond, frame);
        this._emit("?");
        this.compile(node3.body, frame);
        this._emit(":");
        if (node3.else_ !== null) {
          this.compile(node3.else_, frame);
        } else {
          this._emit('""');
        }
        this._emit(")");
      };
      _proto.compileIn = function compileIn(node3, frame) {
        this._emit("runtime.inOperator(");
        this.compile(node3.left, frame);
        this._emit(",");
        this.compile(node3.right, frame);
        this._emit(")");
      };
      _proto.compileIs = function compileIs(node3, frame) {
        var right = node3.right.name ? node3.right.name.value : node3.right.value;
        this._emit('env.getTest("' + right + '").call(context, ');
        this.compile(node3.left, frame);
        if (node3.right.args) {
          this._emit(",");
          this.compile(node3.right.args, frame);
        }
        this._emit(") === true");
      };
      _proto._binOpEmitter = function _binOpEmitter(node3, frame, str) {
        this.compile(node3.left, frame);
        this._emit(str);
        this.compile(node3.right, frame);
      };
      _proto.compileOr = function compileOr(node3, frame) {
        return this._binOpEmitter(node3, frame, " || ");
      };
      _proto.compileAnd = function compileAnd(node3, frame) {
        return this._binOpEmitter(node3, frame, " && ");
      };
      _proto.compileAdd = function compileAdd(node3, frame) {
        return this._binOpEmitter(node3, frame, " + ");
      };
      _proto.compileConcat = function compileConcat(node3, frame) {
        return this._binOpEmitter(node3, frame, ' + "" + ');
      };
      _proto.compileSub = function compileSub(node3, frame) {
        return this._binOpEmitter(node3, frame, " - ");
      };
      _proto.compileMul = function compileMul(node3, frame) {
        return this._binOpEmitter(node3, frame, " * ");
      };
      _proto.compileDiv = function compileDiv(node3, frame) {
        return this._binOpEmitter(node3, frame, " / ");
      };
      _proto.compileMod = function compileMod(node3, frame) {
        return this._binOpEmitter(node3, frame, " % ");
      };
      _proto.compileNot = function compileNot(node3, frame) {
        this._emit("!");
        this.compile(node3.target, frame);
      };
      _proto.compileFloorDiv = function compileFloorDiv(node3, frame) {
        this._emit("Math.floor(");
        this.compile(node3.left, frame);
        this._emit(" / ");
        this.compile(node3.right, frame);
        this._emit(")");
      };
      _proto.compilePow = function compilePow(node3, frame) {
        this._emit("Math.pow(");
        this.compile(node3.left, frame);
        this._emit(", ");
        this.compile(node3.right, frame);
        this._emit(")");
      };
      _proto.compileNeg = function compileNeg(node3, frame) {
        this._emit("-");
        this.compile(node3.target, frame);
      };
      _proto.compilePos = function compilePos(node3, frame) {
        this._emit("+");
        this.compile(node3.target, frame);
      };
      _proto.compileCompare = function compileCompare(node3, frame) {
        var _this5 = this;
        this.compile(node3.expr, frame);
        node3.ops.forEach(function(op) {
          _this5._emit(" " + compareOps[op.type] + " ");
          _this5.compile(op.expr, frame);
        });
      };
      _proto.compileLookupVal = function compileLookupVal(node3, frame) {
        this._emit("runtime.memberLookup((");
        this._compileExpression(node3.target, frame);
        this._emit("),");
        this._compileExpression(node3.val, frame);
        this._emit(")");
      };
      _proto._getNodeName = function _getNodeName(node3) {
        switch (node3.typename) {
          case "Symbol":
            return node3.value;
          case "FunCall":
            return "the return value of (" + this._getNodeName(node3.name) + ")";
          case "LookupVal":
            return this._getNodeName(node3.target) + '["' + this._getNodeName(node3.val) + '"]';
          case "Literal":
            return node3.value.toString();
          default:
            return "--expression--";
        }
      };
      _proto.compileFunCall = function compileFunCall(node3, frame) {
        this._emit("(lineno = " + node3.lineno + ", colno = " + node3.colno + ", ");
        this._emit("runtime.callWrap(");
        this._compileExpression(node3.name, frame);
        this._emit(', "' + this._getNodeName(node3.name).replace(/"/g, '\\"') + '", context, ');
        this._compileAggregate(node3.args, frame, "[", "])");
        this._emit(")");
      };
      _proto.compileFilter = function compileFilter(node3, frame) {
        var name = node3.name;
        this.assertType(name, nodes.Symbol);
        this._emit('env.getFilter("' + name.value + '").call(context, ');
        this._compileAggregate(node3.args, frame);
        this._emit(")");
      };
      _proto.compileFilterAsync = function compileFilterAsync(node3, frame) {
        var name = node3.name;
        var symbol = node3.symbol.value;
        this.assertType(name, nodes.Symbol);
        frame.set(symbol, symbol);
        this._emit('env.getFilter("' + name.value + '").call(context, ');
        this._compileAggregate(node3.args, frame);
        this._emitLine(", " + this._makeCallback(symbol));
        this._addScopeLevel();
      };
      _proto.compileKeywordArgs = function compileKeywordArgs(node3, frame) {
        this._emit("runtime.makeKeywordArgs(");
        this.compileDict(node3, frame);
        this._emit(")");
      };
      _proto.compileSet = function compileSet(node3, frame) {
        var _this6 = this;
        var ids = [];
        node3.targets.forEach(function(target) {
          var name = target.value;
          var id = frame.lookup(name);
          if (id === null || id === void 0) {
            id = _this6._tmpid();
            _this6._emitLine("var " + id + ";");
          }
          ids.push(id);
        });
        if (node3.value) {
          this._emit(ids.join(" = ") + " = ");
          this._compileExpression(node3.value, frame);
          this._emitLine(";");
        } else {
          this._emit(ids.join(" = ") + " = ");
          this.compile(node3.body, frame);
          this._emitLine(";");
        }
        node3.targets.forEach(function(target, i2) {
          var id = ids[i2];
          var name = target.value;
          _this6._emitLine('frame.set("' + name + '", ' + id + ", true);");
          _this6._emitLine("if(frame.topLevel) {");
          _this6._emitLine('context.setVariable("' + name + '", ' + id + ");");
          _this6._emitLine("}");
          if (name.charAt(0) !== "_") {
            _this6._emitLine("if(frame.topLevel) {");
            _this6._emitLine('context.addExport("' + name + '", ' + id + ");");
            _this6._emitLine("}");
          }
        });
      };
      _proto.compileSwitch = function compileSwitch(node3, frame) {
        var _this7 = this;
        this._emit("switch (");
        this.compile(node3.expr, frame);
        this._emit(") {");
        node3.cases.forEach(function(c2, i2) {
          _this7._emit("case ");
          _this7.compile(c2.cond, frame);
          _this7._emit(": ");
          _this7.compile(c2.body, frame);
          if (c2.body.children.length) {
            _this7._emitLine("break;");
          }
        });
        if (node3.default) {
          this._emit("default:");
          this.compile(node3.default, frame);
        }
        this._emit("}");
      };
      _proto.compileIf = function compileIf(node3, frame, async) {
        var _this8 = this;
        this._emit("if(");
        this._compileExpression(node3.cond, frame);
        this._emitLine(") {");
        this._withScopedSyntax(function() {
          _this8.compile(node3.body, frame);
          if (async) {
            _this8._emit("cb()");
          }
        });
        if (node3.else_) {
          this._emitLine("}\nelse {");
          this._withScopedSyntax(function() {
            _this8.compile(node3.else_, frame);
            if (async) {
              _this8._emit("cb()");
            }
          });
        } else if (async) {
          this._emitLine("}\nelse {");
          this._emit("cb()");
        }
        this._emitLine("}");
      };
      _proto.compileIfAsync = function compileIfAsync(node3, frame) {
        this._emit("(function(cb) {");
        this.compileIf(node3, frame, true);
        this._emit("})(" + this._makeCallback());
        this._addScopeLevel();
      };
      _proto._emitLoopBindings = function _emitLoopBindings(node3, arr, i2, len) {
        var _this9 = this;
        var bindings = [{
          name: "index",
          val: i2 + " + 1"
        }, {
          name: "index0",
          val: i2
        }, {
          name: "revindex",
          val: len + " - " + i2
        }, {
          name: "revindex0",
          val: len + " - " + i2 + " - 1"
        }, {
          name: "first",
          val: i2 + " === 0"
        }, {
          name: "last",
          val: i2 + " === " + len + " - 1"
        }, {
          name: "length",
          val: len
        }];
        bindings.forEach(function(b2) {
          _this9._emitLine('frame.set("loop.' + b2.name + '", ' + b2.val + ");");
        });
      };
      _proto.compileFor = function compileFor(node3, frame) {
        var _this10 = this;
        var i2 = this._tmpid();
        var len = this._tmpid();
        var arr = this._tmpid();
        frame = frame.push();
        this._emitLine("frame = frame.push();");
        this._emit("var " + arr + " = ");
        this._compileExpression(node3.arr, frame);
        this._emitLine(";");
        this._emit("if(" + arr + ") {");
        this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
        if (node3.name instanceof nodes.Array) {
          this._emitLine("var " + i2 + ";");
          this._emitLine("if(runtime.isArray(" + arr + ")) {");
          this._emitLine("var " + len + " = " + arr + ".length;");
          this._emitLine("for(" + i2 + "=0; " + i2 + " < " + arr + ".length; " + i2 + "++) {");
          node3.name.children.forEach(function(child, u2) {
            var tid = _this10._tmpid();
            _this10._emitLine("var " + tid + " = " + arr + "[" + i2 + "][" + u2 + "];");
            _this10._emitLine('frame.set("' + child + '", ' + arr + "[" + i2 + "][" + u2 + "]);");
            frame.set(node3.name.children[u2].value, tid);
          });
          this._emitLoopBindings(node3, arr, i2, len);
          this._withScopedSyntax(function() {
            _this10.compile(node3.body, frame);
          });
          this._emitLine("}");
          this._emitLine("} else {");
          var _node$name$children = node3.name.children, key = _node$name$children[0], val = _node$name$children[1];
          var k2 = this._tmpid();
          var v3 = this._tmpid();
          frame.set(key.value, k2);
          frame.set(val.value, v3);
          this._emitLine(i2 + " = -1;");
          this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");
          this._emitLine("for(var " + k2 + " in " + arr + ") {");
          this._emitLine(i2 + "++;");
          this._emitLine("var " + v3 + " = " + arr + "[" + k2 + "];");
          this._emitLine('frame.set("' + key.value + '", ' + k2 + ");");
          this._emitLine('frame.set("' + val.value + '", ' + v3 + ");");
          this._emitLoopBindings(node3, arr, i2, len);
          this._withScopedSyntax(function() {
            _this10.compile(node3.body, frame);
          });
          this._emitLine("}");
          this._emitLine("}");
        } else {
          var _v = this._tmpid();
          frame.set(node3.name.value, _v);
          this._emitLine("var " + len + " = " + arr + ".length;");
          this._emitLine("for(var " + i2 + "=0; " + i2 + " < " + arr + ".length; " + i2 + "++) {");
          this._emitLine("var " + _v + " = " + arr + "[" + i2 + "];");
          this._emitLine('frame.set("' + node3.name.value + '", ' + _v + ");");
          this._emitLoopBindings(node3, arr, i2, len);
          this._withScopedSyntax(function() {
            _this10.compile(node3.body, frame);
          });
          this._emitLine("}");
        }
        this._emitLine("}");
        if (node3.else_) {
          this._emitLine("if (!" + len + ") {");
          this.compile(node3.else_, frame);
          this._emitLine("}");
        }
        this._emitLine("frame = frame.pop();");
      };
      _proto._compileAsyncLoop = function _compileAsyncLoop(node3, frame, parallel) {
        var _this11 = this;
        var i2 = this._tmpid();
        var len = this._tmpid();
        var arr = this._tmpid();
        var asyncMethod = parallel ? "asyncAll" : "asyncEach";
        frame = frame.push();
        this._emitLine("frame = frame.push();");
        this._emit("var " + arr + " = runtime.fromIterator(");
        this._compileExpression(node3.arr, frame);
        this._emitLine(");");
        if (node3.name instanceof nodes.Array) {
          var arrayLen = node3.name.children.length;
          this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");
          node3.name.children.forEach(function(name) {
            _this11._emit(name.value + ",");
          });
          this._emit(i2 + "," + len + ",next) {");
          node3.name.children.forEach(function(name) {
            var id2 = name.value;
            frame.set(id2, id2);
            _this11._emitLine('frame.set("' + id2 + '", ' + id2 + ");");
          });
        } else {
          var id = node3.name.value;
          this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i2 + ", " + len + ",next) {");
          this._emitLine('frame.set("' + id + '", ' + id + ");");
          frame.set(id, id);
        }
        this._emitLoopBindings(node3, arr, i2, len);
        this._withScopedSyntax(function() {
          var buf;
          if (parallel) {
            buf = _this11._pushBuffer();
          }
          _this11.compile(node3.body, frame);
          _this11._emitLine("next(" + i2 + (buf ? "," + buf : "") + ");");
          if (parallel) {
            _this11._popBuffer();
          }
        });
        var output = this._tmpid();
        this._emitLine("}, " + this._makeCallback(output));
        this._addScopeLevel();
        if (parallel) {
          this._emitLine(this.buffer + " += " + output + ";");
        }
        if (node3.else_) {
          this._emitLine("if (!" + arr + ".length) {");
          this.compile(node3.else_, frame);
          this._emitLine("}");
        }
        this._emitLine("frame = frame.pop();");
      };
      _proto.compileAsyncEach = function compileAsyncEach(node3, frame) {
        this._compileAsyncLoop(node3, frame);
      };
      _proto.compileAsyncAll = function compileAsyncAll(node3, frame) {
        this._compileAsyncLoop(node3, frame, true);
      };
      _proto._compileMacro = function _compileMacro(node3, frame) {
        var _this12 = this;
        var args = [];
        var kwargs = null;
        var funcId = "macro_" + this._tmpid();
        var keepFrame = frame !== void 0;
        node3.args.children.forEach(function(arg, i2) {
          if (i2 === node3.args.children.length - 1 && arg instanceof nodes.Dict) {
            kwargs = arg;
          } else {
            _this12.assertType(arg, nodes.Symbol);
            args.push(arg);
          }
        });
        var realNames = [].concat(args.map(function(n2) {
          return "l_" + n2.value;
        }), ["kwargs"]);
        var argNames = args.map(function(n2) {
          return '"' + n2.value + '"';
        });
        var kwargNames = (kwargs && kwargs.children || []).map(function(n2) {
          return '"' + n2.key.value + '"';
        });
        var currFrame;
        if (keepFrame) {
          currFrame = frame.push(true);
        } else {
          currFrame = new Frame();
        }
        this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(", ") + "], ", "[" + kwargNames.join(", ") + "], ", "function (" + realNames.join(", ") + ") {", "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
        args.forEach(function(arg) {
          _this12._emitLine('frame.set("' + arg.value + '", l_' + arg.value + ");");
          currFrame.set(arg.value, "l_" + arg.value);
        });
        if (kwargs) {
          kwargs.children.forEach(function(pair) {
            var name = pair.key.value;
            _this12._emit('frame.set("' + name + '", ');
            _this12._emit('Object.prototype.hasOwnProperty.call(kwargs, "' + name + '")');
            _this12._emit(' ? kwargs["' + name + '"] : ');
            _this12._compileExpression(pair.value, currFrame);
            _this12._emit(");");
          });
        }
        var bufferId = this._pushBuffer();
        this._withScopedSyntax(function() {
          _this12.compile(node3.body, currFrame);
        });
        this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
        this._emitLine("return new runtime.SafeString(" + bufferId + ");");
        this._emitLine("});");
        this._popBuffer();
        return funcId;
      };
      _proto.compileMacro = function compileMacro(node3, frame) {
        var funcId = this._compileMacro(node3);
        var name = node3.name.value;
        frame.set(name, funcId);
        if (frame.parent) {
          this._emitLine('frame.set("' + name + '", ' + funcId + ");");
        } else {
          if (node3.name.value.charAt(0) !== "_") {
            this._emitLine('context.addExport("' + name + '");');
          }
          this._emitLine('context.setVariable("' + name + '", ' + funcId + ");");
        }
      };
      _proto.compileCaller = function compileCaller(node3, frame) {
        this._emit("(function (){");
        var funcId = this._compileMacro(node3, frame);
        this._emit("return " + funcId + ";})()");
      };
      _proto._compileGetTemplate = function _compileGetTemplate(node3, frame, eagerCompile, ignoreMissing) {
        var parentTemplateId = this._tmpid();
        var parentName = this._templateName();
        var cb = this._makeCallback(parentTemplateId);
        var eagerCompileArg = eagerCompile ? "true" : "false";
        var ignoreMissingArg = ignoreMissing ? "true" : "false";
        this._emit("env.getTemplate(");
        this._compileExpression(node3.template, frame);
        this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);
        return parentTemplateId;
      };
      _proto.compileImport = function compileImport(node3, frame) {
        var target = node3.target.value;
        var id = this._compileGetTemplate(node3, frame, false, false);
        this._addScopeLevel();
        this._emitLine(id + ".getExported(" + (node3.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
        this._addScopeLevel();
        frame.set(target, id);
        if (frame.parent) {
          this._emitLine('frame.set("' + target + '", ' + id + ");");
        } else {
          this._emitLine('context.setVariable("' + target + '", ' + id + ");");
        }
      };
      _proto.compileFromImport = function compileFromImport(node3, frame) {
        var _this13 = this;
        var importedId = this._compileGetTemplate(node3, frame, false, false);
        this._addScopeLevel();
        this._emitLine(importedId + ".getExported(" + (node3.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
        this._addScopeLevel();
        node3.names.children.forEach(function(nameNode) {
          var name;
          var alias;
          var id = _this13._tmpid();
          if (nameNode instanceof nodes.Pair) {
            name = nameNode.key.value;
            alias = nameNode.value.value;
          } else {
            name = nameNode.value;
            alias = name;
          }
          _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ', "' + name + '")) {');
          _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");
          _this13._emitLine("} else {");
          _this13._emitLine(`cb(new Error("cannot import '` + name + `'")); return;`);
          _this13._emitLine("}");
          frame.set(alias, id);
          if (frame.parent) {
            _this13._emitLine('frame.set("' + alias + '", ' + id + ");");
          } else {
            _this13._emitLine('context.setVariable("' + alias + '", ' + id + ");");
          }
        });
      };
      _proto.compileBlock = function compileBlock(node3) {
        var id = this._tmpid();
        if (!this.inBlock) {
          this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
        }
        this._emit('context.getBlock("' + node3.name.value + '")');
        if (!this.inBlock) {
          this._emit(")");
        }
        this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
        this._emitLine(this.buffer + " += " + id + ";");
        this._addScopeLevel();
      };
      _proto.compileSuper = function compileSuper(node3, frame) {
        var name = node3.blockName.value;
        var id = node3.symbol.value;
        var cb = this._makeCallback(id);
        this._emitLine('context.getSuper(env, "' + name + '", b_' + name + ", frame, runtime, " + cb);
        this._emitLine(id + " = runtime.markSafe(" + id + ");");
        this._addScopeLevel();
        frame.set(id, id);
      };
      _proto.compileExtends = function compileExtends(node3, frame) {
        var k2 = this._tmpid();
        var parentTemplateId = this._compileGetTemplate(node3, frame, true, false);
        this._emitLine("parentTemplate = " + parentTemplateId);
        this._emitLine("for(var " + k2 + " in parentTemplate.blocks) {");
        this._emitLine("context.addBlock(" + k2 + ", parentTemplate.blocks[" + k2 + "]);");
        this._emitLine("}");
        this._addScopeLevel();
      };
      _proto.compileInclude = function compileInclude(node3, frame) {
        this._emitLine("var tasks = [];");
        this._emitLine("tasks.push(");
        this._emitLine("function(callback) {");
        var id = this._compileGetTemplate(node3, frame, false, node3.ignoreMissing);
        this._emitLine("callback(null," + id + ");});");
        this._emitLine("});");
        var id2 = this._tmpid();
        this._emitLine("tasks.push(");
        this._emitLine("function(template, callback){");
        this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
        this._emitLine("callback(null," + id2 + ");});");
        this._emitLine("});");
        this._emitLine("tasks.push(");
        this._emitLine("function(result, callback){");
        this._emitLine(this.buffer + " += result;");
        this._emitLine("callback(null);");
        this._emitLine("});");
        this._emitLine("env.waterfall(tasks, function(){");
        this._addScopeLevel();
      };
      _proto.compileTemplateData = function compileTemplateData(node3, frame) {
        this.compileLiteral(node3, frame);
      };
      _proto.compileCapture = function compileCapture(node3, frame) {
        var _this14 = this;
        var buffer = this.buffer;
        this.buffer = "output";
        this._emitLine("(function() {");
        this._emitLine('var output = "";');
        this._withScopedSyntax(function() {
          _this14.compile(node3.body, frame);
        });
        this._emitLine("return output;");
        this._emitLine("})()");
        this.buffer = buffer;
      };
      _proto.compileOutput = function compileOutput(node3, frame) {
        var _this15 = this;
        var children = node3.children;
        children.forEach(function(child) {
          if (child instanceof nodes.TemplateData) {
            if (child.value) {
              _this15._emit(_this15.buffer + " += ");
              _this15.compileLiteral(child, frame);
              _this15._emitLine(";");
            }
          } else {
            _this15._emit(_this15.buffer + " += runtime.suppressValue(");
            if (_this15.throwOnUndefined) {
              _this15._emit("runtime.ensureDefined(");
            }
            _this15.compile(child, frame);
            if (_this15.throwOnUndefined) {
              _this15._emit("," + node3.lineno + "," + node3.colno + ")");
            }
            _this15._emit(", env.opts.autoescape);\n");
          }
        });
      };
      _proto.compileRoot = function compileRoot(node3, frame) {
        var _this16 = this;
        if (frame) {
          this.fail("compileRoot: root node can't have frame");
        }
        frame = new Frame();
        this._emitFuncBegin(node3, "root");
        this._emitLine("var parentTemplate = null;");
        this._compileChildren(node3, frame);
        this._emitLine("if(parentTemplate) {");
        this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
        this._emitLine("} else {");
        this._emitLine("cb(null, " + this.buffer + ");");
        this._emitLine("}");
        this._emitFuncEnd(true);
        this.inBlock = true;
        var blockNames = [];
        var blocks = node3.findAll(nodes.Block);
        blocks.forEach(function(block, i2) {
          var name = block.name.value;
          if (blockNames.indexOf(name) !== -1) {
            throw new Error('Block "' + name + '" defined more than once.');
          }
          blockNames.push(name);
          _this16._emitFuncBegin(block, "b_" + name);
          var tmpFrame = new Frame();
          _this16._emitLine("var frame = frame.push(true);");
          _this16.compile(block.body, tmpFrame);
          _this16._emitFuncEnd();
        });
        this._emitLine("return {");
        blocks.forEach(function(block, i2) {
          var blockName = "b_" + block.name.value;
          _this16._emitLine(blockName + ": " + blockName + ",");
        });
        this._emitLine("root: root\n};");
      };
      _proto.compile = function compile(node3, frame) {
        var _compile = this["compile" + node3.typename];
        if (_compile) {
          _compile.call(this, node3, frame);
        } else {
          this.fail("compile: Cannot compile node: " + node3.typename, node3.lineno, node3.colno);
        }
      };
      _proto.getCode = function getCode() {
        return this.codebuf.join("");
      };
      return Compiler2;
    })(Obj);
    module2.exports = {
      compile: function compile(src, asyncFilters, extensions, name, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var c2 = new Compiler(name, opts.throwOnUndefined);
        var preprocessors = (extensions || []).map(function(ext) {
          return ext.preprocess;
        }).filter(function(f3) {
          return !!f3;
        });
        var processedSrc = preprocessors.reduce(function(s2, processor) {
          return processor(s2);
        }, src);
        c2.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
        return c2.getCode();
      },
      Compiler
    };
  }
});

// ../../node_modules/nunjucks/src/filters.js
var require_filters = __commonJS({
  "../../node_modules/nunjucks/src/filters.js"(exports2, module2) {
    "use strict";
    var lib = require_lib();
    var r2 = require_runtime();
    var _exports = module2.exports = {};
    function normalize2(value, defaultValue) {
      if (value === null || value === void 0 || value === false) {
        return defaultValue;
      }
      return value;
    }
    _exports.abs = Math.abs;
    function isNaN3(num) {
      return num !== num;
    }
    function batch(arr, linecount, fillWith) {
      var i2;
      var res = [];
      var tmp = [];
      for (i2 = 0; i2 < arr.length; i2++) {
        if (i2 % linecount === 0 && tmp.length) {
          res.push(tmp);
          tmp = [];
        }
        tmp.push(arr[i2]);
      }
      if (tmp.length) {
        if (fillWith) {
          for (i2 = tmp.length; i2 < linecount; i2++) {
            tmp.push(fillWith);
          }
        }
        res.push(tmp);
      }
      return res;
    }
    _exports.batch = batch;
    function capitalize3(str) {
      str = normalize2(str, "");
      var ret = str.toLowerCase();
      return r2.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
    }
    _exports.capitalize = capitalize3;
    function center(str, width) {
      str = normalize2(str, "");
      width = width || 80;
      if (str.length >= width) {
        return str;
      }
      var spaces = width - str.length;
      var pre = lib.repeat(" ", spaces / 2 - spaces % 2);
      var post = lib.repeat(" ", spaces / 2);
      return r2.copySafeness(str, pre + str + post);
    }
    _exports.center = center;
    function default_(val, def, bool) {
      if (bool) {
        return val || def;
      } else {
        return val !== void 0 ? val : def;
      }
    }
    _exports["default"] = default_;
    function dictsort(val, caseSensitive, by) {
      if (!lib.isObject(val)) {
        throw new lib.TemplateError("dictsort filter: val must be an object");
      }
      var array = [];
      for (var k2 in val) {
        array.push([k2, val[k2]]);
      }
      var si;
      if (by === void 0 || by === "key") {
        si = 0;
      } else if (by === "value") {
        si = 1;
      } else {
        throw new lib.TemplateError("dictsort filter: You can only sort by either key or value");
      }
      array.sort(function(t1, t2) {
        var a2 = t1[si];
        var b2 = t2[si];
        if (!caseSensitive) {
          if (lib.isString(a2)) {
            a2 = a2.toUpperCase();
          }
          if (lib.isString(b2)) {
            b2 = b2.toUpperCase();
          }
        }
        return a2 > b2 ? 1 : a2 === b2 ? 0 : -1;
      });
      return array;
    }
    _exports.dictsort = dictsort;
    function dump(obj, spaces) {
      return JSON.stringify(obj, null, spaces);
    }
    _exports.dump = dump;
    function escape4(str) {
      if (str instanceof r2.SafeString) {
        return str;
      }
      str = str === null || str === void 0 ? "" : str;
      return r2.markSafe(lib.escape(str.toString()));
    }
    _exports.escape = escape4;
    function safe(str) {
      if (str instanceof r2.SafeString) {
        return str;
      }
      str = str === null || str === void 0 ? "" : str;
      return r2.markSafe(str.toString());
    }
    _exports.safe = safe;
    function first(arr) {
      return arr[0];
    }
    _exports.first = first;
    function forceescape(str) {
      str = str === null || str === void 0 ? "" : str;
      return r2.markSafe(lib.escape(str.toString()));
    }
    _exports.forceescape = forceescape;
    function groupby(arr, attr) {
      return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
    }
    _exports.groupby = groupby;
    function indent(str, width, indentfirst) {
      str = normalize2(str, "");
      if (str === "") {
        return "";
      }
      width = width || 4;
      var lines = str.split("\n");
      var sp = lib.repeat(" ", width);
      var res = lines.map(function(l2, i2) {
        return i2 === 0 && !indentfirst ? l2 : "" + sp + l2;
      }).join("\n");
      return r2.copySafeness(str, res);
    }
    _exports.indent = indent;
    function join2(arr, del, attr) {
      del = del || "";
      if (attr) {
        arr = lib.map(arr, function(v3) {
          return v3[attr];
        });
      }
      return arr.join(del);
    }
    _exports.join = join2;
    function last3(arr) {
      return arr[arr.length - 1];
    }
    _exports.last = last3;
    function lengthFilter(val) {
      var value = normalize2(val, "");
      if (value !== void 0) {
        if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
          return value.size;
        }
        if (lib.isObject(value) && !(value instanceof r2.SafeString)) {
          return lib.keys(value).length;
        }
        return value.length;
      }
      return 0;
    }
    _exports.length = lengthFilter;
    function list(val) {
      if (lib.isString(val)) {
        return val.split("");
      } else if (lib.isObject(val)) {
        return lib._entries(val || {}).map(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return {
            key,
            value
          };
        });
      } else if (lib.isArray(val)) {
        return val;
      } else {
        throw new lib.TemplateError("list filter: type not iterable");
      }
    }
    _exports.list = list;
    function lower(str) {
      str = normalize2(str, "");
      return str.toLowerCase();
    }
    _exports.lower = lower;
    function nl2br(str) {
      if (str === null || str === void 0) {
        return "";
      }
      return r2.copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
    }
    _exports.nl2br = nl2br;
    function random3(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    _exports.random = random3;
    function getSelectOrReject(expectedTestResult) {
      function filter2(arr, testName, secondArg) {
        if (testName === void 0) {
          testName = "truthy";
        }
        var context = this;
        var test2 = context.env.getTest(testName);
        return lib.toArray(arr).filter(function examineTestResult(item) {
          return test2.call(context, item, secondArg) === expectedTestResult;
        });
      }
      return filter2;
    }
    _exports.reject = getSelectOrReject(false);
    function rejectattr(arr, attr) {
      return arr.filter(function(item) {
        return !item[attr];
      });
    }
    _exports.rejectattr = rejectattr;
    _exports.select = getSelectOrReject(true);
    function selectattr(arr, attr) {
      return arr.filter(function(item) {
        return !!item[attr];
      });
    }
    _exports.selectattr = selectattr;
    function replace2(str, old, new_, maxCount) {
      var originalStr = str;
      if (old instanceof RegExp) {
        return str.replace(old, new_);
      }
      if (typeof maxCount === "undefined") {
        maxCount = -1;
      }
      var res = "";
      if (typeof old === "number") {
        old = "" + old;
      } else if (typeof old !== "string") {
        return str;
      }
      if (typeof str === "number") {
        str = "" + str;
      }
      if (typeof str !== "string" && !(str instanceof r2.SafeString)) {
        return str;
      }
      if (old === "") {
        res = new_ + str.split("").join(new_) + new_;
        return r2.copySafeness(str, res);
      }
      var nextIndex = str.indexOf(old);
      if (maxCount === 0 || nextIndex === -1) {
        return str;
      }
      var pos = 0;
      var count = 0;
      while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
        res += str.substring(pos, nextIndex) + new_;
        pos = nextIndex + old.length;
        count++;
        nextIndex = str.indexOf(old, pos);
      }
      if (pos < str.length) {
        res += str.substring(pos);
      }
      return r2.copySafeness(originalStr, res);
    }
    _exports.replace = replace2;
    function reverse2(val) {
      var arr;
      if (lib.isString(val)) {
        arr = list(val);
      } else {
        arr = lib.map(val, function(v3) {
          return v3;
        });
      }
      arr.reverse();
      if (lib.isString(val)) {
        return r2.copySafeness(val, arr.join(""));
      }
      return arr;
    }
    _exports.reverse = reverse2;
    function round2(val, precision, method2) {
      precision = precision || 0;
      var factor = Math.pow(10, precision);
      var rounder;
      if (method2 === "ceil") {
        rounder = Math.ceil;
      } else if (method2 === "floor") {
        rounder = Math.floor;
      } else {
        rounder = Math.round;
      }
      return rounder(val * factor) / factor;
    }
    _exports.round = round2;
    function slice2(arr, slices, fillWith) {
      var sliceLength = Math.floor(arr.length / slices);
      var extra = arr.length % slices;
      var res = [];
      var offset = 0;
      for (var i2 = 0; i2 < slices; i2++) {
        var start = offset + i2 * sliceLength;
        if (i2 < extra) {
          offset++;
        }
        var end = offset + (i2 + 1) * sliceLength;
        var currSlice = arr.slice(start, end);
        if (fillWith && i2 >= extra) {
          currSlice.push(fillWith);
        }
        res.push(currSlice);
      }
      return res;
    }
    _exports.slice = slice2;
    function sum3(arr, attr, start) {
      if (start === void 0) {
        start = 0;
      }
      if (attr) {
        arr = lib.map(arr, function(v3) {
          return v3[attr];
        });
      }
      return start + arr.reduce(function(a2, b2) {
        return a2 + b2;
      }, 0);
    }
    _exports.sum = sum3;
    _exports.sort = r2.makeMacro(["value", "reverse", "case_sensitive", "attribute"], [], function sortFilter(arr, reversed, caseSens, attr) {
      var _this = this;
      var array = lib.map(arr, function(v3) {
        return v3;
      });
      var getAttribute = lib.getAttrGetter(attr);
      array.sort(function(a2, b2) {
        var x3 = attr ? getAttribute(a2) : a2;
        var y2 = attr ? getAttribute(b2) : b2;
        if (_this.env.opts.throwOnUndefined && attr && (x3 === void 0 || y2 === void 0)) {
          throw new TypeError('sort: attribute "' + attr + '" resolved to undefined');
        }
        if (!caseSens && lib.isString(x3) && lib.isString(y2)) {
          x3 = x3.toLowerCase();
          y2 = y2.toLowerCase();
        }
        if (x3 < y2) {
          return reversed ? 1 : -1;
        } else if (x3 > y2) {
          return reversed ? -1 : 1;
        } else {
          return 0;
        }
      });
      return array;
    });
    function string(obj) {
      return r2.copySafeness(obj, obj);
    }
    _exports.string = string;
    function striptags(input, preserveLinebreaks) {
      input = normalize2(input, "");
      var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
      var trimmedInput = trim3(input.replace(tags, ""));
      var res = "";
      if (preserveLinebreaks) {
        res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
      } else {
        res = trimmedInput.replace(/\s+/gi, " ");
      }
      return r2.copySafeness(input, res);
    }
    _exports.striptags = striptags;
    function title(str) {
      str = normalize2(str, "");
      var words3 = str.split(" ").map(function(word) {
        return capitalize3(word);
      });
      return r2.copySafeness(str, words3.join(" "));
    }
    _exports.title = title;
    function trim3(str) {
      return r2.copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
    }
    _exports.trim = trim3;
    function truncate3(input, length, killwords, end) {
      var orig = input;
      input = normalize2(input, "");
      length = length || 255;
      if (input.length <= length) {
        return input;
      }
      if (killwords) {
        input = input.substring(0, length);
      } else {
        var idx = input.lastIndexOf(" ", length);
        if (idx === -1) {
          idx = length;
        }
        input = input.substring(0, idx);
      }
      input += end !== void 0 && end !== null ? end : "...";
      return r2.copySafeness(orig, input);
    }
    _exports.truncate = truncate3;
    function upper(str) {
      str = normalize2(str, "");
      return str.toUpperCase();
    }
    _exports.upper = upper;
    function urlencode(obj) {
      var enc = encodeURIComponent;
      if (lib.isString(obj)) {
        return enc(obj);
      } else {
        var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
        return keyvals.map(function(_ref2) {
          var k2 = _ref2[0], v3 = _ref2[1];
          return enc(k2) + "=" + enc(v3);
        }).join("&");
      }
    }
    _exports.urlencode = urlencode;
    var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
    var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
    var httpHttpsRe = /^https?:\/\/.*$/;
    var wwwRe = /^www\./;
    var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
    function urlize(str, length, nofollow) {
      if (isNaN3(length)) {
        length = Infinity;
      }
      var noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
      var words3 = str.split(/(\s+)/).filter(function(word) {
        return word && word.length;
      }).map(function(word) {
        var matches2 = word.match(puncRe);
        var possibleUrl = matches2 ? matches2[1] : word;
        var shortUrl = possibleUrl.substr(0, length);
        if (httpHttpsRe.test(possibleUrl)) {
          return '<a href="' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
        }
        if (wwwRe.test(possibleUrl)) {
          return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
        }
        if (emailRe.test(possibleUrl)) {
          return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + "</a>";
        }
        if (tldRe.test(possibleUrl)) {
          return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
        }
        return word;
      });
      return words3.join("");
    }
    _exports.urlize = urlize;
    function wordcount(str) {
      str = normalize2(str, "");
      var words3 = str ? str.match(/\w+/g) : null;
      return words3 ? words3.length : null;
    }
    _exports.wordcount = wordcount;
    function float(val, def) {
      var res = parseFloat(val);
      return isNaN3(res) ? def : res;
    }
    _exports.float = float;
    var intFilter = r2.makeMacro(["value", "default", "base"], [], function doInt(value, defaultValue, base) {
      if (base === void 0) {
        base = 10;
      }
      var res = parseInt(value, base);
      return isNaN3(res) ? defaultValue : res;
    });
    _exports.int = intFilter;
    _exports.d = _exports.default;
    _exports.e = _exports.escape;
  }
});

// ../../node_modules/nunjucks/src/loader.js
var require_loader = __commonJS({
  "../../node_modules/nunjucks/src/loader.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var path4 = require("path");
    var _require = require_object2();
    var EmitterObj = _require.EmitterObj;
    module2.exports = /* @__PURE__ */ (function(_EmitterObj) {
      _inheritsLoose(Loader, _EmitterObj);
      function Loader() {
        return _EmitterObj.apply(this, arguments) || this;
      }
      var _proto = Loader.prototype;
      _proto.resolve = function resolve(from, to) {
        return path4.resolve(path4.dirname(from), to);
      };
      _proto.isRelative = function isRelative(filename) {
        return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
      };
      return Loader;
    })(EmitterObj);
  }
});

// ../../node_modules/nunjucks/src/precompiled-loader.js
var require_precompiled_loader = __commonJS({
  "../../node_modules/nunjucks/src/precompiled-loader.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var Loader = require_loader();
    var PrecompiledLoader = /* @__PURE__ */ (function(_Loader) {
      _inheritsLoose(PrecompiledLoader2, _Loader);
      function PrecompiledLoader2(compiledTemplates) {
        var _this;
        _this = _Loader.call(this) || this;
        _this.precompiled = compiledTemplates || {};
        return _this;
      }
      var _proto = PrecompiledLoader2.prototype;
      _proto.getSource = function getSource(name) {
        if (this.precompiled[name]) {
          return {
            src: {
              type: "code",
              obj: this.precompiled[name]
            },
            path: name
          };
        }
        return null;
      };
      return PrecompiledLoader2;
    })(Loader);
    module2.exports = {
      PrecompiledLoader
    };
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path4 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path4.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path4 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path4.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix2 = "";
      let glob = "";
      if (start > 0) {
        prefix2 = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix: prefix2,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i2 = slashes[idx];
          const value = input.slice(n2, i2);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix2;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i2;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v3) => utils.escapeRegex(v3)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate3 = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest3;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest3 = remaining()) && /^\.[^\\/.]+$/.test(rest3)) {
            const expression = parse(rest3, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m3, esc, chars, first, rest3, index) => {
          if (first === "\\") {
            backslashes = true;
            return m3;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest3 ? QMARK.repeat(rest3.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest3 ? QMARK.repeat(rest3.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest3 ? star : "");
            }
            return star;
          }
          return esc ? m3 : `\\${m3}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m3) => {
              return m3.length % 2 === 0 ? "\\\\" : m3 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest4 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest4];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range3 = [];
            for (let i2 = arr.length - 1; i2 >= 0; i2--) {
              tokens.pop();
              if (arr[i2].type === "brace") {
                break;
              }
              if (arr[i2].type !== "dots") {
                range3.unshift(arr[i2].value);
              }
            }
            output = expandRange(range3, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t2 of toks) {
              state.output += t2.output || t2.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate3();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest3 = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest3)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before2 = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before2 && (before2.type === "star" || before2.type === "globstar");
          if (opts.bash === true && (!isStart || rest3[0] && rest3[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest3.slice(0, 3) === "/**") {
            const after3 = input[state.index + 4];
            if (after3 && after3 !== "/") {
              break;
            }
            rest3 = rest3.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest3[0] === "/") {
            const end = rest3[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest3[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create2 = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create2(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create2(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path4 = require("path");
    var scan = require_scan();
    var parse = require_parse();
    var utils = require_utils();
    var constants = require_constants();
    var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch2 of fns) {
            const state2 = isMatch2(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch: isMatch2, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result2 = { glob, state, regex, posix, input, output, match, isMatch: isMatch2 };
        if (typeof opts.onResult === "function") {
          opts.onResult(result2);
        }
        if (isMatch2 === false) {
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result2);
          }
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result2);
        }
        return returnObject ? result2 : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path4.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p3) => picomatch.parse(p3, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// ../../node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "../../node_modules/readdirp/index.js"(exports2, module2) {
    "use strict";
    var fs5 = require("fs");
    var { Readable } = require("stream");
    var sysPath = require("path");
    var { promisify } = require("util");
    var picomatch = require_picomatch2();
    var readdir = promisify(fs5.readdir);
    var stat = promisify(fs5.stat);
    var lstat = promisify(fs5.lstat);
    var realpath = promisify(fs5.realpath);
    var BANG = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var [maj, min2] = process.versions.node.split(".").slice(0, 2).map((n2) => Number.parseInt(n2, 10));
    var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min2 >= 5);
    var normalizeFilter = (filter2) => {
      if (filter2 === void 0) return;
      if (typeof filter2 === "function") return filter2;
      if (typeof filter2 === "string") {
        const glob = picomatch(filter2.trim());
        return (entry) => glob(entry.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG) {
            negative.push(picomatch(trimmed.slice(1)));
          } else {
            positive.push(picomatch(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry) => positive.some((f3) => f3(entry.basename)) && !negative.some((f3) => f3(entry.basename));
          }
          return (entry) => !negative.some((f3) => f3(entry.basename));
        }
        return (entry) => positive.some((f3) => f3(entry.basename));
      }
    };
    var ReaddirpStream = class _ReaddirpStream extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path4) => true,
          directoryFilter: (path4) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options.highWaterMark || 4096
        });
        const opts = { ..._ReaddirpStream.defaultOptions, ...options };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        if (wantBigintFsStats) {
          this._stat = (path4) => statMethod(path4, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath.resolve(root);
        this._isDirent = "Dirent" in fs5 && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading) return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path4, depth, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path4));
              for (const entry of await Promise.all(slice2)) {
                if (this.destroyed) return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed) return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path4, depth) {
        let files;
        try {
          files = await readdir(path4, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path: path4 };
      }
      async _formatEntry(dirent, path4) {
        let entry;
        try {
          const basename = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath.resolve(sysPath.join(path4, basename));
          entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        const stats = entry && entry[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await realpath(full);
            const entryRealPathStats = await lstat(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp = (root, options = {}) => {
      let type = options.entryType || options.type;
      if (type === "both") type = FILE_DIR_TYPE;
      if (type) options.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options.root = root;
      return new ReaddirpStream(options);
    };
    var readdirpPromise = (root, options = {}) => {
      return new Promise((resolve, reject2) => {
        const files = [];
        readdirp(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve(files)).on("error", (error) => reject2(error));
      });
    };
    readdirp.promise = readdirpPromise;
    readdirp.ReaddirpStream = ReaddirpStream;
    readdirp.default = readdirp;
    module2.exports = readdirp;
  }
});

// ../../node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "../../node_modules/normalize-path/index.js"(exports2, module2) {
    module2.exports = function(path4, stripTrailing) {
      if (typeof path4 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path4 === "\\" || path4 === "/") return "/";
      var len = path4.length;
      if (len <= 1) return path4;
      var prefix2 = "";
      if (len > 4 && path4[3] === "\\") {
        var ch = path4[2];
        if ((ch === "?" || ch === ".") && path4.slice(0, 2) === "\\\\") {
          path4 = path4.slice(2);
          prefix2 = "//";
        }
      }
      var segs = path4.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix2 + segs.join("/");
    };
  }
});

// ../../node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "../../node_modules/anymatch/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var picomatch = require_picomatch2();
    var normalizePath = require_normalize_path();
    var BANG = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher, options) => {
      if (typeof matcher === "function") {
        return matcher;
      }
      if (typeof matcher === "string") {
        const glob = picomatch(matcher, options);
        return (string) => matcher === string || glob(string);
      }
      if (matcher instanceof RegExp) {
        return (string) => matcher.test(string);
      }
      return (string) => false;
    };
    var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path4 = normalizePath(_path, false);
      for (let index = 0; index < negPatterns.length; index++) {
        const nglob = negPatterns[index];
        if (nglob(path4)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path4].concat(args.slice(1));
      for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (isList ? pattern(...applied) : pattern(path4)) {
          return returnIndex ? index : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options === "boolean" ? { returnIndex: options } : options;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch.default = anymatch;
    module2.exports = anymatch;
  }
});

// ../../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "../../node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2]) return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// ../../node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "../../node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close2 = chars[open];
          if (close2) {
            var n2 = str.indexOf(close2, index);
            if (n2 !== -1) {
              index = n2 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close2 = chars[open];
          if (close2) {
            var n2 = str.indexOf(close2, index);
            if (n2 !== -1) {
              index = n2 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// ../../node_modules/chokidar/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "../../node_modules/chokidar/node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// ../../node_modules/braces/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node3, type) => node3.nodes.find((node4) => node4.type === type);
    exports2.exceedsLimit = (min2, max2, step = 1, limit) => {
      if (limit === false) return false;
      if (!exports2.isInteger(min2) || !exports2.isInteger(max2)) return false;
      return (Number(max2) - Number(min2)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n2 = 0, type) => {
      const node3 = block.nodes[n2];
      if (!node3) return;
      if (type && node3.type === type || node3.type === "open" || node3.type === "close") {
        if (node3.escaped !== true) {
          node3.value = "\\" + node3.value;
          node3.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node3) => {
      if (node3.type !== "brace") return false;
      if (node3.commas >> 0 + node3.ranges >> 0 === 0) {
        node3.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node3) => {
      if (node3.type === "open" || node3.type === "close") {
        return true;
      }
      return node3.open === true || node3.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node3) => {
      if (node3.type === "text") acc.push(node3.value);
      if (node3.type === "range") node3.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result2 = [];
      const flat = (arr) => {
        for (let i2 = 0; i2 < arr.length; i2++) {
          const ele = arr[i2];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result2.push(ele);
          }
        }
        return result2;
      };
      flat(args);
      return result2;
    };
  }
});

// ../../node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = (ast, options = {}) => {
      const stringify = (node3, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node3.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node3.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node3)) {
            return "\\" + node3.value;
          }
          return node3.value;
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes) {
          for (const child of node3.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// ../../node_modules/is-number/index.js
var require_is_number = __commonJS({
  "../../node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// ../../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "../../node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber2 = require_is_number();
    var toRegexRange = (min2, max2, options) => {
      if (isNumber2(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max2 === void 0 || min2 === max2) {
        return String(min2);
      }
      if (isNumber2(max2) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap3 = String(opts.wrap);
      let cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap3;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a2 = Math.min(min2, max2);
      let b2 = Math.max(min2, max2);
      if (Math.abs(a2 - b2) === 1) {
        let result2 = min2 + "|" + max2;
        if (opts.capture) {
          return `(${result2})`;
        }
        if (opts.wrap === false) {
          return result2;
        }
        return `(?:${result2})`;
      }
      let isPadded = hasPadding(min2) || hasPadding(max2);
      let state = { min: min2, max: max2, a: a2, b: b2 };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a2 < 0) {
        let newMin = b2 < 0 ? Math.abs(b2) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a2), state, opts);
        a2 = state.a = 0;
      }
      if (b2 >= 0) {
        positives = splitToPatterns(a2, b2, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min2, max2) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min2, nines);
      let stops = /* @__PURE__ */ new Set([max2]);
      while (min2 <= stop && stop <= max2) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min2, nines);
      }
      stop = countZeros(max2 + 1, zeros) - 1;
      while (min2 < stop && stop <= max2) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max2 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip3(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i2 = 0; i2 < digits; i2++) {
        let [startDigit, stopDigit] = zipped[i2];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min2, max2, tok, options) {
      let ranges = splitToRanges(min2, max2);
      let tokens = [];
      let start = min2;
      let prev;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let max3 = ranges[i2];
        let obj = rangeToPattern(String(start), String(max3), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max3 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max3, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max3 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix2, intersection3, options) {
      let result2 = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection3 && !contains(comparison, "string", string)) {
          result2.push(prefix2 + string);
        }
        if (intersection3 && contains(comparison, "string", string)) {
          result2.push(prefix2 + string);
        }
      }
      return result2;
    }
    function zip3(a2, b2) {
      let arr = [];
      for (let i2 = 0; i2 < a2.length; i2++) arr.push([a2[i2], b2[i2]]);
      return arr;
    }
    function compare(a2, b2) {
      return a2 > b2 ? 1 : b2 > a2 ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min2, len) {
      return Number(String(min2).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a2, b2, options) {
      return `[${a2}${b2 - a2 === 1 ? "" : "-"}${b2}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// ../../node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "../../node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform2 = (toNumber2) => {
      return (value) => toNumber2 === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber2 = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-") value = value.slice(1);
      if (value === "0") return false;
      while (value[++index] === "0") ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad3 = (input, maxLength, toNumber2) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber2 === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      parts.positives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      let prefix2 = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result2;
      if (parts.positives.length) {
        positives = parts.positives.map((v3) => toMaxLen(String(v3), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix2}${parts.negatives.map((v3) => toMaxLen(String(v3), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result2 = `${positives}|${negatives}`;
      } else {
        result2 = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix2}${result2})`;
      }
      return result2;
    };
    var toRange = (a2, b2, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a2, b2, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a2);
      if (a2 === b2) return start;
      let stop = String.fromCharCode(b2);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap3 = options.wrap === true;
        let prefix2 = options.capture ? "" : "?:";
        return wrap3 ? `(${prefix2}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util2.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a2 = Number(start);
      let b2 = Number(end);
      if (!Number.isInteger(a2) || !Number.isInteger(b2)) {
        if (options.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a2 === 0) a2 = 0;
      if (b2 === 0) b2 = 0;
      let descending = a2 > b2;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber2 = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform2(toNumber2);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range3 = [];
      let index = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        if (options.toRegex === true && step > 1) {
          push(a2);
        } else {
          range3.push(pad3(format(a2, index), maxLen, toNumber2));
        }
        a2 = descending ? a2 - step : a2 + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range3, null, { wrap: false, ...options });
      }
      return range3;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber2(start) && start.length > 1 || !isNumber2(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a2 = `${start}`.charCodeAt(0);
      let b2 = `${end}`.charCodeAt(0);
      let descending = a2 > b2;
      let min2 = Math.min(a2, b2);
      let max2 = Math.max(a2, b2);
      if (options.toRegex && step === 1) {
        return toRange(min2, max2, false, options);
      }
      let range3 = [];
      let index = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        range3.push(format(a2, index));
        a2 = descending ? a2 - step : a2 + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range3, null, { wrap: false, options });
      }
      return range3;
    };
    var fill4 = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill4(start, end, 1, { transform: step });
      }
      if (isObject2(step)) {
        return fill4(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber2(step)) {
        if (step != null && !isObject2(step)) return invalidStep(step, opts);
        return fill4(start, end, 1, step);
      }
      if (isNumber2(start) && isNumber2(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill4;
  }
});

// ../../node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "../../node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill4 = require_fill_range();
    var utils = require_utils2();
    var compile = (ast, options = {}) => {
      const walk = (node3, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node3.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix2 = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node3.isOpen === true) {
          return prefix2 + node3.value;
        }
        if (node3.isClose === true) {
          console.log("node.isClose", prefix2, node3.value);
          return prefix2 + node3.value;
        }
        if (node3.type === "open") {
          return invalid ? prefix2 + node3.value : "(";
        }
        if (node3.type === "close") {
          return invalid ? prefix2 + node3.value : ")";
        }
        if (node3.type === "comma") {
          return node3.prev.type === "comma" ? "" : invalid ? node3.value : "|";
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes && node3.ranges > 0) {
          const args = utils.reduce(node3.nodes);
          const range3 = fill4(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range3.length !== 0) {
            return args.length > 1 && range3.length > 1 ? `(${range3})` : range3;
          }
        }
        if (node3.nodes) {
          for (const child of node3.nodes) {
            output += walk(child, node3);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// ../../node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "../../node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill4 = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils2();
    var append = (queue = "", stash = "", enclose = false) => {
      const result2 = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length) return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value of item) {
            result2.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result2.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result2);
    };
    var expand = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk = (node3, parent = {}) => {
        node3.queue = [];
        let p3 = parent;
        let q3 = parent.queue;
        while (p3.type !== "brace" && p3.type !== "root" && p3.parent) {
          p3 = p3.parent;
          q3 = p3.queue;
        }
        if (node3.invalid || node3.dollar) {
          q3.push(append(q3.pop(), stringify(node3, options)));
          return;
        }
        if (node3.type === "brace" && node3.invalid !== true && node3.nodes.length === 2) {
          q3.push(append(q3.pop(), ["{}"]));
          return;
        }
        if (node3.nodes && node3.ranges > 0) {
          const args = utils.reduce(node3.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range3 = fill4(...args, options);
          if (range3.length === 0) {
            range3 = stringify(node3, options);
          }
          q3.push(append(q3.pop(), range3));
          node3.nodes = [];
          return;
        }
        const enclose = utils.encloseBrace(node3);
        let queue = node3.queue;
        let block = node3;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i2 = 0; i2 < node3.nodes.length; i2++) {
          const child = node3.nodes[i2];
          if (child.type === "comma" && node3.type === "brace") {
            if (i2 === 1) queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q3.push(append(q3.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node3);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// ../../node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// ../../node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max2) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node3) => {
        if (node3.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node3.type === "text") {
          prev.value += node3.value;
          return;
        }
        block.nodes.push(node3);
        node3.parent = block;
        node3.prev = prev;
        prev = node3;
        return node3;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true) value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before2 = siblings[siblings.length - 1];
            before2.value += prev.value + value;
            prev = before2;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node3) => {
            if (!node3.nodes) {
              if (node3.type === "open") node3.isOpen = true;
              if (node3.type === "close") node3.isClose = true;
              if (!node3.nodes) node3.type = "text";
              node3.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// ../../node_modules/braces/index.js
var require_braces = __commonJS({
  "../../node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result2 = braces.create(pattern, options);
          if (Array.isArray(result2)) {
            output.push(...result2);
          } else {
            output.push(result2);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result2 = expand(input, options);
      if (options.noempty === true) {
        result2 = result2.filter(Boolean);
      }
      if (options.nodupes === true) {
        result2 = [...new Set(result2)];
      }
      return result2;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// ../../node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "../../node_modules/binary-extensions/binary-extensions.json"(exports2, module2) {
    module2.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "afdesign",
      "afphoto",
      "afpub",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// ../../node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "../../node_modules/binary-extensions/index.js"(exports2, module2) {
    module2.exports = require_binary_extensions();
  }
});

// ../../node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "../../node_modules/is-binary-path/index.js"(exports2, module2) {
    "use strict";
    var path4 = require("path");
    var binaryExtensions = require_binary_extensions2();
    var extensions = new Set(binaryExtensions);
    module2.exports = (filePath) => extensions.has(path4.extname(filePath).slice(1).toLowerCase());
  }
});

// ../../node_modules/chokidar/lib/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/chokidar/lib/constants.js"(exports2) {
    "use strict";
    var { sep } = require("path");
    var { platform } = process;
    var os3 = require("os");
    exports2.EV_ALL = "all";
    exports2.EV_READY = "ready";
    exports2.EV_ADD = "add";
    exports2.EV_CHANGE = "change";
    exports2.EV_ADD_DIR = "addDir";
    exports2.EV_UNLINK = "unlink";
    exports2.EV_UNLINK_DIR = "unlinkDir";
    exports2.EV_RAW = "raw";
    exports2.EV_ERROR = "error";
    exports2.STR_DATA = "data";
    exports2.STR_END = "end";
    exports2.STR_CLOSE = "close";
    exports2.FSEVENT_CREATED = "created";
    exports2.FSEVENT_MODIFIED = "modified";
    exports2.FSEVENT_DELETED = "deleted";
    exports2.FSEVENT_MOVED = "moved";
    exports2.FSEVENT_CLONED = "cloned";
    exports2.FSEVENT_UNKNOWN = "unknown";
    exports2.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
    exports2.FSEVENT_TYPE_FILE = "file";
    exports2.FSEVENT_TYPE_DIRECTORY = "directory";
    exports2.FSEVENT_TYPE_SYMLINK = "symlink";
    exports2.KEY_LISTENERS = "listeners";
    exports2.KEY_ERR = "errHandlers";
    exports2.KEY_RAW = "rawEmitters";
    exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
    exports2.DOT_SLASH = `.${sep}`;
    exports2.BACK_SLASH_RE = /\\/g;
    exports2.DOUBLE_SLASH_RE = /\/\//;
    exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports2.REPLACER_RE = /^\.[/\\]/;
    exports2.SLASH = "/";
    exports2.SLASH_SLASH = "//";
    exports2.BRACE_START = "{";
    exports2.BANG = "!";
    exports2.ONE_DOT = ".";
    exports2.TWO_DOTS = "..";
    exports2.STAR = "*";
    exports2.GLOBSTAR = "**";
    exports2.ROOT_GLOBSTAR = "/**/*";
    exports2.SLASH_GLOBSTAR = "/**";
    exports2.DIR_SUFFIX = "Dir";
    exports2.ANYMATCH_OPTS = { dot: true };
    exports2.STRING_TYPE = "string";
    exports2.FUNCTION_TYPE = "function";
    exports2.EMPTY_STR = "";
    exports2.EMPTY_FN = () => {
    };
    exports2.IDENTITY_FN = (val) => val;
    exports2.isWindows = platform === "win32";
    exports2.isMacos = platform === "darwin";
    exports2.isLinux = platform === "linux";
    exports2.isIBMi = os3.type() === "OS400";
  }
});

// ../../node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "../../node_modules/chokidar/lib/nodefs-handler.js"(exports2, module2) {
    "use strict";
    var fs5 = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var isBinaryPath = require_is_binary_path();
    var {
      isWindows,
      isLinux,
      EMPTY_FN,
      EMPTY_STR,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE,
      EV_ADD,
      EV_ADD_DIR,
      EV_ERROR,
      STR_DATA,
      STR_END,
      BRACE_START,
      STAR
    } = require_constants3();
    var THROTTLE_MODE_WATCH = "watch";
    var open = promisify(fs5.open);
    var stat = promisify(fs5.stat);
    var lstat = promisify(fs5.lstat);
    var close2 = promisify(fs5.close);
    var fsrealpath = promisify(fs5.realpath);
    var statMethods = { lstat, stat };
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set2 = cont[key];
      if (set2 instanceof Set) {
        set2.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path4, options, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path4);
        emitRaw(rawEvent, evPath, { watchedPath: path4 });
        if (evPath && path4 !== evPath) {
          fsWatchBroadcast(
            sysPath.resolve(path4, evPath),
            KEY_LISTENERS,
            sysPath.join(path4, evPath)
          );
        }
      };
      try {
        return fs5.watch(path4, options, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont) return;
      foreach(cont[type], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path4, fullPath, options, handlers2) => {
      const { listener, errHandler, rawEmitter } = handlers2;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(
          path4,
          options,
          listener,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path4,
          options,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher) return;
        watcher.on(EV_ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows && error.code === "EPERM") {
            try {
              const fd = await open(path4, "r");
              await close2(fd);
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path4, fullPath, options, handlers2) => {
      const { listener, rawEmitter } = handlers2;
      let cont = FsWatchFileInstances.get(fullPath);
      let listeners = /* @__PURE__ */ new Set();
      let rawEmitters = /* @__PURE__ */ new Set();
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        listeners = cont.listeners;
        rawEmitters = cont.rawEmitters;
        fs5.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options,
          watcher: fs5.watchFile(fullPath, options, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path4, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs5.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path4, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path4);
        const basename = sysPath.basename(path4);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath.resolve(path4);
        const options = { persistent: opts.persistent };
        if (!listener) listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path4, absolutePath, options, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path4, absolutePath, options, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname = sysPath.dirname(file);
        const basename = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        let prevStats = stats;
        if (parent.has(basename)) return;
        const listener = async (path4, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat(file);
              if (this.fsw.closed) return;
              const at3 = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at3 || at3 <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path4);
                prevStats = newStats2;
                this.fsw._addPathCloser(path4, this._watchWithNodeFs(file, listener));
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname, basename);
            }
          } else if (parent.has(basename)) {
            const at3 = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at3 || at3 <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD, file, 0)) return;
          this.fsw._emit(EV_ADD, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry, directory, path4, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path4);
          } catch (e2) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed) return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE, path4, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD, path4, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, EMPTY_STR);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler) return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry),
          depth: 0
        }).on(STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const item = entry.path;
          let path4 = sysPath.join(directory, item);
          current.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path4, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path4 = sysPath.join(dir, sysPath.relative(dir, path4));
            this._addToNodeFs(path4, initialAdd, wh, depth + 1);
          }
        }).on(EV_ERROR, this._boundHandleError);
        return new Promise(
          (resolve) => stream.once(STR_END, () => {
            if (this.fsw.closed) {
              stream = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve();
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream = void 0;
            if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed) return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0) return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path4, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path4) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path4, depth);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path4.includes(STAR) && !path4.includes(BRACE_START);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path4);
            const targetPath = follow ? await fsrealpath(path4) : path4;
            if (this.fsw.closed) return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed) return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path4) : path4;
            if (this.fsw.closed) return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path4, wh, targetPath);
            if (this.fsw.closed) return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path4), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path4, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path4;
          }
        }
      }
    };
    module2.exports = NodeFsHandler;
  }
});

// ../../node_modules/fsevents/fsevents.js
var require_fsevents = __commonJS({
  "../../node_modules/fsevents/fsevents.js"(exports2) {
    "use strict";
    if (process.platform !== "darwin") {
      throw new Error(`Module 'fsevents' is not compatible with platform '${process.platform}'`);
    }
    var Native = require("./fsevents-X6WP4TKM.node");
    var events = Native.constants;
    function watch(path4, since, handler) {
      if (typeof path4 !== "string") {
        throw new TypeError(`fsevents argument 1 must be a string and not a ${typeof path4}`);
      }
      if ("function" === typeof since && "undefined" === typeof handler) {
        handler = since;
        since = Native.flags.SinceNow;
      }
      if (typeof since !== "number") {
        throw new TypeError(`fsevents argument 2 must be a number and not a ${typeof since}`);
      }
      if (typeof handler !== "function") {
        throw new TypeError(`fsevents argument 3 must be a function and not a ${typeof handler}`);
      }
      let instance = Native.start(Native.global, path4, since, handler);
      if (!instance) throw new Error(`could not watch: ${path4}`);
      return () => {
        const result2 = instance ? Promise.resolve(instance).then(Native.stop) : Promise.resolve(void 0);
        instance = void 0;
        return result2;
      };
    }
    function getInfo(path4, flags) {
      return {
        path: path4,
        flags,
        event: getEventType(flags),
        type: getFileType(flags),
        changes: getFileChanges(flags)
      };
    }
    function getFileType(flags) {
      if (events.ItemIsFile & flags) return "file";
      if (events.ItemIsDir & flags) return "directory";
      if (events.MustScanSubDirs & flags) return "directory";
      if (events.ItemIsSymlink & flags) return "symlink";
    }
    function anyIsTrue(obj) {
      for (let key in obj) {
        if (obj[key]) return true;
      }
      return false;
    }
    function getEventType(flags) {
      if (events.ItemRemoved & flags) return "deleted";
      if (events.ItemRenamed & flags) return "moved";
      if (events.ItemCreated & flags) return "created";
      if (events.ItemModified & flags) return "modified";
      if (events.RootChanged & flags) return "root-changed";
      if (events.ItemCloned & flags) return "cloned";
      if (anyIsTrue(flags)) return "modified";
      return "unknown";
    }
    function getFileChanges(flags) {
      return {
        inode: !!(events.ItemInodeMetaMod & flags),
        finder: !!(events.ItemFinderInfoMod & flags),
        access: !!(events.ItemChangeOwner & flags),
        xattrs: !!(events.ItemXattrMod & flags)
      };
    }
    exports2.watch = watch;
    exports2.getInfo = getInfo;
    exports2.constants = events;
  }
});

// ../../node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "../../node_modules/chokidar/lib/fsevents-handler.js"(exports2, module2) {
    "use strict";
    var fs5 = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var fsevents;
    try {
      fsevents = require_fsevents();
    } catch (error) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj = Number.parseInt(mtch[1], 10);
        const min2 = Number.parseInt(mtch[2], 10);
        if (maj === 8 && min2 < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD,
      EV_CHANGE,
      EV_ADD_DIR,
      EV_UNLINK,
      EV_ERROR,
      STR_DATA,
      STR_END,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      // FSEVENT_CLONED,
      FSEVENT_UNKNOWN,
      FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE,
      EMPTY_FN,
      IDENTITY_FN
    } = require_constants3();
    var Depth = (value) => isNaN(value) ? {} : { depth: value };
    var stat = promisify(fs5.stat);
    var lstat = promisify(fs5.lstat);
    var realpath = promisify(fs5.realpath);
    var statMethods = { stat, lstat };
    var FSEventsWatchers = /* @__PURE__ */ new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path4, callback) => {
      const stop = fsevents.watch(path4, callback);
      return { stop };
    };
    function setFSEventsListener(path4, realPath, listener, rawEmitter) {
      let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
      const parentPath = sysPath.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath.resolve(path4);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size) return;
            if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list) => {
              list(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher) return cont.watcher.stop().then(() => {
            cont.rawEmitter = cont.watcher = void 0;
            Object.freeze(cont);
          });
        }
      };
    }
    var couldConsolidate = (path4) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path4) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path4, root) => {
      let i2 = 0;
      while (!path4.indexOf(root) && (path4 = sysPath.dirname(path4)) !== root) i2++;
      return i2;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler = class {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path4, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path4, stats)) {
          ipaths.add(path4);
          if (stats && stats.isDirectory()) {
            ipaths.add(path4 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path4);
        ipaths.delete(path4 + ROOT_GLOBSTAR);
      }
      addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat(path4);
          if (this.fsw.closed) return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error) {
          if (error.code === "EACCES") {
            this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path4)) return;
        if (event === EV_UNLINK) {
          const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory);
          }
        } else {
          if (event === EV_ADD) {
            if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path4);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path4, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path4);
          if (eventName === EV_ADD_DIR) this._addToFsEvents(path4, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed) return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth) return;
          const path4 = transform2(sysPath.join(
            watchPath,
            sysPath.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path4)) return;
          const parent = sysPath.dirname(path4);
          const item = sysPath.basename(path4);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path4 : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE) {
              let stats;
              try {
                stats = await stat(path4);
              } catch (error) {
              }
              if (this.fsw.closed) return;
              if (this.checkIgnored(path4, stats)) return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path4) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path4.replace(linkTarget, linkPath);
            } else if (path4 !== DOT_SLASH) {
              aliasedPath = sysPath.join(linkPath, path4);
            }
            return transform2(aliasedPath);
          }, false, curDepth);
        } catch (error) {
          if (this.fsw._handleError(error)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
        const base = sysPath.basename(pp);
        if (isDir) this.fsw._getWatchedDir(pp);
        if (dirObj.has(base)) return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
        }
      }
      initWatch(realPath, path4, wh, processPath) {
        if (this.fsw.closed) return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path4, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path4, transform2, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform2 === FUNCTION_TYPE ? transform2 : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path4);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter) this.emitAdd(processPath(path4), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth) return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry) => wh.filterPath(entry),
              directoryFilter: (entry) => wh.filterDir(entry),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
              const joinedPath = sysPath.join(wh.watchPath, entry.path);
              const { fullPath } = entry;
              if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error) {
          if (!error || this.fsw._handleError(error)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform2 === FUNCTION_TYPE) {
            this.initWatch(void 0, path4, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh.watchPath);
            } catch (e2) {
            }
            this.initWatch(realPath, path4, wh, processPath);
          }
        }
      }
    };
    module2.exports = FsEventsHandler;
    module2.exports.canUse = canUse;
  }
});

// ../../node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "../../node_modules/chokidar/index.js"(exports2) {
    "use strict";
    var { EventEmitter } = require("events");
    var fs5 = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var readdirp = require_readdirp();
    var anymatch = require_anymatch().default;
    var globParent = require_glob_parent();
    var isGlob = require_is_glob();
    var braces = require_braces();
    var normalizePath = require_normalize_path();
    var NodeFsHandler = require_nodefs_handler();
    var FsEventsHandler = require_fsevents_handler();
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows,
      isMacos,
      isIBMi
    } = require_constants3();
    var stat = promisify(fs5.stat);
    var readdir = promisify(fs5.readdir);
    var arrify = (value = []) => Array.isArray(value) ? value : [value];
    var flatten3 = (list, result2 = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten3(item, result2);
        } else {
          result2.push(item);
        }
      });
      return result2;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten3(arrify(paths_));
      if (!paths.every((p3) => typeof p3 === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path4) => toUnix(sysPath.normalize(toUnix(path4)));
    var normalizeIgnored = (cwd = EMPTY_STR) => (path4) => {
      if (typeof path4 !== STRING_TYPE) return path4;
      return normalizePathToUnix(sysPath.isAbsolute(path4) ? path4 : sysPath.join(cwd, path4));
    };
    var getAbsolutePath = (path4, cwd) => {
      if (sysPath.isAbsolute(path4)) {
        return path4;
      }
      if (path4.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path4.slice(1));
      }
      return sysPath.join(cwd, path4);
    };
    var undef = (opts, key) => opts[key] === void 0;
    var DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items) return;
        if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items) return;
        items.delete(item);
        if (items.size > 0) return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items) return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items) return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path4, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path4 = path4.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path4;
        if (path4 === EMPTY_STR) this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path4, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path4);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1) parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry.fullPath;
      }
      entryPath(entry) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
        );
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path4) {
        if (!this.hasGlob) return [];
        const parts = [];
        const expandedPath = path4.includes(BRACE_START) ? braces.expand(path4) : [path4];
        expandedPath.forEach((path5) => {
          parts.push(sysPath.relative(this.watchPath, path5).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i2) => {
              if (part === GLOBSTAR) globstar = true;
              return globstar || !entryParts[0][i2] || anymatch(part, entryParts[0][i2], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    var FSWatcher = class extends EventEmitter {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts) Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent")) opts.persistent = true;
        if (undef(opts, "ignoreInitial")) opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors")) opts.ignorePermissionErrors = false;
        if (undef(opts, "interval")) opts.interval = 100;
        if (undef(opts, "binaryInterval")) opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing")) opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents")) opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents) opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic")) opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic) this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks")) opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish")) opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold) awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval) awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored) opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path4) => {
            const absPath = getAbsolutePath(path4, cwd);
            if (disableGlobbing || !isGlob(path4)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path4) => {
          if (path4.startsWith(BANG)) {
            this._ignoredPaths.add(path4.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path4);
          this._ignoredPaths.delete(path4 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount) this._readyCount = paths.length;
          if (this.options.persistent) this._readyCount += paths.length;
          paths.forEach((path4) => this._fsEventsHandler._addToFsEvents(path4));
        } else {
          if (!this._readyCount) this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path4) => {
              const res = await this._nodeFsHandler._addToNodeFs(path4, !_internal, 0, 0, _origAdd);
              if (res) this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed) return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed) return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path4) => {
          if (!sysPath.isAbsolute(path4) && !this._closers.has(path4)) {
            if (cwd) path4 = sysPath.join(cwd, path4);
            path4 = sysPath.resolve(path4);
          }
          this._closePath(path4);
          this._ignoredPaths.add(path4);
          if (this._watched.has(path4)) {
            this._ignoredPaths.add(path4 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed) return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise) closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path4, val1, val2, val3) {
        if (this.closed) return;
        const opts = this.options;
        if (isWindows) path4 = sysPath.normalize(path4);
        if (opts.cwd) path4 = sysPath.relative(opts.cwd, path4);
        const args = [event, path4];
        if (val3 !== void 0) args.push(val1, val2, val3);
        else if (val2 !== void 0) args.push(val1, val2);
        else if (val1 !== void 0) args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path4))) {
          pw.lastChange = /* @__PURE__ */ new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path4, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path5) => {
                this.emit(...entry);
                this.emit(EV_ALL, ...entry);
                this._pendingUnlinks.delete(path5);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path4)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path4);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path4, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path4, 50);
          if (isThrottled) return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path4) : path4;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed) return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error);
        }
        return error || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path4, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path4);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path4);
          const count = item ? item.count : 0;
          action.delete(path4);
          clearTimeout(timeoutObject);
          if (item) clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path4, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path4, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path4;
        if (this.options.cwd && !sysPath.isAbsolute(path4)) {
          fullPath = sysPath.join(this.options.cwd, path4);
        }
        const now2 = /* @__PURE__ */ new Date();
        const awaitWriteFinish = (prevStat) => {
          fs5.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path4)) {
              if (err && err.code !== "ENOENT") awfEmit(err);
              return;
            }
            const now3 = Number(/* @__PURE__ */ new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path4).lastChange = now3;
            }
            const pw = this._pendingWrites.get(path4);
            const df = now3 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path4);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path4)) {
          this._pendingWrites.set(path4, {
            lastChange: now2,
            cancelWait: () => {
              this._pendingWrites.delete(path4);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path4, stats) {
        if (this.options.atomic && DOT_RE.test(path4)) return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path5) => typeof path5 === STRING_TYPE && !isGlob(path5)).map((path5) => path5 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path4, stats]);
      }
      _isntIgnored(path4, stat2) {
        return !this._isIgnored(path4, stat2);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path4, depth) {
        const watchPath = depth || this.options.disableGlobbing || !isGlob(path4) ? path4 : globParent(path4);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path4, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors) return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it2 = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it2);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory) {
        const path4 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path4);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path4) || this._watched.has(fullPath);
        if (!this._throttle("remove", path4, 100)) return;
        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path4);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path4, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path4;
        if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path4);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD) return;
        }
        this._watched.delete(path4);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path4)) this._emit(eventName, path4);
        if (!this.options.useFsEvents) {
          this._closePath(path4);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path4) {
        this._closeFile(path4);
        const dir = sysPath.dirname(path4);
        this._getWatchedDir(dir).remove(sysPath.basename(path4));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path4) {
        const closers = this._closers.get(path4);
        if (!closers) return;
        closers.forEach((closer) => closer());
        this._closers.delete(path4);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path4, closer) {
        if (!closer) return;
        let list = this._closers.get(path4);
        if (!list) {
          list = [];
          this._closers.set(path4, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed) return;
        const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream = readdirp(root, options);
        this._streams.add(stream);
        stream.once(STR_CLOSE, () => {
          stream = void 0;
        });
        stream.once(STR_END, () => {
          if (stream) {
            this._streams.delete(stream);
            stream = void 0;
          }
        });
        return stream;
      }
    };
    exports2.FSWatcher = FSWatcher;
    var watch = (paths, options) => {
      const watcher = new FSWatcher(options);
      watcher.add(paths);
      return watcher;
    };
    exports2.watch = watch;
  }
});

// ../../node_modules/nunjucks/src/node-loaders.js
var require_node_loaders = __commonJS({
  "../../node_modules/nunjucks/src/node-loaders.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var fs5 = require("fs");
    var path4 = require("path");
    var Loader = require_loader();
    var _require = require_precompiled_loader();
    var PrecompiledLoader = _require.PrecompiledLoader;
    var chokidar;
    var FileSystemLoader = /* @__PURE__ */ (function(_Loader) {
      _inheritsLoose(FileSystemLoader2, _Loader);
      function FileSystemLoader2(searchPaths, opts) {
        var _this;
        _this = _Loader.call(this) || this;
        if (typeof opts === "boolean") {
          console.log("[nunjucks] Warning: you passed a boolean as the second argument to FileSystemLoader, but it now takes an options object. See http://mozilla.github.io/nunjucks/api.html#filesystemloader");
        }
        opts = opts || {};
        _this.pathsToNames = {};
        _this.noCache = !!opts.noCache;
        if (searchPaths) {
          searchPaths = Array.isArray(searchPaths) ? searchPaths : [searchPaths];
          _this.searchPaths = searchPaths.map(path4.normalize);
        } else {
          _this.searchPaths = ["."];
        }
        if (opts.watch) {
          try {
            chokidar = require_chokidar();
          } catch (e2) {
            throw new Error("watch requires chokidar to be installed");
          }
          var paths = _this.searchPaths.filter(fs5.existsSync);
          var watcher = chokidar.watch(paths);
          watcher.on("all", function(event, fullname) {
            fullname = path4.resolve(fullname);
            if (event === "change" && fullname in _this.pathsToNames) {
              _this.emit("update", _this.pathsToNames[fullname], fullname);
            }
          });
          watcher.on("error", function(error) {
            console.log("Watcher error: " + error);
          });
        }
        return _this;
      }
      var _proto = FileSystemLoader2.prototype;
      _proto.getSource = function getSource(name) {
        var fullpath = null;
        var paths = this.searchPaths;
        for (var i2 = 0; i2 < paths.length; i2++) {
          var basePath = path4.resolve(paths[i2]);
          var p3 = path4.resolve(paths[i2], name);
          if (p3.indexOf(basePath) === 0 && fs5.existsSync(p3)) {
            fullpath = p3;
            break;
          }
        }
        if (!fullpath) {
          return null;
        }
        this.pathsToNames[fullpath] = name;
        var source = {
          src: fs5.readFileSync(fullpath, "utf-8"),
          path: fullpath,
          noCache: this.noCache
        };
        this.emit("load", name, source);
        return source;
      };
      return FileSystemLoader2;
    })(Loader);
    var NodeResolveLoader = /* @__PURE__ */ (function(_Loader2) {
      _inheritsLoose(NodeResolveLoader2, _Loader2);
      function NodeResolveLoader2(opts) {
        var _this2;
        _this2 = _Loader2.call(this) || this;
        opts = opts || {};
        _this2.pathsToNames = {};
        _this2.noCache = !!opts.noCache;
        if (opts.watch) {
          try {
            chokidar = require_chokidar();
          } catch (e2) {
            throw new Error("watch requires chokidar to be installed");
          }
          _this2.watcher = chokidar.watch();
          _this2.watcher.on("change", function(fullname) {
            _this2.emit("update", _this2.pathsToNames[fullname], fullname);
          });
          _this2.watcher.on("error", function(error) {
            console.log("Watcher error: " + error);
          });
          _this2.on("load", function(name, source) {
            _this2.watcher.add(source.path);
          });
        }
        return _this2;
      }
      var _proto2 = NodeResolveLoader2.prototype;
      _proto2.getSource = function getSource(name) {
        if (/^\.?\.?(\/|\\)/.test(name)) {
          return null;
        }
        if (/^[A-Z]:/.test(name)) {
          return null;
        }
        var fullpath;
        try {
          fullpath = require.resolve(name);
        } catch (e2) {
          return null;
        }
        this.pathsToNames[fullpath] = name;
        var source = {
          src: fs5.readFileSync(fullpath, "utf-8"),
          path: fullpath,
          noCache: this.noCache
        };
        this.emit("load", name, source);
        return source;
      };
      return NodeResolveLoader2;
    })(Loader);
    module2.exports = {
      FileSystemLoader,
      PrecompiledLoader,
      NodeResolveLoader
    };
  }
});

// ../../node_modules/nunjucks/src/loaders.js
var require_loaders = __commonJS({
  "../../node_modules/nunjucks/src/loaders.js"(exports2, module2) {
    "use strict";
    module2.exports = require_node_loaders();
  }
});

// ../../node_modules/nunjucks/src/tests.js
var require_tests = __commonJS({
  "../../node_modules/nunjucks/src/tests.js"(exports2) {
    "use strict";
    var SafeString = require_runtime().SafeString;
    function callable(value) {
      return typeof value === "function";
    }
    exports2.callable = callable;
    function defined(value) {
      return value !== void 0;
    }
    exports2.defined = defined;
    function divisibleby(one, two) {
      return one % two === 0;
    }
    exports2.divisibleby = divisibleby;
    function escaped(value) {
      return value instanceof SafeString;
    }
    exports2.escaped = escaped;
    function equalto(one, two) {
      return one === two;
    }
    exports2.equalto = equalto;
    exports2.eq = exports2.equalto;
    exports2.sameas = exports2.equalto;
    function even(value) {
      return value % 2 === 0;
    }
    exports2.even = even;
    function falsy(value) {
      return !value;
    }
    exports2.falsy = falsy;
    function ge3(one, two) {
      return one >= two;
    }
    exports2.ge = ge3;
    function greaterthan(one, two) {
      return one > two;
    }
    exports2.greaterthan = greaterthan;
    exports2.gt = exports2.greaterthan;
    function le3(one, two) {
      return one <= two;
    }
    exports2.le = le3;
    function lessthan(one, two) {
      return one < two;
    }
    exports2.lessthan = lessthan;
    exports2.lt = exports2.lessthan;
    function lower(value) {
      return value.toLowerCase() === value;
    }
    exports2.lower = lower;
    function ne3(one, two) {
      return one !== two;
    }
    exports2.ne = ne3;
    function nullTest(value) {
      return value === null;
    }
    exports2.null = nullTest;
    function number(value) {
      return typeof value === "number";
    }
    exports2.number = number;
    function odd(value) {
      return value % 2 === 1;
    }
    exports2.odd = odd;
    function string(value) {
      return typeof value === "string";
    }
    exports2.string = string;
    function truthy(value) {
      return !!value;
    }
    exports2.truthy = truthy;
    function undefinedTest(value) {
      return value === void 0;
    }
    exports2.undefined = undefinedTest;
    function upper(value) {
      return value.toUpperCase() === value;
    }
    exports2.upper = upper;
    function iterable(value) {
      if (typeof Symbol !== "undefined") {
        return !!value[Symbol.iterator];
      } else {
        return Array.isArray(value) || typeof value === "string";
      }
    }
    exports2.iterable = iterable;
    function mapping(value) {
      var bool = value !== null && value !== void 0 && typeof value === "object" && !Array.isArray(value);
      if (Set) {
        return bool && !(value instanceof Set);
      } else {
        return bool;
      }
    }
    exports2.mapping = mapping;
  }
});

// ../../node_modules/nunjucks/src/globals.js
var require_globals = __commonJS({
  "../../node_modules/nunjucks/src/globals.js"(exports2, module2) {
    "use strict";
    function _cycler(items) {
      var index = -1;
      return {
        current: null,
        reset: function reset() {
          index = -1;
          this.current = null;
        },
        next: function next() {
          index++;
          if (index >= items.length) {
            index = 0;
          }
          this.current = items[index];
          return this.current;
        }
      };
    }
    function _joiner(sep) {
      sep = sep || ",";
      var first = true;
      return function() {
        var val = first ? "" : sep;
        first = false;
        return val;
      };
    }
    function globals() {
      return {
        range: function range3(start, stop, step) {
          if (typeof stop === "undefined") {
            stop = start;
            start = 0;
            step = 1;
          } else if (!step) {
            step = 1;
          }
          var arr = [];
          if (step > 0) {
            for (var i2 = start; i2 < stop; i2 += step) {
              arr.push(i2);
            }
          } else {
            for (var _i = start; _i > stop; _i += step) {
              arr.push(_i);
            }
          }
          return arr;
        },
        cycler: function cycler() {
          return _cycler(Array.prototype.slice.call(arguments));
        },
        joiner: function joiner(sep) {
          return _joiner(sep);
        }
      };
    }
    module2.exports = globals;
  }
});

// ../../node_modules/nunjucks/src/express-app.js
var require_express_app = __commonJS({
  "../../node_modules/nunjucks/src/express-app.js"(exports2, module2) {
    "use strict";
    var path4 = require("path");
    module2.exports = function express(env2, app) {
      function NunjucksView(name, opts) {
        this.name = name;
        this.path = name;
        this.defaultEngine = opts.defaultEngine;
        this.ext = path4.extname(name);
        if (!this.ext && !this.defaultEngine) {
          throw new Error("No default engine was specified and no extension was provided.");
        }
        if (!this.ext) {
          this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
        }
      }
      NunjucksView.prototype.render = function render(opts, cb) {
        env2.render(this.name, opts, cb);
      };
      app.set("view", NunjucksView);
      app.set("nunjucksEnv", env2);
      return env2;
    };
  }
});

// ../../node_modules/nunjucks/src/environment.js
var require_environment = __commonJS({
  "../../node_modules/nunjucks/src/environment.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p4) {
        o3.__proto__ = p4;
        return o3;
      };
      return _setPrototypeOf(o2, p3);
    }
    var asap = require_asap();
    var _waterfall = require_a_sync_waterfall();
    var lib = require_lib();
    var compiler = require_compiler();
    var filters = require_filters();
    var _require = require_loaders();
    var FileSystemLoader = _require.FileSystemLoader;
    var WebLoader = _require.WebLoader;
    var PrecompiledLoader = _require.PrecompiledLoader;
    var tests = require_tests();
    var globals = require_globals();
    var _require2 = require_object2();
    var Obj = _require2.Obj;
    var EmitterObj = _require2.EmitterObj;
    var globalRuntime = require_runtime();
    var handleError = globalRuntime.handleError;
    var Frame = globalRuntime.Frame;
    var expressApp = require_express_app();
    function callbackAsap(cb, err, res) {
      asap(function() {
        cb(err, res);
      });
    }
    var noopTmplSrc = {
      type: "code",
      obj: {
        root: function root(env2, context, frame, runtime, cb) {
          try {
            cb(null, "");
          } catch (e2) {
            cb(handleError(e2, null, null));
          }
        }
      }
    };
    var Environment2 = /* @__PURE__ */ (function(_EmitterObj) {
      _inheritsLoose(Environment3, _EmitterObj);
      function Environment3() {
        return _EmitterObj.apply(this, arguments) || this;
      }
      var _proto = Environment3.prototype;
      _proto.init = function init4(loaders, opts) {
        var _this = this;
        opts = this.opts = opts || {};
        this.opts.dev = !!opts.dev;
        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
        this.opts.throwOnUndefined = !!opts.throwOnUndefined;
        this.opts.trimBlocks = !!opts.trimBlocks;
        this.opts.lstripBlocks = !!opts.lstripBlocks;
        this.loaders = [];
        if (!loaders) {
          if (FileSystemLoader) {
            this.loaders = [new FileSystemLoader("views")];
          } else if (WebLoader) {
            this.loaders = [new WebLoader("/views")];
          }
        } else {
          this.loaders = lib.isArray(loaders) ? loaders : [loaders];
        }
        if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
          this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
        }
        this._initLoaders();
        this.globals = globals();
        this.filters = {};
        this.tests = {};
        this.asyncFilters = [];
        this.extensions = {};
        this.extensionsList = [];
        lib._entries(filters).forEach(function(_ref) {
          var name = _ref[0], filter2 = _ref[1];
          return _this.addFilter(name, filter2);
        });
        lib._entries(tests).forEach(function(_ref2) {
          var name = _ref2[0], test2 = _ref2[1];
          return _this.addTest(name, test2);
        });
      };
      _proto._initLoaders = function _initLoaders() {
        var _this2 = this;
        this.loaders.forEach(function(loader) {
          loader.cache = {};
          if (typeof loader.on === "function") {
            loader.on("update", function(name, fullname) {
              loader.cache[name] = null;
              _this2.emit("update", name, fullname, loader);
            });
            loader.on("load", function(name, source) {
              _this2.emit("load", name, source, loader);
            });
          }
        });
      };
      _proto.invalidateCache = function invalidateCache() {
        this.loaders.forEach(function(loader) {
          loader.cache = {};
        });
      };
      _proto.addExtension = function addExtension(name, extension) {
        extension.__name = name;
        this.extensions[name] = extension;
        this.extensionsList.push(extension);
        return this;
      };
      _proto.removeExtension = function removeExtension(name) {
        var extension = this.getExtension(name);
        if (!extension) {
          return;
        }
        this.extensionsList = lib.without(this.extensionsList, extension);
        delete this.extensions[name];
      };
      _proto.getExtension = function getExtension(name) {
        return this.extensions[name];
      };
      _proto.hasExtension = function hasExtension(name) {
        return !!this.extensions[name];
      };
      _proto.addGlobal = function addGlobal(name, value) {
        this.globals[name] = value;
        return this;
      };
      _proto.getGlobal = function getGlobal(name) {
        if (typeof this.globals[name] === "undefined") {
          throw new Error("global not found: " + name);
        }
        return this.globals[name];
      };
      _proto.addFilter = function addFilter(name, func, async) {
        var wrapped = func;
        if (async) {
          this.asyncFilters.push(name);
        }
        this.filters[name] = wrapped;
        return this;
      };
      _proto.getFilter = function getFilter(name) {
        if (!this.filters[name]) {
          throw new Error("filter not found: " + name);
        }
        return this.filters[name];
      };
      _proto.addTest = function addTest(name, func) {
        this.tests[name] = func;
        return this;
      };
      _proto.getTest = function getTest(name) {
        if (!this.tests[name]) {
          throw new Error("test not found: " + name);
        }
        return this.tests[name];
      };
      _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
        var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
        return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
      };
      _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
        var _this3 = this;
        var that = this;
        var tmpl = null;
        if (name && name.raw) {
          name = name.raw;
        }
        if (lib.isFunction(parentName)) {
          cb = parentName;
          parentName = null;
          eagerCompile = eagerCompile || false;
        }
        if (lib.isFunction(eagerCompile)) {
          cb = eagerCompile;
          eagerCompile = false;
        }
        if (name instanceof Template) {
          tmpl = name;
        } else if (typeof name !== "string") {
          throw new Error("template names must be a string: " + name);
        } else {
          for (var i2 = 0; i2 < this.loaders.length; i2++) {
            var loader = this.loaders[i2];
            tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];
            if (tmpl) {
              break;
            }
          }
        }
        if (tmpl) {
          if (eagerCompile) {
            tmpl.compile();
          }
          if (cb) {
            cb(null, tmpl);
            return void 0;
          } else {
            return tmpl;
          }
        }
        var syncResult;
        var createTemplate = function createTemplate2(err, info) {
          if (!info && !err && !ignoreMissing) {
            err = new Error("template not found: " + name);
          }
          if (err) {
            if (cb) {
              cb(err);
              return;
            } else {
              throw err;
            }
          }
          var newTmpl;
          if (!info) {
            newTmpl = new Template(noopTmplSrc, _this3, "", eagerCompile);
          } else {
            newTmpl = new Template(info.src, _this3, info.path, eagerCompile);
            if (!info.noCache) {
              info.loader.cache[name] = newTmpl;
            }
          }
          if (cb) {
            cb(null, newTmpl);
          } else {
            syncResult = newTmpl;
          }
        };
        lib.asyncIter(this.loaders, function(loader2, i3, next, done) {
          function handle(err, src) {
            if (err) {
              done(err);
            } else if (src) {
              src.loader = loader2;
              done(null, src);
            } else {
              next();
            }
          }
          name = that.resolveTemplate(loader2, parentName, name);
          if (loader2.async) {
            loader2.getSource(name, handle);
          } else {
            handle(null, loader2.getSource(name));
          }
        }, createTemplate);
        return syncResult;
      };
      _proto.express = function express(app) {
        return expressApp(this, app);
      };
      _proto.render = function render(name, ctx, cb) {
        if (lib.isFunction(ctx)) {
          cb = ctx;
          ctx = null;
        }
        var syncResult = null;
        this.getTemplate(name, function(err, tmpl) {
          if (err && cb) {
            callbackAsap(cb, err);
          } else if (err) {
            throw err;
          } else {
            syncResult = tmpl.render(ctx, cb);
          }
        });
        return syncResult;
      };
      _proto.renderString = function renderString(src, ctx, opts, cb) {
        if (lib.isFunction(opts)) {
          cb = opts;
          opts = {};
        }
        opts = opts || {};
        var tmpl = new Template(src, this, opts.path);
        return tmpl.render(ctx, cb);
      };
      _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
        return _waterfall(tasks, callback, forceAsync);
      };
      return Environment3;
    })(EmitterObj);
    var Context = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Context2, _Obj);
      function Context2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto2 = Context2.prototype;
      _proto2.init = function init4(ctx, blocks, env2) {
        var _this4 = this;
        this.env = env2 || new Environment2();
        this.ctx = lib.extend({}, ctx);
        this.blocks = {};
        this.exported = [];
        lib.keys(blocks).forEach(function(name) {
          _this4.addBlock(name, blocks[name]);
        });
      };
      _proto2.lookup = function lookup2(name) {
        if (name in this.env.globals && !(name in this.ctx)) {
          return this.env.globals[name];
        } else {
          return this.ctx[name];
        }
      };
      _proto2.setVariable = function setVariable(name, val) {
        this.ctx[name] = val;
      };
      _proto2.getVariables = function getVariables() {
        return this.ctx;
      };
      _proto2.addBlock = function addBlock(name, block) {
        this.blocks[name] = this.blocks[name] || [];
        this.blocks[name].push(block);
        return this;
      };
      _proto2.getBlock = function getBlock(name) {
        if (!this.blocks[name]) {
          throw new Error('unknown block "' + name + '"');
        }
        return this.blocks[name][0];
      };
      _proto2.getSuper = function getSuper(env2, name, block, frame, runtime, cb) {
        var idx = lib.indexOf(this.blocks[name] || [], block);
        var blk = this.blocks[name][idx + 1];
        var context = this;
        if (idx === -1 || !blk) {
          throw new Error('no super block available for "' + name + '"');
        }
        blk(env2, context, frame, runtime, cb);
      };
      _proto2.addExport = function addExport(name) {
        this.exported.push(name);
      };
      _proto2.getExported = function getExported() {
        var _this5 = this;
        var exported = {};
        this.exported.forEach(function(name) {
          exported[name] = _this5.ctx[name];
        });
        return exported;
      };
      return Context2;
    })(Obj);
    var Template = /* @__PURE__ */ (function(_Obj2) {
      _inheritsLoose(Template2, _Obj2);
      function Template2() {
        return _Obj2.apply(this, arguments) || this;
      }
      var _proto3 = Template2.prototype;
      _proto3.init = function init4(src, env2, path4, eagerCompile) {
        this.env = env2 || new Environment2();
        if (lib.isObject(src)) {
          switch (src.type) {
            case "code":
              this.tmplProps = src.obj;
              break;
            case "string":
              this.tmplStr = src.obj;
              break;
            default:
              throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
          }
        } else if (lib.isString(src)) {
          this.tmplStr = src;
        } else {
          throw new Error("src must be a string or an object describing the source");
        }
        this.path = path4;
        if (eagerCompile) {
          try {
            this._compile();
          } catch (err) {
            throw lib._prettifyError(this.path, this.env.opts.dev, err);
          }
        } else {
          this.compiled = false;
        }
      };
      _proto3.render = function render(ctx, parentFrame, cb) {
        var _this6 = this;
        if (typeof ctx === "function") {
          cb = ctx;
          ctx = {};
        } else if (typeof parentFrame === "function") {
          cb = parentFrame;
          parentFrame = null;
        }
        var forceAsync = !parentFrame;
        try {
          this.compile();
        } catch (e2) {
          var err = lib._prettifyError(this.path, this.env.opts.dev, e2);
          if (cb) {
            return callbackAsap(cb, err);
          } else {
            throw err;
          }
        }
        var context = new Context(ctx || {}, this.blocks, this.env);
        var frame = parentFrame ? parentFrame.push(true) : new Frame();
        frame.topLevel = true;
        var syncResult = null;
        var didError = false;
        this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err2, res) {
          if (didError && cb && typeof res !== "undefined") {
            return;
          }
          if (err2) {
            err2 = lib._prettifyError(_this6.path, _this6.env.opts.dev, err2);
            didError = true;
          }
          if (cb) {
            if (forceAsync) {
              callbackAsap(cb, err2, res);
            } else {
              cb(err2, res);
            }
          } else {
            if (err2) {
              throw err2;
            }
            syncResult = res;
          }
        });
        return syncResult;
      };
      _proto3.getExported = function getExported(ctx, parentFrame, cb) {
        if (typeof ctx === "function") {
          cb = ctx;
          ctx = {};
        }
        if (typeof parentFrame === "function") {
          cb = parentFrame;
          parentFrame = null;
        }
        try {
          this.compile();
        } catch (e2) {
          if (cb) {
            return cb(e2);
          } else {
            throw e2;
          }
        }
        var frame = parentFrame ? parentFrame.push() : new Frame();
        frame.topLevel = true;
        var context = new Context(ctx || {}, this.blocks, this.env);
        this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err) {
          if (err) {
            cb(err, null);
          } else {
            cb(null, context.getExported());
          }
        });
      };
      _proto3.compile = function compile() {
        if (!this.compiled) {
          this._compile();
        }
      };
      _proto3._compile = function _compile() {
        var props;
        if (this.tmplProps) {
          props = this.tmplProps;
        } else {
          var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
          var func = new Function(source);
          props = func();
        }
        this.blocks = this._getBlocks(props);
        this.rootRenderFunc = props.root;
        this.compiled = true;
      };
      _proto3._getBlocks = function _getBlocks(props) {
        var blocks = {};
        lib.keys(props).forEach(function(k2) {
          if (k2.slice(0, 2) === "b_") {
            blocks[k2.slice(2)] = props[k2];
          }
        });
        return blocks;
      };
      return Template2;
    })(Obj);
    module2.exports = {
      Environment: Environment2,
      Template
    };
  }
});

// ../../node_modules/nunjucks/src/precompile-global.js
var require_precompile_global = __commonJS({
  "../../node_modules/nunjucks/src/precompile-global.js"(exports2, module2) {
    "use strict";
    function precompileGlobal(templates, opts) {
      var out = "";
      opts = opts || {};
      for (var i2 = 0; i2 < templates.length; i2++) {
        var name = JSON.stringify(templates[i2].name);
        var template2 = templates[i2].template;
        out += "(function() {(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})[" + name + "] = (function() {\n" + template2 + "\n})();\n";
        if (opts.asFunction) {
          out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
        }
        out += "})();\n";
      }
      return out;
    }
    module2.exports = precompileGlobal;
  }
});

// ../../node_modules/nunjucks/src/precompile.js
var require_precompile = __commonJS({
  "../../node_modules/nunjucks/src/precompile.js"(exports2, module2) {
    "use strict";
    var fs5 = require("fs");
    var path4 = require("path");
    var _require = require_lib();
    var _prettifyError = _require._prettifyError;
    var compiler = require_compiler();
    var _require2 = require_environment();
    var Environment2 = _require2.Environment;
    var precompileGlobal = require_precompile_global();
    function match(filename, patterns) {
      if (!Array.isArray(patterns)) {
        return false;
      }
      return patterns.some(function(pattern) {
        return filename.match(pattern);
      });
    }
    function precompileString(str, opts) {
      opts = opts || {};
      opts.isString = true;
      var env2 = opts.env || new Environment2([]);
      var wrapper = opts.wrapper || precompileGlobal;
      if (!opts.name) {
        throw new Error('the "name" option is required when compiling a string');
      }
      return wrapper([_precompile(str, opts.name, env2)], opts);
    }
    function precompile(input, opts) {
      opts = opts || {};
      var env2 = opts.env || new Environment2([]);
      var wrapper = opts.wrapper || precompileGlobal;
      if (opts.isString) {
        return precompileString(input, opts);
      }
      var pathStats = fs5.existsSync(input) && fs5.statSync(input);
      var precompiled = [];
      var templates = [];
      function addTemplates(dir) {
        fs5.readdirSync(dir).forEach(function(file) {
          var filepath = path4.join(dir, file);
          var subpath = filepath.substr(path4.join(input, "/").length);
          var stat = fs5.statSync(filepath);
          if (stat && stat.isDirectory()) {
            subpath += "/";
            if (!match(subpath, opts.exclude)) {
              addTemplates(filepath);
            }
          } else if (match(subpath, opts.include)) {
            templates.push(filepath);
          }
        });
      }
      if (pathStats.isFile()) {
        precompiled.push(_precompile(fs5.readFileSync(input, "utf-8"), opts.name || input, env2));
      } else if (pathStats.isDirectory()) {
        addTemplates(input);
        for (var i2 = 0; i2 < templates.length; i2++) {
          var name = templates[i2].replace(path4.join(input, "/"), "");
          try {
            precompiled.push(_precompile(fs5.readFileSync(templates[i2], "utf-8"), name, env2));
          } catch (e2) {
            if (opts.force) {
              console.error(e2);
            } else {
              throw e2;
            }
          }
        }
      }
      return wrapper(precompiled, opts);
    }
    function _precompile(str, name, env2) {
      env2 = env2 || new Environment2([]);
      var asyncFilters = env2.asyncFilters;
      var extensions = env2.extensionsList;
      var template2;
      name = name.replace(/\\/g, "/");
      try {
        template2 = compiler.compile(str, asyncFilters, extensions, name, env2.opts);
      } catch (err) {
        throw _prettifyError(name, false, err);
      }
      return {
        name,
        template: template2
      };
    }
    module2.exports = {
      precompile,
      precompileString
    };
  }
});

// ../../node_modules/nunjucks/src/jinja-compat.js
var require_jinja_compat = __commonJS({
  "../../node_modules/nunjucks/src/jinja-compat.js"(exports2, module2) {
    "use strict";
    function installCompat() {
      "use strict";
      var runtime = this.runtime;
      var lib = this.lib;
      var Compiler = this.compiler.Compiler;
      var Parser = this.parser.Parser;
      var nodes = this.nodes;
      var lexer = this.lexer;
      var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
      var orig_memberLookup = runtime.memberLookup;
      var orig_Compiler_assertType;
      var orig_Parser_parseAggregate;
      if (Compiler) {
        orig_Compiler_assertType = Compiler.prototype.assertType;
      }
      if (Parser) {
        orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
      }
      function uninstall() {
        runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
        runtime.memberLookup = orig_memberLookup;
        if (Compiler) {
          Compiler.prototype.assertType = orig_Compiler_assertType;
        }
        if (Parser) {
          Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
        }
      }
      runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
        var val = orig_contextOrFrameLookup.apply(this, arguments);
        if (val !== void 0) {
          return val;
        }
        switch (key) {
          case "True":
            return true;
          case "False":
            return false;
          case "None":
            return null;
          default:
            return void 0;
        }
      };
      function getTokensState(tokens) {
        return {
          index: tokens.index,
          lineno: tokens.lineno,
          colno: tokens.colno
        };
      }
      if (process.env.BUILD_TYPE !== "SLIM" && nodes && Compiler && Parser) {
        var Slice = nodes.Node.extend("Slice", {
          fields: ["start", "stop", "step"],
          init: function init4(lineno, colno, start, stop, step) {
            start = start || new nodes.Literal(lineno, colno, null);
            stop = stop || new nodes.Literal(lineno, colno, null);
            step = step || new nodes.Literal(lineno, colno, 1);
            this.parent(lineno, colno, start, stop, step);
          }
        });
        Compiler.prototype.assertType = function assertType(node3) {
          if (node3 instanceof Slice) {
            return;
          }
          orig_Compiler_assertType.apply(this, arguments);
        };
        Compiler.prototype.compileSlice = function compileSlice(node3, frame) {
          this._emit("(");
          this._compileExpression(node3.start, frame);
          this._emit("),(");
          this._compileExpression(node3.stop, frame);
          this._emit("),(");
          this._compileExpression(node3.step, frame);
          this._emit(")");
        };
        Parser.prototype.parseAggregate = function parseAggregate() {
          var _this = this;
          var origState = getTokensState(this.tokens);
          origState.colno--;
          origState.index--;
          try {
            return orig_Parser_parseAggregate.apply(this);
          } catch (e2) {
            var errState = getTokensState(this.tokens);
            var rethrow = function rethrow2() {
              lib._assign(_this.tokens, errState);
              return e2;
            };
            lib._assign(this.tokens, origState);
            this.peeked = false;
            var tok = this.peekToken();
            if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
              throw rethrow();
            } else {
              this.nextToken();
            }
            var node3 = new Slice(tok.lineno, tok.colno);
            var isSlice = false;
            for (var i2 = 0; i2 <= node3.fields.length; i2++) {
              if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                break;
              }
              if (i2 === node3.fields.length) {
                if (isSlice) {
                  this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                } else {
                  break;
                }
              }
              if (this.skip(lexer.TOKEN_COLON)) {
                isSlice = true;
              } else {
                var field = node3.fields[i2];
                node3[field] = this.parseExpression();
                isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
              }
            }
            if (!isSlice) {
              throw rethrow();
            }
            return new nodes.Array(tok.lineno, tok.colno, [node3]);
          }
        };
      }
      function sliceLookup(obj, start, stop, step) {
        obj = obj || [];
        if (start === null) {
          start = step < 0 ? obj.length - 1 : 0;
        }
        if (stop === null) {
          stop = step < 0 ? -1 : obj.length;
        } else if (stop < 0) {
          stop += obj.length;
        }
        if (start < 0) {
          start += obj.length;
        }
        var results = [];
        for (var i2 = start; ; i2 += step) {
          if (i2 < 0 || i2 > obj.length) {
            break;
          }
          if (step > 0 && i2 >= stop) {
            break;
          }
          if (step < 0 && i2 <= stop) {
            break;
          }
          results.push(runtime.memberLookup(obj, i2));
        }
        return results;
      }
      function hasOwnProp(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      var ARRAY_MEMBERS = {
        pop: function pop(index) {
          if (index === void 0) {
            return this.pop();
          }
          if (index >= this.length || index < 0) {
            throw new Error("KeyError");
          }
          return this.splice(index, 1);
        },
        append: function append(element) {
          return this.push(element);
        },
        remove: function remove3(element) {
          for (var i2 = 0; i2 < this.length; i2++) {
            if (this[i2] === element) {
              return this.splice(i2, 1);
            }
          }
          throw new Error("ValueError");
        },
        count: function count(element) {
          var count2 = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            if (this[i2] === element) {
              count2++;
            }
          }
          return count2;
        },
        index: function index(element) {
          var i2;
          if ((i2 = this.indexOf(element)) === -1) {
            throw new Error("ValueError");
          }
          return i2;
        },
        find: function find2(element) {
          return this.indexOf(element);
        },
        insert: function insert(index, elem) {
          return this.splice(index, 0, elem);
        }
      };
      var OBJECT_MEMBERS = {
        items: function items() {
          return lib._entries(this);
        },
        values: function values2() {
          return lib._values(this);
        },
        keys: function keys2() {
          return lib.keys(this);
        },
        get: function get2(key, def) {
          var output = this[key];
          if (output === void 0) {
            output = def;
          }
          return output;
        },
        has_key: function has_key(key) {
          return hasOwnProp(this, key);
        },
        pop: function pop(key, def) {
          var output = this[key];
          if (output === void 0 && def !== void 0) {
            output = def;
          } else if (output === void 0) {
            throw new Error("KeyError");
          } else {
            delete this[key];
          }
          return output;
        },
        popitem: function popitem() {
          var keys2 = lib.keys(this);
          if (!keys2.length) {
            throw new Error("KeyError");
          }
          var k2 = keys2[0];
          var val = this[k2];
          delete this[k2];
          return [k2, val];
        },
        setdefault: function setdefault(key, def) {
          if (def === void 0) {
            def = null;
          }
          if (!(key in this)) {
            this[key] = def;
          }
          return this[key];
        },
        update: function update3(kwargs) {
          lib._assign(this, kwargs);
          return null;
        }
      };
      OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
      OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
      OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
      runtime.memberLookup = function memberLookup(obj, val, autoescape) {
        if (arguments.length === 4) {
          return sliceLookup.apply(this, arguments);
        }
        obj = obj || {};
        if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
          return ARRAY_MEMBERS[val].bind(obj);
        }
        if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
          return OBJECT_MEMBERS[val].bind(obj);
        }
        return orig_memberLookup.apply(this, arguments);
      };
      return uninstall;
    }
    module2.exports = installCompat;
  }
});

// ../../node_modules/nunjucks/index.js
var require_nunjucks = __commonJS({
  "../../node_modules/nunjucks/index.js"(exports2, module2) {
    "use strict";
    var lib = require_lib();
    var _require = require_environment();
    var Environment2 = _require.Environment;
    var Template = _require.Template;
    var Loader = require_loader();
    var loaders = require_loaders();
    var precompile = require_precompile();
    var compiler = require_compiler();
    var parser = require_parser();
    var lexer = require_lexer();
    var runtime = require_runtime();
    var nodes = require_nodes();
    var installJinjaCompat = require_jinja_compat();
    var e2;
    function configure(templatesPath, opts) {
      opts = opts || {};
      if (lib.isObject(templatesPath)) {
        opts = templatesPath;
        templatesPath = null;
      }
      var TemplateLoader;
      if (loaders.FileSystemLoader) {
        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
          watch: opts.watch,
          noCache: opts.noCache
        });
      } else if (loaders.WebLoader) {
        TemplateLoader = new loaders.WebLoader(templatesPath, {
          useCache: opts.web && opts.web.useCache,
          async: opts.web && opts.web.async
        });
      }
      e2 = new Environment2(TemplateLoader, opts);
      if (opts && opts.express) {
        e2.express(opts.express);
      }
      return e2;
    }
    module2.exports = {
      Environment: Environment2,
      Template,
      Loader,
      FileSystemLoader: loaders.FileSystemLoader,
      NodeResolveLoader: loaders.NodeResolveLoader,
      PrecompiledLoader: loaders.PrecompiledLoader,
      WebLoader: loaders.WebLoader,
      compiler,
      parser,
      lexer,
      runtime,
      lib,
      nodes,
      installJinjaCompat,
      configure,
      reset: function reset() {
        e2 = void 0;
      },
      compile: function compile(src, env2, path4, eagerCompile) {
        if (!e2) {
          configure();
        }
        return new Template(src, env2, path4, eagerCompile);
      },
      render: function render(name, ctx, cb) {
        if (!e2) {
          configure();
        }
        return e2.render(name, ctx, cb);
      },
      renderString: function renderString(src, ctx, cb) {
        if (!e2) {
          configure();
        }
        return e2.renderString(src, ctx, cb);
      },
      precompile: precompile ? precompile.precompile : void 0,
      precompileString: precompile ? precompile.precompileString : void 0
    };
  }
});

// ../../node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/punycode/punycode.js"(exports2, module2) {
    "use strict";
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7F]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor2 = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error(type) {
      throw new RangeError(errors[type]);
    }
    function map2(array, callback) {
      const result2 = [];
      let length = array.length;
      while (length--) {
        result2[length] = callback(array[length]);
      }
      return result2;
    }
    function mapDomain(domain, callback) {
      const parts = domain.split("@");
      let result2 = "";
      if (parts.length > 1) {
        result2 = parts[0] + "@";
        domain = parts[1];
      }
      domain = domain.replace(regexSeparators, ".");
      const labels = domain.split(".");
      const encoded = map2(labels, callback).join(".");
      return result2 + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    var basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function(delta, numPoints, firstTime) {
      let k2 = 0;
      delta = firstTime ? floor2(delta / damp) : delta >> 1;
      delta += floor2(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
        delta = floor2(delta / baseMinusTMin);
      }
      return floor2(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i2 = 0;
      let n2 = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j3 = 0; j3 < basic; ++j3) {
        if (input.charCodeAt(j3) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j3));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i2;
        for (let w3 = 1, k2 = base; ; k2 += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor2((maxInt - i2) / w3)) {
            error("overflow");
          }
          i2 += digit * w3;
          const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t2) {
            break;
          }
          const baseMinusT = base - t2;
          if (w3 > floor2(maxInt / baseMinusT)) {
            error("overflow");
          }
          w3 *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor2(i2 / out) > maxInt - n2) {
          error("overflow");
        }
        n2 += floor2(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n2);
      }
      return String.fromCodePoint(...output);
    };
    var encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n2 = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m3 = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n2 && currentValue < m3) {
            m3 = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m3 - n2 > floor2((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m3 - n2) * handledCPCountPlusOne;
        n2 = m3;
        for (const currentValue of input) {
          if (currentValue < n2 && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n2) {
            let q3 = delta;
            for (let k2 = base; ; k2 += base) {
              const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q3 < t2) {
                break;
              }
              const qMinusT = q3 - t2;
              const baseMinusT = base - t2;
              output.push(
                stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
              );
              q3 = floor2(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q3, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    };
    var toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    module2.exports = punycode;
  }
});

// ../../node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "../../node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port) return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// ../../node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "../../node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e2) {
        return null;
      }
    }
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e2) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result2 = {}, part;
      while (part = parser.exec(query)) {
        var key = decode(part[1]), value = decode(part[2]);
        if (key === null || value === null || key in result2) continue;
        result2[key] = value;
      }
      return result2;
    }
    function querystringify(obj, prefix2) {
      prefix2 = prefix2 || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix2) prefix2 = "?";
      for (key in obj) {
        if (has2.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode(key);
          value = encode(value);
          if (key === null || value === null) continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix2 + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// ../../node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "../../node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined") globalVar = window;
      else if (typeof global !== "undefined") globalVar = global;
      else if (typeof self !== "undefined") globalVar = self;
      else globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url2(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url2(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest3;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest3 = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest3 = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest3 = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest3 = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest3 = rest3.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest3 = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest3 = rest3.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest3 = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest: rest3
      };
    }
    function resolve(relative, base) {
      if (relative === "") return base;
      var path4 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path4.length, last3 = path4[i2 - 1], unshift = false, up = 0;
      while (i2--) {
        if (path4[i2] === ".") {
          path4.splice(i2, 1);
        } else if (path4[i2] === "..") {
          path4.splice(i2, 1);
          up++;
        } else if (up) {
          if (i2 === 0) unshift = true;
          path4.splice(i2, 1);
          up--;
        }
      }
      if (unshift) path4.unshift("");
      if (last3 === "." || last3 === "..") path4.push("");
      return path4.join("/");
    }
    function Url2(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url2)) {
        return new Url2(address, location, parser);
      }
      var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i2 = 0;
      if ("object" !== type && "string" !== type) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser) parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i2 < instructions.length; i2++) {
        instruction = instructions[i2];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key = instruction[1];
        if (parse !== parse) {
          url[key] = address;
        } else if ("string" === typeof parse) {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }
      if (parser) url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set2(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port) value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i2 = 0; i2 < rules.length; i2++) {
        var ins = rules[i2];
        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString2(stringify) {
      if (!stringify || "function" !== typeof stringify) stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
      var result2 = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result2 += url.username;
        if (url.password) result2 += ":" + url.password;
        result2 += "@";
      } else if (url.password) {
        result2 += ":" + url.password;
        result2 += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result2 += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result2 += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query) result2 += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash) result2 += url.hash;
      return result2;
    }
    Url2.prototype = { set: set2, toString: toString2 };
    Url2.extractProtocol = extractProtocol;
    Url2.location = lolcation;
    Url2.trimLeft = trimLeft;
    Url2.qs = qs;
    module2.exports = Url2;
  }
});

// ../../node_modules/psl/dist/psl.cjs
var require_psl = __commonJS({
  "../../node_modules/psl/dist/psl.cjs"(exports2) {
    "use strict";
    Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    function K3(e2) {
      return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
    }
    var O3;
    var F3;
    function Q3() {
      if (F3) return O3;
      F3 = 1;
      const e2 = 2147483647, s2 = 36, c2 = 1, o2 = 26, t2 = 38, d2 = 700, z3 = 72, y2 = 128, g2 = "-", P3 = /^xn--/, V3 = /[^\0-\x7F]/, G3 = /[\x2E\u3002\uFF0E\uFF61]/g, W3 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, C2 = s2 - c2, h2 = Math.floor, I3 = String.fromCharCode;
      function v3(a2) {
        throw new RangeError(W3[a2]);
      }
      function U3(a2, i2) {
        const m3 = [];
        let n2 = a2.length;
        for (; n2--; ) m3[n2] = i2(a2[n2]);
        return m3;
      }
      function S3(a2, i2) {
        const m3 = a2.split("@");
        let n2 = "";
        m3.length > 1 && (n2 = m3[0] + "@", a2 = m3[1]), a2 = a2.replace(G3, ".");
        const r2 = a2.split("."), p3 = U3(r2, i2).join(".");
        return n2 + p3;
      }
      function L3(a2) {
        const i2 = [];
        let m3 = 0;
        const n2 = a2.length;
        for (; m3 < n2; ) {
          const r2 = a2.charCodeAt(m3++);
          if (r2 >= 55296 && r2 <= 56319 && m3 < n2) {
            const p3 = a2.charCodeAt(m3++);
            (p3 & 64512) == 56320 ? i2.push(((r2 & 1023) << 10) + (p3 & 1023) + 65536) : (i2.push(r2), m3--);
          } else i2.push(r2);
        }
        return i2;
      }
      const $3 = (a2) => String.fromCodePoint(...a2), J3 = function(a2) {
        return a2 >= 48 && a2 < 58 ? 26 + (a2 - 48) : a2 >= 65 && a2 < 91 ? a2 - 65 : a2 >= 97 && a2 < 123 ? a2 - 97 : s2;
      }, D3 = function(a2, i2) {
        return a2 + 22 + 75 * (a2 < 26) - ((i2 != 0) << 5);
      }, T3 = function(a2, i2, m3) {
        let n2 = 0;
        for (a2 = m3 ? h2(a2 / d2) : a2 >> 1, a2 += h2(a2 / i2); a2 > C2 * o2 >> 1; n2 += s2) a2 = h2(a2 / C2);
        return h2(n2 + (C2 + 1) * a2 / (a2 + t2));
      }, E2 = function(a2) {
        const i2 = [], m3 = a2.length;
        let n2 = 0, r2 = y2, p3 = z3, j3 = a2.lastIndexOf(g2);
        j3 < 0 && (j3 = 0);
        for (let u2 = 0; u2 < j3; ++u2) a2.charCodeAt(u2) >= 128 && v3("not-basic"), i2.push(a2.charCodeAt(u2));
        for (let u2 = j3 > 0 ? j3 + 1 : 0; u2 < m3; ) {
          const k2 = n2;
          for (let l2 = 1, b2 = s2; ; b2 += s2) {
            u2 >= m3 && v3("invalid-input");
            const w3 = J3(a2.charCodeAt(u2++));
            w3 >= s2 && v3("invalid-input"), w3 > h2((e2 - n2) / l2) && v3("overflow"), n2 += w3 * l2;
            const x3 = b2 <= p3 ? c2 : b2 >= p3 + o2 ? o2 : b2 - p3;
            if (w3 < x3) break;
            const q3 = s2 - x3;
            l2 > h2(e2 / q3) && v3("overflow"), l2 *= q3;
          }
          const f3 = i2.length + 1;
          p3 = T3(n2 - k2, f3, k2 == 0), h2(n2 / f3) > e2 - r2 && v3("overflow"), r2 += h2(n2 / f3), n2 %= f3, i2.splice(n2++, 0, r2);
        }
        return String.fromCodePoint(...i2);
      }, B3 = function(a2) {
        const i2 = [];
        a2 = L3(a2);
        const m3 = a2.length;
        let n2 = y2, r2 = 0, p3 = z3;
        for (const k2 of a2) k2 < 128 && i2.push(I3(k2));
        const j3 = i2.length;
        let u2 = j3;
        for (j3 && i2.push(g2); u2 < m3; ) {
          let k2 = e2;
          for (const l2 of a2) l2 >= n2 && l2 < k2 && (k2 = l2);
          const f3 = u2 + 1;
          k2 - n2 > h2((e2 - r2) / f3) && v3("overflow"), r2 += (k2 - n2) * f3, n2 = k2;
          for (const l2 of a2) if (l2 < n2 && ++r2 > e2 && v3("overflow"), l2 === n2) {
            let b2 = r2;
            for (let w3 = s2; ; w3 += s2) {
              const x3 = w3 <= p3 ? c2 : w3 >= p3 + o2 ? o2 : w3 - p3;
              if (b2 < x3) break;
              const q3 = b2 - x3, M3 = s2 - x3;
              i2.push(I3(D3(x3 + q3 % M3, 0))), b2 = h2(q3 / M3);
            }
            i2.push(I3(D3(b2, 0))), p3 = T3(r2, f3, u2 === j3), r2 = 0, ++u2;
          }
          ++r2, ++n2;
        }
        return i2.join("");
      };
      return O3 = { version: "2.3.1", ucs2: { decode: L3, encode: $3 }, decode: E2, encode: B3, toASCII: function(a2) {
        return S3(a2, function(i2) {
          return V3.test(i2) ? "xn--" + B3(i2) : i2;
        });
      }, toUnicode: function(a2) {
        return S3(a2, function(i2) {
          return P3.test(i2) ? E2(i2.slice(4).toLowerCase()) : i2;
        });
      } }, O3;
    }
    var X3 = Q3();
    var A3 = K3(X3);
    var Y3 = ["ac", "com.ac", "edu.ac", "gov.ac", "mil.ac", "net.ac", "org.ac", "ad", "ae", "ac.ae", "co.ae", "gov.ae", "mil.ae", "net.ae", "org.ae", "sch.ae", "aero", "airline.aero", "airport.aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "air-surveillance.aero", "air-traffic-control.aero", "aircraft.aero", "airtraffic.aero", "ambulance.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "freight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "marketplace.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "taxi.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "com.af", "edu.af", "gov.af", "net.af", "org.af", "ag", "co.ag", "com.ag", "net.ag", "nom.ag", "org.ag", "ai", "com.ai", "net.ai", "off.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "co.ao", "ed.ao", "edu.ao", "gov.ao", "gv.ao", "it.ao", "og.ao", "org.ao", "pb.ao", "aq", "ar", "bet.ar", "com.ar", "coop.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "mutual.ar", "net.ar", "org.ar", "senasa.ar", "tur.ar", "arpa", "e164.arpa", "home.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "sth.ac.at", "co.at", "gv.at", "or.at", "au", "asn.au", "com.au", "edu.au", "gov.au", "id.au", "net.au", "org.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "catholic.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "schools.nsw.edu.au", "aw", "com.aw", "ax", "az", "biz.az", "com.az", "edu.az", "gov.az", "info.az", "int.az", "mil.az", "name.az", "net.az", "org.az", "pp.az", "pro.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "bh", "com.bh", "edu.bh", "gov.bh", "net.bh", "org.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "africa.bj", "agro.bj", "architectes.bj", "assur.bj", "avocats.bj", "co.bj", "com.bj", "eco.bj", "econo.bj", "edu.bj", "info.bj", "loisirs.bj", "money.bj", "net.bj", "org.bj", "ote.bj", "restaurant.bj", "resto.bj", "tourism.bj", "univ.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "mil.bo", "net.bo", "org.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "plurinacional.bo", "politica.bo", "profesional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "app.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bet.br", "bhz.br", "bib.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "coz.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "des.br", "det.br", "dev.br", "ecn.br", "eco.br", "edu.br", "emp.br", "enf.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "geo.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "leilao.br", "lel.br", "log.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "rep.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "seg.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "tec.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "edu.bs", "gov.bs", "net.bs", "org.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "co.bz", "com.bz", "edu.bz", "gov.bz", "net.bz", "org.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "ac.ci", "a\xE9roport.ci", "asso.ci", "co.ci", "com.ci", "ed.ci", "edu.ci", "go.ci", "gouv.ci", "int.ci", "net.ci", "or.ci", "org.ci", "*.ck", "!www.ck", "cl", "co.cl", "gob.cl", "gov.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "mil.cn", "net.cn", "org.cn", "\u516C\u53F8.cn", "\u7DB2\u7D61.cn", "\u7F51\u7EDC.cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gx.cn", "gz.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hk.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "mo.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "tw.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "co", "com.co", "edu.co", "gov.co", "mil.co", "net.co", "nom.co", "org.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "gob.cu", "inf.cu", "nat.cu", "net.cu", "org.cu", "cv", "com.cv", "edu.cv", "id.cv", "int.cv", "net.cv", "nome.cv", "org.cv", "publ.cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "mil.cy", "net.cy", "org.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "co.dm", "com.dm", "edu.dm", "gov.dm", "net.dm", "org.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "art.dz", "asso.dz", "com.dz", "edu.dz", "gov.dz", "net.dz", "org.dz", "pol.dz", "soc.dz", "tm.dz", "ec", "com.ec", "edu.ec", "fin.ec", "gob.ec", "gov.ec", "info.ec", "k12.ec", "med.ec", "mil.ec", "net.ec", "org.ec", "pro.ec", "edu", "ee", "aip.ee", "com.ee", "edu.ee", "fie.ee", "gov.ee", "lib.ee", "med.ee", "org.ee", "pri.ee", "riik.ee", "eg", "ac.eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "info.eg", "me.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "sport.eg", "tv.eg", "*.er", "es", "com.es", "edu.es", "gob.es", "nom.es", "org.es", "et", "biz.et", "com.et", "edu.et", "gov.et", "info.et", "name.et", "net.et", "org.et", "eu", "fi", "aland.fi", "fj", "ac.fj", "biz.fj", "com.fj", "gov.fj", "info.fj", "mil.fj", "name.fj", "net.fj", "org.fj", "pro.fj", "*.fk", "fm", "com.fm", "edu.fm", "net.fm", "org.fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "avoues.fr", "cci.fr", "greta.fr", "huissier-justice.fr", "ga", "gb", "gd", "edu.gd", "gov.gd", "ge", "com.ge", "edu.ge", "gov.ge", "net.ge", "org.ge", "pvt.ge", "school.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "mil.gh", "org.gh", "gi", "com.gi", "edu.gi", "gov.gi", "ltd.gi", "mod.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "net.gn", "org.gn", "gov", "gp", "asso.gp", "com.gp", "edu.gp", "mobi.gp", "net.gp", "org.gp", "gq", "gr", "com.gr", "edu.gr", "gov.gr", "net.gr", "org.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", "\u4E2A\u4EBA.hk", "\u500B\u4EBA.hk", "\u516C\u53F8.hk", "\u653F\u5E9C.hk", "\u654E\u80B2.hk", "\u6559\u80B2.hk", "\u7B87\u4EBA.hk", "\u7D44\u7E54.hk", "\u7D44\u7EC7.hk", "\u7DB2\u7D61.hk", "\u7DB2\u7EDC.hk", "\u7EC4\u7E54.hk", "\u7EC4\u7EC7.hk", "\u7F51\u7D61.hk", "\u7F51\u7EDC.hk", "hm", "hn", "com.hn", "edu.hn", "gob.hn", "mil.hn", "net.hn", "org.hn", "hr", "com.hr", "from.hr", "iz.hr", "name.hr", "ht", "adult.ht", "art.ht", "asso.ht", "com.ht", "coop.ht", "edu.ht", "firm.ht", "gouv.ht", "info.ht", "med.ht", "net.ht", "org.ht", "perso.ht", "pol.ht", "pro.ht", "rel.ht", "shop.ht", "hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "co.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "info.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "org.hu", "priv.hu", "reklam.hu", "sex.hu", "shop.hu", "sport.hu", "suli.hu", "szex.hu", "tm.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "\u05D9\u05E9\u05E8\u05D0\u05DC", "\u05D0\u05E7\u05D3\u05DE\u05D9\u05D4.\u05D9\u05E9\u05E8\u05D0\u05DC", "\u05D9\u05E9\u05D5\u05D1.\u05D9\u05E9\u05E8\u05D0\u05DC", "\u05E6\u05D4\u05DC.\u05D9\u05E9\u05E8\u05D0\u05DC", "\u05DE\u05DE\u05E9\u05DC.\u05D9\u05E9\u05E8\u05D0\u05DC", "im", "ac.im", "co.im", "ltd.co.im", "plc.co.im", "com.im", "net.im", "org.im", "tt.im", "tv.im", "in", "5g.in", "6g.in", "ac.in", "ai.in", "am.in", "bihar.in", "biz.in", "business.in", "ca.in", "cn.in", "co.in", "com.in", "coop.in", "cs.in", "delhi.in", "dr.in", "edu.in", "er.in", "firm.in", "gen.in", "gov.in", "gujarat.in", "ind.in", "info.in", "int.in", "internet.in", "io.in", "me.in", "mil.in", "net.in", "nic.in", "org.in", "pg.in", "post.in", "pro.in", "res.in", "travel.in", "tv.in", "uk.in", "up.in", "us.in", "info", "int", "eu.int", "io", "co.io", "com.io", "edu.io", "gov.io", "mil.io", "net.io", "nom.io", "org.io", "iq", "com.iq", "edu.iq", "gov.iq", "mil.iq", "net.iq", "org.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", "\u0627\u06CC\u0631\u0627\u0646.ir", "\u0627\u064A\u0631\u0627\u0646.ir", "is", "it", "edu.it", "gov.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-s\xFCd-tirol.it", "trentin-sudtirol.it", "trentin-s\xFCdtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-s\xFCd-tirol.it", "trentino-sudtirol.it", "trentino-s\xFCdtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinos\xFCd-tirol.it", "trentinosudtirol.it", "trentinos\xFCdtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentins\xFCd-tirol.it", "trentinsudtirol.it", "trentins\xFCdtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "vall\xE9e-aoste.it", "vallee-d-aoste.it", "vall\xE9e-d-aoste.it", "valleeaoste.it", "vall\xE9eaoste.it", "valleedaoste.it", "vall\xE9edaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan.it", "balsan-sudtirol.it", "balsan-s\xFCdtirol.it", "balsan-suedtirol.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano.it", "bolzano-altoadige.it", "bozen.it", "bozen-sudtirol.it", "bozen-s\xFCdtirol.it", "bozen-suedtirol.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan.it", "bulsan-sudtirol.it", "bulsan-s\xFCdtirol.it", "bulsan-suedtirol.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forl\xEC.it", "cesenaforli.it", "cesenaforl\xEC.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forl\xEC-cesena.it", "forlicesena.it", "forl\xECcesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza.it", "monza-brianza.it", "monza-e-della-brianza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "s\xFCdtirol.it", "suedtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "agri.jo", "ai.jo", "com.jo", "edu.jo", "eng.jo", "fm.jo", "gov.jo", "mil.jo", "net.jo", "org.jo", "per.jo", "phd.jo", "sch.jo", "tv.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", "\u4E09\u91CD.jp", "\u4EAC\u90FD.jp", "\u4F50\u8CC0.jp", "\u5175\u5EAB.jp", "\u5317\u6D77\u9053.jp", "\u5343\u8449.jp", "\u548C\u6B4C\u5C71.jp", "\u57FC\u7389.jp", "\u5927\u5206.jp", "\u5927\u962A.jp", "\u5948\u826F.jp", "\u5BAE\u57CE.jp", "\u5BAE\u5D0E.jp", "\u5BCC\u5C71.jp", "\u5C71\u53E3.jp", "\u5C71\u5F62.jp", "\u5C71\u68A8.jp", "\u5C90\u961C.jp", "\u5CA1\u5C71.jp", "\u5CA9\u624B.jp", "\u5CF6\u6839.jp", "\u5E83\u5CF6.jp", "\u5FB3\u5CF6.jp", "\u611B\u5A9B.jp", "\u611B\u77E5.jp", "\u65B0\u6F5F.jp", "\u6771\u4EAC.jp", "\u6803\u6728.jp", "\u6C96\u7E04.jp", "\u6ECB\u8CC0.jp", "\u718A\u672C.jp", "\u77F3\u5DDD.jp", "\u795E\u5948\u5DDD.jp", "\u798F\u4E95.jp", "\u798F\u5CA1.jp", "\u798F\u5CF6.jp", "\u79CB\u7530.jp", "\u7FA4\u99AC.jp", "\u8328\u57CE.jp", "\u9577\u5D0E.jp", "\u9577\u91CE.jp", "\u9752\u68EE.jp", "\u9759\u5CA1.jp", "\u9999\u5DDD.jp", "\u9AD8\u77E5.jp", "\u9CE5\u53D6.jp", "\u9E7F\u5150\u5CF6.jp", "*.kawasaki.jp", "!city.kawasaki.jp", "*.kitakyushu.jp", "!city.kitakyushu.jp", "*.kobe.jp", "!city.kobe.jp", "*.nagoya.jp", "!city.nagoya.jp", "*.sapporo.jp", "!city.sapporo.jp", "*.sendai.jp", "!city.sendai.jp", "*.yokohama.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "net.kg", "org.kg", "*.kh", "ki", "biz.ki", "com.ki", "edu.ki", "gov.ki", "info.ki", "net.ki", "org.ki", "km", "ass.km", "com.km", "edu.km", "gov.km", "mil.km", "nom.km", "org.km", "prd.km", "tm.km", "asso.km", "coop.km", "gouv.km", "medecin.km", "notaires.km", "pharmaciens.km", "presse.km", "veterinaire.km", "kn", "edu.kn", "gov.kn", "net.kn", "org.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "com.ky", "edu.ky", "net.ky", "org.ky", "kz", "com.kz", "edu.kz", "gov.kz", "mil.kz", "net.kz", "org.kz", "la", "com.la", "edu.la", "gov.la", "info.la", "int.la", "net.la", "org.la", "per.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "co.lc", "com.lc", "edu.lc", "gov.lc", "net.lc", "org.lc", "li", "lk", "ac.lk", "assn.lk", "com.lk", "edu.lk", "gov.lk", "grp.lk", "hotel.lk", "int.lk", "ltd.lk", "net.lk", "ngo.lk", "org.lk", "sch.lk", "soc.lk", "web.lk", "lr", "com.lr", "edu.lr", "gov.lr", "net.lr", "org.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "asn.lv", "com.lv", "conf.lv", "edu.lv", "gov.lv", "id.lv", "mil.lv", "net.lv", "org.lv", "ly", "com.ly", "edu.ly", "gov.ly", "id.ly", "med.ly", "net.ly", "org.ly", "plc.ly", "sch.ly", "ma", "ac.ma", "co.ma", "gov.ma", "net.ma", "org.ma", "press.ma", "mc", "asso.mc", "tm.mc", "md", "me", "ac.me", "co.me", "edu.me", "gov.me", "its.me", "net.me", "org.me", "priv.me", "mg", "co.mg", "com.mg", "edu.mg", "gov.mg", "mil.mg", "nom.mg", "org.mg", "prd.mg", "mh", "mil", "mk", "com.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "net.mk", "org.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "edu.mn", "gov.mn", "org.mn", "mo", "com.mo", "edu.mo", "gov.mo", "net.mo", "org.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "ac.mu", "co.mu", "com.mu", "gov.mu", "net.mu", "or.mu", "org.mu", "museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "net.mw", "org.mw", "mx", "com.mx", "edu.mx", "gob.mx", "net.mx", "org.mx", "my", "biz.my", "com.my", "edu.my", "gov.my", "mil.my", "name.my", "net.my", "org.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "alt.na", "co.na", "com.na", "gov.na", "net.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "arts.nf", "com.nf", "firm.nf", "info.nf", "net.nf", "other.nf", "per.nf", "rec.nf", "store.nf", "web.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "folkebibl.no", "fylkesbibl.no", "idrett.no", "museum.no", "priv.no", "vgs.no", "dep.no", "herad.no", "kommune.no", "mil.no", "stat.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "\xE5krehamn.no", "algard.no", "\xE5lg\xE5rd.no", "arna.no", "bronnoysund.no", "br\xF8nn\xF8ysund.no", "brumunddal.no", "bryne.no", "drobak.no", "dr\xF8bak.no", "egersund.no", "fetsund.no", "floro.no", "flor\xF8.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "h\xF8nefoss.no", "jessheim.no", "jorpeland.no", "j\xF8rpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langev\xE5g.no", "leirvik.no", "mjondalen.no", "mj\xF8ndalen.no", "mo-i-rana.no", "mosjoen.no", "mosj\xF8en.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "os\xF8yro.no", "raholt.no", "r\xE5holt.no", "sandnessjoen.no", "sandnessj\xF8en.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stj\xF8rdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "aarborte.no", "aejrie.no", "afjord.no", "\xE5fjord.no", "agdenes.no", "nes.akershus.no", "aknoluokta.no", "\xE1k\u014Boluokta.no", "al.no", "\xE5l.no", "alaheadju.no", "\xE1laheadju.no", "alesund.no", "\xE5lesund.no", "alstahaug.no", "alta.no", "\xE1lt\xE1.no", "alvdal.no", "amli.no", "\xE5mli.no", "amot.no", "\xE5mot.no", "andasuolo.no", "andebu.no", "andoy.no", "and\xF8y.no", "ardal.no", "\xE5rdal.no", "aremark.no", "arendal.no", "\xE5s.no", "aseral.no", "\xE5seral.no", "asker.no", "askim.no", "askoy.no", "ask\xF8y.no", "askvoll.no", "asnes.no", "\xE5snes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-h\xF8land.no", "austevoll.no", "austrheim.no", "averoy.no", "aver\xF8y.no", "badaddja.no", "b\xE5d\xE5ddj\xE5.no", "b\xE6rum.no", "bahcavuotna.no", "b\xE1hcavuotna.no", "bahccavuotna.no", "b\xE1hccavuotna.no", "baidar.no", "b\xE1id\xE1r.no", "bajddar.no", "b\xE1jddar.no", "balat.no", "b\xE1l\xE1t.no", "balestrand.no", "ballangen.no", "balsfjord.no", "bamble.no", "bardu.no", "barum.no", "batsfjord.no", "b\xE5tsfjord.no", "bearalvahki.no", "bearalv\xE1hki.no", "beardu.no", "beiarn.no", "berg.no", "bergen.no", "berlevag.no", "berlev\xE5g.no", "bievat.no", "biev\xE1t.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjark\xF8y.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bod\xF8.no", "bokn.no", "bomlo.no", "b\xF8mlo.no", "bremanger.no", "bronnoy.no", "br\xF8nn\xF8y.no", "budejju.no", "nes.buskerud.no", "bygland.no", "bykle.no", "cahcesuolo.no", "\u010D\xE1hcesuolo.no", "davvenjarga.no", "davvenj\xE1rga.no", "davvesiida.no", "deatnu.no", "dielddanuorri.no", "divtasvuodna.no", "divttasvuotna.no", "donna.no", "d\xF8nna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyr\xF8y.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenassi.no", "even\xE1\u0161\u0161i.no", "evenes.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fedje.no", "fet.no", "finnoy.no", "finn\xF8y.no", "fitjar.no", "fjaler.no", "fjell.no", "fla.no", "fl\xE5.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "folldal.no", "forde.no", "f\xF8rde.no", "forsand.no", "fosnes.no", "fr\xE6na.no", "frana.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "froya.no", "fr\xF8ya.no", "fuoisku.no", "fuossko.no", "fusa.no", "fyresdal.no", "gaivuotna.no", "g\xE1ivuotna.no", "galsa.no", "g\xE1ls\xE1.no", "gamvik.no", "gangaviika.no", "g\xE1\u014Bgaviika.no", "gaular.no", "gausdal.no", "giehtavuoatna.no", "gildeskal.no", "gildesk\xE5l.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gj\xF8vik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "grue.no", "gulen.no", "guovdageaidnu.no", "ha.no", "h\xE5.no", "habmer.no", "h\xE1bmer.no", "hadsel.no", "h\xE6gebostad.no", "hagebostad.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "hammarfeasta.no", "h\xE1mm\xE1rfeasta.no", "hammerfest.no", "hapmir.no", "h\xE1pmir.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "hattfjelldal.no", "haugesund.no", "os.hedmark.no", "valer.hedmark.no", "v\xE5ler.hedmark.no", "hemne.no", "hemnes.no", "hemsedal.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hob\xF8l.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holt\xE5len.no", "os.hordaland.no", "hornindal.no", "horten.no", "hoyanger.no", "h\xF8yanger.no", "hoylandet.no", "h\xF8ylandet.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "ibestad.no", "inderoy.no", "inder\xF8y.no", "iveland.no", "ivgu.no", "jevnaker.no", "jolster.no", "j\xF8lster.no", "jondal.no", "kafjord.no", "k\xE5fjord.no", "karasjohka.no", "k\xE1r\xE1\u0161johka.no", "karasjok.no", "karlsoy.no", "karmoy.no", "karm\xF8y.no", "kautokeino.no", "klabu.no", "kl\xE6bu.no", "klepp.no", "kongsberg.no", "kongsvinger.no", "kraanghke.no", "kr\xE5anghke.no", "kragero.no", "krager\xF8.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "kr\xF8dsherad.no", "kv\xE6fjord.no", "kv\xE6nangen.no", "kvafjord.no", "kvalsund.no", "kvam.no", "kvanangen.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvits\xF8y.no", "laakesvuemie.no", "l\xE6rdal.no", "lahppi.no", "l\xE1hppi.no", "lardal.no", "larvik.no", "lavagis.no", "lavangen.no", "leangaviika.no", "lea\u014Bgaviika.no", "lebesby.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "lerdal.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindas.no", "lind\xE5s.no", "lindesnes.no", "loabat.no", "loab\xE1t.no", "lodingen.no", "l\xF8dingen.no", "lom.no", "loppa.no", "lorenskog.no", "l\xF8renskog.no", "loten.no", "l\xF8ten.no", "lund.no", "lunner.no", "luroy.no", "lur\xF8y.no", "luster.no", "lyngdal.no", "lyngen.no", "malatvuopmi.no", "m\xE1latvuopmi.no", "malselv.no", "m\xE5lselv.no", "malvik.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "masoy.no", "m\xE5s\xF8y.no", "matta-varjjat.no", "m\xE1tta-v\xE1rjjat.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "mel\xF8y.no", "meraker.no", "mer\xE5ker.no", "midsund.no", "midtre-gauldal.no", "moareke.no", "mo\xE5reke.no", "modalen.no", "modum.no", "molde.no", "heroy.more-og-romsdal.no", "sande.more-og-romsdal.no", "her\xF8y.m\xF8re-og-romsdal.no", "sande.m\xF8re-og-romsdal.no", "moskenes.no", "moss.no", "mosvik.no", "muosat.no", "muos\xE1t.no", "naamesjevuemie.no", "n\xE5\xE5mesjevuemie.no", "n\xE6r\xF8y.no", "namdalseid.no", "namsos.no", "namsskogan.no", "nannestad.no", "naroy.no", "narviika.no", "narvik.no", "naustdal.no", "navuotna.no", "n\xE1vuotna.no", "nedre-eiker.no", "nesna.no", "nesodden.no", "nesseby.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "bo.nordland.no", "b\xF8.nordland.no", "heroy.nordland.no", "her\xF8y.nordland.no", "nordre-land.no", "nordreisa.no", "nore-og-uvdal.no", "notodden.no", "notteroy.no", "n\xF8tter\xF8y.no", "odda.no", "oksnes.no", "\xF8ksnes.no", "omasvuotna.no", "oppdal.no", "oppegard.no", "oppeg\xE5rd.no", "orkdal.no", "orland.no", "\xF8rland.no", "orskog.no", "\xF8rskog.no", "orsta.no", "\xF8rsta.no", "osen.no", "osteroy.no", "oster\xF8y.no", "valer.ostfold.no", "v\xE5ler.\xF8stfold.no", "ostre-toten.no", "\xF8stre-toten.no", "overhalla.no", "ovre-eiker.no", "\xF8vre-eiker.no", "oyer.no", "\xF8yer.no", "oygarden.no", "\xF8ygarden.no", "oystre-slidre.no", "\xF8ystre-slidre.no", "porsanger.no", "porsangu.no", "pors\xE1\u014Bgu.no", "porsgrunn.no", "rade.no", "r\xE5de.no", "radoy.no", "rad\xF8y.no", "r\xE6lingen.no", "rahkkeravju.no", "r\xE1hkker\xE1vju.no", "raisa.no", "r\xE1isa.no", "rakkestad.no", "ralingen.no", "rana.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennes\xF8y.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "risor.no", "ris\xF8r.no", "rissa.no", "roan.no", "rodoy.no", "r\xF8d\xF8y.no", "rollag.no", "romsa.no", "romskog.no", "r\xF8mskog.no", "roros.no", "r\xF8ros.no", "rost.no", "r\xF8st.no", "royken.no", "r\xF8yken.no", "royrvik.no", "r\xF8yrvik.no", "ruovat.no", "rygge.no", "salangen.no", "salat.no", "s\xE1lat.no", "s\xE1l\xE1t.no", "saltdal.no", "samnanger.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sand\xF8y.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "siellak.no", "sigdal.no", "siljan.no", "sirdal.no", "skanit.no", "sk\xE1nit.no", "skanland.no", "sk\xE5nland.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skierva.no", "skierv\xE1.no", "skiptvet.no", "skjak.no", "skj\xE5k.no", "skjervoy.no", "skjerv\xF8y.no", "skodje.no", "smola.no", "sm\xF8la.no", "snaase.no", "sn\xE5ase.no", "snasa.no", "sn\xE5sa.no", "snillfjord.no", "snoasa.no", "sogndal.no", "sogne.no", "s\xF8gne.no", "sokndal.no", "sola.no", "solund.no", "somna.no", "s\xF8mna.no", "sondre-land.no", "s\xF8ndre-land.no", "songdalen.no", "sor-aurdal.no", "s\xF8r-aurdal.no", "sor-fron.no", "s\xF8r-fron.no", "sor-odal.no", "s\xF8r-odal.no", "sor-varanger.no", "s\xF8r-varanger.no", "sorfold.no", "s\xF8rfold.no", "sorreisa.no", "s\xF8rreisa.no", "sortland.no", "sorum.no", "s\xF8rum.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stj\xF8rdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "tana.no", "bo.telemark.no", "b\xF8.telemark.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "tjome.no", "tj\xF8me.no", "tokke.no", "tolga.no", "tonsberg.no", "t\xF8nsberg.no", "torsken.no", "tr\xE6na.no", "trana.no", "tranoy.no", "tran\xF8y.no", "troandin.no", "trogstad.no", "tr\xF8gstad.no", "tromsa.no", "tromso.no", "troms\xF8.no", "trondheim.no", "trysil.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "tysnes.no", "tysv\xE6r.no", "tysvar.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "unjarga.no", "unj\xE1rga.no", "utsira.no", "vaapste.no", "vadso.no", "vads\xF8.no", "v\xE6r\xF8y.no", "vaga.no", "v\xE5g\xE5.no", "vagan.no", "v\xE5gan.no", "vagsoy.no", "v\xE5gs\xF8y.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vard\xF8.no", "varggat.no", "v\xE1rgg\xE1t.no", "varoy.no", "vefsn.no", "vega.no", "vegarshei.no", "veg\xE5rshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "sande.vestfold.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestv\xE5g\xF8y.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "voagat.no", "volda.no", "voss.no", "*.np", "nr", "biz.nr", "com.nr", "edu.nr", "gov.nr", "info.nr", "net.nr", "org.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "m\u0101ori.nz", "mil.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "abo.pa", "ac.pa", "com.pa", "edu.pa", "gob.pa", "ing.pa", "med.pa", "net.pa", "nom.pa", "org.pa", "sld.pa", "pe", "com.pe", "edu.pe", "gob.pe", "mil.pe", "net.pe", "nom.pe", "org.pe", "pf", "com.pf", "edu.pf", "org.pf", "*.pg", "ph", "com.ph", "edu.ph", "gov.ph", "i.ph", "mil.ph", "net.ph", "ngo.ph", "org.ph", "pk", "ac.pk", "biz.pk", "com.pk", "edu.pk", "fam.pk", "gkp.pk", "gob.pk", "gog.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "gov.pk", "net.pk", "org.pk", "web.pk", "pl", "com.pl", "net.pl", "org.pl", "agro.pl", "aid.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "media.pl", "miasta.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "griw.gov.pl", "ic.gov.pl", "is.gov.pl", "kmpsp.gov.pl", "konsulat.gov.pl", "kppsp.gov.pl", "kwp.gov.pl", "kwpsp.gov.pl", "mup.gov.pl", "mw.gov.pl", "oia.gov.pl", "oirm.gov.pl", "oke.gov.pl", "oow.gov.pl", "oschr.gov.pl", "oum.gov.pl", "pa.gov.pl", "pinb.gov.pl", "piw.gov.pl", "po.gov.pl", "pr.gov.pl", "psp.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "sdn.gov.pl", "sko.gov.pl", "so.gov.pl", "sr.gov.pl", "starostwo.gov.pl", "ug.gov.pl", "ugim.gov.pl", "um.gov.pl", "umig.gov.pl", "upow.gov.pl", "uppo.gov.pl", "us.gov.pl", "uw.gov.pl", "uzs.gov.pl", "wif.gov.pl", "wiih.gov.pl", "winb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wiw.gov.pl", "wkz.gov.pl", "wsa.gov.pl", "wskr.gov.pl", "wsse.gov.pl", "wuoz.gov.pl", "wzmiuw.gov.pl", "zp.gov.pl", "zpisdn.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kazimierz-dolny.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorskie.pl", "pomorze.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "skoczow.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "co.pn", "edu.pn", "gov.pn", "net.pn", "org.pn", "post", "pr", "biz.pr", "com.pr", "edu.pr", "gov.pr", "info.pr", "isla.pr", "name.pr", "net.pr", "org.pr", "pro.pr", "ac.pr", "est.pr", "prof.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "com.ps", "edu.ps", "gov.ps", "net.ps", "org.ps", "plo.ps", "sec.ps", "pt", "com.pt", "edu.pt", "gov.pt", "int.pt", "net.pt", "nome.pt", "org.pt", "publ.pt", "pw", "belau.pw", "co.pw", "ed.pw", "go.pw", "or.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "edu.sa", "gov.sa", "med.sa", "net.sa", "org.sa", "pub.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "edu.sc", "gov.sc", "net.sc", "org.sc", "sd", "com.sd", "edu.sd", "gov.sd", "info.sd", "med.sd", "net.sd", "org.sd", "tv.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "edu.sg", "gov.sg", "net.sg", "org.sg", "sh", "com.sh", "gov.sh", "mil.sh", "net.sh", "org.sh", "si", "sj", "sk", "sl", "com.sl", "edu.sl", "gov.sl", "net.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "edu.so", "gov.so", "me.so", "net.so", "org.so", "sr", "ss", "biz.ss", "co.ss", "com.ss", "edu.ss", "gov.ss", "me.ss", "net.ss", "org.ss", "sch.ss", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "com.sy", "edu.sy", "gov.sy", "mil.sy", "net.sy", "org.sy", "sz", "ac.sz", "co.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "co.tm", "com.tm", "edu.tm", "gov.tm", "mil.tm", "net.tm", "nom.tm", "org.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "info.tn", "intl.tn", "mincom.tn", "nat.tn", "net.tn", "org.tn", "perso.tn", "tourism.tn", "to", "com.to", "edu.to", "gov.to", "mil.to", "net.to", "org.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "k12.tr", "kep.tr", "mil.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "biz.tt", "co.tt", "com.tt", "edu.tt", "gov.tt", "info.tt", "mil.tt", "name.tt", "net.tt", "org.tt", "pro.tt", "tv", "tw", "club.tw", "com.tw", "ebiz.tw", "edu.tw", "game.tw", "gov.tw", "idv.tw", "mil.tw", "net.tw", "org.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "kropyvnytskyi.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "luhansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "uzhhorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zakarpattia.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "ac.ug", "co.ug", "com.ug", "go.ug", "ne.ug", "or.ug", "org.ug", "sc.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "va.us", "vi.us", "vt.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.va.us", "k12.vi.us", "k12.vt.us", "k12.wa.us", "k12.wi.us", "cc.ak.us", "lib.ak.us", "cc.al.us", "lib.al.us", "cc.ar.us", "lib.ar.us", "cc.as.us", "lib.as.us", "cc.az.us", "lib.az.us", "cc.ca.us", "lib.ca.us", "cc.co.us", "lib.co.us", "cc.ct.us", "lib.ct.us", "cc.dc.us", "lib.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.va.us", "cc.vi.us", "cc.vt.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "k12.wy.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.va.us", "lib.vi.us", "lib.vt.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "pvt.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "edu.vc", "gov.vc", "mil.vc", "net.vc", "org.vc", "ve", "arts.ve", "bib.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "nom.ve", "org.ve", "rar.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "ac.vn", "ai.vn", "biz.vn", "com.vn", "edu.vn", "gov.vn", "health.vn", "id.vn", "info.vn", "int.vn", "io.vn", "name.vn", "net.vn", "org.vn", "pro.vn", "angiang.vn", "bacgiang.vn", "backan.vn", "baclieu.vn", "bacninh.vn", "baria-vungtau.vn", "bentre.vn", "binhdinh.vn", "binhduong.vn", "binhphuoc.vn", "binhthuan.vn", "camau.vn", "cantho.vn", "caobang.vn", "daklak.vn", "daknong.vn", "danang.vn", "dienbien.vn", "dongnai.vn", "dongthap.vn", "gialai.vn", "hagiang.vn", "haiduong.vn", "haiphong.vn", "hanam.vn", "hanoi.vn", "hatinh.vn", "haugiang.vn", "hoabinh.vn", "hungyen.vn", "khanhhoa.vn", "kiengiang.vn", "kontum.vn", "laichau.vn", "lamdong.vn", "langson.vn", "laocai.vn", "longan.vn", "namdinh.vn", "nghean.vn", "ninhbinh.vn", "ninhthuan.vn", "phutho.vn", "phuyen.vn", "quangbinh.vn", "quangnam.vn", "quangngai.vn", "quangninh.vn", "quangtri.vn", "soctrang.vn", "sonla.vn", "tayninh.vn", "thaibinh.vn", "thainguyen.vn", "thanhhoa.vn", "thanhphohochiminh.vn", "thuathienhue.vn", "tiengiang.vn", "travinh.vn", "tuyenquang.vn", "vinhlong.vn", "vinhphuc.vn", "yenbai.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "edu.ws", "gov.ws", "net.ws", "org.ws", "yt", "\u0627\u0645\u0627\u0631\u0627\u062A", "\u0570\u0561\u0575", "\u09AC\u09BE\u0982\u09B2\u09BE", "\u0431\u0433", "\u0627\u0644\u0628\u062D\u0631\u064A\u0646", "\u0431\u0435\u043B", "\u4E2D\u56FD", "\u4E2D\u570B", "\u0627\u0644\u062C\u0632\u0627\u0626\u0631", "\u0645\u0635\u0631", "\u0435\u044E", "\u03B5\u03C5", "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627", "\u10D2\u10D4", "\u03B5\u03BB", "\u9999\u6E2F", "\u500B\u4EBA.\u9999\u6E2F", "\u516C\u53F8.\u9999\u6E2F", "\u653F\u5E9C.\u9999\u6E2F", "\u6559\u80B2.\u9999\u6E2F", "\u7D44\u7E54.\u9999\u6E2F", "\u7DB2\u7D61.\u9999\u6E2F", "\u0CAD\u0CBE\u0CB0\u0CA4", "\u0B2D\u0B3E\u0B30\u0B24", "\u09AD\u09BE\u09F0\u09A4", "\u092D\u093E\u0930\u0924\u092E\u094D", "\u092D\u093E\u0930\u094B\u0924", "\u0680\u0627\u0631\u062A", "\u0D2D\u0D3E\u0D30\u0D24\u0D02", "\u092D\u093E\u0930\u0924", "\u0628\u0627\u0631\u062A", "\u0628\u06BE\u0627\u0631\u062A", "\u0C2D\u0C3E\u0C30\u0C24\u0C4D", "\u0AAD\u0ABE\u0AB0\u0AA4", "\u0A2D\u0A3E\u0A30\u0A24", "\u09AD\u09BE\u09B0\u09A4", "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE", "\u0627\u06CC\u0631\u0627\u0646", "\u0627\u064A\u0631\u0627\u0646", "\u0639\u0631\u0627\u0642", "\u0627\u0644\u0627\u0631\u062F\u0646", "\uD55C\uAD6D", "\u049B\u0430\u0437", "\u0EA5\u0EB2\u0EA7", "\u0DBD\u0D82\u0D9A\u0DCF", "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8", "\u0627\u0644\u0645\u063A\u0631\u0628", "\u043C\u043A\u0434", "\u043C\u043E\u043D", "\u6FB3\u9580", "\u6FB3\u95E8", "\u0645\u0644\u064A\u0633\u064A\u0627", "\u0639\u0645\u0627\u0646", "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646", "\u067E\u0627\u0643\u0633\u062A\u0627\u0646", "\u0641\u0644\u0633\u0637\u064A\u0646", "\u0441\u0440\u0431", "\u0430\u043A.\u0441\u0440\u0431", "\u043E\u0431\u0440.\u0441\u0440\u0431", "\u043E\u0434.\u0441\u0440\u0431", "\u043E\u0440\u0433.\u0441\u0440\u0431", "\u043F\u0440.\u0441\u0440\u0431", "\u0443\u043F\u0440.\u0441\u0440\u0431", "\u0440\u0444", "\u0642\u0637\u0631", "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629", "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u0629", "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u06C3", "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0647", "\u0633\u0648\u062F\u0627\u0646", "\u65B0\u52A0\u5761", "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD", "\u0633\u0648\u0631\u064A\u0629", "\u0633\u0648\u0631\u064A\u0627", "\u0E44\u0E17\u0E22", "\u0E17\u0E2B\u0E32\u0E23.\u0E44\u0E17\u0E22", "\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08.\u0E44\u0E17\u0E22", "\u0E40\u0E19\u0E47\u0E15.\u0E44\u0E17\u0E22", "\u0E23\u0E31\u0E10\u0E1A\u0E32\u0E25.\u0E44\u0E17\u0E22", "\u0E28\u0E36\u0E01\u0E29\u0E32.\u0E44\u0E17\u0E22", "\u0E2D\u0E07\u0E04\u0E4C\u0E01\u0E23.\u0E44\u0E17\u0E22", "\u062A\u0648\u0646\u0633", "\u53F0\u7063", "\u53F0\u6E7E", "\u81FA\u7063", "\u0443\u043A\u0440", "\u0627\u0644\u064A\u0645\u0646", "xxx", "ye", "com.ye", "edu.ye", "gov.ye", "mil.ye", "net.ye", "org.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nic.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ads", "adult", "aeg", "aetna", "afl", "africa", "agakhan", "agency", "aig", "airbus", "airforce", "airtel", "akdn", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "aws", "axa", "azure", "baby", "baidu", "banamex", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cool", "corsica", "country", "coupon", "coupons", "courses", "cpa", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cuisinella", "cymru", "cyou", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "international", "intuit", "investments", "ipiranga", "irish", "ismaili", "ist", "istanbul", "itau", "itv", "jaguar", "java", "jcb", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kids", "kim", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "lamborghini", "lamer", "lancaster", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "link", "lipsy", "live", "living", "llc", "llp", "loan", "loans", "locker", "locus", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "luxe", "luxury", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merck", "merckmsd", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "msd", "mtn", "mtr", "music", "nab", "nagoya", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "ollo", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "racing", "radio", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "srl", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiss", "sydney", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vodka", "volvo", "vote", "voting", "voto", "voyage", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xihuan", "xin", "\u0915\u0949\u092E", "\u30BB\u30FC\u30EB", "\u4F5B\u5C71", "\u6148\u5584", "\u96C6\u56E2", "\u5728\u7EBF", "\u70B9\u770B", "\u0E04\u0E2D\u0E21", "\u516B\u5366", "\u0645\u0648\u0642\u0639", "\u516C\u76CA", "\u516C\u53F8", "\u9999\u683C\u91CC\u62C9", "\u7F51\u7AD9", "\u79FB\u52A8", "\u6211\u7231\u4F60", "\u043C\u043E\u0441\u043A\u0432\u0430", "\u043A\u0430\u0442\u043E\u043B\u0438\u043A", "\u043E\u043D\u043B\u0430\u0439\u043D", "\u0441\u0430\u0439\u0442", "\u8054\u901A", "\u05E7\u05D5\u05DD", "\u65F6\u5C1A", "\u5FAE\u535A", "\u6DE1\u9A6C\u9521", "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3", "\u043E\u0440\u0433", "\u0928\u0947\u091F", "\u30B9\u30C8\u30A2", "\u30A2\u30DE\u30BE\u30F3", "\uC0BC\uC131", "\u5546\u6807", "\u5546\u5E97", "\u5546\u57CE", "\u0434\u0435\u0442\u0438", "\u30DD\u30A4\u30F3\u30C8", "\u65B0\u95FB", "\u5BB6\u96FB", "\u0643\u0648\u0645", "\u4E2D\u6587\u7F51", "\u4E2D\u4FE1", "\u5A31\u4E50", "\u8C37\u6B4C", "\u96FB\u8A0A\u76C8\u79D1", "\u8D2D\u7269", "\u30AF\u30E9\u30A6\u30C9", "\u901A\u8CA9", "\u7F51\u5E97", "\u0938\u0902\u0917\u0920\u0928", "\u9910\u5385", "\u7F51\u7EDC", "\u043A\u043E\u043C", "\u4E9A\u9A6C\u900A", "\u98DF\u54C1", "\u98DE\u5229\u6D66", "\u624B\u673A", "\u0627\u0631\u0627\u0645\u0643\u0648", "\u0627\u0644\u0639\u0644\u064A\u0627\u0646", "\u0628\u0627\u0632\u0627\u0631", "\u0627\u0628\u0648\u0638\u0628\u064A", "\u0643\u0627\u062B\u0648\u0644\u064A\u0643", "\u0647\u0645\u0631\u0627\u0647", "\uB2F7\uCEF4", "\u653F\u5E9C", "\u0634\u0628\u0643\u0629", "\u0628\u064A\u062A\u0643", "\u0639\u0631\u0628", "\u673A\u6784", "\u7EC4\u7EC7\u673A\u6784", "\u5065\u5EB7", "\u62DB\u8058", "\u0440\u0443\u0441", "\u5927\u62FF", "\u307F\u3093\u306A", "\u30B0\u30FC\u30B0\u30EB", "\u4E16\u754C", "\u66F8\u7C4D", "\u7F51\u5740", "\uB2F7\uB137", "\u30B3\u30E0", "\u5929\u4E3B\u6559", "\u6E38\u620F", "verm\xF6gensberater", "verm\xF6gensberatung", "\u4F01\u4E1A", "\u4FE1\u606F", "\u5609\u91CC\u5927\u9152\u5E97", "\u5609\u91CC", "\u5E7F\u4E1C", "\u653F\u52A1", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "co.krd", "edu.krd", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "lib.de.us", "12chars.dev", "12chars.it", "12chars.pro", "cc.ua", "inf.ua", "ltd.ua", "611.to", "a2hosted.com", "cpserver.com", "aaa.vodka", "*.on-acorn.io", "activetrail.biz", "adaptable.app", "adobeaemcloud.com", "*.dev.adobeaemcloud.com", "aem.live", "hlx.live", "adobeaemcloud.net", "aem.page", "hlx.page", "hlx3.page", "adobeio-static.net", "adobeioruntime.net", "africa.com", "beep.pl", "airkitapps.com", "airkitapps-au.com", "airkitapps.eu", "aivencloud.com", "akadns.net", "akamai.net", "akamai-staging.net", "akamaiedge.net", "akamaiedge-staging.net", "akamaihd.net", "akamaihd-staging.net", "akamaiorigin.net", "akamaiorigin-staging.net", "akamaized.net", "akamaized-staging.net", "edgekey.net", "edgekey-staging.net", "edgesuite.net", "edgesuite-staging.net", "barsy.ca", "*.compute.estate", "*.alces.network", "kasserver.com", "altervista.org", "alwaysdata.net", "myamaze.net", "execute-api.cn-north-1.amazonaws.com.cn", "execute-api.cn-northwest-1.amazonaws.com.cn", "execute-api.af-south-1.amazonaws.com", "execute-api.ap-east-1.amazonaws.com", "execute-api.ap-northeast-1.amazonaws.com", "execute-api.ap-northeast-2.amazonaws.com", "execute-api.ap-northeast-3.amazonaws.com", "execute-api.ap-south-1.amazonaws.com", "execute-api.ap-south-2.amazonaws.com", "execute-api.ap-southeast-1.amazonaws.com", "execute-api.ap-southeast-2.amazonaws.com", "execute-api.ap-southeast-3.amazonaws.com", "execute-api.ap-southeast-4.amazonaws.com", "execute-api.ap-southeast-5.amazonaws.com", "execute-api.ca-central-1.amazonaws.com", "execute-api.ca-west-1.amazonaws.com", "execute-api.eu-central-1.amazonaws.com", "execute-api.eu-central-2.amazonaws.com", "execute-api.eu-north-1.amazonaws.com", "execute-api.eu-south-1.amazonaws.com", "execute-api.eu-south-2.amazonaws.com", "execute-api.eu-west-1.amazonaws.com", "execute-api.eu-west-2.amazonaws.com", "execute-api.eu-west-3.amazonaws.com", "execute-api.il-central-1.amazonaws.com", "execute-api.me-central-1.amazonaws.com", "execute-api.me-south-1.amazonaws.com", "execute-api.sa-east-1.amazonaws.com", "execute-api.us-east-1.amazonaws.com", "execute-api.us-east-2.amazonaws.com", "execute-api.us-gov-east-1.amazonaws.com", "execute-api.us-gov-west-1.amazonaws.com", "execute-api.us-west-1.amazonaws.com", "execute-api.us-west-2.amazonaws.com", "cloudfront.net", "auth.af-south-1.amazoncognito.com", "auth.ap-east-1.amazoncognito.com", "auth.ap-northeast-1.amazoncognito.com", "auth.ap-northeast-2.amazoncognito.com", "auth.ap-northeast-3.amazoncognito.com", "auth.ap-south-1.amazoncognito.com", "auth.ap-south-2.amazoncognito.com", "auth.ap-southeast-1.amazoncognito.com", "auth.ap-southeast-2.amazoncognito.com", "auth.ap-southeast-3.amazoncognito.com", "auth.ap-southeast-4.amazoncognito.com", "auth.ca-central-1.amazoncognito.com", "auth.ca-west-1.amazoncognito.com", "auth.eu-central-1.amazoncognito.com", "auth.eu-central-2.amazoncognito.com", "auth.eu-north-1.amazoncognito.com", "auth.eu-south-1.amazoncognito.com", "auth.eu-south-2.amazoncognito.com", "auth.eu-west-1.amazoncognito.com", "auth.eu-west-2.amazoncognito.com", "auth.eu-west-3.amazoncognito.com", "auth.il-central-1.amazoncognito.com", "auth.me-central-1.amazoncognito.com", "auth.me-south-1.amazoncognito.com", "auth.sa-east-1.amazoncognito.com", "auth.us-east-1.amazoncognito.com", "auth-fips.us-east-1.amazoncognito.com", "auth.us-east-2.amazoncognito.com", "auth-fips.us-east-2.amazoncognito.com", "auth-fips.us-gov-west-1.amazoncognito.com", "auth.us-west-1.amazoncognito.com", "auth-fips.us-west-1.amazoncognito.com", "auth.us-west-2.amazoncognito.com", "auth-fips.us-west-2.amazoncognito.com", "*.compute.amazonaws.com.cn", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "us-east-1.amazonaws.com", "emrappui-prod.cn-north-1.amazonaws.com.cn", "emrnotebooks-prod.cn-north-1.amazonaws.com.cn", "emrstudio-prod.cn-north-1.amazonaws.com.cn", "emrappui-prod.cn-northwest-1.amazonaws.com.cn", "emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn", "emrstudio-prod.cn-northwest-1.amazonaws.com.cn", "emrappui-prod.af-south-1.amazonaws.com", "emrnotebooks-prod.af-south-1.amazonaws.com", "emrstudio-prod.af-south-1.amazonaws.com", "emrappui-prod.ap-east-1.amazonaws.com", "emrnotebooks-prod.ap-east-1.amazonaws.com", "emrstudio-prod.ap-east-1.amazonaws.com", "emrappui-prod.ap-northeast-1.amazonaws.com", "emrnotebooks-prod.ap-northeast-1.amazonaws.com", "emrstudio-prod.ap-northeast-1.amazonaws.com", "emrappui-prod.ap-northeast-2.amazonaws.com", "emrnotebooks-prod.ap-northeast-2.amazonaws.com", "emrstudio-prod.ap-northeast-2.amazonaws.com", "emrappui-prod.ap-northeast-3.amazonaws.com", "emrnotebooks-prod.ap-northeast-3.amazonaws.com", "emrstudio-prod.ap-northeast-3.amazonaws.com", "emrappui-prod.ap-south-1.amazonaws.com", "emrnotebooks-prod.ap-south-1.amazonaws.com", "emrstudio-prod.ap-south-1.amazonaws.com", "emrappui-prod.ap-south-2.amazonaws.com", "emrnotebooks-prod.ap-south-2.amazonaws.com", "emrstudio-prod.ap-south-2.amazonaws.com", "emrappui-prod.ap-southeast-1.amazonaws.com", "emrnotebooks-prod.ap-southeast-1.amazonaws.com", "emrstudio-prod.ap-southeast-1.amazonaws.com", "emrappui-prod.ap-southeast-2.amazonaws.com", "emrnotebooks-prod.ap-southeast-2.amazonaws.com", "emrstudio-prod.ap-southeast-2.amazonaws.com", "emrappui-prod.ap-southeast-3.amazonaws.com", "emrnotebooks-prod.ap-southeast-3.amazonaws.com", "emrstudio-prod.ap-southeast-3.amazonaws.com", "emrappui-prod.ap-southeast-4.amazonaws.com", "emrnotebooks-prod.ap-southeast-4.amazonaws.com", "emrstudio-prod.ap-southeast-4.amazonaws.com", "emrappui-prod.ca-central-1.amazonaws.com", "emrnotebooks-prod.ca-central-1.amazonaws.com", "emrstudio-prod.ca-central-1.amazonaws.com", "emrappui-prod.ca-west-1.amazonaws.com", "emrnotebooks-prod.ca-west-1.amazonaws.com", "emrstudio-prod.ca-west-1.amazonaws.com", "emrappui-prod.eu-central-1.amazonaws.com", "emrnotebooks-prod.eu-central-1.amazonaws.com", "emrstudio-prod.eu-central-1.amazonaws.com", "emrappui-prod.eu-central-2.amazonaws.com", "emrnotebooks-prod.eu-central-2.amazonaws.com", "emrstudio-prod.eu-central-2.amazonaws.com", "emrappui-prod.eu-north-1.amazonaws.com", "emrnotebooks-prod.eu-north-1.amazonaws.com", "emrstudio-prod.eu-north-1.amazonaws.com", "emrappui-prod.eu-south-1.amazonaws.com", "emrnotebooks-prod.eu-south-1.amazonaws.com", "emrstudio-prod.eu-south-1.amazonaws.com", "emrappui-prod.eu-south-2.amazonaws.com", "emrnotebooks-prod.eu-south-2.amazonaws.com", "emrstudio-prod.eu-south-2.amazonaws.com", "emrappui-prod.eu-west-1.amazonaws.com", "emrnotebooks-prod.eu-west-1.amazonaws.com", "emrstudio-prod.eu-west-1.amazonaws.com", "emrappui-prod.eu-west-2.amazonaws.com", "emrnotebooks-prod.eu-west-2.amazonaws.com", "emrstudio-prod.eu-west-2.amazonaws.com", "emrappui-prod.eu-west-3.amazonaws.com", "emrnotebooks-prod.eu-west-3.amazonaws.com", "emrstudio-prod.eu-west-3.amazonaws.com", "emrappui-prod.il-central-1.amazonaws.com", "emrnotebooks-prod.il-central-1.amazonaws.com", "emrstudio-prod.il-central-1.amazonaws.com", "emrappui-prod.me-central-1.amazonaws.com", "emrnotebooks-prod.me-central-1.amazonaws.com", "emrstudio-prod.me-central-1.amazonaws.com", "emrappui-prod.me-south-1.amazonaws.com", "emrnotebooks-prod.me-south-1.amazonaws.com", "emrstudio-prod.me-south-1.amazonaws.com", "emrappui-prod.sa-east-1.amazonaws.com", "emrnotebooks-prod.sa-east-1.amazonaws.com", "emrstudio-prod.sa-east-1.amazonaws.com", "emrappui-prod.us-east-1.amazonaws.com", "emrnotebooks-prod.us-east-1.amazonaws.com", "emrstudio-prod.us-east-1.amazonaws.com", "emrappui-prod.us-east-2.amazonaws.com", "emrnotebooks-prod.us-east-2.amazonaws.com", "emrstudio-prod.us-east-2.amazonaws.com", "emrappui-prod.us-gov-east-1.amazonaws.com", "emrnotebooks-prod.us-gov-east-1.amazonaws.com", "emrstudio-prod.us-gov-east-1.amazonaws.com", "emrappui-prod.us-gov-west-1.amazonaws.com", "emrnotebooks-prod.us-gov-west-1.amazonaws.com", "emrstudio-prod.us-gov-west-1.amazonaws.com", "emrappui-prod.us-west-1.amazonaws.com", "emrnotebooks-prod.us-west-1.amazonaws.com", "emrstudio-prod.us-west-1.amazonaws.com", "emrappui-prod.us-west-2.amazonaws.com", "emrnotebooks-prod.us-west-2.amazonaws.com", "emrstudio-prod.us-west-2.amazonaws.com", "*.cn-north-1.airflow.amazonaws.com.cn", "*.cn-northwest-1.airflow.amazonaws.com.cn", "*.af-south-1.airflow.amazonaws.com", "*.ap-east-1.airflow.amazonaws.com", "*.ap-northeast-1.airflow.amazonaws.com", "*.ap-northeast-2.airflow.amazonaws.com", "*.ap-northeast-3.airflow.amazonaws.com", "*.ap-south-1.airflow.amazonaws.com", "*.ap-south-2.airflow.amazonaws.com", "*.ap-southeast-1.airflow.amazonaws.com", "*.ap-southeast-2.airflow.amazonaws.com", "*.ap-southeast-3.airflow.amazonaws.com", "*.ap-southeast-4.airflow.amazonaws.com", "*.ca-central-1.airflow.amazonaws.com", "*.ca-west-1.airflow.amazonaws.com", "*.eu-central-1.airflow.amazonaws.com", "*.eu-central-2.airflow.amazonaws.com", "*.eu-north-1.airflow.amazonaws.com", "*.eu-south-1.airflow.amazonaws.com", "*.eu-south-2.airflow.amazonaws.com", "*.eu-west-1.airflow.amazonaws.com", "*.eu-west-2.airflow.amazonaws.com", "*.eu-west-3.airflow.amazonaws.com", "*.il-central-1.airflow.amazonaws.com", "*.me-central-1.airflow.amazonaws.com", "*.me-south-1.airflow.amazonaws.com", "*.sa-east-1.airflow.amazonaws.com", "*.us-east-1.airflow.amazonaws.com", "*.us-east-2.airflow.amazonaws.com", "*.us-west-1.airflow.amazonaws.com", "*.us-west-2.airflow.amazonaws.com", "s3.dualstack.cn-north-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn", "s3-website.dualstack.cn-north-1.amazonaws.com.cn", "s3.cn-north-1.amazonaws.com.cn", "s3-accesspoint.cn-north-1.amazonaws.com.cn", "s3-deprecated.cn-north-1.amazonaws.com.cn", "s3-object-lambda.cn-north-1.amazonaws.com.cn", "s3-website.cn-north-1.amazonaws.com.cn", "s3.dualstack.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn", "s3.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.cn-northwest-1.amazonaws.com.cn", "s3-object-lambda.cn-northwest-1.amazonaws.com.cn", "s3-website.cn-northwest-1.amazonaws.com.cn", "s3.dualstack.af-south-1.amazonaws.com", "s3-accesspoint.dualstack.af-south-1.amazonaws.com", "s3-website.dualstack.af-south-1.amazonaws.com", "s3.af-south-1.amazonaws.com", "s3-accesspoint.af-south-1.amazonaws.com", "s3-object-lambda.af-south-1.amazonaws.com", "s3-website.af-south-1.amazonaws.com", "s3.dualstack.ap-east-1.amazonaws.com", "s3-accesspoint.dualstack.ap-east-1.amazonaws.com", "s3.ap-east-1.amazonaws.com", "s3-accesspoint.ap-east-1.amazonaws.com", "s3-object-lambda.ap-east-1.amazonaws.com", "s3-website.ap-east-1.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com", "s3-website.dualstack.ap-northeast-1.amazonaws.com", "s3.ap-northeast-1.amazonaws.com", "s3-accesspoint.ap-northeast-1.amazonaws.com", "s3-object-lambda.ap-northeast-1.amazonaws.com", "s3-website.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com", "s3-website.dualstack.ap-northeast-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3-accesspoint.ap-northeast-2.amazonaws.com", "s3-object-lambda.ap-northeast-2.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-northeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com", "s3-website.dualstack.ap-northeast-3.amazonaws.com", "s3.ap-northeast-3.amazonaws.com", "s3-accesspoint.ap-northeast-3.amazonaws.com", "s3-object-lambda.ap-northeast-3.amazonaws.com", "s3-website.ap-northeast-3.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3-accesspoint.dualstack.ap-south-1.amazonaws.com", "s3-website.dualstack.ap-south-1.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3-accesspoint.ap-south-1.amazonaws.com", "s3-object-lambda.ap-south-1.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3.dualstack.ap-south-2.amazonaws.com", "s3-accesspoint.dualstack.ap-south-2.amazonaws.com", "s3-website.dualstack.ap-south-2.amazonaws.com", "s3.ap-south-2.amazonaws.com", "s3-accesspoint.ap-south-2.amazonaws.com", "s3-object-lambda.ap-south-2.amazonaws.com", "s3-website.ap-south-2.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com", "s3-website.dualstack.ap-southeast-1.amazonaws.com", "s3.ap-southeast-1.amazonaws.com", "s3-accesspoint.ap-southeast-1.amazonaws.com", "s3-object-lambda.ap-southeast-1.amazonaws.com", "s3-website.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com", "s3-website.dualstack.ap-southeast-2.amazonaws.com", "s3.ap-southeast-2.amazonaws.com", "s3-accesspoint.ap-southeast-2.amazonaws.com", "s3-object-lambda.ap-southeast-2.amazonaws.com", "s3-website.ap-southeast-2.amazonaws.com", "s3.dualstack.ap-southeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com", "s3-website.dualstack.ap-southeast-3.amazonaws.com", "s3.ap-southeast-3.amazonaws.com", "s3-accesspoint.ap-southeast-3.amazonaws.com", "s3-object-lambda.ap-southeast-3.amazonaws.com", "s3-website.ap-southeast-3.amazonaws.com", "s3.dualstack.ap-southeast-4.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com", "s3-website.dualstack.ap-southeast-4.amazonaws.com", "s3.ap-southeast-4.amazonaws.com", "s3-accesspoint.ap-southeast-4.amazonaws.com", "s3-object-lambda.ap-southeast-4.amazonaws.com", "s3-website.ap-southeast-4.amazonaws.com", "s3.dualstack.ap-southeast-5.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com", "s3-website.dualstack.ap-southeast-5.amazonaws.com", "s3.ap-southeast-5.amazonaws.com", "s3-accesspoint.ap-southeast-5.amazonaws.com", "s3-deprecated.ap-southeast-5.amazonaws.com", "s3-object-lambda.ap-southeast-5.amazonaws.com", "s3-website.ap-southeast-5.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com", "s3-fips.dualstack.ca-central-1.amazonaws.com", "s3-website.dualstack.ca-central-1.amazonaws.com", "s3.ca-central-1.amazonaws.com", "s3-accesspoint.ca-central-1.amazonaws.com", "s3-accesspoint-fips.ca-central-1.amazonaws.com", "s3-fips.ca-central-1.amazonaws.com", "s3-object-lambda.ca-central-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com", "s3-fips.dualstack.ca-west-1.amazonaws.com", "s3-website.dualstack.ca-west-1.amazonaws.com", "s3.ca-west-1.amazonaws.com", "s3-accesspoint.ca-west-1.amazonaws.com", "s3-accesspoint-fips.ca-west-1.amazonaws.com", "s3-fips.ca-west-1.amazonaws.com", "s3-object-lambda.ca-west-1.amazonaws.com", "s3-website.ca-west-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3-accesspoint.dualstack.eu-central-1.amazonaws.com", "s3-website.dualstack.eu-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3-accesspoint.eu-central-1.amazonaws.com", "s3-object-lambda.eu-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3.dualstack.eu-central-2.amazonaws.com", "s3-accesspoint.dualstack.eu-central-2.amazonaws.com", "s3-website.dualstack.eu-central-2.amazonaws.com", "s3.eu-central-2.amazonaws.com", "s3-accesspoint.eu-central-2.amazonaws.com", "s3-object-lambda.eu-central-2.amazonaws.com", "s3-website.eu-central-2.amazonaws.com", "s3.dualstack.eu-north-1.amazonaws.com", "s3-accesspoint.dualstack.eu-north-1.amazonaws.com", "s3.eu-north-1.amazonaws.com", "s3-accesspoint.eu-north-1.amazonaws.com", "s3-object-lambda.eu-north-1.amazonaws.com", "s3-website.eu-north-1.amazonaws.com", "s3.dualstack.eu-south-1.amazonaws.com", "s3-accesspoint.dualstack.eu-south-1.amazonaws.com", "s3-website.dualstack.eu-south-1.amazonaws.com", "s3.eu-south-1.amazonaws.com", "s3-accesspoint.eu-south-1.amazonaws.com", "s3-object-lambda.eu-south-1.amazonaws.com", "s3-website.eu-south-1.amazonaws.com", "s3.dualstack.eu-south-2.amazonaws.com", "s3-accesspoint.dualstack.eu-south-2.amazonaws.com", "s3-website.dualstack.eu-south-2.amazonaws.com", "s3.eu-south-2.amazonaws.com", "s3-accesspoint.eu-south-2.amazonaws.com", "s3-object-lambda.eu-south-2.amazonaws.com", "s3-website.eu-south-2.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3-accesspoint.dualstack.eu-west-1.amazonaws.com", "s3-website.dualstack.eu-west-1.amazonaws.com", "s3.eu-west-1.amazonaws.com", "s3-accesspoint.eu-west-1.amazonaws.com", "s3-deprecated.eu-west-1.amazonaws.com", "s3-object-lambda.eu-west-1.amazonaws.com", "s3-website.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3-accesspoint.dualstack.eu-west-2.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3-accesspoint.eu-west-2.amazonaws.com", "s3-object-lambda.eu-west-2.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3-accesspoint.dualstack.eu-west-3.amazonaws.com", "s3-website.dualstack.eu-west-3.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3-accesspoint.eu-west-3.amazonaws.com", "s3-object-lambda.eu-west-3.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3.dualstack.il-central-1.amazonaws.com", "s3-accesspoint.dualstack.il-central-1.amazonaws.com", "s3-website.dualstack.il-central-1.amazonaws.com", "s3.il-central-1.amazonaws.com", "s3-accesspoint.il-central-1.amazonaws.com", "s3-object-lambda.il-central-1.amazonaws.com", "s3-website.il-central-1.amazonaws.com", "s3.dualstack.me-central-1.amazonaws.com", "s3-accesspoint.dualstack.me-central-1.amazonaws.com", "s3-website.dualstack.me-central-1.amazonaws.com", "s3.me-central-1.amazonaws.com", "s3-accesspoint.me-central-1.amazonaws.com", "s3-object-lambda.me-central-1.amazonaws.com", "s3-website.me-central-1.amazonaws.com", "s3.dualstack.me-south-1.amazonaws.com", "s3-accesspoint.dualstack.me-south-1.amazonaws.com", "s3.me-south-1.amazonaws.com", "s3-accesspoint.me-south-1.amazonaws.com", "s3-object-lambda.me-south-1.amazonaws.com", "s3-website.me-south-1.amazonaws.com", "s3.amazonaws.com", "s3-1.amazonaws.com", "s3-ap-east-1.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-northeast-3.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-north-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-east-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "mrap.accesspoint.s3-global.amazonaws.com", "s3-me-south-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-gov-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-gov-west-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3-accesspoint.dualstack.sa-east-1.amazonaws.com", "s3-website.dualstack.sa-east-1.amazonaws.com", "s3.sa-east-1.amazonaws.com", "s3-accesspoint.sa-east-1.amazonaws.com", "s3-object-lambda.sa-east-1.amazonaws.com", "s3-website.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com", "s3-fips.dualstack.us-east-1.amazonaws.com", "s3-website.dualstack.us-east-1.amazonaws.com", "s3.us-east-1.amazonaws.com", "s3-accesspoint.us-east-1.amazonaws.com", "s3-accesspoint-fips.us-east-1.amazonaws.com", "s3-deprecated.us-east-1.amazonaws.com", "s3-fips.us-east-1.amazonaws.com", "s3-object-lambda.us-east-1.amazonaws.com", "s3-website.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-accesspoint.dualstack.us-east-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com", "s3-fips.dualstack.us-east-2.amazonaws.com", "s3-website.dualstack.us-east-2.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3-accesspoint.us-east-2.amazonaws.com", "s3-accesspoint-fips.us-east-2.amazonaws.com", "s3-deprecated.us-east-2.amazonaws.com", "s3-fips.us-east-2.amazonaws.com", "s3-object-lambda.us-east-2.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "s3.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com", "s3-fips.dualstack.us-gov-east-1.amazonaws.com", "s3.us-gov-east-1.amazonaws.com", "s3-accesspoint.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.us-gov-east-1.amazonaws.com", "s3-fips.us-gov-east-1.amazonaws.com", "s3-object-lambda.us-gov-east-1.amazonaws.com", "s3-website.us-gov-east-1.amazonaws.com", "s3.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com", "s3-fips.dualstack.us-gov-west-1.amazonaws.com", "s3.us-gov-west-1.amazonaws.com", "s3-accesspoint.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.us-gov-west-1.amazonaws.com", "s3-fips.us-gov-west-1.amazonaws.com", "s3-object-lambda.us-gov-west-1.amazonaws.com", "s3-website.us-gov-west-1.amazonaws.com", "s3.dualstack.us-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com", "s3-fips.dualstack.us-west-1.amazonaws.com", "s3-website.dualstack.us-west-1.amazonaws.com", "s3.us-west-1.amazonaws.com", "s3-accesspoint.us-west-1.amazonaws.com", "s3-accesspoint-fips.us-west-1.amazonaws.com", "s3-fips.us-west-1.amazonaws.com", "s3-object-lambda.us-west-1.amazonaws.com", "s3-website.us-west-1.amazonaws.com", "s3.dualstack.us-west-2.amazonaws.com", "s3-accesspoint.dualstack.us-west-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com", "s3-fips.dualstack.us-west-2.amazonaws.com", "s3-website.dualstack.us-west-2.amazonaws.com", "s3.us-west-2.amazonaws.com", "s3-accesspoint.us-west-2.amazonaws.com", "s3-accesspoint-fips.us-west-2.amazonaws.com", "s3-deprecated.us-west-2.amazonaws.com", "s3-fips.us-west-2.amazonaws.com", "s3-object-lambda.us-west-2.amazonaws.com", "s3-website.us-west-2.amazonaws.com", "labeling.ap-northeast-1.sagemaker.aws", "labeling.ap-northeast-2.sagemaker.aws", "labeling.ap-south-1.sagemaker.aws", "labeling.ap-southeast-1.sagemaker.aws", "labeling.ap-southeast-2.sagemaker.aws", "labeling.ca-central-1.sagemaker.aws", "labeling.eu-central-1.sagemaker.aws", "labeling.eu-west-1.sagemaker.aws", "labeling.eu-west-2.sagemaker.aws", "labeling.us-east-1.sagemaker.aws", "labeling.us-east-2.sagemaker.aws", "labeling.us-west-2.sagemaker.aws", "notebook.af-south-1.sagemaker.aws", "notebook.ap-east-1.sagemaker.aws", "notebook.ap-northeast-1.sagemaker.aws", "notebook.ap-northeast-2.sagemaker.aws", "notebook.ap-northeast-3.sagemaker.aws", "notebook.ap-south-1.sagemaker.aws", "notebook.ap-south-2.sagemaker.aws", "notebook.ap-southeast-1.sagemaker.aws", "notebook.ap-southeast-2.sagemaker.aws", "notebook.ap-southeast-3.sagemaker.aws", "notebook.ap-southeast-4.sagemaker.aws", "notebook.ca-central-1.sagemaker.aws", "notebook-fips.ca-central-1.sagemaker.aws", "notebook.ca-west-1.sagemaker.aws", "notebook-fips.ca-west-1.sagemaker.aws", "notebook.eu-central-1.sagemaker.aws", "notebook.eu-central-2.sagemaker.aws", "notebook.eu-north-1.sagemaker.aws", "notebook.eu-south-1.sagemaker.aws", "notebook.eu-south-2.sagemaker.aws", "notebook.eu-west-1.sagemaker.aws", "notebook.eu-west-2.sagemaker.aws", "notebook.eu-west-3.sagemaker.aws", "notebook.il-central-1.sagemaker.aws", "notebook.me-central-1.sagemaker.aws", "notebook.me-south-1.sagemaker.aws", "notebook.sa-east-1.sagemaker.aws", "notebook.us-east-1.sagemaker.aws", "notebook-fips.us-east-1.sagemaker.aws", "notebook.us-east-2.sagemaker.aws", "notebook-fips.us-east-2.sagemaker.aws", "notebook.us-gov-east-1.sagemaker.aws", "notebook-fips.us-gov-east-1.sagemaker.aws", "notebook.us-gov-west-1.sagemaker.aws", "notebook-fips.us-gov-west-1.sagemaker.aws", "notebook.us-west-1.sagemaker.aws", "notebook-fips.us-west-1.sagemaker.aws", "notebook.us-west-2.sagemaker.aws", "notebook-fips.us-west-2.sagemaker.aws", "notebook.cn-north-1.sagemaker.com.cn", "notebook.cn-northwest-1.sagemaker.com.cn", "studio.af-south-1.sagemaker.aws", "studio.ap-east-1.sagemaker.aws", "studio.ap-northeast-1.sagemaker.aws", "studio.ap-northeast-2.sagemaker.aws", "studio.ap-northeast-3.sagemaker.aws", "studio.ap-south-1.sagemaker.aws", "studio.ap-southeast-1.sagemaker.aws", "studio.ap-southeast-2.sagemaker.aws", "studio.ap-southeast-3.sagemaker.aws", "studio.ca-central-1.sagemaker.aws", "studio.eu-central-1.sagemaker.aws", "studio.eu-north-1.sagemaker.aws", "studio.eu-south-1.sagemaker.aws", "studio.eu-south-2.sagemaker.aws", "studio.eu-west-1.sagemaker.aws", "studio.eu-west-2.sagemaker.aws", "studio.eu-west-3.sagemaker.aws", "studio.il-central-1.sagemaker.aws", "studio.me-central-1.sagemaker.aws", "studio.me-south-1.sagemaker.aws", "studio.sa-east-1.sagemaker.aws", "studio.us-east-1.sagemaker.aws", "studio.us-east-2.sagemaker.aws", "studio.us-gov-east-1.sagemaker.aws", "studio-fips.us-gov-east-1.sagemaker.aws", "studio.us-gov-west-1.sagemaker.aws", "studio-fips.us-gov-west-1.sagemaker.aws", "studio.us-west-1.sagemaker.aws", "studio.us-west-2.sagemaker.aws", "studio.cn-north-1.sagemaker.com.cn", "studio.cn-northwest-1.sagemaker.com.cn", "*.experiments.sagemaker.aws", "analytics-gateway.ap-northeast-1.amazonaws.com", "analytics-gateway.ap-northeast-2.amazonaws.com", "analytics-gateway.ap-south-1.amazonaws.com", "analytics-gateway.ap-southeast-1.amazonaws.com", "analytics-gateway.ap-southeast-2.amazonaws.com", "analytics-gateway.eu-central-1.amazonaws.com", "analytics-gateway.eu-west-1.amazonaws.com", "analytics-gateway.us-east-1.amazonaws.com", "analytics-gateway.us-east-2.amazonaws.com", "analytics-gateway.us-west-2.amazonaws.com", "amplifyapp.com", "*.awsapprunner.com", "webview-assets.aws-cloud9.af-south-1.amazonaws.com", "vfs.cloud9.af-south-1.amazonaws.com", "webview-assets.cloud9.af-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-east-1.amazonaws.com", "vfs.cloud9.ap-east-1.amazonaws.com", "webview-assets.cloud9.ap-east-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com", "vfs.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com", "vfs.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com", "vfs.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.aws-cloud9.ap-south-1.amazonaws.com", "vfs.cloud9.ap-south-1.amazonaws.com", "webview-assets.cloud9.ap-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com", "vfs.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com", "vfs.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.aws-cloud9.ca-central-1.amazonaws.com", "vfs.cloud9.ca-central-1.amazonaws.com", "webview-assets.cloud9.ca-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-central-1.amazonaws.com", "vfs.cloud9.eu-central-1.amazonaws.com", "webview-assets.cloud9.eu-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-north-1.amazonaws.com", "vfs.cloud9.eu-north-1.amazonaws.com", "webview-assets.cloud9.eu-north-1.amazonaws.com", "webview-assets.aws-cloud9.eu-south-1.amazonaws.com", "vfs.cloud9.eu-south-1.amazonaws.com", "webview-assets.cloud9.eu-south-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-1.amazonaws.com", "vfs.cloud9.eu-west-1.amazonaws.com", "webview-assets.cloud9.eu-west-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-2.amazonaws.com", "vfs.cloud9.eu-west-2.amazonaws.com", "webview-assets.cloud9.eu-west-2.amazonaws.com", "webview-assets.aws-cloud9.eu-west-3.amazonaws.com", "vfs.cloud9.eu-west-3.amazonaws.com", "webview-assets.cloud9.eu-west-3.amazonaws.com", "webview-assets.aws-cloud9.il-central-1.amazonaws.com", "vfs.cloud9.il-central-1.amazonaws.com", "webview-assets.aws-cloud9.me-south-1.amazonaws.com", "vfs.cloud9.me-south-1.amazonaws.com", "webview-assets.cloud9.me-south-1.amazonaws.com", "webview-assets.aws-cloud9.sa-east-1.amazonaws.com", "vfs.cloud9.sa-east-1.amazonaws.com", "webview-assets.cloud9.sa-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-1.amazonaws.com", "vfs.cloud9.us-east-1.amazonaws.com", "webview-assets.cloud9.us-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-2.amazonaws.com", "vfs.cloud9.us-east-2.amazonaws.com", "webview-assets.cloud9.us-east-2.amazonaws.com", "webview-assets.aws-cloud9.us-west-1.amazonaws.com", "vfs.cloud9.us-west-1.amazonaws.com", "webview-assets.cloud9.us-west-1.amazonaws.com", "webview-assets.aws-cloud9.us-west-2.amazonaws.com", "vfs.cloud9.us-west-2.amazonaws.com", "webview-assets.cloud9.us-west-2.amazonaws.com", "awsapps.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "af-south-1.elasticbeanstalk.com", "ap-east-1.elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ap-southeast-3.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-north-1.elasticbeanstalk.com", "eu-south-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "il-central-1.elasticbeanstalk.com", "me-south-1.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-east-1.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com.cn", "*.elb.amazonaws.com", "awsglobalaccelerator.com", "*.private.repost.aws", "eero.online", "eero-stage.online", "apigee.io", "panel.dev", "siiites.com", "appspacehosted.com", "appspaceusercontent.com", "appudo.net", "on-aptible.com", "f5.si", "arvanedge.ir", "user.aseinet.ne.jp", "gv.vc", "d.gv.vc", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "cdn.prod.atlassian-dev.net", "translated.page", "myfritz.link", "myfritz.net", "onavstack.net", "*.awdev.ca", "*.advisor.ws", "ecommerce-shop.pl", "b-data.io", "balena-devices.com", "base.ec", "official.ec", "buyshop.jp", "fashionstore.jp", "handcrafted.jp", "kawaiishop.jp", "supersale.jp", "theshop.jp", "shopselect.net", "base.shop", "beagleboard.io", "*.beget.app", "pages.gay", "bnr.la", "bitbucket.io", "blackbaudcdn.net", "of.je", "bluebite.io", "boomla.net", "boutir.com", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "*.s.brave.io", "shop.brendly.hr", "shop.brendly.rs", "browsersafetymark.io", "radio.am", "radio.fm", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "cafjs.com", "canva-apps.cn", "*.my.canvasite.cn", "canva-apps.com", "*.my.canva.site", "drr.ac", "uwu.ai", "carrd.co", "crd.co", "ju.mp", "api.gov.uk", "cdn77-storage.com", "rsc.contentproxy9.cz", "r.cdn77.net", "cdn77-ssl.net", "c.cdn77.org", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "za.bz", "br.com", "cn.com", "de.com", "eu.com", "jpn.com", "mex.com", "ru.com", "sa.com", "uk.com", "us.com", "za.com", "com.de", "gb.net", "hu.net", "jp.net", "se.net", "uk.net", "ae.org", "com.se", "cx.ua", "discourse.group", "discourse.team", "clerk.app", "clerkstage.app", "*.lcl.dev", "*.lclstage.dev", "*.stg.dev", "*.stgstage.dev", "cleverapps.cc", "*.services.clever-cloud.com", "cleverapps.io", "cleverapps.tech", "clickrising.net", "cloudns.asia", "cloudns.be", "cloud-ip.biz", "cloudns.biz", "cloudns.cc", "cloudns.ch", "cloudns.cl", "cloudns.club", "dnsabr.com", "ip-ddns.com", "cloudns.cx", "cloudns.eu", "cloudns.in", "cloudns.info", "ddns-ip.net", "dns-cloud.net", "dns-dynamic.net", "cloudns.nz", "cloudns.org", "ip-dynamic.org", "cloudns.ph", "cloudns.pro", "cloudns.pw", "cloudns.us", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "*.cloudera.site", "cf-ipfs.com", "cloudflare-ipfs.com", "trycloudflare.com", "pages.dev", "r2.dev", "workers.dev", "cloudflare.net", "cdn.cloudflare.net", "cdn.cloudflareanycast.net", "cdn.cloudflarecn.net", "cdn.cloudflareglobal.net", "cust.cloudscale.ch", "objects.lpg.cloudscale.ch", "objects.rma.cloudscale.ch", "wnext.app", "cnpy.gdn", "*.otap.co", "co.ca", "co.com", "codeberg.page", "csb.app", "preview.csb.app", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "ctfcloud.net", "convex.site", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "dyn.cosidns.de", "dnsupdater.de", "dynamisches-dns.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "craft.me", "realm.cz", "on.crisp.email", "*.cryptonomic.net", "curv.dev", "cfolks.pl", "cyon.link", "cyon.site", "platform0.app", "fnwk.site", "folionetwork.site", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "dyndns.dappnode.io", "builtwithdark.com", "darklang.io", "demo.datadetect.com", "instance.datadetect.com", "edgestack.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyn-ip24.de", "dyndns1.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "debian.net", "definima.io", "definima.net", "deno.dev", "deno-staging.dev", "dedyn.io", "deta.app", "deta.dev", "dfirma.pl", "dkonto.pl", "you2.pl", "ondigitalocean.app", "*.digitaloceanspaces.com", "us.kg", "rss.my.id", "diher.solutions", "discordsays.com", "discordsez.com", "jozi.biz", "dnshome.de", "online.th", "shop.th", "drayddns.com", "shoparena.pl", "dreamhosters.com", "durumis.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "dy.fi", "tunk.org", "dyndns.biz", "for-better.biz", "for-more.biz", "for-some.biz", "for-the.biz", "selfip.biz", "webhop.biz", "ftpaccess.cc", "game-server.cc", "myphotos.cc", "scrapping.cc", "blogdns.com", "cechire.com", "dnsalias.com", "dnsdojo.com", "doesntexist.com", "dontexist.com", "doomdns.com", "dyn-o-saur.com", "dynalias.com", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "from-ak.com", "from-al.com", "from-ar.com", "from-ca.com", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-ma.com", "from-md.com", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "getmyip.com", "gotdns.com", "hobby-site.com", "homelinux.com", "homeunix.com", "iamallama.com", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bulls-fan.com", "is-a-caterer.com", "is-a-chef.com", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-certified.com", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-not-certified.com", "is-slick.com", "is-uberleet.com", "is-with-theband.com", "isa-geek.com", "isa-hockeynut.com", "issmarterthanyou.com", "likes-pie.com", "likescandy.com", "neat-url.com", "saves-the-whales.com", "selfip.com", "sells-for-less.com", "sells-for-u.com", "servebbs.com", "simple-url.com", "space-to-rent.com", "teaches-yoga.com", "writesthisblog.com", "ath.cx", "fuettertdasnetz.de", "isteingeek.de", "istmein.de", "lebtimnetz.de", "leitungsen.de", "traeumtgerade.de", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "dyndns.info", "for-our.info", "groks-the.info", "groks-this.info", "here-for-more.info", "knowsitall.info", "selfip.info", "webhop.info", "forgot.her.name", "forgot.his.name", "at-band-camp.net", "blogdns.net", "broke-it.net", "buyshouses.net", "dnsalias.net", "dnsdojo.net", "does-it.net", "dontexist.net", "dynalias.net", "dynathome.net", "endofinternet.net", "from-az.net", "from-co.net", "from-la.net", "from-ny.net", "gets-it.net", "ham-radio-op.net", "homeftp.net", "homeip.net", "homelinux.net", "homeunix.net", "in-the-band.net", "is-a-chef.net", "is-a-geek.net", "isa-geek.net", "kicks-ass.net", "office-on-the.net", "podzone.net", "scrapper-site.net", "selfip.net", "sells-it.net", "servebbs.net", "serveftp.net", "thruhere.net", "webhop.net", "merseine.nu", "mine.nu", "shacknet.nu", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "dnsalias.org", "dnsdojo.org", "doesntexist.org", "dontexist.org", "doomdns.org", "dvrdns.org", "dynalias.org", "dyndns.org", "go.dyndns.org", "home.dyndns.org", "endofinternet.org", "endoftheinternet.org", "from-me.org", "game-host.org", "gotdns.org", "hobby-site.org", "homedns.org", "homeftp.org", "homelinux.org", "homeunix.org", "is-a-bruinsfan.org", "is-a-candidate.org", "is-a-celticsfan.org", "is-a-chef.org", "is-a-geek.org", "is-a-knight.org", "is-a-linux-user.org", "is-a-patsfan.org", "is-a-soxfan.org", "is-found.org", "is-lost.org", "is-saved.org", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "isa-geek.org", "kicks-ass.org", "misconfused.org", "podzone.org", "readmyblog.org", "selfip.org", "sellsyourhome.org", "servebbs.org", "serveftp.org", "servegame.org", "stuff-4-sale.org", "webhop.org", "better-than.tv", "dyndns.tv", "on-the-web.tv", "worse-than.tv", "is-by.us", "land-4-sale.us", "stuff-4-sale.us", "dyndns.ws", "mypets.ws", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "dynv6.net", "e4.cz", "easypanel.app", "easypanel.host", "*.ewp.live", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "at.emf.camp", "rt.ht", "elementor.cloud", "elementor.cool", "en-root.fr", "mytuleap.com", "tuleap-partners.com", "encr.app", "encoreapi.com", "eu.encoway.cloud", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "pl.eu.org", "pt.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eurodir.ru", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "relay.evervault.app", "relay.evervault.dev", "expo.app", "staging.expo.app", "onfabrica.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "u.channelsdvr.net", "edgecompute.app", "fastly-edge.com", "fastly-terrarium.com", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastlylb.net", "map.fastlylb.net", "*.user.fm", "fastvps-server.com", "fastvps.host", "myfast.host", "fastvps.site", "myfast.space", "conn.uk", "copro.uk", "hosp.uk", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "mydobiss.com", "fh-muenster.io", "filegear.me", "firebaseapp.com", "fldrv.com", "flutterflow.app", "fly.dev", "shw.io", "edgeapp.net", "forgeblocks.com", "id.forgerock.io", "framer.ai", "framer.app", "framercanvas.com", "framer.media", "framer.photos", "framer.website", "framer.wiki", "0e.vc", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "freemyip.com", "*.frusky.de", "wien.funkfeuer.at", "daemon.asia", "dix.asia", "mydns.bz", "0am.jp", "0g0.jp", "0j0.jp", "0t0.jp", "mydns.jp", "pgw.jp", "wjg.jp", "keyword-on.net", "live-on.net", "server-on.net", "mydns.tw", "mydns.vc", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "aliases121.com", "campaign.gov.uk", "service.gov.uk", "independent-commission.uk", "independent-inquest.uk", "independent-inquiry.uk", "independent-panel.uk", "independent-review.uk", "public-inquiry.uk", "royal-commission.uk", "gehirn.ne.jp", "usercontent.jp", "gentapps.com", "gentlentapis.com", "lab.ms", "cdn-edges.net", "localcert.net", "localhostcert.net", "gsj.bz", "githubusercontent.com", "githubpreview.dev", "github.io", "gitlab.io", "gitapp.si", "gitpage.si", "glitch.me", "nog.community", "co.ro", "shop.ro", "lolipop.io", "angry.jp", "babyblue.jp", "babymilk.jp", "backdrop.jp", "bambina.jp", "bitter.jp", "blush.jp", "boo.jp", "boy.jp", "boyfriend.jp", "but.jp", "candypop.jp", "capoo.jp", "catfood.jp", "cheap.jp", "chicappa.jp", "chillout.jp", "chips.jp", "chowder.jp", "chu.jp", "ciao.jp", "cocotte.jp", "coolblog.jp", "cranky.jp", "cutegirl.jp", "daa.jp", "deca.jp", "deci.jp", "digick.jp", "egoism.jp", "fakefur.jp", "fem.jp", "flier.jp", "floppy.jp", "fool.jp", "frenchkiss.jp", "girlfriend.jp", "girly.jp", "gloomy.jp", "gonna.jp", "greater.jp", "hacca.jp", "heavy.jp", "her.jp", "hiho.jp", "hippy.jp", "holy.jp", "hungry.jp", "icurus.jp", "itigo.jp", "jellybean.jp", "kikirara.jp", "kill.jp", "kilo.jp", "kuron.jp", "littlestar.jp", "lolipopmc.jp", "lolitapunk.jp", "lomo.jp", "lovepop.jp", "lovesick.jp", "main.jp", "mods.jp", "mond.jp", "mongolian.jp", "moo.jp", "namaste.jp", "nikita.jp", "nobushi.jp", "noor.jp", "oops.jp", "parallel.jp", "parasite.jp", "pecori.jp", "peewee.jp", "penne.jp", "pepper.jp", "perma.jp", "pigboat.jp", "pinoko.jp", "punyu.jp", "pupu.jp", "pussycat.jp", "pya.jp", "raindrop.jp", "readymade.jp", "sadist.jp", "schoolbus.jp", "secret.jp", "staba.jp", "stripper.jp", "sub.jp", "sunnyday.jp", "thick.jp", "tonkotsu.jp", "under.jp", "upper.jp", "velvet.jp", "verse.jp", "versus.jp", "vivian.jp", "watson.jp", "weblike.jp", "whitesnow.jp", "zombie.jp", "heteml.net", "graphic.design", "goip.de", "blogspot.ae", "blogspot.al", "blogspot.am", "*.hosted.app", "*.run.app", "web.app", "blogspot.com.ar", "blogspot.co.at", "blogspot.com.au", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.com.br", "blogspot.com.by", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.com.co", "*.0emm.com", "appspot.com", "*.r.appspot.com", "blogspot.com", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "withgoogle.com", "withyoutube.com", "blogspot.cv", "blogspot.com.cy", "blogspot.cz", "blogspot.de", "*.gateway.dev", "blogspot.dk", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.fi", "blogspot.fr", "cloud.goog", "translate.goog", "*.usercontent.goog", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.co.id", "blogspot.ie", "blogspot.co.il", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.co.ke", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.com.mt", "blogspot.mx", "blogspot.my", "cloudfunctions.net", "blogspot.com.ng", "blogspot.nl", "blogspot.no", "blogspot.co.nz", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.com.tr", "blogspot.tw", "blogspot.ug", "blogspot.co.uk", "blogspot.com.uy", "blogspot.vn", "blogspot.co.za", "goupile.fr", "pymnt.uk", "cloudapps.digital", "london.cloudapps.digital", "gov.nl", "grafana-dev.net", "grayjayleagues.com", "g\xFCnstigbestellen.de", "g\xFCnstigliefern.de", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "h\xE4kkinen.fi", "hrsn.dev", "hashbang.sh", "hasura.app", "hasura-app.io", "hatenablog.com", "hatenadiary.com", "hateblo.jp", "hatenablog.jp", "hatenadiary.jp", "hatenadiary.org", "pages.it.hs-heilbronn.de", "pages-research.it.hs-heilbronn.de", "heiyu.space", "helioho.st", "heliohost.us", "hepforge.org", "herokuapp.com", "herokussl.com", "heyflow.page", "heyflow.site", "ravendb.cloud", "ravendb.community", "development.run", "ravendb.run", "homesklep.pl", "*.kin.one", "*.id.pub", "*.kin.pub", "secaas.hk", "hoplix.shop", "orx.biz", "biz.gl", "biz.ng", "co.biz.ng", "dl.biz.ng", "go.biz.ng", "lg.biz.ng", "on.biz.ng", "col.ng", "firm.ng", "gen.ng", "ltd.ng", "ngo.ng", "plc.ng", "ie.ua", "hostyhosting.io", "hf.space", "static.hf.space", "hypernode.io", "iobb.net", "co.cz", "*.moonscale.io", "moonscale.net", "gr.com", "iki.fi", "ibxos.it", "iliadboxos.it", "smushcdn.com", "wphostedmail.com", "wpmucdn.com", "tempurl.host", "wpmudev.host", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-vpn.de", "in-dsl.net", "in-vpn.net", "in-dsl.org", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "na4u.ru", "apps-1and1.com", "live-website.com", "apps-1and1.net", "websitebuilder.online", "app-ionos.space", "iopsys.se", "*.dweb.link", "ipifony.net", "ir.md", "is-a-good.dev", "is-a.dev", "iservschule.de", "mein-iserv.de", "schulplattform.de", "schulserver.de", "test-iserv.de", "iserv.dev", "mel.cloudlets.com.au", "cloud.interhostsolutions.be", "alp1.ae.flow.ch", "appengine.flow.ch", "es-1.axarnet.cloud", "diadem.cloud", "vip.jelastic.cloud", "jele.cloud", "it1.eur.aruba.jenv-aruba.cloud", "it1.jenv-aruba.cloud", "keliweb.cloud", "cs.keliweb.cloud", "oxa.cloud", "tn.oxa.cloud", "uk.oxa.cloud", "primetel.cloud", "uk.primetel.cloud", "ca.reclaim.cloud", "uk.reclaim.cloud", "us.reclaim.cloud", "ch.trendhosting.cloud", "de.trendhosting.cloud", "jele.club", "dopaas.com", "paas.hosted-by-previder.com", "rag-cloud.hosteur.com", "rag-cloud-ch.hosteur.com", "jcloud.ik-server.com", "jcloud-ver-jpc.ik-server.com", "demo.jelastic.com", "paas.massivegrid.com", "jed.wafaicloud.com", "ryd.wafaicloud.com", "j.scaleforce.com.cy", "jelastic.dogado.eu", "fi.cloudplatform.fi", "demo.datacenter.fi", "paas.datacenter.fi", "jele.host", "mircloud.host", "paas.beebyte.io", "sekd1.beebyteapp.io", "jele.io", "jc.neen.it", "jcloud.kz", "cloudjiffy.net", "fra1-de.cloudjiffy.net", "west1-us.cloudjiffy.net", "jls-sto1.elastx.net", "jls-sto2.elastx.net", "jls-sto3.elastx.net", "fr-1.paas.massivegrid.net", "lon-1.paas.massivegrid.net", "lon-2.paas.massivegrid.net", "ny-1.paas.massivegrid.net", "ny-2.paas.massivegrid.net", "sg-1.paas.massivegrid.net", "jelastic.saveincloud.net", "nordeste-idc.saveincloud.net", "j.scaleforce.net", "sdscloud.pl", "unicloud.pl", "mircloud.ru", "enscaled.sg", "jele.site", "jelastic.team", "orangecloud.tn", "j.layershift.co.uk", "phx.enscaled.us", "mircloud.us", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "jotelulu.cloud", "webadorsite.com", "jouwweb.site", "*.cns.joyent.com", "*.triton.zone", "js.org", "kaas.gg", "khplay.nl", "kapsi.fi", "ezproxy.kuleuven.be", "kuleuven.cloud", "keymachine.de", "kinghost.net", "uni5.net", "knightpoint.systems", "koobin.events", "webthings.io", "krellian.net", "oya.to", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "lelux.site", "libp2p.direct", "runcontainers.dev", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "linkyard-cloud.ch", "linkyard.cloud", "members.linode.com", "*.nodebalancer.linode.com", "*.linodeobjects.com", "ip.linodeusercontent.com", "we.bs", "filegear-sg.me", "ggff.net", "*.user.localcert.dev", "lodz.pl", "pabianice.pl", "plock.pl", "sieradz.pl", "skierniewice.pl", "zgierz.pl", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "lohmus.me", "servers.run", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.club", "barsycenter.com", "barsyonline.com", "barsy.de", "barsy.dev", "barsy.eu", "barsy.gr", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsyonline.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.ro", "barsy.rs", "barsy.shop", "barsyonline.shop", "barsy.site", "barsy.store", "barsy.support", "barsy.uk", "barsy.co.uk", "barsyonline.co.uk", "*.magentosite.cloud", "hb.cldmail.ru", "matlab.cloud", "modelscape.com", "mwcloudnonprod.com", "polyspace.com", "mayfirst.info", "mayfirst.org", "mazeplay.com", "mcdir.me", "mcdir.ru", "vps.mcdir.ru", "mcpre.ru", "mediatech.by", "mediatech.dev", "hra.health", "medusajs.app", "miniserver.com", "memset.net", "messerli.app", "atmeta.com", "apps.fbsbx.com", "*.cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "*.azurecontainer.io", "azure-api.net", "azure-mobile.net", "azureedge.net", "azurefd.net", "azurestaticapps.net", "1.azurestaticapps.net", "2.azurestaticapps.net", "3.azurestaticapps.net", "4.azurestaticapps.net", "5.azurestaticapps.net", "6.azurestaticapps.net", "7.azurestaticapps.net", "centralus.azurestaticapps.net", "eastasia.azurestaticapps.net", "eastus2.azurestaticapps.net", "westeurope.azurestaticapps.net", "westus2.azurestaticapps.net", "azurewebsites.net", "cloudapp.net", "trafficmanager.net", "blob.core.windows.net", "servicebus.windows.net", "routingthecloud.com", "sn.mynetname.net", "routingthecloud.net", "routingthecloud.org", "csx.cc", "mydbserver.com", "webspaceconfig.de", "mittwald.info", "mittwaldserver.info", "typo3server.info", "project.space", "modx.dev", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "hostedpi.com", "caracal.mythic-beasts.com", "customer.mythic-beasts.com", "fentiger.mythic-beasts.com", "lynx.mythic-beasts.com", "ocelot.mythic-beasts.com", "oncilla.mythic-beasts.com", "onza.mythic-beasts.com", "sphinx.mythic-beasts.com", "vs.mythic-beasts.com", "x.mythic-beasts.com", "yali.mythic-beasts.com", "cust.retrosnub.co.uk", "ui.nabu.casa", "cloud.nospamproxy.com", "netfy.app", "netlify.app", "4u.com", "nfshost.com", "ipfs.nftstorage.link", "ngo.us", "ngrok.app", "ngrok-free.app", "ngrok.dev", "ngrok-free.dev", "ngrok.io", "ap.ngrok.io", "au.ngrok.io", "eu.ngrok.io", "in.ngrok.io", "jp.ngrok.io", "sa.ngrok.io", "us.ngrok.io", "ngrok.pizza", "ngrok.pro", "torun.pl", "nh-serv.co.uk", "nimsite.uk", "mmafan.biz", "myftp.biz", "no-ip.biz", "no-ip.ca", "fantasyleague.cc", "gotdns.ch", "3utilities.com", "blogsyte.com", "ciscofreak.com", "damnserver.com", "ddnsking.com", "ditchyourip.com", "dnsiskinky.com", "dynns.com", "geekgalaxy.com", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "myactivedirectory.com", "mysecuritycamera.com", "myvnc.com", "net-freaks.com", "onthewifi.com", "point2this.com", "quicksytes.com", "securitytactics.com", "servebeer.com", "servecounterstrike.com", "serveexchange.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "servehumour.com", "serveirc.com", "servemp3.com", "servep2p.com", "servepics.com", "servequake.com", "servesarcasm.com", "stufftoread.com", "unusualperson.com", "workisboring.com", "dvrcam.info", "ilovecollege.info", "no-ip.info", "brasilia.me", "ddns.me", "dnsfor.me", "hopto.me", "loginto.me", "noip.me", "webhop.me", "bounceme.net", "ddns.net", "eating-organic.net", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.net", "nhlfan.net", "no-ip.net", "pgafan.net", "privatizehealthinsurance.net", "redirectme.net", "serveblog.net", "serveminecraft.net", "sytes.net", "cable-modem.org", "collegefan.org", "couchpotatofries.org", "hopto.org", "mlbfan.org", "myftp.org", "mysecuritycamera.org", "nflfan.org", "no-ip.org", "read-books.org", "ufcfan.org", "zapto.org", "no-ip.co.uk", "golffan.us", "noip.us", "pointto.us", "stage.nodeart.io", "*.developer.app", "noop.app", "*.northflank.app", "*.build.run", "*.code.run", "*.database.run", "*.migration.run", "noticeable.news", "notion.site", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "myiphost.com", "forumz.info", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "nsupdate.info", "nerdpol.ovh", "nyc.mn", "prvcy.page", "obl.ong", "observablehq.cloud", "static.observableusercontent.com", "omg.lol", "cloudycluster.net", "omniwe.site", "123webseite.at", "123website.be", "simplesite.com.br", "123website.ch", "simplesite.com", "123webseite.de", "123hjemmeside.dk", "123miweb.es", "123kotisivu.fi", "123siteweb.fr", "simplesite.gr", "123homepage.it", "123website.lu", "123website.nl", "123hjemmeside.no", "service.one", "simplesite.pl", "123paginaweb.pt", "123minsida.se", "is-a-fullstack.dev", "is-cool.dev", "is-not-a.dev", "localplayer.dev", "is-local.org", "opensocial.site", "opencraft.hosting", "16-b.it", "32-b.it", "64-b.it", "orsites.com", "operaunite.com", "*.customer-oci.com", "*.oci.customer-oci.com", "*.ocp.customer-oci.com", "*.ocs.customer-oci.com", "*.oraclecloudapps.com", "*.oraclegovcloudapps.com", "*.oraclegovcloudapps.uk", "tech.orange", "can.re", "authgear-staging.com", "authgearapps.com", "skygearapp.com", "outsystemscloud.com", "*.hosting.ovh.net", "*.webpaas.ovh.net", "ownprovider.com", "own.pm", "*.owo.codes", "ox.rs", "oy.lc", "pgfog.com", "pagexl.com", "gotpantheon.com", "pantheonsite.io", "*.paywhirl.com", "*.xmit.co", "xmit.dev", "madethis.site", "srv.us", "gh.srv.us", "gl.srv.us", "lk3.ru", "mypep.link", "perspecta.cloud", "on-web.fr", "*.upsun.app", "upsunapp.com", "ent.platform.sh", "eu.platform.sh", "us.platform.sh", "*.platformsh.site", "*.tst.site", "platter-app.com", "platter-app.dev", "platterp.us", "pley.games", "onporter.run", "co.bn", "postman-echo.com", "pstmn.io", "mock.pstmn.io", "httpbin.org", "prequalifyme.today", "xen.prgmr.com", "priv.at", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "pubtls.org", "pythonanywhere.com", "eu.pythonanywhere.com", "qa2.com", "qcx.io", "*.sys.qcx.io", "myqnapcloud.cn", "alpha-myqnapcloud.com", "dev-myqnapcloud.com", "mycloudnas.com", "mynascloud.com", "myqnapcloud.com", "qoto.io", "qualifioapp.com", "ladesk.com", "qbuser.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "cloudsite.builders", "myradweb.net", "servername.us", "web.in", "in.net", "myrdbx.io", "site.rb-hosting.io", "*.on-rancher.cloud", "*.on-k3s.io", "*.on-rio.io", "ravpage.co.il", "readthedocs-hosted.com", "readthedocs.io", "rhcloud.com", "instances.spawn.cc", "onrender.com", "app.render.com", "replit.app", "id.replit.app", "firewalledreplit.co", "id.firewalledreplit.co", "repl.co", "id.repl.co", "replit.dev", "archer.replit.dev", "bones.replit.dev", "canary.replit.dev", "global.replit.dev", "hacker.replit.dev", "id.replit.dev", "janeway.replit.dev", "kim.replit.dev", "kira.replit.dev", "kirk.replit.dev", "odo.replit.dev", "paris.replit.dev", "picard.replit.dev", "pike.replit.dev", "prerelease.replit.dev", "reed.replit.dev", "riker.replit.dev", "sisko.replit.dev", "spock.replit.dev", "staging.replit.dev", "sulu.replit.dev", "tarpit.replit.dev", "teams.replit.dev", "tucker.replit.dev", "wesley.replit.dev", "worf.replit.dev", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "adimo.co.uk", "itcouldbewor.se", "aus.basketball", "nz.basketball", "git-pages.rit.edu", "rocky.page", "rub.de", "ruhr-uni-bochum.de", "io.noc.ruhr-uni-bochum.de", "\u0431\u0438\u0437.\u0440\u0443\u0441", "\u043A\u043E\u043C.\u0440\u0443\u0441", "\u043A\u0440\u044B\u043C.\u0440\u0443\u0441", "\u043C\u0438\u0440.\u0440\u0443\u0441", "\u043C\u0441\u043A.\u0440\u0443\u0441", "\u043E\u0440\u0433.\u0440\u0443\u0441", "\u0441\u0430\u043C\u0430\u0440\u0430.\u0440\u0443\u0441", "\u0441\u043E\u0447\u0438.\u0440\u0443\u0441", "\u0441\u043F\u0431.\u0440\u0443\u0441", "\u044F.\u0440\u0443\u0441", "ras.ru", "nyat.app", "180r.com", "dojin.com", "sakuratan.com", "sakuraweb.com", "x0.com", "2-d.jp", "bona.jp", "crap.jp", "daynight.jp", "eek.jp", "flop.jp", "halfmoon.jp", "jeez.jp", "matrix.jp", "mimoza.jp", "ivory.ne.jp", "mail-box.ne.jp", "mints.ne.jp", "mokuren.ne.jp", "opal.ne.jp", "sakura.ne.jp", "sumomo.ne.jp", "topaz.ne.jp", "netgamers.jp", "nyanta.jp", "o0o0.jp", "rdy.jp", "rgr.jp", "rulez.jp", "s3.isk01.sakurastorage.jp", "s3.isk02.sakurastorage.jp", "saloon.jp", "sblo.jp", "skr.jp", "tank.jp", "uh-oh.jp", "undo.jp", "rs.webaccel.jp", "user.webaccel.jp", "websozai.jp", "xii.jp", "squares.net", "jpn.org", "kirara.st", "x0.to", "from.tv", "sakura.tv", "*.builder.code.com", "*.dev-builder.code.com", "*.stg-builder.code.com", "*.001.test.code-builder-stg.platform.salesforce.com", "*.d.crm.dev", "*.w.crm.dev", "*.wa.crm.dev", "*.wb.crm.dev", "*.wc.crm.dev", "*.wd.crm.dev", "*.we.crm.dev", "*.wf.crm.dev", "sandcats.io", "logoip.com", "logoip.de", "fr-par-1.baremetal.scw.cloud", "fr-par-2.baremetal.scw.cloud", "nl-ams-1.baremetal.scw.cloud", "cockpit.fr-par.scw.cloud", "fnc.fr-par.scw.cloud", "functions.fnc.fr-par.scw.cloud", "k8s.fr-par.scw.cloud", "nodes.k8s.fr-par.scw.cloud", "s3.fr-par.scw.cloud", "s3-website.fr-par.scw.cloud", "whm.fr-par.scw.cloud", "priv.instances.scw.cloud", "pub.instances.scw.cloud", "k8s.scw.cloud", "cockpit.nl-ams.scw.cloud", "k8s.nl-ams.scw.cloud", "nodes.k8s.nl-ams.scw.cloud", "s3.nl-ams.scw.cloud", "s3-website.nl-ams.scw.cloud", "whm.nl-ams.scw.cloud", "cockpit.pl-waw.scw.cloud", "k8s.pl-waw.scw.cloud", "nodes.k8s.pl-waw.scw.cloud", "s3.pl-waw.scw.cloud", "s3-website.pl-waw.scw.cloud", "scalebook.scw.cloud", "smartlabeling.scw.cloud", "dedibox.fr", "schokokeks.net", "gov.scot", "service.gov.scot", "scrysec.com", "client.scrypted.io", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "seidat.net", "sellfy.store", "minisite.ms", "senseering.net", "servebolt.cloud", "biz.ua", "co.ua", "pp.ua", "as.sh.cn", "sheezy.games", "shiftedit.io", "myshopblocks.com", "myshopify.com", "shopitsite.com", "shopware.shop", "shopware.store", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "small-web.org", "aeroport.fr", "avocat.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "vp4.me", "*.snowflake.app", "*.privatelink.snowflake.app", "streamlit.app", "streamlitapp.com", "try-snowplow.com", "mafelo.net", "playstation-cloud.com", "srht.site", "apps.lair.io", "*.stolos.io", "spacekit.io", "ind.mom", "customer.speedpartner.de", "myspreadshop.at", "myspreadshop.com.au", "myspreadshop.be", "myspreadshop.ca", "myspreadshop.ch", "myspreadshop.com", "myspreadshop.de", "myspreadshop.dk", "myspreadshop.es", "myspreadshop.fi", "myspreadshop.fr", "myspreadshop.ie", "myspreadshop.it", "myspreadshop.net", "myspreadshop.nl", "myspreadshop.no", "myspreadshop.pl", "myspreadshop.se", "myspreadshop.co.uk", "w-corp-staticblitz.com", "w-credentialless-staticblitz.com", "w-staticblitz.com", "stackhero-network.com", "runs.onstackit.cloud", "stackit.gg", "stackit.rocks", "stackit.run", "stackit.zone", "musician.io", "novecore.site", "api.stdlib.com", "feedback.ac", "forms.ac", "assessments.cx", "calculators.cx", "funnels.cx", "paynow.cx", "quizzes.cx", "researched.cx", "tests.cx", "surveys.so", "storebase.store", "storipress.app", "storj.farm", "strapiapp.com", "media.strapiapp.com", "vps-host.net", "atl.jelastic.vps-host.net", "njs.jelastic.vps-host.net", "ric.jelastic.vps-host.net", "streak-link.com", "streaklinks.com", "streakusercontent.com", "soc.srcf.net", "user.srcf.net", "utwente.io", "temp-dns.com", "supabase.co", "supabase.in", "supabase.net", "syncloud.it", "dscloud.biz", "direct.quickconnect.cn", "dsmynas.com", "familyds.com", "diskstation.me", "dscloud.me", "i234.me", "myds.me", "synology.me", "dscloud.mobi", "dsmynas.net", "familyds.net", "dsmynas.org", "familyds.org", "direct.quickconnect.to", "vpnplus.to", "mytabit.com", "mytabit.co.il", "tabitorder.co.il", "taifun-dns.de", "ts.net", "*.c.ts.net", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "taveusercontent.com", "p.tawk.email", "p.tawkto.email", "site.tb-hosting.com", "edugit.io", "s3.teckids.org", "telebit.app", "telebit.io", "*.telebit.xyz", "*.firenet.ch", "*.svc.firenet.ch", "reservd.com", "thingdustdata.com", "cust.dev.thingdust.io", "reservd.dev.thingdust.io", "cust.disrec.thingdust.io", "reservd.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "reservd.testing.thingdust.io", "tickets.io", "arvo.network", "azimuth.network", "tlon.network", "torproject.net", "pages.torproject.net", "townnews-staging.com", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "site.transip.me", "*.transurl.nl", "tuxfamily.org", "dd-dns.de", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "diskstation.eu", "diskstation.org", "typedream.app", "pro.typeform.com", "*.uberspace.de", "uber.space", "hk.com", "inc.hk", "ltd.hk", "hk.org", "it.com", "unison-services.cloud", "virtual-user.de", "virtualuser.de", "name.pm", "sch.tf", "biz.wf", "sch.wf", "org.yt", "rs.ba", "bielsko.pl", "upli.io", "urown.cloud", "dnsupdate.info", "us.org", "v.ua", "express.val.run", "web.val.run", "vercel.app", "v0.build", "vercel.dev", "vusercontent.net", "now.sh", "2038.io", "router.management", "v-info.info", "voorloper.cloud", "*.vultrobjects.com", "wafflecell.com", "webflow.io", "webflowtest.io", "*.webhare.dev", "bookonline.app", "hotelwithflight.com", "reserve-online.com", "reserve-online.net", "cprapid.com", "pleskns.com", "wp2.host", "pdns.page", "plesk.page", "wpsquared.site", "*.wadl.top", "remotewd.com", "box.ca", "pages.wiardweb.com", "toolforge.org", "wmcloud.org", "wmflabs.org", "wdh.app", "panel.gg", "daemon.panel.gg", "wixsite.com", "wixstudio.com", "editorx.io", "wixstudio.io", "wix.run", "messwithdns.com", "woltlab-demo.com", "myforum.community", "community-pro.de", "diskussionsbereich.de", "community-pro.net", "meinforum.net", "affinitylottery.org.uk", "raffleentry.org.uk", "weeklylottery.org.uk", "wpenginepowered.com", "js.wpenginepowered.com", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "yandexcloud.net", "storage.yandexcloud.net", "website.yandexcloud.net", "official.academy", "yolasite.com", "yombo.me", "ynh.fr", "nohost.me", "noho.st", "za.net", "za.org", "zap.cloud", "zeabur.app", "bss.design", "basicserver.io", "virtualserver.io", "enterprisecloud.nu"];
    var Z3 = Y3.reduce((e2, s2) => {
      const c2 = s2.replace(/^(\*\.|\!)/, ""), o2 = A3.toASCII(c2), t2 = s2.charAt(0);
      if (e2.has(o2)) throw new Error(`Multiple rules found for ${s2} (${o2})`);
      return e2.set(o2, { rule: s2, suffix: c2, punySuffix: o2, wildcard: t2 === "*", exception: t2 === "!" }), e2;
    }, /* @__PURE__ */ new Map());
    var aa2 = (e2) => {
      const c2 = A3.toASCII(e2).split(".");
      for (let o2 = 0; o2 < c2.length; o2++) {
        const t2 = c2.slice(o2).join("."), d2 = Z3.get(t2);
        if (d2) return d2;
      }
      return null;
    };
    var H3 = { DOMAIN_TOO_SHORT: "Domain name too short.", DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.", LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.", LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.", LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.", LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.", LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes." };
    var oa2 = (e2) => {
      const s2 = A3.toASCII(e2);
      if (s2.length < 1) return "DOMAIN_TOO_SHORT";
      if (s2.length > 255) return "DOMAIN_TOO_LONG";
      const c2 = s2.split(".");
      let o2;
      for (let t2 = 0; t2 < c2.length; ++t2) {
        if (o2 = c2[t2], !o2.length) return "LABEL_TOO_SHORT";
        if (o2.length > 63) return "LABEL_TOO_LONG";
        if (o2.charAt(0) === "-") return "LABEL_STARTS_WITH_DASH";
        if (o2.charAt(o2.length - 1) === "-") return "LABEL_ENDS_WITH_DASH";
        if (!/^[a-z0-9\-_]+$/.test(o2)) return "LABEL_INVALID_CHARS";
      }
    };
    var _2 = (e2) => {
      if (typeof e2 != "string") throw new TypeError("Domain name must be a string.");
      let s2 = e2.slice(0).toLowerCase();
      s2.charAt(s2.length - 1) === "." && (s2 = s2.slice(0, s2.length - 1));
      const c2 = oa2(s2);
      if (c2) return { input: e2, error: { message: H3[c2], code: c2 } };
      const o2 = { input: e2, tld: null, sld: null, domain: null, subdomain: null, listed: false }, t2 = s2.split(".");
      if (t2[t2.length - 1] === "local") return o2;
      const d2 = () => (/xn--/.test(s2) && (o2.domain && (o2.domain = A3.toASCII(o2.domain)), o2.subdomain && (o2.subdomain = A3.toASCII(o2.subdomain))), o2), z3 = aa2(s2);
      if (!z3) return t2.length < 2 ? o2 : (o2.tld = t2.pop(), o2.sld = t2.pop(), o2.domain = [o2.sld, o2.tld].join("."), t2.length && (o2.subdomain = t2.pop()), d2());
      o2.listed = true;
      const y2 = z3.suffix.split("."), g2 = t2.slice(0, t2.length - y2.length);
      return z3.exception && g2.push(y2.shift()), o2.tld = y2.join("."), !g2.length || (z3.wildcard && (y2.unshift(g2.pop()), o2.tld = y2.join(".")), !g2.length) || (o2.sld = g2.pop(), o2.domain = [o2.sld, o2.tld].join("."), g2.length && (o2.subdomain = g2.join("."))), d2();
    };
    var N2 = (e2) => e2 && _2(e2).domain || null;
    var R3 = (e2) => {
      const s2 = _2(e2);
      return !!(s2.domain && s2.listed);
    };
    var sa2 = { parse: _2, get: N2, isValid: R3 };
    exports2.default = sa2;
    exports2.errorCodes = H3;
    exports2.get = N2;
    exports2.isValid = R3;
    exports2.parse = _2;
  }
});

// ../../node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS({
  "../../node_modules/tough-cookie/lib/pubsuffix-psl.js"(exports2) {
    "use strict";
    var psl = require_psl();
    var SPECIAL_USE_DOMAINS = [
      "local",
      "example",
      "invalid",
      "localhost",
      "test"
    ];
    var SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];
    function getPublicSuffix(domain, options = {}) {
      const domainParts = domain.split(".");
      const topLevelDomain = domainParts[domainParts.length - 1];
      const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
      const ignoreError = !!options.ignoreError;
      if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        if (domainParts.length > 1) {
          const secondLevelDomain = domainParts[domainParts.length - 2];
          return `${secondLevelDomain}.${topLevelDomain}`;
        } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
          return `${topLevelDomain}`;
        }
      }
      if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        throw new Error(
          `Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`
        );
      }
      return psl.get(domain);
    }
    exports2.getPublicSuffix = getPublicSuffix;
  }
});

// ../../node_modules/tough-cookie/lib/store.js
var require_store = __commonJS({
  "../../node_modules/tough-cookie/lib/store.js"(exports2) {
    "use strict";
    var Store = class {
      constructor() {
        this.synchronous = false;
      }
      findCookie(domain, path4, key, cb) {
        throw new Error("findCookie is not implemented");
      }
      findCookies(domain, path4, allowSpecialUseDomain, cb) {
        throw new Error("findCookies is not implemented");
      }
      putCookie(cookie, cb) {
        throw new Error("putCookie is not implemented");
      }
      updateCookie(oldCookie, newCookie, cb) {
        throw new Error("updateCookie is not implemented");
      }
      removeCookie(domain, path4, key, cb) {
        throw new Error("removeCookie is not implemented");
      }
      removeCookies(domain, path4, cb) {
        throw new Error("removeCookies is not implemented");
      }
      removeAllCookies(cb) {
        throw new Error("removeAllCookies is not implemented");
      }
      getAllCookies(cb) {
        throw new Error(
          "getAllCookies is not implemented (therefore jar cannot be serialized)"
        );
      }
    };
    exports2.Store = Store;
  }
});

// ../../node_modules/tough-cookie/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/tough-cookie/node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function") fn.apply(this, arguments);
        else {
          return new Promise((resolve, reject2) => {
            arguments[arguments.length] = (err, res) => {
              if (err) return reject2(err);
              resolve(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function") return fn.apply(this, arguments);
        else {
          delete arguments[arguments.length - 1];
          arguments.length--;
          fn.apply(this, arguments).then((r2) => cb(null, r2), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS({
  "../../node_modules/tough-cookie/lib/permuteDomain.js"(exports2) {
    "use strict";
    var pubsuffix = require_pubsuffix_psl();
    function permuteDomain(domain, allowSpecialUseDomain) {
      const pubSuf = pubsuffix.getPublicSuffix(domain, {
        allowSpecialUseDomain
      });
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
      if (domain.slice(-1) == ".") {
        domain = domain.slice(0, -1);
      }
      const prefix2 = domain.slice(0, -(pubSuf.length + 1));
      const parts = prefix2.split(".").reverse();
      let cur = pubSuf;
      const permutations = [cur];
      while (parts.length) {
        cur = `${parts.shift()}.${cur}`;
        permutations.push(cur);
      }
      return permutations;
    }
    exports2.permuteDomain = permuteDomain;
  }
});

// ../../node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS({
  "../../node_modules/tough-cookie/lib/pathMatch.js"(exports2) {
    "use strict";
    function pathMatch(reqPath, cookiePath) {
      if (cookiePath === reqPath) {
        return true;
      }
      const idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
      return false;
    }
    exports2.pathMatch = pathMatch;
  }
});

// ../../node_modules/tough-cookie/lib/utilHelper.js
var require_utilHelper = __commonJS({
  "../../node_modules/tough-cookie/lib/utilHelper.js"(exports2) {
    function requireUtil() {
      try {
        return require("util");
      } catch (e2) {
        return null;
      }
    }
    function lookupCustomInspectSymbol() {
      return Symbol.for("nodejs.util.inspect.custom");
    }
    function tryReadingCustomSymbolFromUtilInspect(options) {
      const _requireUtil = options.requireUtil || requireUtil;
      const util2 = _requireUtil();
      return util2 ? util2.inspect.custom : null;
    }
    exports2.getUtilInspect = function getUtilInspect(fallback, options = {}) {
      const _requireUtil = options.requireUtil || requireUtil;
      const util2 = _requireUtil();
      return function inspect(value, showHidden, depth) {
        return util2 ? util2.inspect(value, showHidden, depth) : fallback(value);
      };
    };
    exports2.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
      const _lookupCustomInspectSymbol = options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;
      return _lookupCustomInspectSymbol() || tryReadingCustomSymbolFromUtilInspect(options);
    };
  }
});

// ../../node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS({
  "../../node_modules/tough-cookie/lib/memstore.js"(exports2) {
    "use strict";
    var { fromCallback } = require_universalify();
    var Store = require_store().Store;
    var permuteDomain = require_permuteDomain().permuteDomain;
    var pathMatch = require_pathMatch().pathMatch;
    var { getCustomInspectSymbol, getUtilInspect } = require_utilHelper();
    var MemoryCookieStore = class extends Store {
      constructor() {
        super();
        this.synchronous = true;
        this.idx = /* @__PURE__ */ Object.create(null);
        const customInspectSymbol = getCustomInspectSymbol();
        if (customInspectSymbol) {
          this[customInspectSymbol] = this.inspect;
        }
      }
      inspect() {
        const util2 = { inspect: getUtilInspect(inspectFallback) };
        return `{ idx: ${util2.inspect(this.idx, false, 2)} }`;
      }
      findCookie(domain, path4, key, cb) {
        if (!this.idx[domain]) {
          return cb(null, void 0);
        }
        if (!this.idx[domain][path4]) {
          return cb(null, void 0);
        }
        return cb(null, this.idx[domain][path4][key] || null);
      }
      findCookies(domain, path4, allowSpecialUseDomain, cb) {
        const results = [];
        if (typeof allowSpecialUseDomain === "function") {
          cb = allowSpecialUseDomain;
          allowSpecialUseDomain = true;
        }
        if (!domain) {
          return cb(null, []);
        }
        let pathMatcher;
        if (!path4) {
          pathMatcher = function matchAll(domainIndex) {
            for (const curPath in domainIndex) {
              const pathIndex = domainIndex[curPath];
              for (const key in pathIndex) {
                results.push(pathIndex[key]);
              }
            }
          };
        } else {
          pathMatcher = function matchRFC(domainIndex) {
            Object.keys(domainIndex).forEach((cookiePath) => {
              if (pathMatch(path4, cookiePath)) {
                const pathIndex = domainIndex[cookiePath];
                for (const key in pathIndex) {
                  results.push(pathIndex[key]);
                }
              }
            });
          };
        }
        const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
        const idx = this.idx;
        domains.forEach((curDomain) => {
          const domainIndex = idx[curDomain];
          if (!domainIndex) {
            return;
          }
          pathMatcher(domainIndex);
        });
        cb(null, results);
      }
      putCookie(cookie, cb) {
        if (!this.idx[cookie.domain]) {
          this.idx[cookie.domain] = /* @__PURE__ */ Object.create(null);
        }
        if (!this.idx[cookie.domain][cookie.path]) {
          this.idx[cookie.domain][cookie.path] = /* @__PURE__ */ Object.create(null);
        }
        this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
        cb(null);
      }
      updateCookie(oldCookie, newCookie, cb) {
        this.putCookie(newCookie, cb);
      }
      removeCookie(domain, path4, key, cb) {
        if (this.idx[domain] && this.idx[domain][path4] && this.idx[domain][path4][key]) {
          delete this.idx[domain][path4][key];
        }
        cb(null);
      }
      removeCookies(domain, path4, cb) {
        if (this.idx[domain]) {
          if (path4) {
            delete this.idx[domain][path4];
          } else {
            delete this.idx[domain];
          }
        }
        return cb(null);
      }
      removeAllCookies(cb) {
        this.idx = /* @__PURE__ */ Object.create(null);
        return cb(null);
      }
      getAllCookies(cb) {
        const cookies = [];
        const idx = this.idx;
        const domains = Object.keys(idx);
        domains.forEach((domain) => {
          const paths = Object.keys(idx[domain]);
          paths.forEach((path4) => {
            const keys2 = Object.keys(idx[domain][path4]);
            keys2.forEach((key) => {
              if (key !== null) {
                cookies.push(idx[domain][path4][key]);
              }
            });
          });
        });
        cookies.sort((a2, b2) => {
          return (a2.creationIndex || 0) - (b2.creationIndex || 0);
        });
        cb(null, cookies);
      }
    };
    [
      "findCookie",
      "findCookies",
      "putCookie",
      "updateCookie",
      "removeCookie",
      "removeCookies",
      "removeAllCookies",
      "getAllCookies"
    ].forEach((name) => {
      MemoryCookieStore.prototype[name] = fromCallback(
        MemoryCookieStore.prototype[name]
      );
    });
    exports2.MemoryCookieStore = MemoryCookieStore;
    function inspectFallback(val) {
      const domains = Object.keys(val);
      if (domains.length === 0) {
        return "[Object: null prototype] {}";
      }
      let result2 = "[Object: null prototype] {\n";
      Object.keys(val).forEach((domain, i2) => {
        result2 += formatDomain(domain, val[domain]);
        if (i2 < domains.length - 1) {
          result2 += ",";
        }
        result2 += "\n";
      });
      result2 += "}";
      return result2;
    }
    function formatDomain(domainName, domainValue) {
      const indent = "  ";
      let result2 = `${indent}'${domainName}': [Object: null prototype] {
`;
      Object.keys(domainValue).forEach((path4, i2, paths) => {
        result2 += formatPath(path4, domainValue[path4]);
        if (i2 < paths.length - 1) {
          result2 += ",";
        }
        result2 += "\n";
      });
      result2 += `${indent}}`;
      return result2;
    }
    function formatPath(pathName, pathValue) {
      const indent = "    ";
      let result2 = `${indent}'${pathName}': [Object: null prototype] {
`;
      Object.keys(pathValue).forEach((cookieName, i2, cookieNames) => {
        const cookie = pathValue[cookieName];
        result2 += `      ${cookieName}: ${cookie.inspect()}`;
        if (i2 < cookieNames.length - 1) {
          result2 += ",";
        }
        result2 += "\n";
      });
      result2 += `${indent}}`;
      return result2;
    }
    exports2.inspectFallback = inspectFallback;
  }
});

// ../../node_modules/tough-cookie/lib/validators.js
var require_validators = __commonJS({
  "../../node_modules/tough-cookie/lib/validators.js"(exports2) {
    "use strict";
    var toString2 = Object.prototype.toString;
    function isFunction3(data) {
      return typeof data === "function";
    }
    function isNonEmptyString(data) {
      return isString3(data) && data !== "";
    }
    function isDate4(data) {
      return isInstanceStrict(data, Date) && isInteger2(data.getTime());
    }
    function isEmptyString(data) {
      return data === "" || data instanceof String && data.toString() === "";
    }
    function isString3(data) {
      return typeof data === "string" || data instanceof String;
    }
    function isObject2(data) {
      return toString2.call(data) === "[object Object]";
    }
    function isInstanceStrict(data, prototype) {
      try {
        return data instanceof prototype;
      } catch (error) {
        return false;
      }
    }
    function isUrlStringOrObject(data) {
      return isNonEmptyString(data) || isObject2(data) && "hostname" in data && "pathname" in data && "protocol" in data || isInstanceStrict(data, URL);
    }
    function isInteger2(data) {
      return typeof data === "number" && data % 1 === 0;
    }
    function validate(bool, cb, options) {
      if (!isFunction3(cb)) {
        options = cb;
        cb = null;
      }
      if (!isObject2(options)) options = { Error: "Failed Check" };
      if (!bool) {
        if (cb) {
          cb(new ParameterError(options));
        } else {
          throw new ParameterError(options);
        }
      }
    }
    var ParameterError = class extends Error {
      constructor(...params) {
        super(...params);
      }
    };
    exports2.ParameterError = ParameterError;
    exports2.isFunction = isFunction3;
    exports2.isNonEmptyString = isNonEmptyString;
    exports2.isDate = isDate4;
    exports2.isEmptyString = isEmptyString;
    exports2.isString = isString3;
    exports2.isObject = isObject2;
    exports2.isUrlStringOrObject = isUrlStringOrObject;
    exports2.validate = validate;
  }
});

// ../../node_modules/tough-cookie/lib/version.js
var require_version = __commonJS({
  "../../node_modules/tough-cookie/lib/version.js"(exports2, module2) {
    module2.exports = "4.1.4";
  }
});

// ../../node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS({
  "../../node_modules/tough-cookie/lib/cookie.js"(exports2) {
    "use strict";
    var punycode = require_punycode();
    var urlParse4 = require_url_parse();
    var pubsuffix = require_pubsuffix_psl();
    var Store = require_store().Store;
    var MemoryCookieStore = require_memstore().MemoryCookieStore;
    var pathMatch = require_pathMatch().pathMatch;
    var validators = require_validators();
    var VERSION = require_version();
    var { fromCallback } = require_universalify();
    var { getCustomInspectSymbol } = require_utilHelper();
    var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
    var CONTROL_CHARS = /[\x00-\x1F]/;
    var TERMINATORS = ["\n", "\r", "\0"];
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    var MONTH_TO_NUM = {
      jan: 0,
      feb: 1,
      mar: 2,
      apr: 3,
      may: 4,
      jun: 5,
      jul: 6,
      aug: 7,
      sep: 8,
      oct: 9,
      nov: 10,
      dec: 11
    };
    var MAX_TIME = 2147483647e3;
    var MIN_TIME = 0;
    var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
    function checkSameSiteContext(value) {
      validators.validate(validators.isNonEmptyString(value), value);
      const context = String(value).toLowerCase();
      if (context === "none" || context === "lax" || context === "strict") {
        return context;
      } else {
        return null;
      }
    }
    var PrefixSecurityEnum = Object.freeze({
      SILENT: "silent",
      STRICT: "strict",
      DISABLED: "unsafe-disabled"
    });
    var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
    var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
    function parseDigits(token, minDigits, maxDigits, trailingOK) {
      let count = 0;
      while (count < token.length) {
        const c2 = token.charCodeAt(count);
        if (c2 <= 47 || c2 >= 58) {
          break;
        }
        count++;
      }
      if (count < minDigits || count > maxDigits) {
        return null;
      }
      if (!trailingOK && count != token.length) {
        return null;
      }
      return parseInt(token.substr(0, count), 10);
    }
    function parseTime(token) {
      const parts = token.split(":");
      const result2 = [0, 0, 0];
      if (parts.length !== 3) {
        return null;
      }
      for (let i2 = 0; i2 < 3; i2++) {
        const trailingOK = i2 == 2;
        const num = parseDigits(parts[i2], 1, 2, trailingOK);
        if (num === null) {
          return null;
        }
        result2[i2] = num;
      }
      return result2;
    }
    function parseMonth(token) {
      token = String(token).substr(0, 3).toLowerCase();
      const num = MONTH_TO_NUM[token];
      return num >= 0 ? num : null;
    }
    function parseDate(str) {
      if (!str) {
        return;
      }
      const tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
      let hour = null;
      let minute = null;
      let second = null;
      let dayOfMonth = null;
      let month = null;
      let year = null;
      for (let i2 = 0; i2 < tokens.length; i2++) {
        const token = tokens[i2].trim();
        if (!token.length) {
          continue;
        }
        let result2;
        if (second === null) {
          result2 = parseTime(token);
          if (result2) {
            hour = result2[0];
            minute = result2[1];
            second = result2[2];
            continue;
          }
        }
        if (dayOfMonth === null) {
          result2 = parseDigits(token, 1, 2, true);
          if (result2 !== null) {
            dayOfMonth = result2;
            continue;
          }
        }
        if (month === null) {
          result2 = parseMonth(token);
          if (result2 !== null) {
            month = result2;
            continue;
          }
        }
        if (year === null) {
          result2 = parseDigits(token, 2, 4, true);
          if (result2 !== null) {
            year = result2;
            if (year >= 70 && year <= 99) {
              year += 1900;
            } else if (year >= 0 && year <= 69) {
              year += 2e3;
            }
          }
        }
      }
      if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
      }
      return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
    }
    function formatDate(date) {
      validators.validate(validators.isDate(date), date);
      return date.toUTCString();
    }
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./, "");
      if (IP_V6_REGEX_OBJECT.test(str)) {
        str = str.replace("[", "").replace("]", "");
      }
      if (punycode && /[^\u0001-\u007f]/.test(str)) {
        str = punycode.toASCII(str);
      }
      return str.toLowerCase();
    }
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
      if (str == domStr) {
        return true;
      }
      const idx = str.lastIndexOf(domStr);
      if (idx <= 0) {
        return false;
      }
      if (str.length !== domStr.length + idx) {
        return false;
      }
      if (str.substr(idx - 1, 1) !== ".") {
        return false;
      }
      if (IP_REGEX_LOWERCASE.test(str)) {
        return false;
      }
      return true;
    }
    function defaultPath(path4) {
      if (!path4 || path4.substr(0, 1) !== "/") {
        return "/";
      }
      if (path4 === "/") {
        return path4;
      }
      const rightSlash = path4.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
      return path4.slice(0, rightSlash);
    }
    function trimTerminator(str) {
      if (validators.isEmptyString(str)) return str;
      for (let t2 = 0; t2 < TERMINATORS.length; t2++) {
        const terminatorIdx = str.indexOf(TERMINATORS[t2]);
        if (terminatorIdx !== -1) {
          str = str.substr(0, terminatorIdx);
        }
      }
      return str;
    }
    function parseCookiePair(cookiePair, looseMode) {
      cookiePair = trimTerminator(cookiePair);
      validators.validate(validators.isString(cookiePair), cookiePair);
      let firstEq = cookiePair.indexOf("=");
      if (looseMode) {
        if (firstEq === 0) {
          cookiePair = cookiePair.substr(1);
          firstEq = cookiePair.indexOf("=");
        }
      } else {
        if (firstEq <= 0) {
          return;
        }
      }
      let cookieName, cookieValue;
      if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
      } else {
        cookieName = cookiePair.substr(0, firstEq).trim();
        cookieValue = cookiePair.substr(firstEq + 1).trim();
      }
      if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return;
      }
      const c2 = new Cookie3();
      c2.key = cookieName;
      c2.value = cookieValue;
      return c2;
    }
    function parse(str, options) {
      if (!options || typeof options !== "object") {
        options = {};
      }
      if (validators.isEmptyString(str) || !validators.isString(str)) {
        return null;
      }
      str = str.trim();
      const firstSemi = str.indexOf(";");
      const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
      const c2 = parseCookiePair(cookiePair, !!options.loose);
      if (!c2) {
        return;
      }
      if (firstSemi === -1) {
        return c2;
      }
      const unparsed = str.slice(firstSemi + 1).trim();
      if (unparsed.length === 0) {
        return c2;
      }
      const cookie_avs = unparsed.split(";");
      while (cookie_avs.length) {
        const av = cookie_avs.shift().trim();
        if (av.length === 0) {
          continue;
        }
        const av_sep = av.indexOf("=");
        let av_key, av_value;
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0, av_sep);
          av_value = av.substr(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
          av_value = av_value.trim();
        }
        switch (av_key) {
          case "expires":
            if (av_value) {
              const exp = parseDate(av_value);
              if (exp) {
                c2.expires = exp;
              }
            }
            break;
          case "max-age":
            if (av_value) {
              if (/^-?[0-9]+$/.test(av_value)) {
                const delta = parseInt(av_value, 10);
                c2.setMaxAge(delta);
              }
            }
            break;
          case "domain":
            if (av_value) {
              const domain = av_value.trim().replace(/^\./, "");
              if (domain) {
                c2.domain = domain.toLowerCase();
              }
            }
            break;
          case "path":
            c2.path = av_value && av_value[0] === "/" ? av_value : null;
            break;
          case "secure":
            c2.secure = true;
            break;
          case "httponly":
            c2.httpOnly = true;
            break;
          case "samesite":
            const enforcement = av_value ? av_value.toLowerCase() : "";
            switch (enforcement) {
              case "strict":
                c2.sameSite = "strict";
                break;
              case "lax":
                c2.sameSite = "lax";
                break;
              case "none":
                c2.sameSite = "none";
                break;
              default:
                c2.sameSite = void 0;
                break;
            }
            break;
          default:
            c2.extensions = c2.extensions || [];
            c2.extensions.push(av);
            break;
        }
      }
      return c2;
    }
    function isSecurePrefixConditionMet(cookie) {
      validators.validate(validators.isObject(cookie), cookie);
      return !cookie.key.startsWith("__Secure-") || cookie.secure;
    }
    function isHostPrefixConditionMet(cookie) {
      validators.validate(validators.isObject(cookie));
      return !cookie.key.startsWith("__Host-") || cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/";
    }
    function jsonParse(str) {
      let obj;
      try {
        obj = JSON.parse(str);
      } catch (e2) {
        return e2;
      }
      return obj;
    }
    function fromJSON(str) {
      if (!str || validators.isEmptyString(str)) {
        return null;
      }
      let obj;
      if (typeof str === "string") {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        obj = str;
      }
      const c2 = new Cookie3();
      for (let i2 = 0; i2 < Cookie3.serializableProperties.length; i2++) {
        const prop = Cookie3.serializableProperties[i2];
        if (obj[prop] === void 0 || obj[prop] === cookieDefaults[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (obj[prop] === null) {
            c2[prop] = null;
          } else {
            c2[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
          }
        } else {
          c2[prop] = obj[prop];
        }
      }
      return c2;
    }
    function cookieCompare(a2, b2) {
      validators.validate(validators.isObject(a2), a2);
      validators.validate(validators.isObject(b2), b2);
      let cmp = 0;
      const aPathLen = a2.path ? a2.path.length : 0;
      const bPathLen = b2.path ? b2.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
      const aTime = a2.creation ? a2.creation.getTime() : MAX_TIME;
      const bTime = b2.creation ? b2.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = a2.creationIndex - b2.creationIndex;
      return cmp;
    }
    function permutePath(path4) {
      validators.validate(validators.isString(path4));
      if (path4 === "/") {
        return ["/"];
      }
      const permutations = [path4];
      while (path4.length > 1) {
        const lindex = path4.lastIndexOf("/");
        if (lindex === 0) {
          break;
        }
        path4 = path4.substr(0, lindex);
        permutations.push(path4);
      }
      permutations.push("/");
      return permutations;
    }
    function getCookieContext(url) {
      if (url instanceof Object) {
        return url;
      }
      try {
        url = decodeURI(url);
      } catch (err) {
      }
      return urlParse4(url);
    }
    var cookieDefaults = {
      // the order in which the RFC has them:
      key: "",
      value: "",
      expires: "Infinity",
      maxAge: null,
      domain: null,
      path: null,
      secure: false,
      httpOnly: false,
      extensions: null,
      // set by the CookieJar:
      hostOnly: null,
      pathIsDefault: null,
      creation: null,
      lastAccessed: null,
      sameSite: void 0
    };
    var Cookie3 = class _Cookie {
      constructor(options = {}) {
        const customInspectSymbol = getCustomInspectSymbol();
        if (customInspectSymbol) {
          this[customInspectSymbol] = this.inspect;
        }
        Object.assign(this, cookieDefaults, options);
        this.creation = this.creation || /* @__PURE__ */ new Date();
        Object.defineProperty(this, "creationIndex", {
          configurable: false,
          enumerable: false,
          // important for assert.deepEqual checks
          writable: true,
          value: ++_Cookie.cookiesCreated
        });
      }
      inspect() {
        const now2 = Date.now();
        const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
        const createAge = this.creation ? `${now2 - this.creation.getTime()}ms` : "?";
        const accessAge = this.lastAccessed ? `${now2 - this.lastAccessed.getTime()}ms` : "?";
        return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
      }
      toJSON() {
        const obj = {};
        for (const prop of _Cookie.serializableProperties) {
          if (this[prop] === cookieDefaults[prop]) {
            continue;
          }
          if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
            if (this[prop] === null) {
              obj[prop] = null;
            } else {
              obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
            }
          } else if (prop === "maxAge") {
            if (this[prop] !== null) {
              obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
            }
          } else {
            if (this[prop] !== cookieDefaults[prop]) {
              obj[prop] = this[prop];
            }
          }
        }
        return obj;
      }
      clone() {
        return fromJSON(this.toJSON());
      }
      validate() {
        if (!COOKIE_OCTETS.test(this.value)) {
          return false;
        }
        if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
          return false;
        }
        if (this.maxAge != null && this.maxAge <= 0) {
          return false;
        }
        if (this.path != null && !PATH_VALUE.test(this.path)) {
          return false;
        }
        const cdomain = this.cdomain();
        if (cdomain) {
          if (cdomain.match(/\.$/)) {
            return false;
          }
          const suffix = pubsuffix.getPublicSuffix(cdomain);
          if (suffix == null) {
            return false;
          }
        }
        return true;
      }
      setExpires(exp) {
        if (exp instanceof Date) {
          this.expires = exp;
        } else {
          this.expires = parseDate(exp) || "Infinity";
        }
      }
      setMaxAge(age) {
        if (age === Infinity || age === -Infinity) {
          this.maxAge = age.toString();
        } else {
          this.maxAge = age;
        }
      }
      cookieString() {
        let val = this.value;
        if (val == null) {
          val = "";
        }
        if (this.key === "") {
          return val;
        }
        return `${this.key}=${val}`;
      }
      // gives Set-Cookie header format
      toString() {
        let str = this.cookieString();
        if (this.expires != Infinity) {
          if (this.expires instanceof Date) {
            str += `; Expires=${formatDate(this.expires)}`;
          } else {
            str += `; Expires=${this.expires}`;
          }
        }
        if (this.maxAge != null && this.maxAge != Infinity) {
          str += `; Max-Age=${this.maxAge}`;
        }
        if (this.domain && !this.hostOnly) {
          str += `; Domain=${this.domain}`;
        }
        if (this.path) {
          str += `; Path=${this.path}`;
        }
        if (this.secure) {
          str += "; Secure";
        }
        if (this.httpOnly) {
          str += "; HttpOnly";
        }
        if (this.sameSite && this.sameSite !== "none") {
          const ssCanon = _Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
          str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
        }
        if (this.extensions) {
          this.extensions.forEach((ext) => {
            str += `; ${ext}`;
          });
        }
        return str;
      }
      // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere)
      // S5.3 says to give the "latest representable date" for which we use Infinity
      // For "expired" we use 0
      TTL(now2) {
        if (this.maxAge != null) {
          return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
        }
        let expires = this.expires;
        if (expires != Infinity) {
          if (!(expires instanceof Date)) {
            expires = parseDate(expires) || Infinity;
          }
          if (expires == Infinity) {
            return Infinity;
          }
          return expires.getTime() - (now2 || Date.now());
        }
        return Infinity;
      }
      // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere)
      expiryTime(now2) {
        if (this.maxAge != null) {
          const relativeTo = now2 || this.creation || /* @__PURE__ */ new Date();
          const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
          return relativeTo.getTime() + age;
        }
        if (this.expires == Infinity) {
          return Infinity;
        }
        return this.expires.getTime();
      }
      // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere), except it returns a Date
      expiryDate(now2) {
        const millisec = this.expiryTime(now2);
        if (millisec == Infinity) {
          return new Date(MAX_TIME);
        } else if (millisec == -Infinity) {
          return new Date(MIN_TIME);
        } else {
          return new Date(millisec);
        }
      }
      // This replaces the "persistent-flag" parts of S5.3 step 3
      isPersistent() {
        return this.maxAge != null || this.expires != Infinity;
      }
      // Mostly S5.1.2 and S5.2.3:
      canonicalizedDomain() {
        if (this.domain == null) {
          return null;
        }
        return canonicalDomain(this.domain);
      }
      cdomain() {
        return this.canonicalizedDomain();
      }
    };
    Cookie3.cookiesCreated = 0;
    Cookie3.parse = parse;
    Cookie3.fromJSON = fromJSON;
    Cookie3.serializableProperties = Object.keys(cookieDefaults);
    Cookie3.sameSiteLevel = {
      strict: 3,
      lax: 2,
      none: 1
    };
    Cookie3.sameSiteCanonical = {
      strict: "Strict",
      lax: "Lax"
    };
    function getNormalizedPrefixSecurity(prefixSecurity) {
      if (prefixSecurity != null) {
        const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
        switch (normalizedPrefixSecurity) {
          case PrefixSecurityEnum.STRICT:
          case PrefixSecurityEnum.SILENT:
          case PrefixSecurityEnum.DISABLED:
            return normalizedPrefixSecurity;
        }
      }
      return PrefixSecurityEnum.SILENT;
    }
    var CookieJar2 = class _CookieJar {
      constructor(store, options = { rejectPublicSuffixes: true }) {
        if (typeof options === "boolean") {
          options = { rejectPublicSuffixes: options };
        }
        validators.validate(validators.isObject(options), options);
        this.rejectPublicSuffixes = options.rejectPublicSuffixes;
        this.enableLooseMode = !!options.looseMode;
        this.allowSpecialUseDomain = typeof options.allowSpecialUseDomain === "boolean" ? options.allowSpecialUseDomain : true;
        this.store = store || new MemoryCookieStore();
        this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
        this._cloneSync = syncWrap("clone");
        this._importCookiesSync = syncWrap("_importCookies");
        this.getCookiesSync = syncWrap("getCookies");
        this.getCookieStringSync = syncWrap("getCookieString");
        this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
        this.removeAllCookiesSync = syncWrap("removeAllCookies");
        this.setCookieSync = syncWrap("setCookie");
        this.serializeSync = syncWrap("serialize");
      }
      setCookie(cookie, url, options, cb) {
        validators.validate(validators.isUrlStringOrObject(url), cb, options);
        let err;
        if (validators.isFunction(url)) {
          cb = url;
          return cb(new Error("No URL was specified"));
        }
        const context = getCookieContext(url);
        if (validators.isFunction(options)) {
          cb = options;
          options = {};
        }
        validators.validate(validators.isFunction(cb), cb);
        if (!validators.isNonEmptyString(cookie) && !validators.isObject(cookie) && cookie instanceof String && cookie.length == 0) {
          return cb(null);
        }
        const host = canonicalDomain(context.hostname);
        const loose = options.loose || this.enableLooseMode;
        let sameSiteContext = null;
        if (options.sameSiteContext) {
          sameSiteContext = checkSameSiteContext(options.sameSiteContext);
          if (!sameSiteContext) {
            return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
          }
        }
        if (typeof cookie === "string" || cookie instanceof String) {
          cookie = Cookie3.parse(cookie, { loose });
          if (!cookie) {
            err = new Error("Cookie failed to parse");
            return cb(options.ignoreError ? null : err);
          }
        } else if (!(cookie instanceof Cookie3)) {
          err = new Error(
            "First argument to setCookie must be a Cookie object or string"
          );
          return cb(options.ignoreError ? null : err);
        }
        const now2 = options.now || /* @__PURE__ */ new Date();
        if (this.rejectPublicSuffixes && cookie.domain) {
          const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
            allowSpecialUseDomain: this.allowSpecialUseDomain,
            ignoreError: options.ignoreError
          });
          if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
            err = new Error("Cookie has domain set to a public suffix");
            return cb(options.ignoreError ? null : err);
          }
        }
        if (cookie.domain) {
          if (!domainMatch(host, cookie.cdomain(), false)) {
            err = new Error(
              `Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`
            );
            return cb(options.ignoreError ? null : err);
          }
          if (cookie.hostOnly == null) {
            cookie.hostOnly = false;
          }
        } else {
          cookie.hostOnly = true;
          cookie.domain = host;
        }
        if (!cookie.path || cookie.path[0] !== "/") {
          cookie.path = defaultPath(context.pathname);
          cookie.pathIsDefault = true;
        }
        if (options.http === false && cookie.httpOnly) {
          err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err);
        }
        if (cookie.sameSite !== "none" && cookie.sameSite !== void 0 && sameSiteContext) {
          if (sameSiteContext === "none") {
            err = new Error(
              "Cookie is SameSite but this is a cross-origin request"
            );
            return cb(options.ignoreError ? null : err);
          }
        }
        const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
        const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
        if (!prefixSecurityDisabled) {
          let errorFound = false;
          let errorMsg;
          if (!isSecurePrefixConditionMet(cookie)) {
            errorFound = true;
            errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
          } else if (!isHostPrefixConditionMet(cookie)) {
            errorFound = true;
            errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
          }
          if (errorFound) {
            return cb(
              options.ignoreError || ignoreErrorForPrefixSecurity ? null : new Error(errorMsg)
            );
          }
        }
        const store = this.store;
        if (!store.updateCookie) {
          store.updateCookie = function(oldCookie, newCookie, cb2) {
            this.putCookie(newCookie, cb2);
          };
        }
        function withCookie(err2, oldCookie) {
          if (err2) {
            return cb(err2);
          }
          const next = function(err3) {
            if (err3) {
              return cb(err3);
            } else {
              cb(null, cookie);
            }
          };
          if (oldCookie) {
            if (options.http === false && oldCookie.httpOnly) {
              err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
              return cb(options.ignoreError ? null : err2);
            }
            cookie.creation = oldCookie.creation;
            cookie.creationIndex = oldCookie.creationIndex;
            cookie.lastAccessed = now2;
            store.updateCookie(oldCookie, cookie, next);
          } else {
            cookie.creation = cookie.lastAccessed = now2;
            store.putCookie(cookie, next);
          }
        }
        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
      }
      // RFC6365 S5.4
      getCookies(url, options, cb) {
        validators.validate(validators.isUrlStringOrObject(url), cb, url);
        const context = getCookieContext(url);
        if (validators.isFunction(options)) {
          cb = options;
          options = {};
        }
        validators.validate(validators.isObject(options), cb, options);
        validators.validate(validators.isFunction(cb), cb);
        const host = canonicalDomain(context.hostname);
        const path4 = context.pathname || "/";
        let secure = options.secure;
        if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
          secure = true;
        }
        let sameSiteLevel = 0;
        if (options.sameSiteContext) {
          const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
          sameSiteLevel = Cookie3.sameSiteLevel[sameSiteContext];
          if (!sameSiteLevel) {
            return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
          }
        }
        let http = options.http;
        if (http == null) {
          http = true;
        }
        const now2 = options.now || Date.now();
        const expireCheck = options.expire !== false;
        const allPaths = !!options.allPaths;
        const store = this.store;
        function matchingCookie(c2) {
          if (c2.hostOnly) {
            if (c2.domain != host) {
              return false;
            }
          } else {
            if (!domainMatch(host, c2.domain, false)) {
              return false;
            }
          }
          if (!allPaths && !pathMatch(path4, c2.path)) {
            return false;
          }
          if (c2.secure && !secure) {
            return false;
          }
          if (c2.httpOnly && !http) {
            return false;
          }
          if (sameSiteLevel) {
            const cookieLevel = Cookie3.sameSiteLevel[c2.sameSite || "none"];
            if (cookieLevel > sameSiteLevel) {
              return false;
            }
          }
          if (expireCheck && c2.expiryTime() <= now2) {
            store.removeCookie(c2.domain, c2.path, c2.key, () => {
            });
            return false;
          }
          return true;
        }
        store.findCookies(
          host,
          allPaths ? null : path4,
          this.allowSpecialUseDomain,
          (err, cookies) => {
            if (err) {
              return cb(err);
            }
            cookies = cookies.filter(matchingCookie);
            if (options.sort !== false) {
              cookies = cookies.sort(cookieCompare);
            }
            const now3 = /* @__PURE__ */ new Date();
            for (const cookie of cookies) {
              cookie.lastAccessed = now3;
            }
            cb(null, cookies);
          }
        );
      }
      getCookieString(...args) {
        const cb = args.pop();
        validators.validate(validators.isFunction(cb), cb);
        const next = function(err, cookies) {
          if (err) {
            cb(err);
          } else {
            cb(
              null,
              cookies.sort(cookieCompare).map((c2) => c2.cookieString()).join("; ")
            );
          }
        };
        args.push(next);
        this.getCookies.apply(this, args);
      }
      getSetCookieStrings(...args) {
        const cb = args.pop();
        validators.validate(validators.isFunction(cb), cb);
        const next = function(err, cookies) {
          if (err) {
            cb(err);
          } else {
            cb(
              null,
              cookies.map((c2) => {
                return c2.toString();
              })
            );
          }
        };
        args.push(next);
        this.getCookies.apply(this, args);
      }
      serialize(cb) {
        validators.validate(validators.isFunction(cb), cb);
        let type = this.store.constructor.name;
        if (validators.isObject(type)) {
          type = null;
        }
        const serialized = {
          // The version of tough-cookie that serialized this jar. Generally a good
          // practice since future versions can make data import decisions based on
          // known past behavior. When/if this matters, use `semver`.
          version: `tough-cookie@${VERSION}`,
          // add the store type, to make humans happy:
          storeType: type,
          // CookieJar configuration:
          rejectPublicSuffixes: !!this.rejectPublicSuffixes,
          enableLooseMode: !!this.enableLooseMode,
          allowSpecialUseDomain: !!this.allowSpecialUseDomain,
          prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
          // this gets filled from getAllCookies:
          cookies: []
        };
        if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
          return cb(
            new Error(
              "store does not support getAllCookies and cannot be serialized"
            )
          );
        }
        this.store.getAllCookies((err, cookies) => {
          if (err) {
            return cb(err);
          }
          serialized.cookies = cookies.map((cookie) => {
            cookie = cookie instanceof Cookie3 ? cookie.toJSON() : cookie;
            delete cookie.creationIndex;
            return cookie;
          });
          return cb(null, serialized);
        });
      }
      toJSON() {
        return this.serializeSync();
      }
      // use the class method CookieJar.deserialize instead of calling this directly
      _importCookies(serialized, cb) {
        let cookies = serialized.cookies;
        if (!cookies || !Array.isArray(cookies)) {
          return cb(new Error("serialized jar has no cookies array"));
        }
        cookies = cookies.slice();
        const putNext = (err) => {
          if (err) {
            return cb(err);
          }
          if (!cookies.length) {
            return cb(err, this);
          }
          let cookie;
          try {
            cookie = fromJSON(cookies.shift());
          } catch (e2) {
            return cb(e2);
          }
          if (cookie === null) {
            return putNext(null);
          }
          this.store.putCookie(cookie, putNext);
        };
        putNext();
      }
      clone(newStore, cb) {
        if (arguments.length === 1) {
          cb = newStore;
          newStore = null;
        }
        this.serialize((err, serialized) => {
          if (err) {
            return cb(err);
          }
          _CookieJar.deserialize(serialized, newStore, cb);
        });
      }
      cloneSync(newStore) {
        if (arguments.length === 0) {
          return this._cloneSync();
        }
        if (!newStore.synchronous) {
          throw new Error(
            "CookieJar clone destination store is not synchronous; use async API instead."
          );
        }
        return this._cloneSync(newStore);
      }
      removeAllCookies(cb) {
        validators.validate(validators.isFunction(cb), cb);
        const store = this.store;
        if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
          return store.removeAllCookies(cb);
        }
        store.getAllCookies((err, cookies) => {
          if (err) {
            return cb(err);
          }
          if (cookies.length === 0) {
            return cb(null);
          }
          let completedCount = 0;
          const removeErrors = [];
          function removeCookieCb(removeErr) {
            if (removeErr) {
              removeErrors.push(removeErr);
            }
            completedCount++;
            if (completedCount === cookies.length) {
              return cb(removeErrors.length ? removeErrors[0] : null);
            }
          }
          cookies.forEach((cookie) => {
            store.removeCookie(
              cookie.domain,
              cookie.path,
              cookie.key,
              removeCookieCb
            );
          });
        });
      }
      static deserialize(strOrObj, store, cb) {
        if (arguments.length !== 3) {
          cb = store;
          store = null;
        }
        validators.validate(validators.isFunction(cb), cb);
        let serialized;
        if (typeof strOrObj === "string") {
          serialized = jsonParse(strOrObj);
          if (serialized instanceof Error) {
            return cb(serialized);
          }
        } else {
          serialized = strOrObj;
        }
        const jar = new _CookieJar(store, {
          rejectPublicSuffixes: serialized.rejectPublicSuffixes,
          looseMode: serialized.enableLooseMode,
          allowSpecialUseDomain: serialized.allowSpecialUseDomain,
          prefixSecurity: serialized.prefixSecurity
        });
        jar._importCookies(serialized, (err) => {
          if (err) {
            return cb(err);
          }
          cb(null, jar);
        });
      }
      static deserializeSync(strOrObj, store) {
        const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
        const jar = new _CookieJar(store, {
          rejectPublicSuffixes: serialized.rejectPublicSuffixes,
          looseMode: serialized.enableLooseMode
        });
        if (!jar.store.synchronous) {
          throw new Error(
            "CookieJar store is not synchronous; use async API instead."
          );
        }
        jar._importCookiesSync(serialized);
        return jar;
      }
    };
    CookieJar2.fromJSON = CookieJar2.deserializeSync;
    [
      "_importCookies",
      "clone",
      "getCookies",
      "getCookieString",
      "getSetCookieStrings",
      "removeAllCookies",
      "serialize",
      "setCookie"
    ].forEach((name) => {
      CookieJar2.prototype[name] = fromCallback(CookieJar2.prototype[name]);
    });
    CookieJar2.deserialize = fromCallback(CookieJar2.deserialize);
    function syncWrap(method2) {
      return function(...args) {
        if (!this.store.synchronous) {
          throw new Error(
            "CookieJar store is not synchronous; use async API instead."
          );
        }
        let syncErr, syncResult;
        this[method2](...args, (err, result2) => {
          syncErr = err;
          syncResult = result2;
        });
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    exports2.version = VERSION;
    exports2.CookieJar = CookieJar2;
    exports2.Cookie = Cookie3;
    exports2.Store = Store;
    exports2.MemoryCookieStore = MemoryCookieStore;
    exports2.parseDate = parseDate;
    exports2.formatDate = formatDate;
    exports2.parse = parse;
    exports2.fromJSON = fromJSON;
    exports2.domainMatch = domainMatch;
    exports2.defaultPath = defaultPath;
    exports2.pathMatch = pathMatch;
    exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
    exports2.cookieCompare = cookieCompare;
    exports2.permuteDomain = require_permuteDomain().permuteDomain;
    exports2.permutePath = permutePath;
    exports2.canonicalDomain = canonicalDomain;
    exports2.PrefixSecurityEnum = PrefixSecurityEnum;
    exports2.ParameterError = validators.ParameterError;
  }
});

// ../../node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "../../node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// ../../node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
var byteToHex;
var init_stringify = __esm({
  "../../node_modules/uuid/dist/esm-node/stringify.js"() {
    byteToHex = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).slice(1));
    }
  }
});

// ../../node_modules/uuid/dist/esm-node/native.js
var import_crypto2, native_default;
var init_native = __esm({
  "../../node_modules/uuid/dist/esm-node/native.js"() {
    import_crypto2 = __toESM(require("crypto"));
    native_default = {
      randomUUID: import_crypto2.default.randomUUID
    };
  }
});

// ../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../../node_modules/uuid/dist/esm-node/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// ../../node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "../../node_modules/uuid/dist/esm-node/index.js"() {
    init_v4();
  }
});

// ../../node_modules/@seald-io/nedb/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/utils.js"(exports2, module2) {
    var uniq3 = (array, iteratee2) => {
      if (iteratee2) return [...new Map(array.map((x3) => [iteratee2(x3), x3])).values()];
      else return [...new Set(array)];
    };
    var isObject2 = (arg) => typeof arg === "object" && arg !== null;
    var isDate4 = (d2) => isObject2(d2) && Object.prototype.toString.call(d2) === "[object Date]";
    var isRegExp4 = (re3) => isObject2(re3) && Object.prototype.toString.call(re3) === "[object RegExp]";
    var pick2 = (object, keys2) => {
      return keys2.reduce((obj, key) => {
        if (object && Object.prototype.hasOwnProperty.call(object, key)) {
          obj[key] = object[key];
        }
        return obj;
      }, {});
    };
    var filterIndexNames = (indexNames) => ([k2, v3]) => !!(typeof v3 === "string" || typeof v3 === "number" || typeof v3 === "boolean" || isDate4(v3) || v3 === null) && indexNames.includes(k2);
    module2.exports.uniq = uniq3;
    module2.exports.isDate = isDate4;
    module2.exports.isRegExp = isRegExp4;
    module2.exports.pick = pick2;
    module2.exports.filterIndexNames = filterIndexNames;
  }
});

// ../../node_modules/@seald-io/nedb/lib/model.js
var require_model = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/model.js"(exports2, module2) {
    var { uniq: uniq3, isDate: isDate4, isRegExp: isRegExp4 } = require_utils3();
    var checkKey = (k2, v3) => {
      if (typeof k2 === "number") k2 = k2.toString();
      if (k2[0] === "$" && !(k2 === "$$date" && typeof v3 === "number") && !(k2 === "$$deleted" && v3 === true) && !(k2 === "$$indexCreated") && !(k2 === "$$indexRemoved")) throw new Error("Field names cannot begin with the $ character");
      if (k2.indexOf(".") !== -1) throw new Error("Field names cannot contain a .");
    };
    var checkObject = (obj) => {
      if (Array.isArray(obj)) {
        obj.forEach((o2) => {
          checkObject(o2);
        });
      }
      if (typeof obj === "object" && obj !== null) {
        for (const k2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k2)) {
            checkKey(k2, obj[k2]);
            checkObject(obj[k2]);
          }
        }
      }
    };
    var serialize = (obj) => {
      return JSON.stringify(obj, function(k2, v3) {
        checkKey(k2, v3);
        if (v3 === void 0) return void 0;
        if (v3 === null) return null;
        if (typeof this[k2].getTime === "function") return { $$date: this[k2].getTime() };
        return v3;
      });
    };
    var deserialize = (rawData) => JSON.parse(rawData, function(k2, v3) {
      if (k2 === "$$date") return new Date(v3);
      if (typeof v3 === "string" || typeof v3 === "number" || typeof v3 === "boolean" || v3 === null) return v3;
      if (v3 && v3.$$date) return v3.$$date;
      return v3;
    });
    function deepCopy(obj, strictKeys) {
      if (typeof obj === "boolean" || typeof obj === "number" || typeof obj === "string" || obj === null || isDate4(obj)) return obj;
      if (Array.isArray(obj)) return obj.map((o2) => deepCopy(o2, strictKeys));
      if (typeof obj === "object") {
        const res = {};
        for (const k2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k2) && (!strictKeys || k2[0] !== "$" && k2.indexOf(".") === -1)) {
            res[k2] = deepCopy(obj[k2], strictKeys);
          }
        }
        return res;
      }
      return void 0;
    }
    var isPrimitiveType = (obj) => typeof obj === "boolean" || typeof obj === "number" || typeof obj === "string" || obj === null || isDate4(obj) || Array.isArray(obj);
    var compareNSB = (a2, b2) => {
      if (a2 < b2) return -1;
      if (a2 > b2) return 1;
      return 0;
    };
    var compareArrays = (a2, b2) => {
      const minLength = Math.min(a2.length, b2.length);
      for (let i2 = 0; i2 < minLength; i2 += 1) {
        const comp = compareThings(a2[i2], b2[i2]);
        if (comp !== 0) return comp;
      }
      return compareNSB(a2.length, b2.length);
    };
    var compareThings = (a2, b2, _compareStrings) => {
      const compareStrings = _compareStrings || compareNSB;
      if (a2 === void 0) return b2 === void 0 ? 0 : -1;
      if (b2 === void 0) return 1;
      if (a2 === null) return b2 === null ? 0 : -1;
      if (b2 === null) return 1;
      if (typeof a2 === "number") return typeof b2 === "number" ? compareNSB(a2, b2) : -1;
      if (typeof b2 === "number") return typeof a2 === "number" ? compareNSB(a2, b2) : 1;
      if (typeof a2 === "string") return typeof b2 === "string" ? compareStrings(a2, b2) : -1;
      if (typeof b2 === "string") return typeof a2 === "string" ? compareStrings(a2, b2) : 1;
      if (typeof a2 === "boolean") return typeof b2 === "boolean" ? compareNSB(a2, b2) : -1;
      if (typeof b2 === "boolean") return typeof a2 === "boolean" ? compareNSB(a2, b2) : 1;
      if (isDate4(a2)) return isDate4(b2) ? compareNSB(a2.getTime(), b2.getTime()) : -1;
      if (isDate4(b2)) return isDate4(a2) ? compareNSB(a2.getTime(), b2.getTime()) : 1;
      if (Array.isArray(a2)) return Array.isArray(b2) ? compareArrays(a2, b2) : -1;
      if (Array.isArray(b2)) return Array.isArray(a2) ? compareArrays(a2, b2) : 1;
      const aKeys = Object.keys(a2).sort();
      const bKeys = Object.keys(b2).sort();
      for (let i2 = 0; i2 < Math.min(aKeys.length, bKeys.length); i2 += 1) {
        const comp = compareThings(a2[aKeys[i2]], b2[bKeys[i2]]);
        if (comp !== 0) return comp;
      }
      return compareNSB(aKeys.length, bKeys.length);
    };
    var createModifierFunction = (lastStepModifierFunction, unset2 = false) => (obj, field, value) => {
      const func = (obj2, field2, value2) => {
        const fieldParts = typeof field2 === "string" ? field2.split(".") : field2;
        if (fieldParts.length === 1) lastStepModifierFunction(obj2, field2, value2);
        else {
          if (obj2[fieldParts[0]] === void 0) {
            if (unset2) return;
            obj2[fieldParts[0]] = {};
          }
          func(obj2[fieldParts[0]], fieldParts.slice(1), value2);
        }
      };
      return func(obj, field, value);
    };
    var $addToSetPartial = (obj, field, value) => {
      if (!Object.prototype.hasOwnProperty.call(obj, field)) {
        obj[field] = [];
      }
      if (!Array.isArray(obj[field])) throw new Error("Can't $addToSet an element on non-array values");
      if (value !== null && typeof value === "object" && value.$each) {
        if (Object.keys(value).length > 1) throw new Error("Can't use another field in conjunction with $each");
        if (!Array.isArray(value.$each)) throw new Error("$each requires an array value");
        value.$each.forEach((v3) => {
          $addToSetPartial(obj, field, v3);
        });
      } else {
        let addToSet = true;
        obj[field].forEach((v3) => {
          if (compareThings(v3, value) === 0) addToSet = false;
        });
        if (addToSet) obj[field].push(value);
      }
    };
    var modifierFunctions = {
      /**
       * Set a field to a new value
       */
      $set: createModifierFunction((obj, field, value) => {
        obj[field] = value;
      }),
      /**
       * Unset a field
       */
      $unset: createModifierFunction((obj, field, value) => {
        delete obj[field];
      }, true),
      /**
       * Updates the value of the field, only if specified field is smaller than the current value of the field
       */
      $min: createModifierFunction((obj, field, value) => {
        if (typeof obj[field] === "undefined") obj[field] = value;
        else if (value < obj[field]) obj[field] = value;
      }),
      /**
       * Updates the value of the field, only if specified field is greater than the current value of the field
       */
      $max: createModifierFunction((obj, field, value) => {
        if (typeof obj[field] === "undefined") obj[field] = value;
        else if (value > obj[field]) obj[field] = value;
      }),
      /**
       * Increment a numeric field's value
       */
      $inc: createModifierFunction((obj, field, value) => {
        if (typeof value !== "number") throw new Error(`${value} must be a number`);
        if (typeof obj[field] !== "number") {
          if (!Object.prototype.hasOwnProperty.call(obj, field)) obj[field] = value;
          else throw new Error("Don't use the $inc modifier on non-number fields");
        } else obj[field] += value;
      }),
      /**
       * Removes all instances of a value from an existing array
       */
      $pull: createModifierFunction((obj, field, value) => {
        if (!Array.isArray(obj[field])) throw new Error("Can't $pull an element from non-array values");
        const arr = obj[field];
        for (let i2 = arr.length - 1; i2 >= 0; i2 -= 1) {
          if (match(arr[i2], value)) arr.splice(i2, 1);
        }
      }),
      /**
       * Remove the first or last element of an array
       */
      $pop: createModifierFunction((obj, field, value) => {
        if (!Array.isArray(obj[field])) throw new Error("Can't $pop an element from non-array values");
        if (typeof value !== "number") throw new Error(`${value} isn't an integer, can't use it with $pop`);
        if (value === 0) return;
        if (value > 0) obj[field] = obj[field].slice(0, obj[field].length - 1);
        else obj[field] = obj[field].slice(1);
      }),
      /**
       * Add an element to an array field only if it is not already in it
       * No modification if the element is already in the array
       * Note that it doesn't check whether the original array contains duplicates
       */
      $addToSet: createModifierFunction($addToSetPartial),
      /**
       * Push an element to the end of an array field
       * Optional modifier $each instead of value to push several values
       * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/
       * Difference with MongoDB: if $slice is specified and not $each, we act as if value is an empty array
       */
      $push: createModifierFunction((obj, field, value) => {
        if (!Object.prototype.hasOwnProperty.call(obj, field)) obj[field] = [];
        if (!Array.isArray(obj[field])) throw new Error("Can't $push an element on non-array values");
        if (value !== null && typeof value === "object" && value.$slice && value.$each === void 0) value.$each = [];
        if (value !== null && typeof value === "object" && value.$each) {
          if (Object.keys(value).length >= 3 || Object.keys(value).length === 2 && value.$slice === void 0) throw new Error("Can only use $slice in cunjunction with $each when $push to array");
          if (!Array.isArray(value.$each)) throw new Error("$each requires an array value");
          value.$each.forEach((v3) => {
            obj[field].push(v3);
          });
          if (value.$slice === void 0 || typeof value.$slice !== "number") return;
          if (value.$slice === 0) obj[field] = [];
          else {
            let start;
            let end;
            const n2 = obj[field].length;
            if (value.$slice < 0) {
              start = Math.max(0, n2 + value.$slice);
              end = n2;
            } else if (value.$slice > 0) {
              start = 0;
              end = Math.min(n2, value.$slice);
            }
            obj[field] = obj[field].slice(start, end);
          }
        } else {
          obj[field].push(value);
        }
      })
    };
    var modify = (obj, updateQuery) => {
      const keys2 = Object.keys(updateQuery);
      const firstChars = keys2.map((item) => item[0]);
      const dollarFirstChars = firstChars.filter((c2) => c2 === "$");
      let newDoc;
      let modifiers;
      if (keys2.indexOf("_id") !== -1 && updateQuery._id !== obj._id) throw new Error("You cannot change a document's _id");
      if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) throw new Error("You cannot mix modifiers and normal fields");
      if (dollarFirstChars.length === 0) {
        newDoc = deepCopy(updateQuery);
        newDoc._id = obj._id;
      } else {
        modifiers = uniq3(keys2);
        newDoc = deepCopy(obj);
        modifiers.forEach((m3) => {
          if (!modifierFunctions[m3]) throw new Error(`Unknown modifier ${m3}`);
          if (typeof updateQuery[m3] !== "object") throw new Error(`Modifier ${m3}'s argument must be an object`);
          const keys3 = Object.keys(updateQuery[m3]);
          keys3.forEach((k2) => {
            modifierFunctions[m3](newDoc, k2, updateQuery[m3][k2]);
          });
        });
      }
      checkObject(newDoc);
      if (obj._id !== newDoc._id) throw new Error("You can't change a document's _id");
      return newDoc;
    };
    var getDotValue = (obj, field) => {
      const fieldParts = typeof field === "string" ? field.split(".") : field;
      if (!obj) return void 0;
      if (fieldParts.length === 0) return obj;
      if (fieldParts.length === 1) return obj[fieldParts[0]];
      if (Array.isArray(obj[fieldParts[0]])) {
        const i2 = parseInt(fieldParts[1], 10);
        if (typeof i2 === "number" && !isNaN(i2)) return getDotValue(obj[fieldParts[0]][i2], fieldParts.slice(2));
        return obj[fieldParts[0]].map((el) => getDotValue(el, fieldParts.slice(1)));
      } else return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));
    };
    var getDotValues = (obj, fields) => {
      if (!Array.isArray(fields)) throw new Error("fields must be an Array");
      if (fields.length > 1) {
        const key = {};
        for (const field of fields) {
          key[field] = getDotValue(obj, field);
        }
        return key;
      } else return getDotValue(obj, fields[0]);
    };
    var areThingsEqual = (a2, b2) => {
      if (a2 === null || typeof a2 === "string" || typeof a2 === "boolean" || typeof a2 === "number" || b2 === null || typeof b2 === "string" || typeof b2 === "boolean" || typeof b2 === "number") return a2 === b2;
      if (isDate4(a2) || isDate4(b2)) return isDate4(a2) && isDate4(b2) && a2.getTime() === b2.getTime();
      if (!(Array.isArray(a2) && Array.isArray(b2)) && (Array.isArray(a2) || Array.isArray(b2)) || a2 === void 0 || b2 === void 0) return false;
      let aKeys;
      let bKeys;
      try {
        aKeys = Object.keys(a2);
        bKeys = Object.keys(b2);
      } catch (e2) {
        return false;
      }
      if (aKeys.length !== bKeys.length) return false;
      for (const el of aKeys) {
        if (bKeys.indexOf(el) === -1) return false;
        if (!areThingsEqual(a2[el], b2[el])) return false;
      }
      return true;
    };
    var areComparable = (a2, b2) => {
      if (typeof a2 !== "string" && typeof a2 !== "number" && !isDate4(a2) && typeof b2 !== "string" && typeof b2 !== "number" && !isDate4(b2)) return false;
      if (typeof a2 !== typeof b2) return false;
      return true;
    };
    var comparisonFunctions = {
      /** Lower than */
      $lt: (a2, b2) => areComparable(a2, b2) && a2 < b2,
      /** Lower than or equals */
      $lte: (a2, b2) => areComparable(a2, b2) && a2 <= b2,
      /** Greater than */
      $gt: (a2, b2) => areComparable(a2, b2) && a2 > b2,
      /** Greater than or equals */
      $gte: (a2, b2) => areComparable(a2, b2) && a2 >= b2,
      /** Does not equal */
      $ne: (a2, b2) => a2 === void 0 || !areThingsEqual(a2, b2),
      /** Is in Array */
      $in: (a2, b2) => {
        if (!Array.isArray(b2)) throw new Error("$in operator called with a non-array");
        for (const el of b2) {
          if (areThingsEqual(a2, el)) return true;
        }
        return false;
      },
      /** Is not in Array */
      $nin: (a2, b2) => {
        if (!Array.isArray(b2)) throw new Error("$nin operator called with a non-array");
        return !comparisonFunctions.$in(a2, b2);
      },
      /** Matches Regexp */
      $regex: (a2, b2) => {
        if (!isRegExp4(b2)) throw new Error("$regex operator called with non regular expression");
        if (typeof a2 !== "string") return false;
        else return b2.test(a2);
      },
      /** Returns true if field exists */
      $exists: (a2, b2) => {
        if (b2 || b2 === "") b2 = true;
        else b2 = false;
        if (a2 === void 0) return !b2;
        else return b2;
      },
      /** Specific to Arrays, returns true if a length equals b */
      $size: (a2, b2) => {
        if (!Array.isArray(a2)) return false;
        if (b2 % 1 !== 0) throw new Error("$size operator called without an integer");
        return a2.length === b2;
      },
      /** Specific to Arrays, returns true if some elements of a match the query b */
      $elemMatch: (a2, b2) => {
        if (!Array.isArray(a2)) return false;
        return a2.some((el) => match(el, b2));
      }
    };
    var arrayComparisonFunctions = { $size: true, $elemMatch: true };
    var logicalOperators = {
      /**
       * Match any of the subqueries
       * @param {document} obj
       * @param {query[]} query
       * @return {boolean}
       */
      $or: (obj, query) => {
        if (!Array.isArray(query)) throw new Error("$or operator used without an array");
        for (let i2 = 0; i2 < query.length; i2 += 1) {
          if (match(obj, query[i2])) return true;
        }
        return false;
      },
      /**
       * Match all of the subqueries
       * @param {document} obj
       * @param {query[]} query
       * @return {boolean}
       */
      $and: (obj, query) => {
        if (!Array.isArray(query)) throw new Error("$and operator used without an array");
        for (let i2 = 0; i2 < query.length; i2 += 1) {
          if (!match(obj, query[i2])) return false;
        }
        return true;
      },
      /**
       * Inverted match of the query
       * @param {document} obj
       * @param {query} query
       * @return {boolean}
       */
      $not: (obj, query) => !match(obj, query),
      /**
       * @callback whereCallback
       * @param {document} obj
       * @return {boolean}
       */
      /**
       * Use a function to match
       * @param {document} obj
       * @param {whereCallback} fn
       * @return {boolean}
       */
      $where: (obj, fn) => {
        if (typeof fn !== "function") throw new Error("$where operator used without a function");
        const result2 = fn.call(obj);
        if (typeof result2 !== "boolean") throw new Error("$where function must return boolean");
        return result2;
      }
    };
    var match = (obj, query) => {
      if (isPrimitiveType(obj) || isPrimitiveType(query)) return matchQueryPart({ needAKey: obj }, "needAKey", query);
      for (const queryKey in query) {
        if (Object.prototype.hasOwnProperty.call(query, queryKey)) {
          const queryValue = query[queryKey];
          if (queryKey[0] === "$") {
            if (!logicalOperators[queryKey]) throw new Error(`Unknown logical operator ${queryKey}`);
            if (!logicalOperators[queryKey](obj, queryValue)) return false;
          } else if (!matchQueryPart(obj, queryKey, queryValue)) return false;
        }
      }
      return true;
    };
    function matchQueryPart(obj, queryKey, queryValue, treatObjAsValue) {
      const objValue = getDotValue(obj, queryKey);
      if (Array.isArray(objValue) && !treatObjAsValue) {
        if (Array.isArray(queryValue)) return matchQueryPart(obj, queryKey, queryValue, true);
        if (queryValue !== null && typeof queryValue === "object" && !isRegExp4(queryValue)) {
          for (const key in queryValue) {
            if (Object.prototype.hasOwnProperty.call(queryValue, key) && arrayComparisonFunctions[key]) {
              return matchQueryPart(obj, queryKey, queryValue, true);
            }
          }
        }
        for (const el of objValue) {
          if (matchQueryPart({ k: el }, "k", queryValue)) return true;
        }
        return false;
      }
      if (queryValue !== null && typeof queryValue === "object" && !isRegExp4(queryValue) && !Array.isArray(queryValue)) {
        const keys2 = Object.keys(queryValue);
        const firstChars = keys2.map((item) => item[0]);
        const dollarFirstChars = firstChars.filter((c2) => c2 === "$");
        if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) throw new Error("You cannot mix operators and normal fields");
        if (dollarFirstChars.length > 0) {
          for (const key of keys2) {
            if (!comparisonFunctions[key]) throw new Error(`Unknown comparison function ${key}`);
            if (!comparisonFunctions[key](objValue, queryValue[key])) return false;
          }
          return true;
        }
      }
      if (isRegExp4(queryValue)) return comparisonFunctions.$regex(objValue, queryValue);
      return areThingsEqual(objValue, queryValue);
    }
    module2.exports.serialize = serialize;
    module2.exports.deserialize = deserialize;
    module2.exports.deepCopy = deepCopy;
    module2.exports.checkObject = checkObject;
    module2.exports.isPrimitiveType = isPrimitiveType;
    module2.exports.modify = modify;
    module2.exports.getDotValue = getDotValue;
    module2.exports.getDotValues = getDotValues;
    module2.exports.match = match;
    module2.exports.areThingsEqual = areThingsEqual;
    module2.exports.compareThings = compareThings;
  }
});

// ../../node_modules/@seald-io/nedb/lib/cursor.js
var require_cursor = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/cursor.js"(exports2, module2) {
    var model = require_model();
    var { callbackify } = require("util");
    var Cursor = class {
      /**
       * Create a new cursor for this collection.
       * @param {Datastore} db - The datastore this cursor is bound to
       * @param {query} query - The query this cursor will operate on
       * @param {Cursor~mapFn} [mapFn] - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove
       */
      constructor(db, query, mapFn) {
        this.db = db;
        this.query = query || {};
        if (mapFn) this.mapFn = mapFn;
        this._limit = void 0;
        this._skip = void 0;
        this._sort = void 0;
        this._projection = void 0;
      }
      /**
       * Set a limit to the number of results for the given Cursor.
       * @param {Number} limit
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      limit(limit) {
        this._limit = limit;
        return this;
      }
      /**
       * Skip a number of results for the given Cursor.
       * @param {Number} skip
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      skip(skip2) {
        this._skip = skip2;
        return this;
      }
      /**
       * Sort results of the query for the given Cursor.
       * @param {Object.<string, number>} sortQuery - sortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      sort(sortQuery) {
        this._sort = sortQuery;
        return this;
      }
      /**
       * Add the use of a projection to the given Cursor.
       * @param {Object.<string, number>} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2
       * { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits.
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      projection(projection) {
        this._projection = projection;
        return this;
      }
      /**
       * Apply the projection.
       *
       * This is an internal function. You should use {@link Cursor#execAsync} or {@link Cursor#exec}.
       * @param {document[]} candidates
       * @return {document[]}
       * @private
       */
      _project(candidates) {
        const res = [];
        let action;
        if (this._projection === void 0 || Object.keys(this._projection).length === 0) {
          return candidates;
        }
        const keepId = this._projection._id !== 0;
        const { _id, ...rest3 } = this._projection;
        this._projection = rest3;
        const keys2 = Object.keys(this._projection);
        keys2.forEach((k2) => {
          if (action !== void 0 && this._projection[k2] !== action) throw new Error("Can't both keep and omit fields except for _id");
          action = this._projection[k2];
        });
        candidates.forEach((candidate) => {
          let toPush;
          if (action === 1) {
            toPush = { $set: {} };
            keys2.forEach((k2) => {
              toPush.$set[k2] = model.getDotValue(candidate, k2);
              if (toPush.$set[k2] === void 0) delete toPush.$set[k2];
            });
            toPush = model.modify({}, toPush);
          } else {
            toPush = { $unset: {} };
            keys2.forEach((k2) => {
              toPush.$unset[k2] = true;
            });
            toPush = model.modify(candidate, toPush);
          }
          if (keepId) toPush._id = candidate._id;
          else delete toPush._id;
          res.push(toPush);
        });
        return res;
      }
      /**
       * Get all matching elements
       * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne
       * This is an internal function, use execAsync which uses the executor
       * @return {document[]|Promise<*>}
       * @private
       */
      async _execAsync() {
        let res = [];
        let added = 0;
        let skipped = 0;
        const candidates = await this.db._getCandidatesAsync(this.query);
        for (const candidate of candidates) {
          if (model.match(candidate, this.query)) {
            if (!this._sort) {
              if (this._skip && this._skip > skipped) skipped += 1;
              else {
                res.push(candidate);
                added += 1;
                if (this._limit && this._limit <= added) break;
              }
            } else res.push(candidate);
          }
        }
        if (this._sort) {
          const criteria = Object.entries(this._sort).map(([key, direction]) => ({ key, direction }));
          res.sort((a2, b2) => {
            for (const criterion of criteria) {
              const compare = criterion.direction * model.compareThings(model.getDotValue(a2, criterion.key), model.getDotValue(b2, criterion.key), this.db.compareStrings);
              if (compare !== 0) return compare;
            }
            return 0;
          });
          const limit = this._limit || res.length;
          const skip2 = this._skip || 0;
          res = res.slice(skip2, skip2 + limit);
        }
        res = this._project(res);
        if (this.mapFn) return this.mapFn(res);
        return res;
      }
      /**
       * @callback Cursor~execCallback
       * @param {Error} err
       * @param {document[]|*} res If a mapFn was given to the Cursor, then the type of this parameter is the one returned by the mapFn.
       */
      /**
       * Callback version of {@link Cursor#exec}.
       * @param {Cursor~execCallback} _callback
       * @see Cursor#execAsync
       */
      exec(_callback) {
        callbackify(() => this.execAsync())(_callback);
      }
      /**
       * Get all matching elements.
       * Will return pointers to matched elements (shallow copies), returning full copies is the role of {@link Datastore#findAsync} or {@link Datastore#findOneAsync}.
       * @return {Promise<document[]|*>}
       * @async
       */
      execAsync() {
        return this.db.executor.pushAsync(() => this._execAsync());
      }
      then(onFulfilled, onRejected) {
        return this.execAsync().then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.execAsync().catch(onRejected);
      }
      finally(onFinally) {
        return this.execAsync().finally(onFinally);
      }
    };
    module2.exports = Cursor;
  }
});

// ../../node_modules/@seald-io/nedb/lib/customUtils.js
var require_customUtils = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/customUtils.js"(exports2, module2) {
    var crypto3 = require("crypto");
    var uid = (len) => crypto3.randomBytes(Math.ceil(Math.max(8, len * 2))).toString("base64").replace(/[+/]/g, "").slice(0, len);
    module2.exports.uid = uid;
  }
});

// ../../node_modules/@seald-io/nedb/lib/waterfall.js
var require_waterfall = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/waterfall.js"(exports2, module2) {
    var Waterfall = class {
      /**
       * Instantiate a new Waterfall.
       */
      constructor() {
        this.guardian = Promise.resolve();
      }
      /**
       *
       * @param {AsyncFunction} func
       * @return {AsyncFunction}
       */
      waterfall(func) {
        return (...args) => {
          this.guardian = this.guardian.then(() => {
            return func(...args).then((result2) => ({ error: false, result: result2 }), (result2) => ({ error: true, result: result2 }));
          });
          return this.guardian.then(({ error, result: result2 }) => {
            if (error) return Promise.reject(result2);
            else return Promise.resolve(result2);
          });
        };
      }
      /**
       * Shorthand for chaining a promise to the Waterfall
       * @param {Promise} promise
       * @return {Promise}
       */
      chain(promise) {
        return this.waterfall(() => promise)();
      }
    };
    module2.exports = Waterfall;
  }
});

// ../../node_modules/@seald-io/nedb/lib/executor.js
var require_executor = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/executor.js"(exports2, module2) {
    var Waterfall = require_waterfall();
    var Executor = class {
      /**
       * Instantiates a new Executor.
       */
      constructor() {
        this.ready = false;
        this.queue = new Waterfall();
        this.buffer = null;
        this._triggerBuffer = null;
        this.resetBuffer();
      }
      /**
       * If executor is ready, queue task (and process it immediately if executor was idle)
       * If not, buffer task for later processing
       * @param {AsyncFunction} task Function to execute
       * @param {boolean} [forceQueuing = false] Optional (defaults to false) force executor to queue task even if it is not ready
       * @return {Promise<*>}
       * @async
       * @see Executor#push
       */
      pushAsync(task, forceQueuing = false) {
        if (this.ready || forceQueuing) return this.queue.waterfall(task)();
        else return this.buffer.waterfall(task)();
      }
      /**
       * Queue all tasks in buffer (in the same order they came in)
       * Automatically sets executor as ready
       */
      processBuffer() {
        this.ready = true;
        this._triggerBuffer();
        this.queue.waterfall(() => this.buffer.guardian);
      }
      /**
       * Removes all tasks queued up in the buffer
       */
      resetBuffer() {
        this.buffer = new Waterfall();
        this.buffer.chain(new Promise((resolve) => {
          this._triggerBuffer = resolve;
        }));
        if (this.ready) this._triggerBuffer();
      }
    };
    module2.exports = Executor;
  }
});

// ../../node_modules/@seald-io/binary-search-tree/lib/customUtils.js
var require_customUtils2 = __commonJS({
  "../../node_modules/@seald-io/binary-search-tree/lib/customUtils.js"(exports2, module2) {
    var getRandomArray = (n2) => {
      if (n2 === 0) return [];
      if (n2 === 1) return [0];
      const res = getRandomArray(n2 - 1);
      const next = Math.floor(Math.random() * n2);
      res.splice(next, 0, n2 - 1);
      return res;
    };
    module2.exports.getRandomArray = getRandomArray;
    var defaultCompareKeysFunction = (a2, b2) => {
      if (a2 < b2) return -1;
      if (a2 > b2) return 1;
      if (a2 === b2) return 0;
      const err = new Error("Couldn't compare elements");
      err.a = a2;
      err.b = b2;
      throw err;
    };
    module2.exports.defaultCompareKeysFunction = defaultCompareKeysFunction;
    var defaultCheckValueEquality = (a2, b2) => a2 === b2;
    module2.exports.defaultCheckValueEquality = defaultCheckValueEquality;
  }
});

// ../../node_modules/@seald-io/binary-search-tree/lib/bst.js
var require_bst = __commonJS({
  "../../node_modules/@seald-io/binary-search-tree/lib/bst.js"(exports2, module2) {
    var customUtils = require_customUtils2();
    var BinarySearchTree = class {
      /**
       * Constructor
       * @param {Object} options Optional
       * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
       * @param {Key}      options.key Initialize this BST's key with key
       * @param {Value}    options.value Initialize this BST's data with [value]
       * @param {Function} options.compareKeys Initialize this BST's compareKeys
       */
      constructor(options) {
        options = options || {};
        this.left = null;
        this.right = null;
        this.parent = options.parent !== void 0 ? options.parent : null;
        if (Object.prototype.hasOwnProperty.call(options, "key")) {
          this.key = options.key;
        }
        this.data = Object.prototype.hasOwnProperty.call(options, "value") ? [options.value] : [];
        this.unique = options.unique || false;
        this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;
        this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;
      }
      /**
       * Get the descendant with max key
       */
      getMaxKeyDescendant() {
        if (this.right) return this.right.getMaxKeyDescendant();
        else return this;
      }
      /**
       * Get the maximum key
       */
      getMaxKey() {
        return this.getMaxKeyDescendant().key;
      }
      /**
       * Get the descendant with min key
       */
      getMinKeyDescendant() {
        if (this.left) return this.left.getMinKeyDescendant();
        else return this;
      }
      /**
       * Get the minimum key
       */
      getMinKey() {
        return this.getMinKeyDescendant().key;
      }
      /**
       * Check that all nodes (incl. leaves) fullfil condition given by fn
       * test is a function passed every (key, data) and which throws if the condition is not met
       */
      checkAllNodesFullfillCondition(test2) {
        if (!Object.prototype.hasOwnProperty.call(this, "key")) return;
        test2(this.key, this.data);
        if (this.left) this.left.checkAllNodesFullfillCondition(test2);
        if (this.right) this.right.checkAllNodesFullfillCondition(test2);
      }
      /**
       * Check that the core BST properties on node ordering are verified
       * Throw if they aren't
       */
      checkNodeOrdering() {
        if (!Object.prototype.hasOwnProperty.call(this, "key")) return;
        if (this.left) {
          this.left.checkAllNodesFullfillCondition((k2) => {
            if (this.compareKeys(k2, this.key) >= 0) throw new Error(`Tree with root ${this.key} is not a binary search tree`);
          });
          this.left.checkNodeOrdering();
        }
        if (this.right) {
          this.right.checkAllNodesFullfillCondition((k2) => {
            if (this.compareKeys(k2, this.key) <= 0) throw new Error(`Tree with root ${this.key} is not a binary search tree`);
          });
          this.right.checkNodeOrdering();
        }
      }
      /**
       * Check that all pointers are coherent in this tree
       */
      checkInternalPointers() {
        if (this.left) {
          if (this.left.parent !== this) throw new Error(`Parent pointer broken for key ${this.key}`);
          this.left.checkInternalPointers();
        }
        if (this.right) {
          if (this.right.parent !== this) throw new Error(`Parent pointer broken for key ${this.key}`);
          this.right.checkInternalPointers();
        }
      }
      /**
       * Check that a tree is a BST as defined here (node ordering and pointer references)
       */
      checkIsBST() {
        this.checkNodeOrdering();
        this.checkInternalPointers();
        if (this.parent) throw new Error("The root shouldn't have a parent");
      }
      /**
       * Get number of keys inserted
       */
      getNumberOfKeys() {
        let res;
        if (!Object.prototype.hasOwnProperty.call(this, "key")) return 0;
        res = 1;
        if (this.left) res += this.left.getNumberOfKeys();
        if (this.right) res += this.right.getNumberOfKeys();
        return res;
      }
      /**
       * Create a BST similar (i.e. same options except for key and value) to the current one
       * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)
       * @param {Object} options see constructor
       */
      createSimilar(options) {
        options = options || {};
        options.unique = this.unique;
        options.compareKeys = this.compareKeys;
        options.checkValueEquality = this.checkValueEquality;
        return new this.constructor(options);
      }
      /**
       * Create the left child of this BST and return it
       */
      createLeftChild(options) {
        const leftChild = this.createSimilar(options);
        leftChild.parent = this;
        this.left = leftChild;
        return leftChild;
      }
      /**
       * Create the right child of this BST and return it
       */
      createRightChild(options) {
        const rightChild = this.createSimilar(options);
        rightChild.parent = this;
        this.right = rightChild;
        return rightChild;
      }
      /**
       * Insert a new element
       */
      insert(key, value) {
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          this.key = key;
          this.data.push(value);
          return;
        }
        if (this.compareKeys(this.key, key) === 0) {
          if (this.unique) {
            const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`);
            err.key = key;
            err.errorType = "uniqueViolated";
            throw err;
          } else this.data.push(value);
          return;
        }
        if (this.compareKeys(key, this.key) < 0) {
          if (this.left) this.left.insert(key, value);
          else this.createLeftChild({ key, value });
        } else {
          if (this.right) this.right.insert(key, value);
          else this.createRightChild({ key, value });
        }
      }
      /**
       * Search for all data corresponding to a key
       */
      search(key) {
        if (!Object.prototype.hasOwnProperty.call(this, "key")) return [];
        if (this.compareKeys(this.key, key) === 0) return this.data;
        if (this.compareKeys(key, this.key) < 0) {
          if (this.left) return this.left.search(key);
          else return [];
        } else {
          if (this.right) return this.right.search(key);
          else return [];
        }
      }
      /**
       * Return a function that tells whether a given key matches a lower bound
       */
      getLowerBoundMatcher(query) {
        if (!Object.prototype.hasOwnProperty.call(query, "$gt") && !Object.prototype.hasOwnProperty.call(query, "$gte")) return () => true;
        if (Object.prototype.hasOwnProperty.call(query, "$gt") && Object.prototype.hasOwnProperty.call(query, "$gte")) {
          if (this.compareKeys(query.$gte, query.$gt) === 0) return (key) => this.compareKeys(key, query.$gt) > 0;
          if (this.compareKeys(query.$gte, query.$gt) > 0) return (key) => this.compareKeys(key, query.$gte) >= 0;
          else return (key) => this.compareKeys(key, query.$gt) > 0;
        }
        if (Object.prototype.hasOwnProperty.call(query, "$gt")) return (key) => this.compareKeys(key, query.$gt) > 0;
        else return (key) => this.compareKeys(key, query.$gte) >= 0;
      }
      /**
       * Return a function that tells whether a given key matches an upper bound
       */
      getUpperBoundMatcher(query) {
        if (!Object.prototype.hasOwnProperty.call(query, "$lt") && !Object.prototype.hasOwnProperty.call(query, "$lte")) return () => true;
        if (Object.prototype.hasOwnProperty.call(query, "$lt") && Object.prototype.hasOwnProperty.call(query, "$lte")) {
          if (this.compareKeys(query.$lte, query.$lt) === 0) return (key) => this.compareKeys(key, query.$lt) < 0;
          if (this.compareKeys(query.$lte, query.$lt) < 0) return (key) => this.compareKeys(key, query.$lte) <= 0;
          else return (key) => this.compareKeys(key, query.$lt) < 0;
        }
        if (Object.prototype.hasOwnProperty.call(query, "$lt")) return (key) => this.compareKeys(key, query.$lt) < 0;
        else return (key) => this.compareKeys(key, query.$lte) <= 0;
      }
      /**
       * Get all data for a key between bounds
       * Return it in key order
       * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)
       * @param {Functions} lbm/ubm matching functions calculated at the first recursive step
       */
      betweenBounds(query, lbm, ubm) {
        const res = [];
        if (!Object.prototype.hasOwnProperty.call(this, "key")) return [];
        lbm = lbm || this.getLowerBoundMatcher(query);
        ubm = ubm || this.getUpperBoundMatcher(query);
        if (lbm(this.key) && this.left) append(res, this.left.betweenBounds(query, lbm, ubm));
        if (lbm(this.key) && ubm(this.key)) append(res, this.data);
        if (ubm(this.key) && this.right) append(res, this.right.betweenBounds(query, lbm, ubm));
        return res;
      }
      /**
       * Delete the current node if it is a leaf
       * Return true if it was deleted
       */
      deleteIfLeaf() {
        if (this.left || this.right) return false;
        if (!this.parent) {
          delete this.key;
          this.data = [];
          return true;
        }
        if (this.parent.left === this) this.parent.left = null;
        else this.parent.right = null;
        return true;
      }
      /**
       * Delete the current node if it has only one child
       * Return true if it was deleted
       */
      deleteIfOnlyOneChild() {
        let child;
        if (this.left && !this.right) child = this.left;
        if (!this.left && this.right) child = this.right;
        if (!child) return false;
        if (!this.parent) {
          this.key = child.key;
          this.data = child.data;
          this.left = null;
          if (child.left) {
            this.left = child.left;
            child.left.parent = this;
          }
          this.right = null;
          if (child.right) {
            this.right = child.right;
            child.right.parent = this;
          }
          return true;
        }
        if (this.parent.left === this) {
          this.parent.left = child;
          child.parent = this.parent;
        } else {
          this.parent.right = child;
          child.parent = this.parent;
        }
        return true;
      }
      /**
       * Delete a key or just a value
       * @param {Key} key
       * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted
       */
      delete(key, value) {
        const newData = [];
        let replaceWith;
        if (!Object.prototype.hasOwnProperty.call(this, "key")) return;
        if (this.compareKeys(key, this.key) < 0) {
          if (this.left) this.left.delete(key, value);
          return;
        }
        if (this.compareKeys(key, this.key) > 0) {
          if (this.right) this.right.delete(key, value);
          return;
        }
        if (!this.compareKeys(key, this.key) === 0) return;
        if (this.data.length > 1 && value !== void 0) {
          this.data.forEach((d2) => {
            if (!this.checkValueEquality(d2, value)) newData.push(d2);
          });
          this.data = newData;
          return;
        }
        if (this.deleteIfLeaf()) return;
        if (this.deleteIfOnlyOneChild()) return;
        if (Math.random() >= 0.5) {
          replaceWith = this.left.getMaxKeyDescendant();
          this.key = replaceWith.key;
          this.data = replaceWith.data;
          if (this === replaceWith.parent) {
            this.left = replaceWith.left;
            if (replaceWith.left) replaceWith.left.parent = replaceWith.parent;
          } else {
            replaceWith.parent.right = replaceWith.left;
            if (replaceWith.left) replaceWith.left.parent = replaceWith.parent;
          }
        } else {
          replaceWith = this.right.getMinKeyDescendant();
          this.key = replaceWith.key;
          this.data = replaceWith.data;
          if (this === replaceWith.parent) {
            this.right = replaceWith.right;
            if (replaceWith.right) replaceWith.right.parent = replaceWith.parent;
          } else {
            replaceWith.parent.left = replaceWith.right;
            if (replaceWith.right) replaceWith.right.parent = replaceWith.parent;
          }
        }
      }
      /**
       * Execute a function on every node of the tree, in key order
       * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data
       */
      executeOnEveryNode(fn) {
        if (this.left) this.left.executeOnEveryNode(fn);
        fn(this);
        if (this.right) this.right.executeOnEveryNode(fn);
      }
      /**
       * Pretty print a tree
       * @param {Boolean} printData To print the nodes' data along with the key
       */
      prettyPrint(printData, spacing) {
        spacing = spacing || "";
        console.log(`${spacing}* ${this.key}`);
        if (printData) console.log(`${spacing}* ${this.data}`);
        if (!this.left && !this.right) return;
        if (this.left) this.left.prettyPrint(printData, `${spacing}  `);
        else console.log(`${spacing}  *`);
        if (this.right) this.right.prettyPrint(printData, `${spacing}  `);
        else console.log(`${spacing}  *`);
      }
    };
    function append(array, toAppend) {
      for (let i2 = 0; i2 < toAppend.length; i2 += 1) {
        array.push(toAppend[i2]);
      }
    }
    module2.exports = BinarySearchTree;
  }
});

// ../../node_modules/@seald-io/binary-search-tree/lib/avltree.js
var require_avltree = __commonJS({
  "../../node_modules/@seald-io/binary-search-tree/lib/avltree.js"(exports2, module2) {
    var BinarySearchTree = require_bst();
    var customUtils = require_customUtils2();
    var AVLTree = class {
      /**
       * Constructor
       * We can't use a direct pointer to the root node (as in the simple binary search tree)
       * as the root will change during tree rotations
       * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
       * @param {Function} options.compareKeys Initialize this BST's compareKeys
       */
      constructor(options) {
        this.tree = new _AVLTree(options);
      }
      checkIsAVLT() {
        this.tree.checkIsAVLT();
      }
      // Insert in the internal tree, update the pointer to the root if needed
      insert(key, value) {
        const newTree = this.tree.insert(key, value);
        if (newTree) {
          this.tree = newTree;
        }
      }
      // Delete a value
      delete(key, value) {
        const newTree = this.tree.delete(key, value);
        if (newTree) {
          this.tree = newTree;
        }
      }
    };
    var _AVLTree = class extends BinarySearchTree {
      /**
       * Constructor of the internal AVLTree
       * @param {Object} options Optional
       * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
       * @param {Key}      options.key Initialize this BST's key with key
       * @param {Value}    options.value Initialize this BST's data with [value]
       * @param {Function} options.compareKeys Initialize this BST's compareKeys
       */
      constructor(options) {
        super();
        options = options || {};
        this.left = null;
        this.right = null;
        this.parent = options.parent !== void 0 ? options.parent : null;
        if (Object.prototype.hasOwnProperty.call(options, "key")) this.key = options.key;
        this.data = Object.prototype.hasOwnProperty.call(options, "value") ? [options.value] : [];
        this.unique = options.unique || false;
        this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;
        this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;
      }
      /**
       * Check the recorded height is correct for every node
       * Throws if one height doesn't match
       */
      checkHeightCorrect() {
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          return;
        }
        if (this.left && this.left.height === void 0) {
          throw new Error("Undefined height for node " + this.left.key);
        }
        if (this.right && this.right.height === void 0) {
          throw new Error("Undefined height for node " + this.right.key);
        }
        if (this.height === void 0) {
          throw new Error("Undefined height for node " + this.key);
        }
        const leftH = this.left ? this.left.height : 0;
        const rightH = this.right ? this.right.height : 0;
        if (this.height !== 1 + Math.max(leftH, rightH)) {
          throw new Error("Height constraint failed for node " + this.key);
        }
        if (this.left) {
          this.left.checkHeightCorrect();
        }
        if (this.right) {
          this.right.checkHeightCorrect();
        }
      }
      /**
       * Return the balance factor
       */
      balanceFactor() {
        const leftH = this.left ? this.left.height : 0;
        const rightH = this.right ? this.right.height : 0;
        return leftH - rightH;
      }
      /**
       * Check that the balance factors are all between -1 and 1
       */
      checkBalanceFactors() {
        if (Math.abs(this.balanceFactor()) > 1) {
          throw new Error("Tree is unbalanced at node " + this.key);
        }
        if (this.left) {
          this.left.checkBalanceFactors();
        }
        if (this.right) {
          this.right.checkBalanceFactors();
        }
      }
      /**
       * When checking if the BST conditions are met, also check that the heights are correct
       * and the tree is balanced
       */
      checkIsAVLT() {
        super.checkIsBST();
        this.checkHeightCorrect();
        this.checkBalanceFactors();
      }
      /**
       * Perform a right rotation of the tree if possible
       * and return the root of the resulting tree
       * The resulting tree's nodes' heights are also updated
       */
      rightRotation() {
        const q3 = this;
        const p3 = this.left;
        if (!p3) return q3;
        const b2 = p3.right;
        if (q3.parent) {
          p3.parent = q3.parent;
          if (q3.parent.left === q3) q3.parent.left = p3;
          else q3.parent.right = p3;
        } else {
          p3.parent = null;
        }
        p3.right = q3;
        q3.parent = p3;
        q3.left = b2;
        if (b2) {
          b2.parent = q3;
        }
        const ah = p3.left ? p3.left.height : 0;
        const bh = b2 ? b2.height : 0;
        const ch = q3.right ? q3.right.height : 0;
        q3.height = Math.max(bh, ch) + 1;
        p3.height = Math.max(ah, q3.height) + 1;
        return p3;
      }
      /**
       * Perform a left rotation of the tree if possible
       * and return the root of the resulting tree
       * The resulting tree's nodes' heights are also updated
       */
      leftRotation() {
        const p3 = this;
        const q3 = this.right;
        if (!q3) {
          return this;
        }
        const b2 = q3.left;
        if (p3.parent) {
          q3.parent = p3.parent;
          if (p3.parent.left === p3) p3.parent.left = q3;
          else p3.parent.right = q3;
        } else {
          q3.parent = null;
        }
        q3.left = p3;
        p3.parent = q3;
        p3.right = b2;
        if (b2) {
          b2.parent = p3;
        }
        const ah = p3.left ? p3.left.height : 0;
        const bh = b2 ? b2.height : 0;
        const ch = q3.right ? q3.right.height : 0;
        p3.height = Math.max(ah, bh) + 1;
        q3.height = Math.max(ch, p3.height) + 1;
        return q3;
      }
      /**
       * Modify the tree if its right subtree is too small compared to the left
       * Return the new root if any
       */
      rightTooSmall() {
        if (this.balanceFactor() <= 1) return this;
        if (this.left.balanceFactor() < 0) this.left.leftRotation();
        return this.rightRotation();
      }
      /**
       * Modify the tree if its left subtree is too small compared to the right
       * Return the new root if any
       */
      leftTooSmall() {
        if (this.balanceFactor() >= -1) {
          return this;
        }
        if (this.right.balanceFactor() > 0) this.right.rightRotation();
        return this.leftRotation();
      }
      /**
       * Rebalance the tree along the given path. The path is given reversed (as he was calculated
       * in the insert and delete functions).
       * Returns the new root of the tree
       * Of course, the first element of the path must be the root of the tree
       */
      rebalanceAlongPath(path4) {
        let newRoot = this;
        let rotated;
        let i2;
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          delete this.height;
          return this;
        }
        for (i2 = path4.length - 1; i2 >= 0; i2 -= 1) {
          path4[i2].height = 1 + Math.max(path4[i2].left ? path4[i2].left.height : 0, path4[i2].right ? path4[i2].right.height : 0);
          if (path4[i2].balanceFactor() > 1) {
            rotated = path4[i2].rightTooSmall();
            if (i2 === 0) newRoot = rotated;
          }
          if (path4[i2].balanceFactor() < -1) {
            rotated = path4[i2].leftTooSmall();
            if (i2 === 0) newRoot = rotated;
          }
        }
        return newRoot;
      }
      /**
       * Insert a key, value pair in the tree while maintaining the AVL tree height constraint
       * Return a pointer to the root node, which may have changed
       */
      insert(key, value) {
        const insertPath = [];
        let currentNode = this;
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          this.key = key;
          this.data.push(value);
          this.height = 1;
          return this;
        }
        while (true) {
          if (currentNode.compareKeys(currentNode.key, key) === 0) {
            if (currentNode.unique) {
              const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`);
              err.key = key;
              err.errorType = "uniqueViolated";
              throw err;
            } else currentNode.data.push(value);
            return this;
          }
          insertPath.push(currentNode);
          if (currentNode.compareKeys(key, currentNode.key) < 0) {
            if (!currentNode.left) {
              insertPath.push(currentNode.createLeftChild({ key, value }));
              break;
            } else currentNode = currentNode.left;
          } else {
            if (!currentNode.right) {
              insertPath.push(currentNode.createRightChild({ key, value }));
              break;
            } else currentNode = currentNode.right;
          }
        }
        return this.rebalanceAlongPath(insertPath);
      }
      /**
       * Delete a key or just a value and return the new root of the tree
       * @param {Key} key
       * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted
       */
      delete(key, value) {
        const newData = [];
        let replaceWith;
        let currentNode = this;
        const deletePath = [];
        if (!Object.prototype.hasOwnProperty.call(this, "key")) return this;
        while (true) {
          if (currentNode.compareKeys(key, currentNode.key) === 0) {
            break;
          }
          deletePath.push(currentNode);
          if (currentNode.compareKeys(key, currentNode.key) < 0) {
            if (currentNode.left) {
              currentNode = currentNode.left;
            } else return this;
          } else {
            if (currentNode.right) {
              currentNode = currentNode.right;
            } else return this;
          }
        }
        if (currentNode.data.length > 1 && value !== void 0) {
          currentNode.data.forEach(function(d2) {
            if (!currentNode.checkValueEquality(d2, value)) newData.push(d2);
          });
          currentNode.data = newData;
          return this;
        }
        if (!currentNode.left && !currentNode.right) {
          if (currentNode === this) {
            delete currentNode.key;
            currentNode.data = [];
            delete currentNode.height;
            return this;
          } else {
            if (currentNode.parent.left === currentNode) currentNode.parent.left = null;
            else currentNode.parent.right = null;
            return this.rebalanceAlongPath(deletePath);
          }
        }
        if (!currentNode.left || !currentNode.right) {
          replaceWith = currentNode.left ? currentNode.left : currentNode.right;
          if (currentNode === this) {
            replaceWith.parent = null;
            return replaceWith;
          } else {
            if (currentNode.parent.left === currentNode) {
              currentNode.parent.left = replaceWith;
              replaceWith.parent = currentNode.parent;
            } else {
              currentNode.parent.right = replaceWith;
              replaceWith.parent = currentNode.parent;
            }
            return this.rebalanceAlongPath(deletePath);
          }
        }
        deletePath.push(currentNode);
        replaceWith = currentNode.left;
        if (!replaceWith.right) {
          currentNode.key = replaceWith.key;
          currentNode.data = replaceWith.data;
          currentNode.left = replaceWith.left;
          if (replaceWith.left) {
            replaceWith.left.parent = currentNode;
          }
          return this.rebalanceAlongPath(deletePath);
        }
        while (true) {
          if (replaceWith.right) {
            deletePath.push(replaceWith);
            replaceWith = replaceWith.right;
          } else break;
        }
        currentNode.key = replaceWith.key;
        currentNode.data = replaceWith.data;
        replaceWith.parent.right = replaceWith.left;
        if (replaceWith.left) replaceWith.left.parent = replaceWith.parent;
        return this.rebalanceAlongPath(deletePath);
      }
    };
    AVLTree._AVLTree = _AVLTree;
    ["getNumberOfKeys", "search", "betweenBounds", "prettyPrint", "executeOnEveryNode"].forEach(function(fn) {
      AVLTree.prototype[fn] = function() {
        return this.tree[fn].apply(this.tree, arguments);
      };
    });
    module2.exports = AVLTree;
  }
});

// ../../node_modules/@seald-io/binary-search-tree/index.js
var require_binary_search_tree = __commonJS({
  "../../node_modules/@seald-io/binary-search-tree/index.js"(exports2, module2) {
    module2.exports.BinarySearchTree = require_bst();
    module2.exports.AVLTree = require_avltree();
  }
});

// ../../node_modules/@seald-io/nedb/lib/indexes.js
var require_indexes = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/indexes.js"(exports2, module2) {
    var BinarySearchTree = require_binary_search_tree().AVLTree;
    var model = require_model();
    var { uniq: uniq3, isDate: isDate4 } = require_utils3();
    var checkValueEquality = (a2, b2) => a2 === b2;
    var projectForUnique = (elt) => {
      if (elt === null) return "$null";
      if (typeof elt === "string") return "$string" + elt;
      if (typeof elt === "boolean") return "$boolean" + elt;
      if (typeof elt === "number") return "$number" + elt;
      if (isDate4(elt)) return "$date" + elt.getTime();
      return elt;
    };
    var Index = class {
      /**
       * Create a new index
       * All methods on an index guarantee that either the whole operation was successful and the index changed
       * or the operation was unsuccessful and an error is thrown while the index is unchanged
       * @param {object} options
       * @param {string} options.fieldName On which field should the index apply, can use dot notation to index on sub fields, can use comma-separated notation to use compound indexes
       * @param {boolean} [options.unique = false] Enforces a unique constraint
       * @param {boolean} [options.sparse = false] Allows a sparse index (we can have documents for which fieldName is `undefined`)
       */
      constructor(options) {
        this.fieldName = options.fieldName;
        if (typeof this.fieldName !== "string") throw new Error("fieldName must be a string");
        this._fields = this.fieldName.split(",");
        this.unique = options.unique || false;
        this.sparse = options.sparse || false;
        this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality };
        this.tree = new BinarySearchTree(this.treeOptions);
      }
      /**
       * Reset an index
       * @param {?document|?document[]} [newData] Data to initialize the index with. If an error is thrown during
       * insertion, the index is not modified.
       */
      reset(newData) {
        this.tree = new BinarySearchTree(this.treeOptions);
        if (newData) this.insert(newData);
      }
      /**
       * Insert a new document in the index
       * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)
       * O(log(n))
       * @param {document|document[]} doc The document, or array of documents, to insert.
       */
      insert(doc) {
        let keys2;
        let failingIndex;
        let error;
        if (Array.isArray(doc)) {
          this.insertMultipleDocs(doc);
          return;
        }
        const key = model.getDotValues(doc, this._fields);
        if ((key === void 0 || typeof key === "object" && key !== null && Object.values(key).every((el) => el === void 0)) && this.sparse) return;
        if (!Array.isArray(key)) this.tree.insert(key, doc);
        else {
          keys2 = uniq3(key, projectForUnique);
          for (let i2 = 0; i2 < keys2.length; i2 += 1) {
            try {
              this.tree.insert(keys2[i2], doc);
            } catch (e2) {
              error = e2;
              failingIndex = i2;
              break;
            }
          }
          if (error) {
            for (let i2 = 0; i2 < failingIndex; i2 += 1) {
              this.tree.delete(keys2[i2], doc);
            }
            throw error;
          }
        }
      }
      /**
       * Insert an array of documents in the index
       * If a constraint is violated, the changes should be rolled back and an error thrown
       * @param {document[]} docs Array of documents to insert.
       * @private
       */
      insertMultipleDocs(docs) {
        let error;
        let failingIndex;
        for (let i2 = 0; i2 < docs.length; i2 += 1) {
          try {
            this.insert(docs[i2]);
          } catch (e2) {
            error = e2;
            failingIndex = i2;
            break;
          }
        }
        if (error) {
          for (let i2 = 0; i2 < failingIndex; i2 += 1) {
            this.remove(docs[i2]);
          }
          throw error;
        }
      }
      /**
       * Removes a document from the index.
       * If an array is passed, we remove all its elements
       * The remove operation is safe with regards to the 'unique' constraint
       * O(log(n))
       * @param {document[]|document} doc The document, or Array of documents, to remove.
       */
      remove(doc) {
        if (Array.isArray(doc)) {
          doc.forEach((d2) => {
            this.remove(d2);
          });
          return;
        }
        const key = model.getDotValues(doc, this._fields);
        if (key === void 0 && this.sparse) return;
        if (!Array.isArray(key)) {
          this.tree.delete(key, doc);
        } else {
          uniq3(key, projectForUnique).forEach((_key) => {
            this.tree.delete(_key, doc);
          });
        }
      }
      /**
       * Update a document in the index
       * If a constraint is violated, changes are rolled back and an error thrown
       * Naive implementation, still in O(log(n))
       * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of
       * `{oldDoc, newDoc}` pairs.
       * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of
       * `{oldDoc, newDoc}` pairs, this second argument is ignored.
       */
      update(oldDoc, newDoc) {
        if (Array.isArray(oldDoc)) {
          this.updateMultipleDocs(oldDoc);
          return;
        }
        this.remove(oldDoc);
        try {
          this.insert(newDoc);
        } catch (e2) {
          this.insert(oldDoc);
          throw e2;
        }
      }
      /**
       * Update multiple documents in the index
       * If a constraint is violated, the changes need to be rolled back
       * and an error thrown
       * @param {Array.<{oldDoc: document, newDoc: document}>} pairs
       *
       * @private
       */
      updateMultipleDocs(pairs) {
        let failingIndex;
        let error;
        for (let i2 = 0; i2 < pairs.length; i2 += 1) {
          this.remove(pairs[i2].oldDoc);
        }
        for (let i2 = 0; i2 < pairs.length; i2 += 1) {
          try {
            this.insert(pairs[i2].newDoc);
          } catch (e2) {
            error = e2;
            failingIndex = i2;
            break;
          }
        }
        if (error) {
          for (let i2 = 0; i2 < failingIndex; i2 += 1) {
            this.remove(pairs[i2].newDoc);
          }
          for (let i2 = 0; i2 < pairs.length; i2 += 1) {
            this.insert(pairs[i2].oldDoc);
          }
          throw error;
        }
      }
      /**
       * Revert an update
       * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to revert to, or an `Array` of `{oldDoc, newDoc}` pairs.
       * @param {document} [newDoc] Document to revert from. If the first argument is an Array of {oldDoc, newDoc}, this second argument is ignored.
       */
      revertUpdate(oldDoc, newDoc) {
        const revert = [];
        if (!Array.isArray(oldDoc)) this.update(newDoc, oldDoc);
        else {
          oldDoc.forEach((pair) => {
            revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });
          });
          this.update(revert);
        }
      }
      /**
       * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)
       * @param {Array.<*>|*} value Value to match the key against
       * @return {document[]}
       */
      getMatching(value) {
        if (!Array.isArray(value)) return this.tree.search(value);
        else {
          const _res = {};
          const res = [];
          value.forEach((v3) => {
            this.getMatching(v3).forEach((doc) => {
              _res[doc._id] = doc;
            });
          });
          Object.keys(_res).forEach((_id) => {
            res.push(_res[_id]);
          });
          return res;
        }
      }
      /**
       * Get all documents in index whose key is between bounds are they are defined by query
       * Documents are sorted by key
       * @param {object} query An object with at least one matcher among $gt, $gte, $lt, $lte.
       * @param {*} [query.$gt] Greater than matcher.
       * @param {*} [query.$gte] Greater than or equal matcher.
       * @param {*} [query.$lt] Lower than matcher.
       * @param {*} [query.$lte] Lower than or equal matcher.
       * @return {document[]}
       */
      getBetweenBounds(query) {
        return this.tree.betweenBounds(query);
      }
      /**
       * Get all elements in the index
       * @return {document[]}
       */
      getAll() {
        const res = [];
        this.tree.executeOnEveryNode((node3) => {
          res.push(...node3.data);
        });
        return res;
      }
    };
    module2.exports = Index;
  }
});

// ../../node_modules/@seald-io/nedb/lib/byline.js
var require_byline = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/byline.js"(exports2, module2) {
    var stream = require("stream");
    var timers = require("timers");
    var { Buffer: Buffer2 } = require("buffer");
    var createLineStream = (readStream, options) => {
      if (!readStream) throw new Error("expected readStream");
      if (!readStream.readable) throw new Error("readStream must be readable");
      const ls = new LineStream(options);
      readStream.pipe(ls);
      return ls;
    };
    var LineStream = class extends stream.Transform {
      constructor(options) {
        super(options);
        options = options || {};
        this._readableState.objectMode = true;
        this._lineBuffer = [];
        this._keepEmptyLines = options.keepEmptyLines || false;
        this._lastChunkEndedWithCR = false;
        this.once("pipe", (src) => {
          if (!this.encoding && src instanceof stream.Readable) this.encoding = src._readableState.encoding;
        });
      }
      _transform(chunk3, encoding, done) {
        encoding = encoding || "utf8";
        if (Buffer2.isBuffer(chunk3)) {
          if (encoding === "buffer") {
            chunk3 = chunk3.toString();
            encoding = "utf8";
          } else chunk3 = chunk3.toString(encoding);
        }
        this._chunkEncoding = encoding;
        const lines = chunk3.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/g);
        if (this._lastChunkEndedWithCR && chunk3[0] === "\n") lines.shift();
        if (this._lineBuffer.length > 0) {
          this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
          lines.shift();
        }
        this._lastChunkEndedWithCR = chunk3[chunk3.length - 1] === "\r";
        this._lineBuffer = this._lineBuffer.concat(lines);
        this._pushBuffer(encoding, 1, done);
      }
      _pushBuffer(encoding, keep, done) {
        while (this._lineBuffer.length > keep) {
          const line = this._lineBuffer.shift();
          if (this._keepEmptyLines || line.length > 0) {
            if (!this.push(this._reencode(line, encoding))) {
              timers.setImmediate(() => {
                this._pushBuffer(encoding, keep, done);
              });
              return;
            }
          }
        }
        done();
      }
      _flush(done) {
        this._pushBuffer(this._chunkEncoding, 0, done);
      }
      // see Readable::push
      _reencode(line, chunkEncoding) {
        if (this.encoding && this.encoding !== chunkEncoding) return Buffer2.from(line, chunkEncoding).toString(this.encoding);
        else if (this.encoding) return line;
        else return Buffer2.from(line, chunkEncoding);
      }
    };
    module2.exports = createLineStream;
  }
});

// ../../node_modules/@seald-io/nedb/lib/storage.js
var require_storage = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/storage.js"(exports2, module2) {
    var fs5 = require("fs");
    var fsPromises = fs5.promises;
    var path4 = require("path");
    var { Readable } = require("stream");
    var DEFAULT_DIR_MODE = 493;
    var DEFAULT_FILE_MODE = 420;
    var existsAsync = (file) => fsPromises.access(file, fs5.constants.F_OK).then(() => true, () => false);
    var renameAsync = fsPromises.rename;
    var writeFileAsync = fsPromises.writeFile;
    var writeFileStream = fs5.createWriteStream;
    var unlinkAsync = fsPromises.unlink;
    var appendFileAsync = fsPromises.appendFile;
    var readFileAsync = fsPromises.readFile;
    var readFileStream = fs5.createReadStream;
    var mkdirAsync = fsPromises.mkdir;
    var ensureFileDoesntExistAsync = async (file) => {
      if (await existsAsync(file)) await unlinkAsync(file);
    };
    var flushToStorageAsync = async (options) => {
      let filename;
      let flags;
      let mode;
      if (typeof options === "string") {
        filename = options;
        flags = "r+";
        mode = DEFAULT_FILE_MODE;
      } else {
        filename = options.filename;
        flags = options.isDir ? "r" : "r+";
        mode = options.mode !== void 0 ? options.mode : DEFAULT_FILE_MODE;
      }
      let filehandle, errorOnFsync, errorOnClose;
      try {
        filehandle = await fsPromises.open(filename, flags, mode);
        try {
          await filehandle.sync();
        } catch (errFS) {
          errorOnFsync = errFS;
        }
      } catch (error) {
        if (error.code !== "EISDIR" || !options.isDir) throw error;
      } finally {
        try {
          await filehandle.close();
        } catch (errC) {
          errorOnClose = errC;
        }
      }
      if ((errorOnFsync || errorOnClose) && !((errorOnFsync.code === "EPERM" || errorOnClose.code === "EISDIR") && options.isDir)) {
        const e2 = new Error("Failed to flush to storage");
        e2.errorOnFsync = errorOnFsync;
        e2.errorOnClose = errorOnClose;
        throw e2;
      }
    };
    var writeFileLinesAsync = (filename, lines, mode = DEFAULT_FILE_MODE) => new Promise((resolve, reject2) => {
      try {
        const stream = writeFileStream(filename, { mode });
        const readable = Readable.from(lines);
        readable.on("data", (line) => {
          try {
            stream.write(line + "\n");
          } catch (err) {
            reject2(err);
          }
        });
        readable.on("end", () => {
          stream.close((err) => {
            if (err) reject2(err);
            else resolve();
          });
        });
        readable.on("error", (err) => {
          reject2(err);
        });
        stream.on("error", (err) => {
          reject2(err);
        });
      } catch (err) {
        reject2(err);
      }
    });
    var crashSafeWriteFileLinesAsync = async (filename, lines, modes = { fileMode: DEFAULT_FILE_MODE, dirMode: DEFAULT_DIR_MODE }) => {
      const tempFilename = filename + "~";
      await flushToStorageAsync({ filename: path4.dirname(filename), isDir: true, mode: modes.dirMode });
      const exists = await existsAsync(filename);
      if (exists) await flushToStorageAsync({ filename, mode: modes.fileMode });
      await writeFileLinesAsync(tempFilename, lines, modes.fileMode);
      await flushToStorageAsync({ filename: tempFilename, mode: modes.fileMode });
      await renameAsync(tempFilename, filename);
      await flushToStorageAsync({ filename: path4.dirname(filename), isDir: true, mode: modes.dirMode });
    };
    var ensureDatafileIntegrityAsync = async (filename, mode = DEFAULT_FILE_MODE) => {
      const tempFilename = filename + "~";
      const filenameExists = await existsAsync(filename);
      if (filenameExists) return;
      const oldFilenameExists = await existsAsync(tempFilename);
      if (!oldFilenameExists) await writeFileAsync(filename, "", { encoding: "utf8", mode });
      else await renameAsync(tempFilename, filename);
    };
    var ensureParentDirectoryExistsAsync = async (filename, mode) => {
      const dir = path4.dirname(filename);
      const parsedDir = path4.parse(path4.resolve(dir));
      if (process.platform !== "win32" || parsedDir.dir !== parsedDir.root || parsedDir.base !== "") {
        await mkdirAsync(dir, { recursive: true, mode });
      }
    };
    module2.exports.existsAsync = existsAsync;
    module2.exports.renameAsync = renameAsync;
    module2.exports.writeFileAsync = writeFileAsync;
    module2.exports.writeFileLinesAsync = writeFileLinesAsync;
    module2.exports.crashSafeWriteFileLinesAsync = crashSafeWriteFileLinesAsync;
    module2.exports.appendFileAsync = appendFileAsync;
    module2.exports.readFileAsync = readFileAsync;
    module2.exports.unlinkAsync = unlinkAsync;
    module2.exports.mkdirAsync = mkdirAsync;
    module2.exports.readFileStream = readFileStream;
    module2.exports.flushToStorageAsync = flushToStorageAsync;
    module2.exports.ensureDatafileIntegrityAsync = ensureDatafileIntegrityAsync;
    module2.exports.ensureFileDoesntExistAsync = ensureFileDoesntExistAsync;
    module2.exports.ensureParentDirectoryExistsAsync = ensureParentDirectoryExistsAsync;
  }
});

// ../../node_modules/@seald-io/nedb/lib/persistence.js
var require_persistence = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/persistence.js"(exports2, module2) {
    var { deprecate } = require("util");
    var byline = require_byline();
    var Index = require_indexes();
    var model = require_model();
    var storage = require_storage();
    var Waterfall = require_waterfall();
    var DEFAULT_DIR_MODE = 493;
    var DEFAULT_FILE_MODE = 420;
    var Persistence = class _Persistence {
      /**
       * Create a new Persistence object for database options.db
       * @param {Datastore} options.db
       * @param {Number} [options.corruptAlertThreshold] Optional, threshold after which an alert is thrown if too much data is corrupt
       * @param {serializationHook} [options.beforeDeserialization] Hook you can use to transform data after it was serialized and before it is written to disk.
       * @param {serializationHook} [options.afterSerialization] Inverse of `afterSerialization`.
       * @param {object} [options.modes] Modes to use for FS permissions. Will not work on Windows.
       * @param {number} [options.modes.fileMode=0o644] Mode to use for files.
       * @param {number} [options.modes.dirMode=0o755] Mode to use for directories.
       */
      constructor(options) {
        this.db = options.db;
        this.inMemoryOnly = this.db.inMemoryOnly;
        this.filename = this.db.filename;
        this.corruptAlertThreshold = options.corruptAlertThreshold !== void 0 ? options.corruptAlertThreshold : 0.1;
        this.modes = options.modes !== void 0 ? options.modes : {
          fileMode: DEFAULT_FILE_MODE,
          dirMode: DEFAULT_DIR_MODE
        };
        if (this.modes.fileMode === void 0) this.modes.fileMode = DEFAULT_FILE_MODE;
        if (this.modes.dirMode === void 0) this.modes.dirMode = DEFAULT_DIR_MODE;
        if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === "~") throw new Error("The datafile name can't end with a ~, which is reserved for crash safe backup files");
        if (options.afterSerialization && !options.beforeDeserialization) throw new Error("Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss");
        if (!options.afterSerialization && options.beforeDeserialization) throw new Error("Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss");
        this.afterSerialization = async (s2) => (options.afterSerialization || ((x3) => x3))(s2);
        this.beforeDeserialization = async (s2) => (options.beforeDeserialization || ((x3) => x3))(s2);
      }
      /**
       * Internal version without using the {@link Datastore#executor} of {@link Datastore#compactDatafileAsync}, use it instead.
       * @return {Promise<void>}
       * @private
       */
      async persistCachedDatabaseAsync() {
        const lines = [];
        if (this.inMemoryOnly) return;
        for (const doc of this.db.getAllData()) {
          lines.push(await this.afterSerialization(model.serialize(doc)));
        }
        for (const fieldName of Object.keys(this.db.indexes)) {
          if (fieldName !== "_id") {
            lines.push(await this.afterSerialization(model.serialize({
              $$indexCreated: {
                fieldName: this.db.indexes[fieldName].fieldName,
                unique: this.db.indexes[fieldName].unique,
                sparse: this.db.indexes[fieldName].sparse
              }
            })));
          }
        }
        await storage.crashSafeWriteFileLinesAsync(this.filename, lines, this.modes);
        this.db.emit("compaction.done");
      }
      /**
       * @see Datastore#compactDatafile
       * @deprecated
       * @param {NoParamCallback} [callback = () => {}]
       * @see Persistence#compactDatafileAsync
       */
      compactDatafile(callback) {
        deprecate((_callback) => this.db.compactDatafile(_callback), "@seald-io/nedb: calling Datastore#persistence#compactDatafile is deprecated, please use Datastore#compactDatafile, it will be removed in the next major version.")(callback);
      }
      /**
       * @see Datastore#setAutocompactionInterval
       * @deprecated
       */
      setAutocompactionInterval(interval) {
        deprecate((_interval) => this.db.setAutocompactionInterval(_interval), "@seald-io/nedb: calling Datastore#persistence#setAutocompactionInterval is deprecated, please use Datastore#setAutocompactionInterval, it will be removed in the next major version.")(interval);
      }
      /**
       * @see Datastore#stopAutocompaction
       * @deprecated
       */
      stopAutocompaction() {
        deprecate(() => this.db.stopAutocompaction(), "@seald-io/nedb: calling Datastore#persistence#stopAutocompaction is deprecated, please use Datastore#stopAutocompaction, it will be removed in the next major version.")();
      }
      /**
       * Persist new state for the given newDocs (can be insertion, update or removal)
       * Use an append-only format
       *
       * Do not use directly, it should only used by a {@link Datastore} instance.
       * @param {document[]} newDocs Can be empty if no doc was updated/removed
       * @return {Promise}
       * @private
       */
      async persistNewStateAsync(newDocs) {
        let toPersist = "";
        if (this.inMemoryOnly) return;
        for (const doc of newDocs) {
          toPersist += await this.afterSerialization(model.serialize(doc)) + "\n";
        }
        if (toPersist.length === 0) return;
        await storage.appendFileAsync(this.filename, toPersist, { encoding: "utf8", mode: this.modes.fileMode });
      }
      /**
       * @typedef rawIndex
       * @property {string} fieldName
       * @property {boolean} [unique]
       * @property {boolean} [sparse]
       */
      /**
       * From a database's raw data, return the corresponding machine understandable collection.
       *
       * Do not use directly, it should only used by a {@link Datastore} instance.
       * @param {string} rawData database file
       * @return {{data: document[], indexes: Object.<string, rawIndex>}}
       * @private
       */
      async treatRawData(rawData) {
        const data = rawData.split("\n").filter((datum) => datum !== "").map(async (datum) => model.deserialize(await this.beforeDeserialization(datum)));
        const dataById = {};
        const indexes = {};
        const dataLength = data.length;
        let corruptItems = 0;
        for (const docToAwait of data) {
          try {
            const doc = await docToAwait;
            if (doc._id) {
              if (doc.$$deleted === true) delete dataById[doc._id];
              else dataById[doc._id] = doc;
            } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != null) indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
            else if (typeof doc.$$indexRemoved === "string") delete indexes[doc.$$indexRemoved];
          } catch (e2) {
            corruptItems += 1;
          }
        }
        if (dataLength > 0) {
          const corruptionRate = corruptItems / dataLength;
          if (corruptionRate > this.corruptAlertThreshold) {
            const error = new Error(`${Math.floor(100 * corruptionRate)}% of the data file is corrupt, more than given corruptAlertThreshold (${Math.floor(100 * this.corruptAlertThreshold)}%). Cautiously refusing to start NeDB to prevent dataloss.`);
            error.corruptionRate = corruptionRate;
            error.corruptItems = corruptItems;
            error.dataLength = dataLength;
            throw error;
          }
        }
        const tdata = Object.values(dataById);
        return { data: tdata, indexes };
      }
      /**
       * From a database's raw data stream, return the corresponding machine understandable collection
       * Is only used by a {@link Datastore} instance.
       *
       * Is only used in the Node.js version, since [React-Native]{@link module:storageReactNative} &
       * [browser]{@link module:storageBrowser} storage modules don't provide an equivalent of
       * {@link module:storage.readFileStream}.
       *
       * Do not use directly, it should only used by a {@link Datastore} instance.
       * @param {Readable} rawStream
       * @return {Promise<{data: document[], indexes: Object.<string, rawIndex>}>}
       * @async
       * @private
       */
      treatRawStreamAsync(rawStream) {
        return new Promise((resolve, reject2) => {
          const dataById = {};
          const indexes = {};
          let corruptItems = 0;
          const lineStream = byline(rawStream);
          let dataLength = 0;
          const waterfall = new Waterfall();
          lineStream.on("data", (line) => {
            const deserializedPromise = this.beforeDeserialization(line);
            return waterfall.waterfall(async () => {
              if (line === "") return;
              try {
                const doc = model.deserialize(await deserializedPromise);
                if (doc._id) {
                  if (doc.$$deleted === true) delete dataById[doc._id];
                  else dataById[doc._id] = doc;
                } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != null) indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
                else if (typeof doc.$$indexRemoved === "string") delete indexes[doc.$$indexRemoved];
              } catch (e2) {
                corruptItems += 1;
              }
              dataLength++;
            })();
          });
          lineStream.on("end", async () => {
            await waterfall.guardian;
            if (dataLength > 0) {
              const corruptionRate = corruptItems / dataLength;
              if (corruptionRate > this.corruptAlertThreshold) {
                const error = new Error(`${Math.floor(100 * corruptionRate)}% of the data file is corrupt, more than given corruptAlertThreshold (${Math.floor(100 * this.corruptAlertThreshold)}%). Cautiously refusing to start NeDB to prevent dataloss.`);
                error.corruptionRate = corruptionRate;
                error.corruptItems = corruptItems;
                error.dataLength = dataLength;
                reject2(error, null);
                return;
              }
            }
            const data = Object.values(dataById);
            resolve({ data, indexes });
          });
          lineStream.on("error", function(err) {
            reject2(err, null);
          });
        });
      }
      /**
       * Load the database
       * 1) Create all indexes
       * 2) Insert all data
       * 3) Compact the database
       *
       * This means pulling data out of the data file or creating it if it doesn't exist
       * Also, all data is persisted right away, which has the effect of compacting the database file
       * This operation is very quick at startup for a big collection (60ms for ~10k docs)
       *
       * Do not use directly as it does not use the [Executor]{@link Datastore.executor}, use {@link Datastore#loadDatabaseAsync} instead.
       * @return {Promise<void>}
       * @private
       */
      async loadDatabaseAsync() {
        this.db._resetIndexes();
        if (this.inMemoryOnly) return;
        await _Persistence.ensureParentDirectoryExistsAsync(this.filename, this.modes.dirMode);
        await storage.ensureDatafileIntegrityAsync(this.filename, this.modes.fileMode);
        let treatedData;
        if (storage.readFileStream) {
          const fileStream = storage.readFileStream(this.filename, { encoding: "utf8", mode: this.modes.fileMode });
          treatedData = await this.treatRawStreamAsync(fileStream);
        } else {
          const rawData = await storage.readFileAsync(this.filename, { encoding: "utf8", mode: this.modes.fileMode });
          treatedData = await this.treatRawData(rawData);
        }
        Object.keys(treatedData.indexes).forEach((key) => {
          this.db.indexes[key] = new Index(treatedData.indexes[key]);
        });
        try {
          this.db._resetIndexes(treatedData.data);
        } catch (e2) {
          this.db._resetIndexes();
          throw e2;
        }
        await this.db.persistence.persistCachedDatabaseAsync();
        this.db.executor.processBuffer();
      }
      /**
       * See {@link Datastore#dropDatabaseAsync}. This function uses {@link Datastore#executor} internally. Decorating this
       * function with an {@link Executor#pushAsync} will result in a deadlock.
       * @return {Promise<void>}
       * @private
       * @see Datastore#dropDatabaseAsync
       */
      async dropDatabaseAsync() {
        this.db.stopAutocompaction();
        this.db.executor.ready = false;
        this.db.executor.resetBuffer();
        await this.db.executor.queue.guardian;
        this.db.indexes = {};
        this.db.indexes._id = new Index({ fieldName: "_id", unique: true });
        this.db.ttlIndexes = {};
        if (!this.db.inMemoryOnly) {
          await this.db.executor.pushAsync(async () => {
            if (await storage.existsAsync(this.filename)) await storage.unlinkAsync(this.filename);
          }, true);
        }
      }
      /**
       * Check if a directory stat and create it on the fly if it is not the case.
       * @param {string} dir
       * @param {number} [mode=0o777]
       * @return {Promise<void>}
       * @private
       */
      static async ensureParentDirectoryExistsAsync(dir, mode = DEFAULT_DIR_MODE) {
        return storage.ensureParentDirectoryExistsAsync(dir, mode);
      }
    };
    module2.exports = Persistence;
  }
});

// ../../node_modules/@seald-io/nedb/lib/datastore.js
var require_datastore = __commonJS({
  "../../node_modules/@seald-io/nedb/lib/datastore.js"(exports2, module2) {
    var { EventEmitter } = require("events");
    var { callbackify, deprecate } = require("util");
    var Cursor = require_cursor();
    var customUtils = require_customUtils();
    var Executor = require_executor();
    var Index = require_indexes();
    var model = require_model();
    var Persistence = require_persistence();
    var { isDate: isDate4, pick: pick2, filterIndexNames } = require_utils3();
    var Datastore = class extends EventEmitter {
      /**
       * Create a new collection, either persistent or in-memory.
       *
       * If you use a persistent datastore without the `autoload` option, you need to call {@link Datastore#loadDatabase} or
       * {@link Datastore#loadDatabaseAsync} manually. This function fetches the data from datafile and prepares the database.
       * **Don't forget it!** If you use a persistent datastore, no command (insert, find, update, remove) will be executed
       * before it is called, so make sure to call it yourself or use the `autoload` option.
       *
       * Also, if loading fails, all commands registered to the {@link Datastore#executor} afterwards will not be executed.
       * They will be registered and executed, in sequence, only after a successful loading.
       *
       * @param {object|string} options Can be an object or a string. If options is a string, the behavior is the same as in
       * v0.6: it will be interpreted as `options.filename`. **Giving a string is deprecated, and will be removed in the
       * next major version.**
       * @param {string} [options.filename = null] Path to the file where the data is persisted. If left blank, the datastore is
       * automatically considered in-memory only. It cannot end with a `~` which is used in the temporary files NeDB uses to
       * perform crash-safe writes. Not used if `options.inMemoryOnly` is `true`.
       * @param {boolean} [options.inMemoryOnly = false] If set to true, no data will be written in storage. This option has
       * priority over `options.filename`.
       * @param {object} [options.modes] Permissions to use for FS. Only used for Node.js storage module. Will not work on Windows.
       * @param {number} [options.modes.fileMode = 0o644] Permissions to use for database files
       * @param {number} [options.modes.dirMode = 0o755] Permissions to use for database directories
       * @param {boolean} [options.timestampData = false] If set to true, createdAt and updatedAt will be created and
       * populated automatically (if not specified by user)
       * @param {boolean} [options.autoload = false] If used, the database will automatically be loaded from the datafile
       * upon creation (you don't need to call `loadDatabase`). Any command issued before load is finished is buffered and
       * will be executed when load is done. When autoloading is done, you can either use the `onload` callback, or you can
       * use `this.autoloadPromise` which resolves (or rejects) when autloading is done.
       * @param {NoParamCallback} [options.onload] If you use autoloading, this is the handler called after the `loadDatabase`. It
       * takes one `error` argument. If you use autoloading without specifying this handler, and an error happens during
       * load, an error will be thrown.
       * @param {serializationHook} [options.beforeDeserialization] Hook you can use to transform data after it was serialized and
       * before it is written to disk. Can be used for example to encrypt data before writing database to disk. This
       * function takes a string as parameter (one line of an NeDB data file) and outputs the transformed string, **which
       * must absolutely not contain a `\n` character** (or data will be lost).
       * @param {serializationHook} [options.afterSerialization] Inverse of `afterSerialization`. Make sure to include both and not
       * just one, or you risk data loss. For the same reason, make sure both functions are inverses of one another. Some
       * failsafe mechanisms are in place to prevent data loss if you misuse the serialization hooks: NeDB checks that never
       * one is declared without the other, and checks that they are reverse of one another by testing on random strings of
       * various lengths. In addition, if too much data is detected as corrupt, NeDB will refuse to start as it could mean
       * you're not using the deserialization hook corresponding to the serialization hook used before.
       * @param {number} [options.corruptAlertThreshold = 0.1] Between 0 and 1, defaults to 10%. NeDB will refuse to start
       * if more than this percentage of the datafile is corrupt. 0 means you don't tolerate any corruption, 1 means you
       * don't care.
       * @param {compareStrings} [options.compareStrings] If specified, it overrides default string comparison which is not
       * well adapted to non-US characters in particular accented letters. Native `localCompare` will most of the time be
       * the right choice.
       * @param {boolean} [options.testSerializationHooks=true] Whether to test the serialization hooks or not,
       * might be CPU-intensive
       */
      constructor(options) {
        super();
        let filename;
        if (typeof options === "string") {
          deprecate(() => {
            filename = options;
            this.inMemoryOnly = false;
          }, "@seald-io/nedb: Giving a string to the Datastore constructor is deprecated and will be removed in the next major version. Please use an options object with an argument 'filename'.")();
        } else {
          options = options || {};
          filename = options.filename;
          this.inMemoryOnly = options.inMemoryOnly || false;
          this.autoload = options.autoload || false;
          this.timestampData = options.timestampData || false;
        }
        if (!filename || typeof filename !== "string" || filename.length === 0) {
          this.filename = null;
          this.inMemoryOnly = true;
        } else {
          this.filename = filename;
        }
        this.compareStrings = options.compareStrings;
        this.persistence = new Persistence({
          db: this,
          afterSerialization: options.afterSerialization,
          beforeDeserialization: options.beforeDeserialization,
          corruptAlertThreshold: options.corruptAlertThreshold,
          modes: options.modes,
          testSerializationHooks: options.testSerializationHooks
        });
        this.executor = new Executor();
        if (this.inMemoryOnly) this.executor.ready = true;
        this.indexes = {};
        this.indexes._id = new Index({ fieldName: "_id", unique: true });
        this.ttlIndexes = {};
        if (this.autoload) {
          this.autoloadPromise = this.loadDatabaseAsync();
          this.autoloadPromise.then(() => {
            if (options.onload) options.onload();
          }, (err) => {
            if (options.onload) options.onload(err);
            else throw err;
          });
        } else this.autoloadPromise = null;
        this._autocompactionIntervalId = null;
      }
      /**
       * Queue a compaction/rewrite of the datafile.
       * It works by rewriting the database file, and compacts it since the cache always contains only the number of
       * documents in the collection while the data file is append-only so it may grow larger.
       *
       * @async
       */
      compactDatafileAsync() {
        return this.executor.pushAsync(() => this.persistence.persistCachedDatabaseAsync());
      }
      /**
       * Callback version of {@link Datastore#compactDatafileAsync}.
       * @param {NoParamCallback} [callback = () => {}]
       * @see Datastore#compactDatafileAsync
       */
      compactDatafile(callback) {
        const promise = this.compactDatafileAsync();
        if (typeof callback === "function") callbackify(() => promise)(callback);
      }
      /**
       * Set automatic compaction every `interval` ms
       * @param {Number} interval in milliseconds, with an enforced minimum of 5000 milliseconds
       */
      setAutocompactionInterval(interval) {
        const minInterval = 5e3;
        if (Number.isNaN(Number(interval))) throw new Error("Interval must be a non-NaN number");
        const realInterval = Math.max(Number(interval), minInterval);
        this.stopAutocompaction();
        this._autocompactionIntervalId = setInterval(() => {
          this.compactDatafile();
        }, realInterval);
      }
      /**
       * Stop autocompaction (do nothing if automatic compaction was not running)
       */
      stopAutocompaction() {
        if (this._autocompactionIntervalId) {
          clearInterval(this._autocompactionIntervalId);
          this._autocompactionIntervalId = null;
        }
      }
      /**
       * Callback version of {@link Datastore#loadDatabaseAsync}.
       * @param {NoParamCallback} [callback]
       * @see Datastore#loadDatabaseAsync
       */
      loadDatabase(callback) {
        const promise = this.loadDatabaseAsync();
        if (typeof callback === "function") callbackify(() => promise)(callback);
      }
      /**
       * Stops auto-compaction, finishes all queued operations, drops the database both in memory and in storage.
       * **WARNING**: it is not recommended re-using an instance of NeDB if its database has been dropped, it is
       * preferable to instantiate a new one.
       * @async
       * @return {Promise}
       */
      dropDatabaseAsync() {
        return this.persistence.dropDatabaseAsync();
      }
      /**
       * Callback version of {@link Datastore#dropDatabaseAsync}.
       * @param {NoParamCallback} [callback]
       * @see Datastore#dropDatabaseAsync
       */
      dropDatabase(callback) {
        const promise = this.dropDatabaseAsync();
        if (typeof callback === "function") callbackify(() => promise)(callback);
      }
      /**
       * Load the database from the datafile, and trigger the execution of buffered commands if any.
       * @async
       * @return {Promise}
       */
      loadDatabaseAsync() {
        return this.executor.pushAsync(() => this.persistence.loadDatabaseAsync(), true);
      }
      /**
       * Get an array of all the data in the database.
       * @return {document[]}
       */
      getAllData() {
        return this.indexes._id.getAll();
      }
      /**
       * Reset all currently defined indexes.
       * @param {?document|?document[]} [newData]
       * @private
       */
      _resetIndexes(newData) {
        for (const index of Object.values(this.indexes)) {
          index.reset(newData);
        }
      }
      /**
       * Callback version of {@link Datastore#ensureIndex}.
       * @param {object} options
       * @param {string|string[]} options.fieldName
       * @param {boolean} [options.unique = false]
       * @param {boolean} [options.sparse = false]
       * @param {number} [options.expireAfterSeconds]
       * @param {NoParamCallback} [callback]
       * @see Datastore#ensureIndex
       */
      ensureIndex(options = {}, callback) {
        const promise = this.ensureIndexAsync(options);
        if (typeof callback === "function") callbackify(() => promise)(callback);
      }
      /**
       * Ensure an index is kept for this field. Same parameters as lib/indexes
       * This function acts synchronously on the indexes, however the persistence of the indexes is deferred with the
       * executor.
       * @param {object} options
       * @param {string|string[]} options.fieldName Name of the field to index. Use the dot notation to index a field in a nested
       * document. For a compound index, use an array of field names. Using a comma in a field name is not permitted.
       * @param {boolean} [options.unique = false] Enforce field uniqueness. Note that a unique index will raise an error
       * if you try to index two documents for which the field is not defined.
       * @param {boolean} [options.sparse = false] Don't index documents for which the field is not defined. Use this option
       * along with "unique" if you want to accept multiple documents for which it is not defined.
       * @param {number} [options.expireAfterSeconds] - If set, the created index is a TTL (time to live) index, that will
       * automatically remove documents when the system date becomes larger than the date on the indexed field plus
       * `expireAfterSeconds`. Documents where the indexed field is not specified or not a `Date` object are ignored.
       * @return {Promise<void>}
       */
      async ensureIndexAsync(options = {}) {
        if (!options.fieldName) {
          const err = new Error("Cannot create an index without a fieldName");
          err.missingFieldName = true;
          throw err;
        }
        const _fields = [].concat(options.fieldName).sort();
        if (_fields.some((field) => field.includes(","))) {
          throw new Error("Cannot use comma in index fieldName");
        }
        const _options = {
          ...options,
          fieldName: _fields.join(",")
        };
        if (this.indexes[_options.fieldName]) return;
        this.indexes[_options.fieldName] = new Index(_options);
        if (options.expireAfterSeconds !== void 0) this.ttlIndexes[_options.fieldName] = _options.expireAfterSeconds;
        try {
          this.indexes[_options.fieldName].insert(this.getAllData());
        } catch (e2) {
          delete this.indexes[_options.fieldName];
          throw e2;
        }
        await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{ $$indexCreated: _options }]), true);
      }
      /**
       * Callback version of {@link Datastore#removeIndexAsync}.
       * @param {string} fieldName
       * @param {NoParamCallback} [callback]
       * @see Datastore#removeIndexAsync
       */
      removeIndex(fieldName, callback = () => {
      }) {
        const promise = this.removeIndexAsync(fieldName);
        callbackify(() => promise)(callback);
      }
      /**
       * Remove an index.
       * @param {string} fieldName Field name of the index to remove. Use the dot notation to remove an index referring to a
       * field in a nested document.
       * @return {Promise<void>}
       * @see Datastore#removeIndex
       */
      async removeIndexAsync(fieldName) {
        delete this.indexes[fieldName];
        await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{ $$indexRemoved: fieldName }]), true);
      }
      /**
       * Add one or several document(s) to all indexes.
       *
       * This is an internal function.
       * @param {document} doc
       * @private
       */
      _addToIndexes(doc) {
        let failingIndex;
        let error;
        const keys2 = Object.keys(this.indexes);
        for (let i2 = 0; i2 < keys2.length; i2 += 1) {
          try {
            this.indexes[keys2[i2]].insert(doc);
          } catch (e2) {
            failingIndex = i2;
            error = e2;
            break;
          }
        }
        if (error) {
          for (let i2 = 0; i2 < failingIndex; i2 += 1) {
            this.indexes[keys2[i2]].remove(doc);
          }
          throw error;
        }
      }
      /**
       * Remove one or several document(s) from all indexes.
       *
       * This is an internal function.
       * @param {document} doc
       * @private
       */
      _removeFromIndexes(doc) {
        for (const index of Object.values(this.indexes)) {
          index.remove(doc);
        }
      }
      /**
       * Update one or several documents in all indexes.
       *
       * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs.
       *
       * If one update violates a constraint, all changes are rolled back.
       *
       * This is an internal function.
       * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of
       * `{oldDoc, newDoc}` pairs.
       * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of
       * `{oldDoc, newDoc}` pairs, this second argument is ignored.
       * @private
       */
      _updateIndexes(oldDoc, newDoc) {
        let failingIndex;
        let error;
        const keys2 = Object.keys(this.indexes);
        for (let i2 = 0; i2 < keys2.length; i2 += 1) {
          try {
            this.indexes[keys2[i2]].update(oldDoc, newDoc);
          } catch (e2) {
            failingIndex = i2;
            error = e2;
            break;
          }
        }
        if (error) {
          for (let i2 = 0; i2 < failingIndex; i2 += 1) {
            this.indexes[keys2[i2]].revertUpdate(oldDoc, newDoc);
          }
          throw error;
        }
      }
      /**
       * Get all candidate documents matching the query, regardless of their expiry status.
       * @param {query} query
       * @return {document[]}
       *
       * @private
       */
      _getRawCandidates(query) {
        const indexNames = Object.keys(this.indexes);
        let usableQuery;
        usableQuery = Object.entries(query).filter(filterIndexNames(indexNames)).pop();
        if (usableQuery) return this.indexes[usableQuery[0]].getMatching(usableQuery[1]);
        const compoundQueryKeys = indexNames.filter((indexName) => indexName.indexOf(",") !== -1).map((indexName) => indexName.split(",")).filter(
          (subIndexNames) => Object.entries(query).filter(filterIndexNames(subIndexNames)).length === subIndexNames.length
        );
        if (compoundQueryKeys.length > 0) return this.indexes[compoundQueryKeys[0]].getMatching(pick2(query, compoundQueryKeys[0]));
        usableQuery = Object.entries(query).filter(
          ([k2, v3]) => !!(query[k2] && Object.prototype.hasOwnProperty.call(query[k2], "$in")) && indexNames.includes(k2)
        ).pop();
        if (usableQuery) return this.indexes[usableQuery[0]].getMatching(usableQuery[1].$in);
        usableQuery = Object.entries(query).filter(
          ([k2, v3]) => !!(query[k2] && (Object.prototype.hasOwnProperty.call(query[k2], "$lt") || Object.prototype.hasOwnProperty.call(query[k2], "$lte") || Object.prototype.hasOwnProperty.call(query[k2], "$gt") || Object.prototype.hasOwnProperty.call(query[k2], "$gte"))) && indexNames.includes(k2)
        ).pop();
        if (usableQuery) return this.indexes[usableQuery[0]].getBetweenBounds(usableQuery[1]);
        return this.getAllData();
      }
      /**
       * Return the list of candidates for a given query
       * Crude implementation for now, we return the candidates given by the first usable index if any
       * We try the following query types, in this order: basic match, $in match, comparison match
       * One way to make it better would be to enable the use of multiple indexes if the first usable index
       * returns too much data. I may do it in the future.
       *
       * Returned candidates will be scanned to find and remove all expired documents
       *
       * This is an internal function.
       * @param {query} query
       * @param {boolean} [dontExpireStaleDocs = false] If true don't remove stale docs. Useful for the remove function
       * which shouldn't be impacted by expirations.
       * @return {Promise<document[]>} candidates
       * @private
       */
      async _getCandidatesAsync(query, dontExpireStaleDocs = false) {
        const validDocs = [];
        const docs = this._getRawCandidates(query);
        if (!dontExpireStaleDocs) {
          const expiredDocsIds = [];
          const ttlIndexesFieldNames = Object.keys(this.ttlIndexes);
          docs.forEach((doc) => {
            if (ttlIndexesFieldNames.every((i2) => !(doc[i2] !== void 0 && isDate4(doc[i2]) && Date.now() > doc[i2].getTime() + this.ttlIndexes[i2] * 1e3))) validDocs.push(doc);
            else expiredDocsIds.push(doc._id);
          });
          for (const _id of expiredDocsIds) {
            await this._removeAsync({ _id }, {});
          }
        } else validDocs.push(...docs);
        return validDocs;
      }
      /**
       * Insert a new document
       * This is an internal function, use {@link Datastore#insertAsync} which has the same signature.
       * @param {document|document[]} newDoc
       * @return {Promise<document|document[]>}
       * @private
       */
      async _insertAsync(newDoc) {
        const preparedDoc = this._prepareDocumentForInsertion(newDoc);
        this._insertInCache(preparedDoc);
        await this.persistence.persistNewStateAsync(Array.isArray(preparedDoc) ? preparedDoc : [preparedDoc]);
        return model.deepCopy(preparedDoc);
      }
      /**
       * Create a new _id that's not already in use
       * @return {string} id
       * @private
       */
      _createNewId() {
        let attemptId = customUtils.uid(16);
        if (this.indexes._id.getMatching(attemptId).length > 0) attemptId = this._createNewId();
        return attemptId;
      }
      /**
       * Prepare a document (or array of documents) to be inserted in a database
       * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input
       * @param {document|document[]} newDoc document, or Array of documents, to prepare
       * @return {document|document[]} prepared document, or Array of prepared documents
       * @private
       */
      _prepareDocumentForInsertion(newDoc) {
        let preparedDoc;
        if (Array.isArray(newDoc)) {
          preparedDoc = [];
          newDoc.forEach((doc) => {
            preparedDoc.push(this._prepareDocumentForInsertion(doc));
          });
        } else {
          preparedDoc = model.deepCopy(newDoc);
          if (preparedDoc._id === void 0) preparedDoc._id = this._createNewId();
          const now2 = /* @__PURE__ */ new Date();
          if (this.timestampData && preparedDoc.createdAt === void 0) preparedDoc.createdAt = now2;
          if (this.timestampData && preparedDoc.updatedAt === void 0) preparedDoc.updatedAt = now2;
          model.checkObject(preparedDoc);
        }
        return preparedDoc;
      }
      /**
       * If newDoc is an array of documents, this will insert all documents in the cache
       * @param {document|document[]} preparedDoc
       * @private
       */
      _insertInCache(preparedDoc) {
        if (Array.isArray(preparedDoc)) this._insertMultipleDocsInCache(preparedDoc);
        else this._addToIndexes(preparedDoc);
      }
      /**
       * If one insertion fails (e.g. because of a unique constraint), roll back all previous
       * inserts and throws the error
       * @param {document[]} preparedDocs
       * @private
       */
      _insertMultipleDocsInCache(preparedDocs) {
        let failingIndex;
        let error;
        for (let i2 = 0; i2 < preparedDocs.length; i2 += 1) {
          try {
            this._addToIndexes(preparedDocs[i2]);
          } catch (e2) {
            error = e2;
            failingIndex = i2;
            break;
          }
        }
        if (error) {
          for (let i2 = 0; i2 < failingIndex; i2 += 1) {
            this._removeFromIndexes(preparedDocs[i2]);
          }
          throw error;
        }
      }
      /**
       * Callback version of {@link Datastore#insertAsync}.
       * @param {document|document[]} newDoc
       * @param {SingleDocumentCallback|MultipleDocumentsCallback} [callback]
       * @see Datastore#insertAsync
       */
      insert(newDoc, callback) {
        const promise = this.insertAsync(newDoc);
        if (typeof callback === "function") callbackify(() => promise)(callback);
      }
      /**
       * Insert a new document, or new documents.
       * @param {document|document[]} newDoc Document or array of documents to insert.
       * @return {Promise<document|document[]>} The document(s) inserted.
       * @async
       */
      insertAsync(newDoc) {
        return this.executor.pushAsync(() => this._insertAsync(newDoc));
      }
      /**
       * Callback for {@link Datastore#countCallback}.
       * @callback Datastore~countCallback
       * @param {?Error} err
       * @param {?number} count
       */
      /**
       * Callback-version of {@link Datastore#countAsync}.
       * @param {query} query
       * @param {Datastore~countCallback} [callback]
       * @return {Cursor<number>|undefined}
       * @see Datastore#countAsync
       */
      count(query, callback) {
        const cursor = this.countAsync(query);
        if (typeof callback === "function") callbackify(cursor.execAsync.bind(cursor))(callback);
        else return cursor;
      }
      /**
       * Count all documents matching the query.
       * @param {query} query MongoDB-style query
       * @return {Cursor<number>} count
       * @async
       */
      countAsync(query) {
        return new Cursor(this, query, (docs) => docs.length);
      }
      /**
       * Callback version of {@link Datastore#findAsync}.
       * @param {query} query
       * @param {projection|MultipleDocumentsCallback} [projection = {}]
       * @param {MultipleDocumentsCallback} [callback]
       * @return {Cursor<document[]>|undefined}
       * @see Datastore#findAsync
       */
      find(query, projection, callback) {
        if (arguments.length === 1) {
          projection = {};
        } else if (arguments.length === 2) {
          if (typeof projection === "function") {
            callback = projection;
            projection = {};
          }
        }
        const cursor = this.findAsync(query, projection);
        if (typeof callback === "function") callbackify(cursor.execAsync.bind(cursor))(callback);
        else return cursor;
      }
      /**
       * Find all documents matching the query.
       * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#limit} or
       * {@link Cursor#skip} before.
       * @param {query} query MongoDB-style query
       * @param {projection} [projection = {}] MongoDB-style projection
       * @return {Cursor<document[]>}
       * @async
       */
      findAsync(query, projection = {}) {
        const cursor = new Cursor(this, query, (docs) => docs.map((doc) => model.deepCopy(doc)));
        cursor.projection(projection);
        return cursor;
      }
      /**
       * @callback Datastore~findOneCallback
       * @param {?Error} err
       * @param {document} doc
       */
      /**
       * Callback version of {@link Datastore#findOneAsync}.
       * @param {query} query
       * @param {projection|SingleDocumentCallback} [projection = {}]
       * @param {SingleDocumentCallback} [callback]
       * @return {Cursor<document>|undefined}
       * @see Datastore#findOneAsync
       */
      findOne(query, projection, callback) {
        if (arguments.length === 1) {
          projection = {};
        } else if (arguments.length === 2) {
          if (typeof projection === "function") {
            callback = projection;
            projection = {};
          }
        }
        const cursor = this.findOneAsync(query, projection);
        if (typeof callback === "function") callbackify(cursor.execAsync.bind(cursor))(callback);
        else return cursor;
      }
      /**
       * Find one document matching the query.
       * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#skip} before.
       * @param {query} query MongoDB-style query
       * @param {projection} projection MongoDB-style projection
       * @return {Cursor<document>}
       */
      findOneAsync(query, projection = {}) {
        const cursor = new Cursor(this, query, (docs) => docs.length === 1 ? model.deepCopy(docs[0]) : null);
        cursor.projection(projection).limit(1);
        return cursor;
      }
      /**
       * See {@link Datastore#updateAsync} return type for the definition of the callback parameters.
       *
       * **WARNING:** Prior to 3.0.0, `upsert` was either `true` of falsy (but not `false`), it is now always a boolean.
       * `affectedDocuments` could be `undefined` when `returnUpdatedDocs` was `false`, it is now `null` in these cases.
       *
       * **WARNING:** Prior to 1.8.0, the `upsert` argument was not given, it was impossible for the developer to determine
       * during a `{ multi: false, returnUpdatedDocs: true, upsert: true }` update if it inserted a document or just updated
       * it.
       *
       * @callback Datastore~updateCallback
       * @param {?Error} err
       * @param {number} numAffected
       * @param {?document[]|?document} affectedDocuments
       * @param {boolean} upsert
       * @see {Datastore#updateAsync}
       */
      /**
       * Version without the using {@link Datastore~executor} of {@link Datastore#updateAsync}, use it instead.
       *
       * @param {query} query
       * @param {document|update} update
       * @param {Object} options
       * @param {boolean} [options.multi = false]
       * @param {boolean} [options.upsert = false]
       * @param {boolean} [options.returnUpdatedDocs = false]
       * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}
       * @private
       * @see Datastore#updateAsync
       */
      async _updateAsync(query, update3, options) {
        const multi = options.multi !== void 0 ? options.multi : false;
        const upsert = options.upsert !== void 0 ? options.upsert : false;
        if (upsert) {
          const cursor = new Cursor(this, query);
          const docs = await cursor.limit(1)._execAsync();
          if (docs.length !== 1) {
            let toBeInserted;
            try {
              model.checkObject(update3);
              toBeInserted = update3;
            } catch (e2) {
              toBeInserted = model.modify(model.deepCopy(query, true), update3);
            }
            const newDoc = await this._insertAsync(toBeInserted);
            return { numAffected: 1, affectedDocuments: newDoc, upsert: true };
          }
        }
        let numReplaced = 0;
        let modifiedDoc;
        const modifications = [];
        let createdAt;
        const candidates = await this._getCandidatesAsync(query);
        for (const candidate of candidates) {
          if (model.match(candidate, query) && (multi || numReplaced === 0)) {
            numReplaced += 1;
            if (this.timestampData) {
              createdAt = candidate.createdAt;
            }
            modifiedDoc = model.modify(candidate, update3);
            if (this.timestampData) {
              modifiedDoc.createdAt = createdAt;
              modifiedDoc.updatedAt = /* @__PURE__ */ new Date();
            }
            modifications.push({ oldDoc: candidate, newDoc: modifiedDoc });
          }
        }
        this._updateIndexes(modifications);
        const updatedDocs = modifications.map((x3) => x3.newDoc);
        await this.persistence.persistNewStateAsync(updatedDocs);
        if (!options.returnUpdatedDocs) return { numAffected: numReplaced, upsert: false, affectedDocuments: null };
        else {
          let updatedDocsDC = [];
          updatedDocs.forEach((doc) => {
            updatedDocsDC.push(model.deepCopy(doc));
          });
          if (!multi) updatedDocsDC = updatedDocsDC[0];
          return { numAffected: numReplaced, affectedDocuments: updatedDocsDC, upsert: false };
        }
      }
      /**
       * Callback version of {@link Datastore#updateAsync}.
       * @param {query} query
       * @param {document|*} update
       * @param {Object|Datastore~updateCallback} [options|]
       * @param {boolean} [options.multi = false]
       * @param {boolean} [options.upsert = false]
       * @param {boolean} [options.returnUpdatedDocs = false]
       * @param {Datastore~updateCallback} [callback]
       * @see Datastore#updateAsync
       *
       */
      update(query, update3, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        const _callback = (err, res = {}) => {
          if (callback) callback(err, res.numAffected, res.affectedDocuments, res.upsert);
        };
        callbackify((query2, update4, options2) => this.updateAsync(query2, update4, options2))(query, update3, options, _callback);
      }
      /**
       * Update all docs matching query.
       * @param {query} query is the same kind of finding query you use with `find` and `findOne`.
       * @param {document|*} update specifies how the documents should be modified. It is either a new document or a
       * set of modifiers (you cannot use both together, it doesn't make sense!). Using a new document will replace the
       * matched docs. Using a set of modifiers will create the fields they need to modify if they don't exist, and you can
       * apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field,
       * `$inc` to increment a field's value and `$min`/`$max` to change field's value, only if provided value is
       * less/greater than current value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special
       * `$each` and `$slice`.
       * @param {Object} [options = {}] Optional options
       * @param {boolean} [options.multi = false] If true, can update multiple documents
       * @param {boolean} [options.upsert = false] If true, can insert a new document corresponding to the `update` rules if
       * your `query` doesn't match anything. If your `update` is a simple object with no modifiers, it is the inserted
       * document. In the other case, the `query` is stripped from all operator recursively, and the `update` is applied to
       * it.
       * @param {boolean} [options.returnUpdatedDocs = false] (not Mongo-DB compatible) If true and update is not an upsert,
       * will return the array of documents matched by the find query and updated. Updated documents will be returned even
       * if the update did not actually modify them.
       * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}
       * - `upsert` is `true` if and only if the update did insert a document, **cannot be true if `options.upsert !== true`**.
       * - `numAffected` is the number of documents affected by the update or insertion (if `options.multi` is `false` or `options.upsert` is `true`, cannot exceed `1`);
       * - `affectedDocuments` can be one of the following:
       *    - If `upsert` is `true`, the inserted document;
       *    - If `options.returnUpdatedDocs` is `false`, `null`;
       *    - If `options.returnUpdatedDocs` is `true`:
       *      - If `options.multi` is `false`, the updated document;
       *      - If `options.multi` is `true`, the array of updated documents.
       * @async
       */
      updateAsync(query, update3, options = {}) {
        return this.executor.pushAsync(() => this._updateAsync(query, update3, options));
      }
      /**
       * @callback Datastore~removeCallback
       * @param {?Error} err
       * @param {?number} numRemoved
       */
      /**
       * Internal version without using the {@link Datastore#executor} of {@link Datastore#removeAsync}, use it instead.
       *
       * @param {query} query
       * @param {object} [options]
       * @param {boolean} [options.multi = false]
       * @return {Promise<number>}
       * @private
       * @see Datastore#removeAsync
       */
      async _removeAsync(query, options = {}) {
        const multi = options.multi !== void 0 ? options.multi : false;
        const candidates = await this._getCandidatesAsync(query, true);
        const removedDocs = [];
        let numRemoved = 0;
        candidates.forEach((d2) => {
          if (model.match(d2, query) && (multi || numRemoved === 0)) {
            numRemoved += 1;
            removedDocs.push({ $$deleted: true, _id: d2._id });
            this._removeFromIndexes(d2);
          }
        });
        await this.persistence.persistNewStateAsync(removedDocs);
        return numRemoved;
      }
      /**
       * Callback version of {@link Datastore#removeAsync}.
       * @param {query} query
       * @param {object|Datastore~removeCallback} [options={}]
       * @param {boolean} [options.multi = false]
       * @param {Datastore~removeCallback} [cb = () => {}]
       * @see Datastore#removeAsync
       */
      remove(query, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        const callback = cb || (() => {
        });
        callbackify((query2, options2) => this.removeAsync(query2, options2))(query, options, callback);
      }
      /**
       * Remove all docs matching the query.
       * @param {query} query MongoDB-style query
       * @param {object} [options={}] Optional options
       * @param {boolean} [options.multi = false] If true, can update multiple documents
       * @return {Promise<number>} How many documents were removed
       * @async
       */
      removeAsync(query, options = {}) {
        return this.executor.pushAsync(() => this._removeAsync(query, options));
      }
    };
    module2.exports = Datastore;
  }
});

// ../../node_modules/@seald-io/nedb/index.js
var require_nedb = __commonJS({
  "../../node_modules/@seald-io/nedb/index.js"(exports2, module2) {
    var Datastore = require_datastore();
    module2.exports = Datastore;
  }
});

// ../../node_modules/fuzzysort/fuzzysort.js
var require_fuzzysort = __commonJS({
  "../../node_modules/fuzzysort/fuzzysort.js"(exports2, module2) {
    (function(root, UMD) {
      if (typeof define === "function" && define.amd) define([], UMD);
      else if (typeof module2 === "object" && module2.exports) module2.exports = UMD();
      else root.fuzzysort = UMD();
    })(exports2, function UMD() {
      function fuzzysortNew(instanceOptions) {
        var fuzzysort2 = {
          single: function(search, target, options) {
            ;
            if (search == "farzher") return { target: "farzher was here (^-^*)/", score: 0, indexes: [0, 1, 2, 3, 4, 5, 6] };
            if (!search) return null;
            var preparedSearch = fuzzysort2.getPreparedSearch(search);
            var searchLowerCodes = preparedSearch.lowerCodes;
            if (!target) return null;
            if (!isObj(target)) target = fuzzysort2.getPrepared(target);
            var searchBitmask = preparedSearch.bitmask;
            if ((searchBitmask & target._bitmask) != searchBitmask) return null;
            return fuzzysort2.algorithm(searchLowerCodes, target, search.toLowerCase());
          },
          go: function(search, targets, options) {
            ;
            if (search == "farzher") return [{ target: "farzher was here (^-^*)/", score: 0, indexes: [0, 1, 2, 3, 4, 5, 6], obj: targets ? targets[0] : null }];
            if (!search) return options && options.all || instanceOptions && instanceOptions.all ? fuzzysort2.all(search, targets, options) : noResults;
            var preparedSearch = fuzzysort2.getPreparedSearch(search);
            var searchLowerCodes = preparedSearch.lowerCodes;
            var searchLowerCode = searchLowerCodes[0];
            var searchBitmask = preparedSearch.bitmask;
            var searchLower = search.toLowerCase();
            var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;
            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;
            var resultsLen = 0;
            var limitedCount = 0;
            var targetsLen = targets.length;
            if (options && options.keys) {
              var scoreFn = options.scoreFn || defaultScoreFn;
              var keys2 = options.keys;
              var keysLen = keys2.length;
              for (var i2 = targetsLen - 1; i2 >= 0; --i2) {
                var obj = targets[i2];
                var objResults = new Array(keysLen);
                for (var keyI = keysLen - 1; keyI >= 0; --keyI) {
                  var key = keys2[keyI];
                  var target = getValue(obj, key);
                  if (!target) {
                    objResults[keyI] = null;
                    continue;
                  }
                  if (!isObj(target)) target = fuzzysort2.getPrepared(target);
                  if ((searchBitmask & target._bitmask) != searchBitmask) objResults[keyI] = null;
                  else objResults[keyI] = fuzzysort2.algorithm(searchLowerCodes, target, searchLower);
                }
                objResults.obj = obj;
                var score = scoreFn(objResults);
                if (score === null) continue;
                if (score < threshold) continue;
                objResults.score = score;
                if (resultsLen < limit) {
                  q3.add(objResults);
                  ++resultsLen;
                } else {
                  ++limitedCount;
                  if (score > q3.peek().score) q3.replaceTop(objResults);
                }
              }
            } else if (options && options.key) {
              var key = options.key;
              for (var i2 = targetsLen - 1; i2 >= 0; --i2) {
                var obj = targets[i2];
                var target = getValue(obj, key);
                if (!target) continue;
                if (!isObj(target)) target = fuzzysort2.getPrepared(target);
                if ((searchBitmask & target._bitmask) != searchBitmask) var result2 = null;
                else var result2 = fuzzysort2.algorithm(searchLowerCodes, target, searchLower);
                if (result2 === null) continue;
                if (result2.score < threshold) continue;
                result2 = { target: result2.target, _targetLower: "", _targetLowerCodes: null, _nextBeginningIndexes: null, _bitmask: 0, score: result2.score, indexes: result2.indexes, obj };
                if (resultsLen < limit) {
                  q3.add(result2);
                  ++resultsLen;
                } else {
                  ++limitedCount;
                  if (result2.score > q3.peek().score) q3.replaceTop(result2);
                }
              }
            } else {
              for (var i2 = targetsLen - 1; i2 >= 0; --i2) {
                var target = targets[i2];
                if (!target) continue;
                if (!isObj(target)) target = fuzzysort2.getPrepared(target);
                if ((searchBitmask & target._bitmask) != searchBitmask) var result2 = null;
                else var result2 = fuzzysort2.algorithm(searchLowerCodes, target, searchLower);
                if (result2 === null) continue;
                if (result2.score < threshold) continue;
                if (resultsLen < limit) {
                  q3.add(result2);
                  ++resultsLen;
                } else {
                  ++limitedCount;
                  if (result2.score > q3.peek().score) q3.replaceTop(result2);
                }
              }
            }
            if (resultsLen === 0) return noResults;
            var results = new Array(resultsLen);
            for (var i2 = resultsLen - 1; i2 >= 0; --i2) results[i2] = q3.poll();
            results.total = resultsLen + limitedCount;
            return results;
          },
          /*deprecated*/
          goAsync: function(search, targets, options) {
            var p3 = new Promise(function(resolve, reject2) {
              resolve(fuzzysort2.go(search, targets, options));
            });
            p3.cancel = function() {
            };
            return p3;
          },
          all: function(search, targets, options) {
            var results = [];
            results.total = targets.length;
            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;
            if (options && options.keys) {
              for (var i2 = 0; i2 < targets.length; i2++) {
                var obj = targets[i2];
                var objResults = new Array(options.keys.length);
                for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {
                  var target = getValue(obj, options.keys[keyI]);
                  if (!target) {
                    objResults[keyI] = null;
                    continue;
                  }
                  if (!isObj(target)) target = fuzzysort2.getPrepared(target);
                  target.score = -9007199254740991;
                  objResults[keyI] = target;
                }
                objResults.obj = obj;
                objResults.score = -9007199254740991;
                results.push(objResults);
                if (results.length >= limit) return results;
              }
            } else if (options && options.key) {
              for (var i2 = 0; i2 < targets.length; i2++) {
                var obj = targets[i2];
                var target = getValue(obj, options.key);
                if (!target) continue;
                if (!isObj(target)) target = fuzzysort2.getPrepared(target);
                target.score = -9007199254740991;
                var result2 = target;
                result2 = { target: result2.target, _targetLower: "", _targetLowerCodes: null, _nextBeginningIndexes: null, _bitmask: 0, score: target.score, indexes: null, obj };
                results.push(result2);
                if (results.length >= limit) return results;
              }
            } else {
              for (var i2 = 0; i2 < targets.length; i2++) {
                var target = targets[i2];
                if (!target) continue;
                if (!isObj(target)) target = fuzzysort2.getPrepared(target);
                target.score = -9007199254740991;
                results.push(target);
                if (results.length >= limit) return results;
              }
            }
            return results;
          },
          highlight: function(result2, hOpen, hClose) {
            if (typeof hOpen == "function") return fuzzysort2.highlightCallback(result2, hOpen);
            if (result2 === null) return null;
            if (hOpen === void 0) hOpen = "<b>";
            if (hClose === void 0) hClose = "</b>";
            var highlighted = "";
            var matchesIndex = 0;
            var opened = false;
            var target = result2.target;
            var targetLen = target.length;
            var matchesBest = result2.indexes;
            for (var i2 = 0; i2 < targetLen; ++i2) {
              var char = target[i2];
              if (matchesBest[matchesIndex] === i2) {
                ++matchesIndex;
                if (!opened) {
                  opened = true;
                  highlighted += hOpen;
                }
                if (matchesIndex === matchesBest.length) {
                  highlighted += char + hClose + target.substr(i2 + 1);
                  break;
                }
              } else {
                if (opened) {
                  opened = false;
                  highlighted += hClose;
                }
              }
              highlighted += char;
            }
            return highlighted;
          },
          highlightCallback: function(result2, cb) {
            if (result2 === null) return null;
            var target = result2.target;
            var targetLen = target.length;
            var indexes = result2.indexes;
            var highlighted = "";
            var matchI = 0;
            var indexesI = 0;
            var opened = false;
            var result2 = [];
            for (var i2 = 0; i2 < targetLen; ++i2) {
              var char = target[i2];
              if (indexes[indexesI] === i2) {
                ++indexesI;
                if (!opened) {
                  opened = true;
                  result2.push(highlighted);
                  highlighted = "";
                }
                if (indexesI === indexes.length) {
                  highlighted += char;
                  result2.push(cb(highlighted, matchI++));
                  highlighted = "";
                  result2.push(target.substr(i2 + 1));
                  break;
                }
              } else {
                if (opened) {
                  opened = false;
                  result2.push(cb(highlighted, matchI++));
                  highlighted = "";
                }
              }
              highlighted += char;
            }
            return result2;
          },
          prepare: function(target) {
            if (!target) target = "";
            var lowerCodes = fuzzysort2.prepareLowerCodes(target);
            return { target, _targetLower: target.toLowerCase(), _targetLowerCodes: lowerCodes, _nextBeginningIndexes: null, _bitmask: fuzzysort2.prepareBitmask(lowerCodes), score: null, indexes: [0], obj: null };
          },
          /*deprecated*/
          prepareSlow: function(target) {
            return fuzzysort2.prepare(target);
          },
          prepareSearch: function(search) {
            if (!search) search = "";
            var lowerCodes = fuzzysort2.prepareLowerCodes(search);
            return { lowerCodes, bitmask: fuzzysort2.prepareBitmask(lowerCodes) };
          },
          // Below this point is only internal code
          // Below this point is only internal code
          // Below this point is only internal code
          // Below this point is only internal code
          getPrepared: function(target) {
            if (target.length > 999) return fuzzysort2.prepare(target);
            var targetPrepared = preparedCache.get(target);
            if (targetPrepared !== void 0) return targetPrepared;
            targetPrepared = fuzzysort2.prepare(target);
            preparedCache.set(target, targetPrepared);
            return targetPrepared;
          },
          getPreparedSearch: function(search) {
            if (search.length > 999) return fuzzysort2.prepareSearch(search);
            var searchPrepared = preparedSearchCache.get(search);
            if (searchPrepared !== void 0) return searchPrepared;
            searchPrepared = fuzzysort2.prepareSearch(search);
            preparedSearchCache.set(search, searchPrepared);
            return searchPrepared;
          },
          algorithm: function(searchLowerCodes, prepared, searchLower) {
            var searchLowerCode = searchLowerCodes[0];
            var targetLowerCodes = prepared._targetLowerCodes;
            var searchLen = searchLowerCodes.length;
            var targetLen = targetLowerCodes.length;
            var searchI = 0;
            var targetI = 0;
            var matchesSimpleLen = 0;
            for (; ; ) {
              var isMatch2 = searchLowerCode === targetLowerCodes[targetI];
              if (isMatch2) {
                matchesSimple[matchesSimpleLen++] = targetI;
                ++searchI;
                if (searchI === searchLen) break;
                searchLowerCode = searchLowerCodes[searchI];
              }
              ++targetI;
              if (targetI >= targetLen) return null;
            }
            var searchI = 0;
            var successStrict = false;
            var matchesStrictLen = 0;
            var nextBeginningIndexes = prepared._nextBeginningIndexes;
            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort2.prepareNextBeginningIndexes(prepared.target);
            var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];
            var backtrackCount = 0;
            if (targetI !== targetLen) for (; ; ) {
              if (targetI >= targetLen) {
                if (searchI <= 0) break;
                ++backtrackCount;
                if (backtrackCount > 200) break;
                --searchI;
                var lastMatch = matchesStrict[--matchesStrictLen];
                targetI = nextBeginningIndexes[lastMatch];
              } else {
                var isMatch2 = searchLowerCodes[searchI] === targetLowerCodes[targetI];
                if (isMatch2) {
                  matchesStrict[matchesStrictLen++] = targetI;
                  ++searchI;
                  if (searchI === searchLen) {
                    successStrict = true;
                    break;
                  }
                  ++targetI;
                } else {
                  targetI = nextBeginningIndexes[targetI];
                }
              }
            }
            var substringIndex = prepared._targetLower.indexOf(searchLower, matchesSimple[0]);
            var isSubstring = ~substringIndex;
            if (isSubstring && !successStrict) {
              for (var i2 = 0; i2 < matchesSimpleLen; ++i2) matchesSimple[i2] = substringIndex + i2;
            }
            var isSubstringBeginning = false;
            if (isSubstring) {
              isSubstringBeginning = prepared._nextBeginningIndexes[substringIndex - 1] == substringIndex;
            }
            {
              if (successStrict) {
                var matchesBest = matchesStrict;
                var matchesBestLen = matchesStrictLen;
              } else {
                var matchesBest = matchesSimple;
                var matchesBestLen = matchesSimpleLen;
              }
              var score = 0;
              var extraMatchGroupCount = 0;
              for (var i2 = searchLen - 1; i2 >= 1; --i2) {
                if (matchesBest[i2] - matchesBest[i2 - 1] !== 1) {
                  score -= matchesBest[i2];
                  ++extraMatchGroupCount;
                }
              }
              var unmatchedDistance = matchesBest[searchLen - 1] - matchesBest[0] - (searchLen - 1);
              score -= unmatchedDistance * extraMatchGroupCount;
              if (matchesBest[0] !== 0) score -= matchesBest[0] * 10;
              if (!successStrict) {
                score *= 1e3;
              } else {
                var uniqueBeginningIndexes = 1;
                for (var i2 = nextBeginningIndexes[0]; i2 < targetLen; i2 = nextBeginningIndexes[i2]) ++uniqueBeginningIndexes;
                if (uniqueBeginningIndexes > 24) score *= (uniqueBeginningIndexes - 24) * 10;
              }
              if (isSubstring) score /= 10;
              if (isSubstringBeginning) score /= 10;
              score -= targetLen - searchLen;
              prepared.score = score;
              prepared.indexes = new Array(matchesBestLen);
              for (var i2 = matchesBestLen - 1; i2 >= 0; --i2) prepared.indexes[i2] = matchesBest[i2];
              return prepared;
            }
          },
          prepareLowerCodes: function(str) {
            var strLen = str.length;
            var lowerCodes = [];
            var lower = str.toLowerCase();
            for (var i2 = 0; i2 < strLen; ++i2) lowerCodes[i2] = lower.charCodeAt(i2);
            return lowerCodes;
          },
          prepareBeginningIndexes: function(target) {
            var targetLen = target.length;
            var beginningIndexes = [];
            var beginningIndexesLen = 0;
            var wasUpper = false;
            var wasAlphanum = false;
            for (var i2 = 0; i2 < targetLen; ++i2) {
              var targetCode = target.charCodeAt(i2);
              var isUpper = targetCode >= 65 && targetCode <= 90;
              var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;
              var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;
              wasUpper = isUpper;
              wasAlphanum = isAlphanum;
              if (isBeginning) beginningIndexes[beginningIndexesLen++] = i2;
            }
            return beginningIndexes;
          },
          prepareNextBeginningIndexes: function(target) {
            var targetLen = target.length;
            var beginningIndexes = fuzzysort2.prepareBeginningIndexes(target);
            var nextBeginningIndexes = [];
            var lastIsBeginning = beginningIndexes[0];
            var lastIsBeginningI = 0;
            for (var i2 = 0; i2 < targetLen; ++i2) {
              if (lastIsBeginning > i2) {
                nextBeginningIndexes[i2] = lastIsBeginning;
              } else {
                lastIsBeginning = beginningIndexes[++lastIsBeginningI];
                nextBeginningIndexes[i2] = lastIsBeginning === void 0 ? targetLen : lastIsBeginning;
              }
            }
            return nextBeginningIndexes;
          },
          prepareBitmask: function(lowerCodes) {
            var bitmask = 0;
            for (var i2 = lowerCodes.length - 1; i2 >= 0; --i2) {
              var lowerCode = lowerCodes[i2];
              var bit = lowerCode >= 97 && lowerCode <= 122 ? lowerCode - 97 : lowerCode >= 48 && lowerCode <= 57 ? 26 : lowerCode === 32 ? 27 : lowerCode <= 127 ? 28 : 29;
              bitmask |= 1 << bit;
            }
            return bitmask;
          },
          cleanup,
          new: fuzzysortNew
        };
        return fuzzysort2;
      }
      var isNode = typeof require !== "undefined" && typeof window === "undefined";
      var MyMap = typeof Map === "function" ? Map : function() {
        var s2 = /* @__PURE__ */ Object.create(null);
        this.get = function(k2) {
          return s2[k2];
        };
        this.set = function(k2, val) {
          s2[k2] = val;
          return this;
        };
        this.clear = function() {
          s2 = /* @__PURE__ */ Object.create(null);
        };
      };
      var preparedCache = new MyMap();
      var preparedSearchCache = new MyMap();
      var noResults = [];
      noResults.total = 0;
      var matchesSimple = [];
      var matchesStrict = [];
      function cleanup() {
        preparedCache.clear();
        preparedSearchCache.clear();
        matchesSimple = [];
        matchesStrict = [];
      }
      function defaultScoreFn(a2) {
        var max2 = -9007199254740991;
        for (var i2 = a2.length - 1; i2 >= 0; --i2) {
          var result2 = a2[i2];
          if (result2 === null) continue;
          var score = result2.score;
          if (score > max2) max2 = score;
        }
        if (max2 === -9007199254740991) return null;
        return max2;
      }
      function getValue(obj, prop) {
        var tmp = obj[prop];
        if (tmp !== void 0) return tmp;
        var segs = prop;
        if (!Array.isArray(prop)) segs = prop.split(".");
        var len = segs.length;
        var i2 = -1;
        while (obj && ++i2 < len) obj = obj[segs[i2]];
        return obj;
      }
      function isObj(x3) {
        return typeof x3 === "object";
      }
      var fastpriorityqueue = function() {
        var r2 = [], o2 = 0, e2 = {};
        function n2() {
          for (var e3 = 0, n3 = r2[e3], c2 = 1; c2 < o2; ) {
            var f3 = c2 + 1;
            e3 = c2, f3 < o2 && r2[f3].score < r2[c2].score && (e3 = f3), r2[e3 - 1 >> 1] = r2[e3], c2 = 1 + (e3 << 1);
          }
          for (var a2 = e3 - 1 >> 1; e3 > 0 && n3.score < r2[a2].score; a2 = (e3 = a2) - 1 >> 1) r2[e3] = r2[a2];
          r2[e3] = n3;
        }
        return e2.add = function(e3) {
          var n3 = o2;
          r2[o2++] = e3;
          for (var c2 = n3 - 1 >> 1; n3 > 0 && e3.score < r2[c2].score; c2 = (n3 = c2) - 1 >> 1) r2[n3] = r2[c2];
          r2[n3] = e3;
        }, e2.poll = function() {
          if (0 !== o2) {
            var e3 = r2[0];
            return r2[0] = r2[--o2], n2(), e3;
          }
        }, e2.peek = function(e3) {
          if (0 !== o2) return r2[0];
        }, e2.replaceTop = function(o3) {
          r2[0] = o3, n2();
        }, e2;
      };
      var q3 = fastpriorityqueue();
      return fuzzysortNew();
    });
  }
});

// src/common/misc.ts
function filterHeaders(headers, name) {
  if (!Array.isArray(headers) || !name || typeof name !== "string") {
    return [];
  }
  return headers.filter((header) => {
    if (!header || !header.name || typeof header.name !== "string") {
      return false;
    }
    return header.name.toLowerCase() === name.toLowerCase();
  });
}
function hasContentTypeHeader(headers) {
  return filterHeaders(headers, "content-type").length > 0;
}
function hasAuthHeader(headers) {
  return filterHeaders(headers, "authorization").length > 0;
}
function hasAcceptHeader(headers) {
  return filterHeaders(headers, "accept").length > 0;
}
function hasAcceptEncodingHeader(headers) {
  return filterHeaders(headers, "accept-encoding").length > 0;
}
function getContentTypeHeader(headers) {
  const matches2 = filterHeaders(headers, "content-type");
  return matches2.length ? matches2[0] : null;
}
function getHostHeader(headers) {
  const matches2 = filterHeaders(headers, "host");
  return matches2.length ? matches2[0] : null;
}
function describeByteSize(bytes, long = false) {
  bytes = Math.round(bytes * 10) / 10;
  let size2;
  let unit;
  if (bytes < 1024 * 2) {
    size2 = bytes;
    unit = long ? "bytes" : "B";
  } else if (bytes < 1024 * 1024 * 2) {
    size2 = bytes / 1024;
    unit = long ? "kilobytes" : "KB";
  } else if (bytes < 1024 * 1024 * 1024 * 2) {
    size2 = bytes / 1024 / 1024;
    unit = long ? "megabytes" : "MB";
  } else {
    size2 = bytes / 1024 / 1024 / 1024;
    unit = long ? "gigabytes" : "GB";
  }
  const rounded = Math.round(size2 * 10) / 10;
  return `${rounded} ${unit}`;
}
function escapeRegex(str) {
  return str.replace(ESCAPE_REGEX_MATCH, "\\$&");
}
function cannotAccessPathError(accessingPath) {
  return process.type === "renderer" || process.type === "browser" ? `Insomnia cannot access the file "${accessingPath}". You must specify which directories Insomnia can access in Insomnia Preferences \u2192 Security` : `Insomnia cannot access the file \u2018${accessingPath}\u2019. You must specify which directories Insomnia can access with one or more "--dataFolders <directory>".`;
}
var import_fuzzysort, ESCAPE_REGEX_MATCH;
var init_misc = __esm({
  "src/common/misc.ts"() {
    "use strict";
    import_fuzzysort = __toESM(require_fuzzysort());
    init_constants();
    ESCAPE_REGEX_MATCH = /[-[\]/{}()*+?.\\^$|]/g;
  }
});

// src/utils/index.ts
var init_utils = __esm({
  "src/utils/index.ts"() {
    "use strict";
  }
});

// src/common/strings.ts
var strings;
var init_strings = __esm({
  "src/common/strings.ts"() {
    "use strict";
    strings = {
      collection: {
        singular: "Collection",
        plural: "Collections"
      },
      mock: {
        singular: "Mock",
        plural: "Mocks"
      },
      document: {
        singular: "Document",
        plural: "Documents"
      },
      organization: {
        singular: "Organization",
        plural: "Organizations"
      },
      project: {
        singular: "Project",
        plural: "Projects"
      },
      workspace: {
        singular: "Workspace",
        plural: "Workspaces"
      },
      defaultProject: {
        singular: "Default",
        plural: "Default"
      },
      localProject: {
        singular: "Local",
        plural: "Local"
      },
      remoteProject: {
        singular: "Remote",
        plural: "Remote"
      },
      environment: {
        singular: "Environment",
        plural: "Environments"
      },
      mcp: {
        singular: "MCP Client",
        plural: "MCP Clients"
      }
    };
  }
});

// src/models/api-spec.ts
var init_api_spec = __esm({
  "src/models/api-spec.ts"() {
    "use strict";
    init_database();
    init_strings();
  }
});

// src/models/ca-certificate.ts
var init_ca_certificate = __esm({
  "src/models/ca-certificate.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/cloud-credential.ts
var init_cloud_credential = __esm({
  "src/models/cloud-credential.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/cookie-jar.ts
var init_cookie_jar = __esm({
  "src/models/cookie-jar.ts"() {
    "use strict";
    init_database();
  }
});

// ../../node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.clonedeep/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag2 = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag2 = "[object Date]";
    var errorTag2 = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag2 = "[object Map]";
    var numberTag2 = "[object Number]";
    var objectTag2 = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag2 = "[object RegExp]";
    var setTag3 = "[object Set]";
    var stringTag2 = "[object String]";
    var symbolTag2 = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag2 = "[object ArrayBuffer]";
    var dataViewTag2 = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag2] = cloneableTags[dataViewTag2] = cloneableTags[boolTag] = cloneableTags[dateTag2] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag2] = cloneableTags[numberTag2] = cloneableTags[objectTag2] = cloneableTags[regexpTag2] = cloneableTags[setTag3] = cloneableTags[stringTag2] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag2] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map2, pair) {
      map2.set(pair[0], pair[1]);
      return map2;
    }
    function addSetEntry(set2, value) {
      set2.add(value);
      return set2;
    }
    function arrayEach(array, iteratee2) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee2(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values2) {
      var index = -1, length = values2.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values2[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee2, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee2(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n2, iteratee2) {
      var index = -1, result2 = Array(n2);
      while (++index < n2) {
        result2[index] = iteratee2(index);
      }
      return result2;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result2 = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result2 = !!(value + "");
        } catch (e2) {
        }
      }
      return result2;
    }
    function mapToArray(map2) {
      var index = -1, result2 = Array(map2.size);
      map2.forEach(function(value, key) {
        result2[++index] = [key, value];
      });
      return result2;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result2 = Array(set2.size);
      set2.forEach(function(value) {
        result2[++index] = value;
      });
      return result2;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString2 = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys2(value, inherited) {
      var result2 = isArray2(value) || isArguments2(value) ? baseTimes(value.length, String) : [];
      var length = result2.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    function assignValue2(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq2(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys2(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result2;
      if (customizer) {
        result2 = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result2 !== void 0) {
        return result2;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result2 = initCloneArray(value);
        if (!isDeep) {
          return copyArray2(value, result2);
        }
      } else {
        var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer3(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag2 || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result2 = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result2, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result2 = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result2);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys2(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue2(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result2;
    }
    function baseCreate(proto) {
      return isObject2(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result2 = keysFunc(object);
      return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString2.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype2(object)) {
        return nativeKeys(object);
      }
      var result2 = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result2.push(key);
        }
      }
      return result2;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result2 = new buffer.constructor(buffer.length);
      buffer.copy(result2);
      return result2;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
      return result2;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
      return arrayReduce(array, addMapEntry, new map2.constructor());
    }
    function cloneRegExp(regexp) {
      var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result2.lastIndex = regexp.lastIndex;
      return result2;
    }
    function cloneSet(set2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
      return arrayReduce(array, addSetEntry, new set2.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray2(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue2(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols2(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols2);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols2 = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray2;
    var getTag2 = baseGetTag;
    if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag3 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
      getTag2 = function(value) {
        var result2 = objectToString2.call(value), Ctor = result2 == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag2;
            case mapCtorString:
              return mapTag2;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag3;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result2;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result2 = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result2.index = array.index;
        result2.input = array.input;
      }
      return result2;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag2:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag2:
          return new Ctor(+object);
        case dataViewTag2:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag2:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag2:
        case stringTag2:
          return new Ctor(object);
        case regexpTag2:
          return cloneRegExp(object);
        case setTag3:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag2:
          return cloneSymbol(object);
      }
    }
    function isIndex2(value, length) {
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype2(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function cloneDeep3(value) {
      return baseClone(value, true, true);
    }
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments2(value) {
      return isArrayLikeObject2(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength3(value.length) && !isFunction3(value);
    }
    function isArrayLikeObject2(value) {
      return isObjectLike2(value) && isArrayLike2(value);
    }
    var isBuffer3 = nativeIsBuffer || stubFalse2;
    function isFunction3(value) {
      var tag = isObject2(value) ? objectToString2.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength3(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function keys2(object) {
      return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys(object);
    }
    function stubArray2() {
      return [];
    }
    function stubFalse2() {
      return false;
    }
    module2.exports = cloneDeep3;
  }
});

// ../../node_modules/json-order/dist/order.js
var require_order = __commonJS({
  "../../node_modules/json-order/dist/order.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lodash_clonedeep_1 = __importDefault(require_lodash());
    var getProperty = function(obj, key, separator) {
      var exists = true;
      var value = key.split(separator).filter(function(s2) {
        return s2.length > 0;
      }).reduce(function(o2, x3) {
        exists = o2 && o2.hasOwnProperty(x3);
        if (!exists) {
          return void 0;
        }
        return o2[x3];
      }, obj);
      return { exists, value };
    };
    var setProperty = function(obj, key, value, separator) {
      key.split(separator).filter(function(s2) {
        return s2.length > 0;
      }).reduce(function(o2, x3, idx, src) {
        if (idx === src.length - 1) {
          var valueToSet = Array.isArray(value) ? lodash_clonedeep_1.default(value).map(function(p3) {
            return typeof p3 === "object" ? {} : p3;
          }) : value;
          o2[x3] = valueToSet;
        }
        return o2[x3];
      }, obj);
    };
    var copyProperty = function(sourceObject, resultObject, propertyPath, separator) {
      var result2 = getProperty(sourceObject, propertyPath, separator);
      if (result2.exists) {
        setProperty(resultObject, propertyPath, result2.value, separator);
      }
    };
    var order = function(sourceObject, map2, separator) {
      if (separator === void 0) {
        separator = "~";
      }
      if (separator.length < 1) {
        throw new Error("Separator should not be an empty string.");
      }
      if (!map2) {
        return sourceObject;
      }
      var mapKeys3 = Object.keys(map2);
      var prefixLength = mapKeys3[0] && mapKeys3[0].length || 0;
      var resultObject = {};
      mapKeys3.forEach(function(mk) {
        var childKeys = map2[mk];
        var parentKey = mk.substr(prefixLength);
        var parent = getProperty(sourceObject, parentKey, separator);
        if (parent.exists) {
          var defaultValue = Array.isArray(parent.value) ? parent.value : {};
          setProperty(resultObject, parentKey, defaultValue, separator);
          childKeys.forEach(function(key) {
            return copyProperty(sourceObject, resultObject, "" + parentKey + separator + key, separator);
          });
        }
      });
      return resultObject;
    };
    exports2.default = order;
  }
});

// ../../node_modules/json-order/dist/parse.js
var require_parse3 = __commonJS({
  "../../node_modules/json-order/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var traverseObject = function(obj, map2, parentKey, separator) {
      var childKeys = Object.keys(obj);
      if (childKeys.length === 0) {
        return;
      }
      if (!Array.isArray(obj)) {
        map2["" + parentKey] = childKeys;
      }
      childKeys.forEach(function(childKey) {
        var value = obj[childKey];
        if (typeof value === "object") {
          traverseObject(value, map2, "" + parentKey + separator + childKey, separator);
        }
      });
    };
    var parse = function(jsonString, prefix2, separator) {
      if (prefix2 === void 0) {
        prefix2 = "$";
      }
      if (separator === void 0) {
        separator = "~";
      }
      if (prefix2.length < 1) {
        throw new Error("Prefix should not be an empty string.");
      }
      if (separator.length < 1) {
        throw new Error("Separator should not be an empty string.");
      }
      var obj = JSON.parse(jsonString);
      var map2 = {};
      traverseObject(obj, map2, prefix2, separator);
      return {
        object: obj,
        map: map2
      };
    };
    exports2.default = parse;
  }
});

// ../../node_modules/json-order/dist/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/json-order/dist/stringify.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var order_1 = __importDefault(require_order());
    var stringify = function(sourceObject, map2, separator, space) {
      if (separator === void 0) {
        separator = "~";
      }
      return JSON.stringify(order_1.default(sourceObject, map2, separator), null, space);
    };
    exports2.default = stringify;
  }
});

// ../../node_modules/json-order/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/json-order/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var order_1 = __importDefault(require_order());
    var parse_1 = __importDefault(require_parse3());
    var stringify_1 = __importDefault(require_stringify2());
    var orderedJSON2 = { parse: parse_1.default, stringify: stringify_1.default, order: order_1.default };
    exports2.default = orderedJSON2;
  }
});

// ../../node_modules/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "../../node_modules/hkdf/lib/hkdf.js"(exports2, module2) {
    var crypto3 = require("crypto");
    function zeros(length) {
      var buf = new Buffer(length);
      buf.fill(0);
      return buf.toString();
    }
    function HKDF2(hashAlg, salt, ikm) {
      this.hashAlg = hashAlg;
      var hash = crypto3.createHash(this.hashAlg);
      this.hashLength = hash.digest().length;
      this.salt = salt || zeros(this.hashLength);
      this.ikm = ikm;
      var hmac = crypto3.createHmac(this.hashAlg, this.salt);
      hmac.update(this.ikm);
      this.prk = hmac.digest();
    }
    HKDF2.prototype = {
      derive: function(info, size2, cb) {
        var prev = new Buffer(0);
        var output;
        var buffers = [];
        var num_blocks = Math.ceil(size2 / this.hashLength);
        info = new Buffer(info);
        for (var i2 = 0; i2 < num_blocks; i2++) {
          var hmac = crypto3.createHmac(this.hashAlg, this.prk);
          hmac.update(prev);
          hmac.update(info);
          hmac.update(new Buffer([i2 + 1]));
          prev = hmac.digest();
          buffers.push(prev);
        }
        output = Buffer.concat(buffers, size2);
        process.nextTick(function() {
          cb(output);
        });
      }
    };
    module2.exports = HKDF2;
  }
});

// ../../node_modules/hkdf/index.js
var require_hkdf2 = __commonJS({
  "../../node_modules/hkdf/index.js"(exports2, module2) {
    module2.exports = require_hkdf();
  }
});

// ../../node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "../../node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// ../../node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "../../node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i2 = 0;
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j3 = 0, carry = input[i2]; j3 < digits.length; ++j3) {
            carry += digits[j3] << 8;
            digits[j3] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i2 = 0; i2 < alphabet.length; ++i2) {
          table[alphabet.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var bytes = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = table[input.charCodeAt(i2)];
        if (value === void 0) {
          return;
        }
        for (var j3 = 0, carry = value; j3 < bytes.length; ++j3) {
          carry += bytes[j3] * base;
          bytes[j3] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k2 = 0; input[k2] === first && k2 < input.length - 1; ++k2) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i2 = 0;
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j3 = 0, carry = input.at(i2); j3 < digits.length; ++j3) {
          carry += digits[j3] << 8;
          digits[j3] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet[digits[i2]];
      }
      return output;
    }
  }
});

// ../../node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "../../node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge2 = require_forge();
    var baseN = require_baseN();
    var util2 = module2.exports = forge2.util = forge2.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util2.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util2.setImmediate = setImmediate;
        } else {
          util2.setImmediate = util2.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util2.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util2.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util2.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util2.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now2 = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util2.setImmediate;
        util2.setImmediate = function(callback) {
          if (Date.now() - now2 > 15) {
            now2 = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util2.nextTick = util2.setImmediate;
    })();
    util2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util2.globalScope = (function() {
      if (util2.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    })();
    util2.isArray = Array.isArray || function(x3) {
      return Object.prototype.toString.call(x3) === "[object Array]";
    };
    util2.isArrayBuffer = function(x3) {
      return typeof ArrayBuffer !== "undefined" && x3 instanceof ArrayBuffer;
    };
    util2.isArrayBufferView = function(x3) {
      return x3 && util2.isArrayBuffer(x3.buffer) && x3.byteLength !== void 0;
    };
    function _checkBitsParam(n2) {
      if (!(n2 === 8 || n2 === 16 || n2 === 24 || n2 === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n2);
      }
    }
    util2.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util2.isArrayBuffer(b2) || util2.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e2) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    util2.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util2.ByteStringBuffer.prototype._optimizeConstructedString = function(x3) {
      this._constructedStringLength += x3;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util2.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util2.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util2.ByteStringBuffer.prototype.fillWithByte = function(b2, n2) {
      b2 = String.fromCharCode(b2);
      var d2 = this.data;
      while (n2 > 0) {
        if (n2 & 1) {
          d2 += b2;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          b2 += b2;
        }
      }
      this.data = d2;
      this._optimizeConstructedString(n2);
      return this;
    };
    util2.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util2.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util2.encodeUtf8(str));
    };
    util2.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      var bytes = "";
      do {
        n2 -= 8;
        bytes += String.fromCharCode(i2 >> n2 & 255);
      } while (n2 > 0);
      return this.putBytes(bytes);
    };
    util2.ByteStringBuffer.prototype.putSignedInt = function(i2, n2) {
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util2.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util2.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util2.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util2.ByteStringBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max2 = 2 << n2 - 2;
      if (x3 >= max2) {
        x3 -= max2 << 1;
      }
      return x3;
    };
    util2.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util2.ByteStringBuffer.prototype.setAt = function(i2, b2) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util2.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util2.ByteStringBuffer.prototype.copy = function() {
      var c2 = util2.createBuffer(this.data);
      c2.read = this.read;
      return c2;
    };
    util2.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util2.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b2 = this.data.charCodeAt(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.toString = function() {
      return util2.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer3 = util2.isArrayBuffer(b2);
      var isArrayBufferView = util2.isArrayBufferView(b2);
      if (isArrayBuffer3 || isArrayBufferView) {
        if (isArrayBuffer3) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util2.DataBuffer = DataBuffer;
    util2.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util2.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util2.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util2.DataBuffer.prototype.fillWithByte = function(b2, n2) {
      this.accommodate(n2);
      for (var i2 = 0; i2 < n2; ++i2) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util2.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util2.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util2.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util2.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util2.isArrayBufferView(bytes.data)) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util2.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util2.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util2.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util2.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util2.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util2.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      do {
        n2 -= 8;
        this.data.setInt8(this.write++, i2 >> n2 & 255);
      } while (n2 > 0);
      return this;
    };
    util2.DataBuffer.prototype.putSignedInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util2.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util2.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util2.DataBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max2 = 2 << n2 - 2;
      if (x3 >= max2) {
        x3 -= max2 << 1;
      }
      return x3;
    };
    util2.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util2.DataBuffer.prototype.setAt = function(i2, b2) {
      this.data.setUint8(i2, b2);
      return this;
    };
    util2.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util2.DataBuffer.prototype.copy = function() {
      return new util2.DataBuffer(this);
    };
    util2.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util2.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util2.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util2.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b2 = this.data.getUint8(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util2.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util2.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util2.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util2.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util2.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util2.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util2.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util2.encodeUtf8(input);
      }
      return new util2.ByteBuffer(input);
    };
    util2.fillString = function(c2, n2) {
      var s2 = "";
      while (n2 > 0) {
        if (n2 & 1) {
          s2 += c2;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          c2 += c2;
        }
      }
      return s2;
    };
    util2.xorBytes = function(s1, s2, n2) {
      var s3 = "";
      var b2 = "";
      var t2 = "";
      var i2 = 0;
      var c2 = 0;
      for (; n2 > 0; --n2, ++i2) {
        b2 = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c2 >= 10) {
          s3 += t2;
          t2 = "";
          c2 = 0;
        }
        t2 += String.fromCharCode(b2);
        ++c2;
      }
      s3 += t2;
      return s3;
    };
    util2.hexToBytes = function(hex) {
      var rval = "";
      var i2 = 0;
      if (hex.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i2 < hex.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
      }
      return rval;
    };
    util2.bytesToHex = function(bytes) {
      return util2.createBuffer(bytes).toHex();
    };
    util2.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util2.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util2.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util2.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util2.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util2.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util2.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j3 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j3++] = str.charCodeAt(i2);
      }
      return output ? j3 - offset : out;
    };
    util2.binary.hex.encode = util2.bytesToHex;
    util2.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i2 = 0, j3 = offset;
      if (hex.length & 1) {
        i2 = 1;
        out[j3++] = parseInt(hex[0], 16);
      }
      for (; i2 < hex.length; i2 += 2) {
        out[j3++] = parseInt(hex.substr(i2, 2), 16);
      }
      return output ? j3 - offset : out;
    };
    util2.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j3 = offset;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j3++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j3++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j3++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j3 - offset : out.subarray(0, j3);
    };
    util2.binary.base58.encode = function(input, maxline) {
      return util2.binary.baseN.encode(input, _base58, maxline);
    };
    util2.binary.base58.decode = function(input, maxline) {
      return util2.binary.baseN.decode(input, _base58, maxline);
    };
    util2.text = {
      utf8: {},
      utf16: {}
    };
    util2.text.utf8.encode = function(str, output, offset) {
      str = util2.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j3 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j3++] = str.charCodeAt(i2);
      }
      return output ? j3 - offset : out;
    };
    util2.text.utf8.decode = function(bytes) {
      return util2.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util2.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j3 = offset;
      var k2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k2++] = str.charCodeAt(i2);
        j3 += 2;
      }
      return output ? j3 - offset : out;
    };
    util2.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util2.deflate = function(api, bytes, raw) {
      bytes = util2.decode64(api.deflate(util2.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util2.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util2.encode64(bytes)).rval;
      return rval === null ? null : util2.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util2.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util2.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = true;
        for (var prop in obj) {
          empty = false;
          break;
        }
        if (empty) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util2.setItem = function(api, id, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util2.getItem = function(api, id, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util2.removeItem = function(api, id, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util2.clearItems = function(api, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util2.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util2.format = function(format) {
      var re3 = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last3 = 0;
      while (match = re3.exec(format)) {
        part = format.substring(last3, re3.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last3 = re3.lastIndex;
        var code = match[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          // FIXME: do proper formating for numbers, etc
          //case 'f':
          //case 'd':
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format.substring(last3));
      return parts.join("");
    };
    util2.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n2 = number, c2 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d2 = dec_point === void 0 ? "," : dec_point;
      var t2 = thousands_sep === void 0 ? "." : thousands_sep, s2 = n2 < 0 ? "-" : "";
      var i2 = parseInt(n2 = Math.abs(+n2 || 0).toFixed(c2), 10) + "";
      var j3 = i2.length > 3 ? i2.length % 3 : 0;
      return s2 + (j3 ? i2.substr(0, j3) + t2 : "") + i2.substr(j3).replace(/(\d{3})(?=\d)/g, "$1" + t2) + (c2 ? d2 + Math.abs(n2 - i2).toFixed(c2).slice(2) : "");
    };
    util2.formatSize = function(size2) {
      if (size2 >= 1073741824) {
        size2 = util2.formatNumber(size2 / 1073741824, 2, ".", "") + " GiB";
      } else if (size2 >= 1048576) {
        size2 = util2.formatNumber(size2 / 1048576, 2, ".", "") + " MiB";
      } else if (size2 >= 1024) {
        size2 = util2.formatNumber(size2 / 1024, 0) + " KiB";
      } else {
        size2 = util2.formatNumber(size2, 0) + " bytes";
      }
      return size2;
    };
    util2.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util2.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util2.bytesFromIPv6(ip);
      }
      return null;
    };
    util2.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b2 = util2.createBuffer();
      for (var i2 = 0; i2 < ip.length; ++i2) {
        var num = parseInt(ip[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util2.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e2) {
        if (e2.length === 0) ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b2 = util2.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip[i2] || ip[i2].length === 0) {
          b2.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util2.hexToBytes(ip[i2]);
        if (bytes.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes);
      }
      return b2.getBytes();
    };
    util2.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util2.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util2.bytesToIPv6(bytes);
      }
      return null;
    };
    util2.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        ip.push(bytes.charCodeAt(i2));
      }
      return ip.join(".");
    };
    util2.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes.length; i2 += 2) {
        var hex = util2.bytesToHex(bytes[i2] + bytes[i2 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last3 = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last3 || idx !== last3.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last3.end = idx;
            if (last3.end - last3.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util2.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util2 && !options.update) {
        return callback(null, util2.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util2.cores = navigator.hardwareConcurrency;
        return callback(null, util2.cores);
      }
      if (typeof Worker === "undefined") {
        util2.cores = 1;
        return callback(null, util2.cores);
      }
      if (typeof Blob === "undefined") {
        util2.cores = 2;
        return callback(null, util2.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e2) {
            var st = Date.now();
            var et2 = st + 4;
            while (Date.now() < et2) ;
            self.postMessage({ st, et: et2 });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample3([], 5, 16);
      function sample3(max2, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max2.reduce(function(avg2, x3) {
            return avg2 + x3;
          }, 0) / max2.length);
          util2.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util2.cores);
        }
        map2(numWorkers, function(err, results) {
          max2.push(reduce2(numWorkers, results));
          sample3(max2, samples - 1, numWorkers);
        });
      }
      function map2(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e2) {
            results.push(e2.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce2(numWorkers, results) {
        var overlaps = [];
        for (var n2 = 0; n2 < numWorkers; ++n2) {
          var r1 = results[n2];
          var overlap = overlaps[n2] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n2 === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max2, overlap2) {
          return Math.max(max2, overlap2.length);
        }, 0);
      }
    };
  }
});

// ../../node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "../../node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    module2.exports = forge2.cipher = forge2.cipher || {};
    forge2.cipher.algorithms = forge2.cipher.algorithms || {};
    forge2.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge2.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge2.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge2.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge2.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge2.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge2.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge2.cipher.algorithms[name] = algorithm;
    };
    forge2.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge2.cipher.algorithms) {
        return forge2.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge2.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge2.util.createBuffer();
      this.output = options.output || forge2.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad3) {
      if (pad3 && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad3(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad3(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "../../node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    forge2.cipher = forge2.cipher || {};
    var modes = module2.exports = forge2.cipher.modes = forge2.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge2.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge2.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge2.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge2.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge2.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge2.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x3, y2) {
      var z_i = [0, 0, 0, 0];
      var v_i = y2.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x3[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x3, out) {
      var lsb = x3[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x3[i2] >>> 1 | (x3[i2 - 1] & 1) << 31;
      }
      out[0] = x3[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x3) {
      var z3 = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x3[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah = this._m[i2][x_i];
        z3[0] ^= ah[0];
        z3[1] ^= ah[1];
        z3[2] ^= ah[2];
        z3[3] ^= ah[3];
      }
      return z3;
    };
    modes.gcm.prototype.ghash = function(h2, y2, x3) {
      y2[0] ^= x3[0];
      y2[1] ^= x3[1];
      y2[2] ^= x3[2];
      y2[3] ^= x3[3];
      return this.tableMultiply(y2);
    };
    modes.gcm.prototype.generateHashTable = function(h2, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size2 = 16 * multiplier;
      var m3 = new Array(size2);
      for (var i2 = 0; i2 < size2; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m3[i2] = this.generateSubHashTable(this.multiply(tmp, h2), bits);
      }
      return m3;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size2 = 1 << bits;
      var half = size2 >>> 1;
      var m3 = new Array(size2);
      m3[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m3[2 * i2], m3[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j3 = 1; j3 < i2; ++j3) {
          var m_i = m3[i2];
          var m_j = m3[j3];
          m3[i2 + j3] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m3[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size2; ++i2) {
        var c2 = m3[i2 ^ half];
        m3[i2] = [mid[0] ^ c2[0], mid[1] ^ c2[1], mid[2] ^ c2[2], mid[3] ^ c2[3]];
      }
      return m3;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge2.util.createBuffer(iv);
      }
      if (forge2.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge2.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv.putByte(tmp[i2]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge2.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// ../../node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "../../node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge2 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge2.aes = forge2.aes || {};
    forge2.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge2.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge2.aes.Algorithm = function(name, mode) {
      if (!init4) {
        initialize();
      }
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge2.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge2.util.createBuffer(key);
      } else if (forge2.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge2.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge2.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge2.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge2.aes._expandKey = function(key, decrypt) {
      if (!init4) {
        initialize();
      }
      return _expandKey(key, decrypt);
    };
    forge2.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge2.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge2.cipher.modes.gcm);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge2.aes.Algorithm(name, mode);
      };
      forge2.cipher.registerAlgorithm(name, factory);
    }
    var init4 = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init4 = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e2 = 0, ei = 0, e22, e4, e8, sx, sx2, me3, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e2] = sx;
        isbox[sx] = e2;
        sx2 = xtime[sx];
        e22 = xtime[e2];
        e4 = xtime[e22];
        e8 = xtime[e4];
        me3 = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e22 ^ e4 ^ e8) << 24 ^ // E (14)
        (e2 ^ e8) << 16 ^ // 9
        (e2 ^ e4 ^ e8) << 8 ^ // D (13)
        (e2 ^ e22 ^ e8);
        for (var n2 = 0; n2 < 4; ++n2) {
          mix[n2][e2] = me3;
          imix[n2][sx] = ime;
          me3 = me3 << 24 | me3 >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e2 === 0) {
          e2 = ei = 1;
        } else {
          e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt) {
      var w3 = key.slice(0);
      var temp, iNk = 1;
      var Nk = w3.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w3[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w3[i2] = w3[i2 - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m22 = imix[2];
        var m3 = imix[3];
        var wnew = w3.slice(0);
        end = w3.length;
        for (var i2 = 0, wi = end - Nb; i2 < end; i2 += Nb, wi -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w3[wi];
            wnew[i2 + 1] = w3[wi + 3];
            wnew[i2 + 2] = w3[wi + 2];
            wnew[i2 + 3] = w3[wi + 1];
          } else {
            for (var n2 = 0; n2 < Nb; ++n2) {
              tmp = w3[wi + n2];
              wnew[i2 + (3 & -n2)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m22[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w3 = wnew;
      }
      return w3;
    }
    function _updateBlock(w3, input, output, decrypt) {
      var Nr2 = w3.length / 4 - 1;
      var m0, m1, m22, m3, sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m22 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m22 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a2, b2, c2, d2, a22, b22, c22;
      a2 = input[0] ^ w3[0];
      b2 = input[decrypt ? 3 : 1] ^ w3[1];
      c2 = input[2] ^ w3[2];
      d2 = input[decrypt ? 1 : 3] ^ w3[3];
      var i2 = 3;
      for (var round2 = 1; round2 < Nr2; ++round2) {
        a22 = m0[a2 >>> 24] ^ m1[b2 >>> 16 & 255] ^ m22[c2 >>> 8 & 255] ^ m3[d2 & 255] ^ w3[++i2];
        b22 = m0[b2 >>> 24] ^ m1[c2 >>> 16 & 255] ^ m22[d2 >>> 8 & 255] ^ m3[a2 & 255] ^ w3[++i2];
        c22 = m0[c2 >>> 24] ^ m1[d2 >>> 16 & 255] ^ m22[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w3[++i2];
        d2 = m0[d2 >>> 24] ^ m1[a2 >>> 16 & 255] ^ m22[b2 >>> 8 & 255] ^ m3[c2 & 255] ^ w3[++i2];
        a2 = a22;
        b2 = b22;
        c2 = c22;
      }
      output[0] = sub[a2 >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c2 >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w3[++i2];
      output[decrypt ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c2 >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w3[++i2];
      output[2] = sub[c2 >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w3[++i2];
      output[decrypt ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c2 & 255] ^ w3[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge2.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge2.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge2.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// ../../node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "../../node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge2 = require_forge();
    forge2.pki = forge2.pki || {};
    var oids = module2.exports = forge2.pki.oids = forge2.oids = forge2.oids || {};
    function _IN(id, name) {
      oids[id] = name;
      oids[name] = id;
    }
    function _I_(id, name) {
      oids[id] = name;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// ../../node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "../../node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge2.asn1 = forge2.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge2.util.isArray(value)) {
        var tmp = [];
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (value[i2] !== void 0) {
            tmp.push(value[i2]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge2.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge2.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn1.copy(obj[i2], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge2.util.isArray(obj1)) {
        if (!forge2.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn1.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal2 = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal2 = equal2 && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal2;
    };
    asn1.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length;
      var longForm = b22 & 128;
      if (!longForm) {
        length = b22;
      } else {
        length = b2.getInt((b22 & 127) << 3);
      }
      return length;
    };
    function _checkBufferLength(bytes, remaining, n2) {
      if (n2 > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = n2;
        throw error;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length;
      var longForm = b2 & 128;
      if (!longForm) {
        length = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length = bytes.getInt(longFormBytes << 3);
      }
      if (length < 0) {
        throw new Error("Negative length: " + length);
      }
      return length;
    };
    asn1.fromDer = function(bytes, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge2.util.createBuffer(bytes);
      }
      var byteCount = bytes.length();
      var value = _fromDer(bytes, bytes.length(), 0, options);
      if (options.parseAllBytes && bytes.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b1 = bytes.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes.length();
      var length = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length !== void 0 && length > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = length;
          throw error;
        }
        length = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value.push(_fromDer(bytes, remaining, depth + 1, options));
            remaining -= start - bytes.length();
          }
        } else {
          while (length > 0) {
            start = bytes.length();
            value.push(_fromDer(bytes, length, depth + 1, options));
            remaining -= start - bytes.length();
            length -= start - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length > 0; length -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length);
          remaining -= length;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes = forge2.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge2.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values2 = oid.split(".");
      var bytes = forge2.util.createBuffer();
      bytes.putByte(40 * parseInt(values2[0], 10) + parseInt(values2[1], 10));
      var last3, valueBytes, value, b2;
      for (var i2 = 2; i2 < values2.length; ++i2) {
        last3 = true;
        valueBytes = [];
        value = parseInt(values2[i2], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last3) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last3 = false;
        } while (value > 0);
        for (var n2 = valueBytes.length - 1; n2 >= 0; --n2) {
          bytes.putByte(valueBytes[n2]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge2.util.createBuffer(bytes);
      }
      var b2 = bytes.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b2 = bytes.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c2 = utc.charAt(10);
        var end = 10;
        if (c2 !== "+" && c2 !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c2 = utc.charAt(end);
        if (c2 === "+" || c2 === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c2 === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c2 = gentime.charAt(end);
      if (c2 === "+" || c2 === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c2 === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x3) {
      var rval = forge2.util.createBuffer();
      if (x3 >= -128 && x3 < 128) {
        return rval.putSignedInt(x3, 8);
      }
      if (x3 >= -32768 && x3 < 32768) {
        return rval.putSignedInt(x3, 16);
      }
      if (x3 >= -8388608 && x3 < 8388608) {
        return rval.putSignedInt(x3, 24);
      }
      if (x3 >= -2147483648 && x3 < 2147483648) {
        return rval.putSignedInt(x3, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x3;
      throw error;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge2.util.createBuffer(bytes);
      }
      var n2 = bytes.length() * 8;
      if (n2 > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n2);
    };
    asn1.validate = function(obj, v3, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v3.tagClass || typeof v3.tagClass === "undefined") && (obj.type === v3.type || typeof v3.type === "undefined")) {
        if (obj.constructed === v3.constructed || typeof v3.constructed === "undefined") {
          rval = true;
          if (v3.value && forge2.util.isArray(v3.value)) {
            var j3 = 0;
            for (var i2 = 0; rval && i2 < v3.value.length; ++i2) {
              rval = v3.value[i2].optional || false;
              if (obj.value[j3]) {
                rval = asn1.validate(obj.value[j3], v3.value[i2], capture, errors);
                if (rval) {
                  ++j3;
                } else if (v3.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v3.name + '] Tag class "' + v3.tagClass + '", type "' + v3.type + '" expected value length "' + v3.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v3.capture) {
              capture[v3.capture] = obj.value;
            }
            if (v3.captureAsn1) {
              capture[v3.captureAsn1] = obj;
            }
            if (v3.captureBitStringContents && "bitStringContents" in obj) {
              capture[v3.captureBitStringContents] = obj.bitStringContents;
            }
            if (v3.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v3.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v3.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v3.name + '] Expected constructed "' + v3.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v3.tagClass) {
          errors.push(
            "[" + v3.name + '] Expected tag class "' + v3.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v3.type) {
          errors.push(
            "[" + v3.name + '] Expected type "' + v3.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge2.pki && forge2.pki.oids) {
            if (oid in forge2.pki.oids) {
              rval += " (" + forge2.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge2.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge2.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge2.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge2.util.decodeUtf8(obj.value);
          } catch (e2) {
            if (e2.message === "URI malformed") {
              rval += "0x" + forge2.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e2;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge2.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// ../../node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "../../node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge2 = require_forge();
    module2.exports = forge2.md = forge2.md || {};
    forge2.md.algorithms = forge2.md.algorithms || {};
  }
});

// ../../node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var hmac = module2.exports = forge2.hmac = forge2.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge2.md.algorithms) {
              _md = forge2.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge2.util.createBuffer(key);
          } else if (forge2.util.isArray(key)) {
            var tmp = key;
            key = forge2.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge2.util.createBuffer();
          _opadding = forge2.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// ../../node_modules/node-forge/lib/md5.js
var require_md5 = __commonJS({
  "../../node_modules/node-forge/lib/md5.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var md5 = module2.exports = forge2.md5 = forge2.md5 || {};
    forge2.md.md5 = forge2.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var bits, carry = 0;
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          bits = md.fullMessageLength[i2] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _g = null;
    var _r2 = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r2 = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        _k[i2] = Math.floor(Math.abs(Math.sin(i2 + 1)) * 4294967296);
      }
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t2, a2, b2, c2, d2, f3, r2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2] = bytes.getInt32Le();
          f3 = d2 ^ b2 & (c2 ^ d2);
          t2 = a2 + f3 + _k[i2] + w3[i2];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        for (; i2 < 32; ++i2) {
          f3 = c2 ^ d2 & (b2 ^ c2);
          t2 = a2 + f3 + _k[i2] + w3[_g[i2]];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        for (; i2 < 48; ++i2) {
          f3 = b2 ^ c2 ^ d2;
          t2 = a2 + f3 + _k[i2] + w3[_g[i2]];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        for (; i2 < 64; ++i2) {
          f3 = c2 ^ (b2 | ~d2);
          t2 = a2 + f3 + _k[i2] + w3[_g[i2]];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "../../node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    var pem = module2.exports = forge2.pem = forge2.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge2.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge2.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values2 = match[2].split(",");
            for (var vi = 0; vi < values2.length; ++vi) {
              header.values.push(ltrim(values2[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values2[0], type: values2[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values2[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values2[0], parameters: values2[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values2 = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values2.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values2.join(",") + "\r\n";
      var length = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// ../../node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "../../node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge2 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge2.des = forge2.des || {};
    forge2.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge2.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge2.des.Algorithm = function(name, mode) {
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge2.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge2.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge2.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge2.cipher.modes.ctr);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge2.des.Algorithm(name, mode);
      };
      forge2.cipher.registerAlgorithm(name, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys2 = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n2 = 0, tmp;
      for (var j3 = 0; j3 < iterations; j3++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys2[n2++] = lefttmp ^ tmp;
          keys2[n2++] = righttmp ^ tmp << 16;
        }
      }
      return keys2;
    }
    function _updateBlock(keys2, input, output, decrypt) {
      var iterations = keys2.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j3 = 0; j3 < iterations; j3 += 3) {
        var endloop = looping[j3 + 1];
        var loopinc = looping[j3 + 2];
        for (var i2 = looping[j3]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys2[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys2[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge2.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge2.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge2.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// ../../node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "../../node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge2 = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge2.pkcs5 = forge2.pkcs5 || {};
    var crypto3;
    if (forge2.util.isNodejs && !forge2.options.usePureJavaScript) {
      crypto3 = require("crypto");
    }
    module2.exports = forge2.pbkdf2 = pkcs5.pbkdf2 = function(p3, s2, c2, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && crypto3.pbkdf2 && (md === null || typeof md !== "object") && (crypto3.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p3 = Buffer.from(p3, "binary");
        s2 = Buffer.from(s2, "binary");
        if (!callback) {
          if (crypto3.pbkdf2Sync.length === 4) {
            return crypto3.pbkdf2Sync(p3, s2, c2, dkLen).toString("binary");
          }
          return crypto3.pbkdf2Sync(p3, s2, c2, dkLen, md).toString("binary");
        }
        if (crypto3.pbkdf2Sync.length === 4) {
          return crypto3.pbkdf2(p3, s2, c2, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto3.pbkdf2(p3, s2, c2, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge2.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge2.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge2.hmac.create();
      prf.start(md, p3);
      var dk = "";
      var xor2, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s2);
          prf.update(forge2.util.int32ToBytes(i2));
          xor2 = u_c1 = prf.digest().getBytes();
          for (var j3 = 2; j3 <= c2; ++j3) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor2 = forge2.util.xorBytes(xor2, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor2 : xor2.substr(0, r2);
        }
        return dk;
      }
      var i2 = 1, j3;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s2);
        prf.update(forge2.util.int32ToBytes(i2));
        xor2 = u_c1 = prf.digest().getBytes();
        j3 = 2;
        inner();
      }
      function inner() {
        if (j3 <= c2) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor2 = forge2.util.xorBytes(xor2, u_c, hLen);
          u_c1 = u_c;
          ++j3;
          return forge2.util.setImmediate(inner);
        }
        dk += i2 < len ? xor2 : xor2.substr(0, r2);
        ++i2;
        outer();
      }
      outer();
    };
  }
});

// ../../node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "../../node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha256 = module2.exports = forge2.sha256 = forge2.sha256 || {};
    forge2.md.sha256 = forge2.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t1, t2, s0, s1, ch, maj, i2, a2, b2, c2, d2, e2, f3, g2, h2;
      var len = bytes.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2] = bytes.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t1 = w3[i2 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w3[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w3[i2] = t1 + w3[i2 - 7] + t2 + w3[i2 - 16] | 0;
        }
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        e2 = s2.h4;
        f3 = s2.h5;
        g2 = s2.h6;
        h2 = s2.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ch = g2 ^ e2 & (f3 ^ g2);
          s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          maj = a2 & b2 | c2 & (a2 ^ b2);
          t1 = h2 + s1 + ch + _k[i2] + w3[i2];
          t2 = s0 + maj;
          h2 = g2;
          g2 = f3;
          f3 = e2;
          e2 = d2 + t1 >>> 0;
          d2 = c2;
          c2 = b2;
          b2 = a2;
          a2 = t1 + t2 >>> 0;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e2 | 0;
        s2.h5 = s2.h5 + f3 | 0;
        s2.h6 = s2.h6 + g2 | 0;
        s2.h7 = s2.h7 + h2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "../../node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    var _crypto = null;
    if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require("crypto");
    }
    var prng = module2.exports = forge2.prng = forge2.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge2.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count) {
            return callback(null, b2.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge2.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge2.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge2.util.createBuffer();
        while (b2.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k2 = 0; k2 < 32; ++k2) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k2].digest().getBytes());
            ctx.pools[k2].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge2.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b2 = forge2.util.createBuffer();
        if (getRandomValues) {
          while (b2.length() < needed) {
            var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b2.putInt32(entropy[i3]);
              }
            } catch (e2) {
              if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
                throw e2;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b2.putByte(next & 255);
            }
          }
        }
        return b2.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e2) {
            callback(e2);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n2) {
        var bytes = "";
        for (var x3 = 0; x3 < n2; x3 += 8) {
          bytes += String.fromCharCode(i3 >> x3 & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e2) {
              var data = e2.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e2) {
            var data = e2.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// ../../node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "../../node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge2.random && forge2.random.getBytes) {
        module2.exports = forge2.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge2.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge2.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge2.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge2.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge2.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge2.md.sha256;
        function spawnPrng() {
          var ctx = forge2.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge2.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge2.options.usePureJavaScript || !forge2.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e2) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e2) {
              _ctx.collectInt(e2.clientX, 16);
              _ctx.collectInt(e2.clientY, 16);
            });
            jQuery2().keypress(function(e2) {
              _ctx.collectInt(e2.charCode, 8);
            });
          }
        }
        if (!forge2.random) {
          forge2.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge2.random[key] = _ctx[key];
          }
        }
        forge2.random.createInstance = spawnPrng;
        module2.exports = forge2.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// ../../node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "../../node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s2 = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge2.rc2 = forge2.rc2 || {};
    forge2.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge2.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L3 = key;
      var T3 = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i2;
      for (i2 = T3; i2 < 128; i2++) {
        L3.putByte(piTable[L3.at(i2 - 1) + L3.at(i2 - T3) & 255]);
      }
      L3.setAt(128 - T8, piTable[L3.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L3.setAt(i2, piTable[L3.at(i2 + 1) ^ L3.at(i2 + T8)]);
      }
      return L3;
    };
    var createCipher = function(key, bits, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j3, K3 = [];
      key = forge2.rc2.expandKey(key, bits);
      for (i2 = 0; i2 < 64; i2++) {
        K3.push(key.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R3) {
          for (i2 = 0; i2 < 4; i2++) {
            R3[i2] += K3[j3] + (R3[(i2 + 3) % 4] & R3[(i2 + 2) % 4]) + (~R3[(i2 + 3) % 4] & R3[(i2 + 1) % 4]);
            R3[i2] = rol(R3[i2], s2[i2]);
            j3++;
          }
        };
        mashRound = function(R3) {
          for (i2 = 0; i2 < 4; i2++) {
            R3[i2] += K3[R3[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R3) {
          for (i2 = 3; i2 >= 0; i2--) {
            R3[i2] = ror(R3[i2], s2[i2]);
            R3[i2] -= K3[j3] + (R3[(i2 + 3) % 4] & R3[(i2 + 2) % 4]) + (~R3[(i2 + 3) % 4] & R3[(i2 + 1) % 4]);
            j3--;
          }
        };
        mashRound = function(R3) {
          for (i2 = 3; i2 >= 0; i2--) {
            R3[i2] -= K3[R3[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R3 = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R3.push(val & 65535);
        }
        j3 = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R3);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R3[i2]);
            } else {
              R3[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R3[i2]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge2.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge2.util.createBuffer();
          _output = output || new forge2.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad3) {
          var rval = true;
          if (encrypt) {
            if (pad3) {
              rval = pad3(8, _input, !encrypt);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad3) {
                rval = pad3(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge2.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge2.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge2.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge2.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge2.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge2.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// ../../node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "../../node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge2 = require_forge();
    module2.exports = forge2.jsbn = forge2.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a2, b2, c2) {
      this.data = [];
      if (a2 != null)
        if ("number" == typeof a2) this.fromNumber(a2, b2, c2);
        else if (b2 == null && "string" != typeof a2) this.fromString(a2, 256);
        else this.fromString(a2, b2);
    }
    forge2.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x3, w3, j3, c2, n2) {
      while (--n2 >= 0) {
        var v3 = x3 * this.data[i2++] + w3.data[j3] + c2;
        c2 = Math.floor(v3 / 67108864);
        w3.data[j3++] = v3 & 67108863;
      }
      return c2;
    }
    function am2(i2, x3, w3, j3, c2, n2) {
      var xl = x3 & 32767, xh = x3 >> 15;
      while (--n2 >= 0) {
        var l2 = this.data[i2] & 32767;
        var h2 = this.data[i2++] >> 15;
        var m3 = xh * l2 + h2 * xl;
        l2 = xl * l2 + ((m3 & 32767) << 15) + w3.data[j3] + (c2 & 1073741823);
        c2 = (l2 >>> 30) + (m3 >>> 15) + xh * h2 + (c2 >>> 30);
        w3.data[j3++] = l2 & 1073741823;
      }
      return c2;
    }
    function am3(i2, x3, w3, j3, c2, n2) {
      var xl = x3 & 16383, xh = x3 >> 14;
      while (--n2 >= 0) {
        var l2 = this.data[i2] & 16383;
        var h2 = this.data[i2++] >> 14;
        var m3 = xh * l2 + h2 * xl;
        l2 = xl * l2 + ((m3 & 16383) << 14) + w3.data[j3] + c2;
        c2 = (l2 >> 28) + (m3 >> 14) + xh * h2;
        w3.data[j3++] = l2 & 268435455;
      }
      return c2;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr3;
    var vv;
    rr3 = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) BI_RC[rr3++] = vv;
    rr3 = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr3++] = vv;
    rr3 = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr3++] = vv;
    function int2char(n2) {
      return BI_RM.charAt(n2);
    }
    function intAt(s2, i2) {
      var c2 = BI_RC[s2.charCodeAt(i2)];
      return c2 == null ? -1 : c2;
    }
    function bnpCopyTo(r2) {
      for (var i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2] = this.data[i2];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x3) {
      this.t = 1;
      this.s = x3 < 0 ? -1 : 0;
      if (x3 > 0) this.data[0] = x3;
      else if (x3 < -1) this.data[0] = x3 + this.DV;
      else this.t = 0;
    }
    function nbv(i2) {
      var r2 = nbi();
      r2.fromInt(i2);
      return r2;
    }
    function bnpFromString(s2, b2) {
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 256) k2 = 8;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else {
        this.fromRadix(s2, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s2.length, mi = false, sh = 0;
      while (--i2 >= 0) {
        var x3 = k2 == 8 ? s2[i2] & 255 : intAt(s2, i2);
        if (x3 < 0) {
          if (s2.charAt(i2) == "-") mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x3;
        else if (sh + k2 > this.DB) {
          this.data[this.t - 1] |= (x3 & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x3 >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x3 << sh;
        sh += k2;
        if (sh >= this.DB) sh -= this.DB;
      }
      if (k2 == 8 && (s2[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c2 = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c2) --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0) return "-" + this.negate().toString(b2);
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else return this.toRadix(b2);
      var km = (1 << k2) - 1, d2, m3 = false, r2 = "", i2 = this.t;
      var p3 = this.DB - i2 * this.DB % k2;
      if (i2-- > 0) {
        if (p3 < this.DB && (d2 = this.data[i2] >> p3) > 0) {
          m3 = true;
          r2 = int2char(d2);
        }
        while (i2 >= 0) {
          if (p3 < k2) {
            d2 = (this.data[i2] & (1 << p3) - 1) << k2 - p3;
            d2 |= this.data[--i2] >> (p3 += this.DB - k2);
          } else {
            d2 = this.data[i2] >> (p3 -= k2) & km;
            if (p3 <= 0) {
              p3 += this.DB;
              --i2;
            }
          }
          if (d2 > 0) m3 = true;
          if (m3) r2 += int2char(d2);
        }
      }
      return m3 ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a2) {
      var r2 = this.s - a2.s;
      if (r2 != 0) return r2;
      var i2 = this.t;
      r2 = i2 - a2.t;
      if (r2 != 0) return this.s < 0 ? -r2 : r2;
      while (--i2 >= 0) if ((r2 = this.data[i2] - a2.data[i2]) != 0) return r2;
      return 0;
    }
    function nbits(x3) {
      var r2 = 1, t2;
      if ((t2 = x3 >>> 16) != 0) {
        x3 = t2;
        r2 += 16;
      }
      if ((t2 = x3 >> 8) != 0) {
        x3 = t2;
        r2 += 8;
      }
      if ((t2 = x3 >> 4) != 0) {
        x3 = t2;
        r2 += 4;
      }
      if ((t2 = x3 >> 2) != 0) {
        x3 = t2;
        r2 += 2;
      }
      if ((t2 = x3 >> 1) != 0) {
        x3 = t2;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n2, r2) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2 + n2] = this.data[i2];
      for (i2 = n2 - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.t = this.t + n2;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n2, r2) {
      for (var i2 = n2; i2 < this.t; ++i2) r2.data[i2 - n2] = this.data[i2];
      r2.t = Math.max(this.t - n2, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n2, r2) {
      var bs = n2 % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n2 / this.DB), c2 = this.s << bs & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r2.data[i2 + ds + 1] = this.data[i2] >> cbs | c2;
        c2 = (this.data[i2] & bm) << bs;
      }
      for (i2 = ds - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.data[ds] = c2;
      r2.t = this.t + ds + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n2, r2) {
      r2.s = this.s;
      var ds = Math.floor(n2 / this.DB);
      if (ds >= this.t) {
        r2.t = 0;
        return;
      }
      var bs = n2 % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r2.data[0] = this.data[ds] >> bs;
      for (var i2 = ds + 1; i2 < this.t; ++i2) {
        r2.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
        r2.data[i2 - ds] = this.data[i2] >> bs;
      }
      if (bs > 0) r2.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r2.t = this.t - ds;
      r2.clamp();
    }
    function bnpSubTo(a2, r2) {
      var i2 = 0, c2 = 0, m3 = Math.min(a2.t, this.t);
      while (i2 < m3) {
        c2 += this.data[i2] - a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 -= a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 -= a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 -= a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 < -1) r2.data[i2++] = this.DV + c2;
      else if (c2 > 0) r2.data[i2++] = c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnpMultiplyTo(a2, r2) {
      var x3 = this.abs(), y2 = a2.abs();
      var i2 = x3.t;
      r2.t = i2 + y2.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < y2.t; ++i2) r2.data[i2 + x3.t] = x3.am(0, y2.data[i2], r2, i2, 0, x3.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a2.s) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x3 = this.abs();
      var i2 = r2.t = 2 * x3.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < x3.t - 1; ++i2) {
        var c2 = x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
        if ((r2.data[i2 + x3.t] += x3.am(i2 + 1, 2 * x3.data[i2], r2, 2 * i2 + 1, c2, x3.t - i2 - 1)) >= x3.DV) {
          r2.data[i2 + x3.t] -= x3.DV;
          r2.data[i2 + x3.t + 1] = 1;
        }
      }
      if (r2.t > 0) r2.data[r2.t - 1] += x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m3, q3, r2) {
      var pm = m3.abs();
      if (pm.t <= 0) return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q3 != null) q3.fromInt(0);
        if (r2 != null) this.copyTo(r2);
        return;
      }
      if (r2 == null) r2 = nbi();
      var y2 = nbi(), ts = this.s, ms = m3.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y2);
        pt.lShiftTo(nsh, r2);
      } else {
        pm.copyTo(y2);
        pt.copyTo(r2);
      }
      var ys2 = y2.t;
      var y0 = y2.data[ys2 - 1];
      if (y0 == 0) return;
      var yt = y0 * (1 << this.F1) + (ys2 > 1 ? y2.data[ys2 - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e2 = 1 << this.F2;
      var i2 = r2.t, j3 = i2 - ys2, t2 = q3 == null ? nbi() : q3;
      y2.dlShiftTo(j3, t2);
      if (r2.compareTo(t2) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t2, r2);
      }
      BigInteger.ONE.dlShiftTo(ys2, t2);
      t2.subTo(y2, y2);
      while (y2.t < ys2) y2.data[y2.t++] = 0;
      while (--j3 >= 0) {
        var qd = r2.data[--i2] == y0 ? this.DM : Math.floor(r2.data[i2] * d1 + (r2.data[i2 - 1] + e2) * d2);
        if ((r2.data[i2] += y2.am(0, qd, r2, j3, 0, ys2)) < qd) {
          y2.dlShiftTo(j3, t2);
          r2.subTo(t2, r2);
          while (r2.data[i2] < --qd) r2.subTo(t2, r2);
        }
      }
      if (q3 != null) {
        r2.drShiftTo(ys2, q3);
        if (ts != ms) BigInteger.ZERO.subTo(q3, q3);
      }
      r2.t = ys2;
      r2.clamp();
      if (nsh > 0) r2.rShiftTo(nsh, r2);
      if (ts < 0) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnMod(a2) {
      var r2 = nbi();
      this.abs().divRemTo(a2, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) a2.subTo(r2, r2);
      return r2;
    }
    function Classic(m3) {
      this.m = m3;
    }
    function cConvert(x3) {
      if (x3.s < 0 || x3.compareTo(this.m) >= 0) return x3.mod(this.m);
      else return x3;
    }
    function cRevert(x3) {
      return x3;
    }
    function cReduce(x3) {
      x3.divRemTo(this.m, null, x3);
    }
    function cMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    function cSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x3 = this.data[0];
      if ((x3 & 1) == 0) return 0;
      var y2 = x3 & 3;
      y2 = y2 * (2 - (x3 & 15) * y2) & 15;
      y2 = y2 * (2 - (x3 & 255) * y2) & 255;
      y2 = y2 * (2 - ((x3 & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x3 * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    function Montgomery(m3) {
      this.m = m3;
      this.mp = m3.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m3.DB - 15) - 1;
      this.mt2 = 2 * m3.t;
    }
    function montConvert(x3) {
      var r2 = nbi();
      x3.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x3.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x3) {
      var r2 = nbi();
      x3.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x3) {
      while (x3.t <= this.mt2)
        x3.data[x3.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j3 = x3.data[i2] & 32767;
        var u0 = j3 * this.mpl + ((j3 * this.mph + (x3.data[i2] >> 15) * this.mpl & this.um) << 15) & x3.DM;
        j3 = i2 + this.m.t;
        x3.data[j3] += this.m.am(0, u0, x3, i2, 0, this.m.t);
        while (x3.data[j3] >= x3.DV) {
          x3.data[j3] -= x3.DV;
          x3.data[++j3]++;
        }
      }
      x3.clamp();
      x3.drShiftTo(this.m.t, x3);
      if (x3.compareTo(this.m) >= 0) x3.subTo(this.m, x3);
    }
    function montSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e2, z3) {
      if (e2 > 4294967295 || e2 < 1) return BigInteger.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z3.convert(this), i2 = nbits(e2) - 1;
      g2.copyTo(r2);
      while (--i2 >= 0) {
        z3.sqrTo(r2, r22);
        if ((e2 & 1 << i2) > 0) z3.mulTo(r22, g2, r2);
        else {
          var t2 = r2;
          r2 = r22;
          r22 = t2;
        }
      }
      return z3.revert(r2);
    }
    function bnModPowInt(e2, m3) {
      var z3;
      if (e2 < 256 || m3.isEven()) z3 = new Classic(m3);
      else z3 = new Montgomery(m3);
      return this.exp(e2, z3);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this.data[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this.data[0];
      else if (this.t == 0) return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
      else return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null) b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36) return "0";
      var cs = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs);
      var d2 = nbv(a2), y2 = nbi(), z3 = nbi(), r2 = "";
      this.divRemTo(d2, y2, z3);
      while (y2.signum() > 0) {
        r2 = (a2 + z3.intValue()).toString(b2).substr(1) + r2;
        y2.divRemTo(d2, y2, z3);
      }
      return z3.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s2, b2) {
      this.fromInt(0);
      if (b2 == null) b2 = 10;
      var cs = this.chunkSize(b2);
      var d2 = Math.pow(b2, cs), mi = false, j3 = 0, w3 = 0;
      for (var i2 = 0; i2 < s2.length; ++i2) {
        var x3 = intAt(s2, i2);
        if (x3 < 0) {
          if (s2.charAt(i2) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w3 = b2 * w3 + x3;
        if (++j3 >= cs) {
          this.dMultiply(d2);
          this.dAddOffset(w3, 0);
          j3 = 0;
          w3 = 0;
        }
      }
      if (j3 > 0) {
        this.dMultiply(Math.pow(b2, j3));
        this.dAddOffset(w3, 0);
      }
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a2, b2, c2) {
      if ("number" == typeof b2) {
        if (a2 < 2) this.fromInt(1);
        else {
          this.fromNumber(a2, c2);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2) this.subTo(BigInteger.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x3 = new Array(), t2 = a2 & 7;
        x3.length = (a2 >> 3) + 1;
        b2.nextBytes(x3);
        if (t2 > 0) x3[0] &= (1 << t2) - 1;
        else x3[0] = 0;
        this.fromString(x3, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p3 = this.DB - i2 * this.DB % 8, d2, k2 = 0;
      if (i2-- > 0) {
        if (p3 < this.DB && (d2 = this.data[i2] >> p3) != (this.s & this.DM) >> p3)
          r2[k2++] = d2 | this.s << this.DB - p3;
        while (i2 >= 0) {
          if (p3 < 8) {
            d2 = (this.data[i2] & (1 << p3) - 1) << 8 - p3;
            d2 |= this.data[--i2] >> (p3 += this.DB - 8);
          } else {
            d2 = this.data[i2] >> (p3 -= 8) & 255;
            if (p3 <= 0) {
              p3 += this.DB;
              --i2;
            }
          }
          if ((d2 & 128) != 0) d2 |= -256;
          if (k2 == 0 && (this.s & 128) != (d2 & 128)) ++k2;
          if (k2 > 0 || d2 != this.s) r2[k2++] = d2;
        }
      }
      return r2;
    }
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    function bnpBitwiseTo(a2, op, r2) {
      var i2, f3, m3 = Math.min(a2.t, this.t);
      for (i2 = 0; i2 < m3; ++i2) r2.data[i2] = op(this.data[i2], a2.data[i2]);
      if (a2.t < this.t) {
        f3 = a2.s & this.DM;
        for (i2 = m3; i2 < this.t; ++i2) r2.data[i2] = op(this.data[i2], f3);
        r2.t = this.t;
      } else {
        f3 = this.s & this.DM;
        for (i2 = m3; i2 < a2.t; ++i2) r2.data[i2] = op(f3, a2.data[i2]);
        r2.t = a2.t;
      }
      r2.s = op(this.s, a2.s);
      r2.clamp();
    }
    function op_and(x3, y2) {
      return x3 & y2;
    }
    function bnAnd(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_and, r2);
      return r2;
    }
    function op_or(x3, y2) {
      return x3 | y2;
    }
    function bnOr(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_or, r2);
      return r2;
    }
    function op_xor(x3, y2) {
      return x3 ^ y2;
    }
    function bnXor(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_xor, r2);
      return r2;
    }
    function op_andnot(x3, y2) {
      return x3 & ~y2;
    }
    function bnAndNot(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i2 = 0; i2 < this.t; ++i2) r2.data[i2] = this.DM & ~this.data[i2];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n2) {
      var r2 = nbi();
      if (n2 < 0) this.rShiftTo(-n2, r2);
      else this.lShiftTo(n2, r2);
      return r2;
    }
    function bnShiftRight(n2) {
      var r2 = nbi();
      if (n2 < 0) this.lShiftTo(-n2, r2);
      else this.rShiftTo(n2, r2);
      return r2;
    }
    function lbit(x3) {
      if (x3 == 0) return -1;
      var r2 = 0;
      if ((x3 & 65535) == 0) {
        x3 >>= 16;
        r2 += 16;
      }
      if ((x3 & 255) == 0) {
        x3 >>= 8;
        r2 += 8;
      }
      if ((x3 & 15) == 0) {
        x3 >>= 4;
        r2 += 4;
      }
      if ((x3 & 3) == 0) {
        x3 >>= 2;
        r2 += 2;
      }
      if ((x3 & 1) == 0) ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0) return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit(x3) {
      var r2 = 0;
      while (x3 != 0) {
        x3 &= x3 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x3 = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2) r2 += cbit(this.data[i2] ^ x3);
      return r2;
    }
    function bnTestBit(n2) {
      var j3 = Math.floor(n2 / this.DB);
      if (j3 >= this.t) return this.s != 0;
      return (this.data[j3] & 1 << n2 % this.DB) != 0;
    }
    function bnpChangeBit(n2, op) {
      var r2 = BigInteger.ONE.shiftLeft(n2);
      this.bitwiseTo(r2, op, r2);
      return r2;
    }
    function bnSetBit(n2) {
      return this.changeBit(n2, op_or);
    }
    function bnClearBit(n2) {
      return this.changeBit(n2, op_andnot);
    }
    function bnFlipBit(n2) {
      return this.changeBit(n2, op_xor);
    }
    function bnpAddTo(a2, r2) {
      var i2 = 0, c2 = 0, m3 = Math.min(a2.t, this.t);
      while (i2 < m3) {
        c2 += this.data[i2] + a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 += a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 += a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 > 0) r2.data[i2++] = c2;
      else if (c2 < -1) r2.data[i2++] = this.DV + c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnAdd(a2) {
      var r2 = nbi();
      this.addTo(a2, r2);
      return r2;
    }
    function bnSubtract(a2) {
      var r2 = nbi();
      this.subTo(a2, r2);
      return r2;
    }
    function bnMultiply(a2) {
      var r2 = nbi();
      this.multiplyTo(a2, r2);
      return r2;
    }
    function bnDivide(a2) {
      var r2 = nbi();
      this.divRemTo(a2, r2, null);
      return r2;
    }
    function bnRemainder(a2) {
      var r2 = nbi();
      this.divRemTo(a2, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a2) {
      var q3 = nbi(), r2 = nbi();
      this.divRemTo(a2, q3, r2);
      return new Array(q3, r2);
    }
    function bnpDMultiply(n2) {
      this.data[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n2, w3) {
      if (n2 == 0) return;
      while (this.t <= w3) this.data[this.t++] = 0;
      this.data[w3] += n2;
      while (this.data[w3] >= this.DV) {
        this.data[w3] -= this.DV;
        if (++w3 >= this.t) this.data[this.t++] = 0;
        ++this.data[w3];
      }
    }
    function NullExp() {
    }
    function nNop(x3) {
      return x3;
    }
    function nMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
    }
    function nSqrTo(x3, r2) {
      x3.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e2) {
      return this.exp(e2, new NullExp());
    }
    function bnpMultiplyLowerTo(a2, n2, r2) {
      var i2 = Math.min(this.t + a2.t, n2);
      r2.s = 0;
      r2.t = i2;
      while (i2 > 0) r2.data[--i2] = 0;
      var j3;
      for (j3 = r2.t - this.t; i2 < j3; ++i2) r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
      for (j3 = Math.min(a2.t, n2); i2 < j3; ++i2) this.am(0, a2.data[i2], r2, i2, 0, n2 - i2);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a2, n2, r2) {
      --n2;
      var i2 = r2.t = this.t + a2.t - n2;
      r2.s = 0;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = Math.max(n2 - this.t, 0); i2 < a2.t; ++i2)
        r2.data[this.t + i2 - n2] = this.am(n2 - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n2);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m3) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m3.t, this.r2);
      this.mu = this.r2.divide(m3);
      this.m = m3;
    }
    function barrettConvert(x3) {
      if (x3.s < 0 || x3.t > 2 * this.m.t) return x3.mod(this.m);
      else if (x3.compareTo(this.m) < 0) return x3;
      else {
        var r2 = nbi();
        x3.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x3) {
      return x3;
    }
    function barrettReduce(x3) {
      x3.drShiftTo(this.m.t - 1, this.r2);
      if (x3.t > this.m.t + 1) {
        x3.t = this.m.t + 1;
        x3.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x3.compareTo(this.r2) < 0) x3.dAddOffset(1, this.m.t + 1);
      x3.subTo(this.r2, x3);
      while (x3.compareTo(this.m) >= 0) x3.subTo(this.m, x3);
    }
    function barrettSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e2, m3) {
      var i2 = e2.bitLength(), k2, r2 = nbv(1), z3;
      if (i2 <= 0) return r2;
      else if (i2 < 18) k2 = 1;
      else if (i2 < 48) k2 = 3;
      else if (i2 < 144) k2 = 4;
      else if (i2 < 768) k2 = 5;
      else k2 = 6;
      if (i2 < 8)
        z3 = new Classic(m3);
      else if (m3.isEven())
        z3 = new Barrett(m3);
      else
        z3 = new Montgomery(m3);
      var g2 = new Array(), n2 = 3, k1 = k2 - 1, km = (1 << k2) - 1;
      g2[1] = z3.convert(this);
      if (k2 > 1) {
        var g22 = nbi();
        z3.sqrTo(g2[1], g22);
        while (n2 <= km) {
          g2[n2] = nbi();
          z3.mulTo(g22, g2[n2 - 2], g2[n2]);
          n2 += 2;
        }
      }
      var j3 = e2.t - 1, w3, is1 = true, r22 = nbi(), t2;
      i2 = nbits(e2.data[j3]) - 1;
      while (j3 >= 0) {
        if (i2 >= k1) w3 = e2.data[j3] >> i2 - k1 & km;
        else {
          w3 = (e2.data[j3] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j3 > 0) w3 |= e2.data[j3 - 1] >> this.DB + i2 - k1;
        }
        n2 = k2;
        while ((w3 & 1) == 0) {
          w3 >>= 1;
          --n2;
        }
        if ((i2 -= n2) < 0) {
          i2 += this.DB;
          --j3;
        }
        if (is1) {
          g2[w3].copyTo(r2);
          is1 = false;
        } else {
          while (n2 > 1) {
            z3.sqrTo(r2, r22);
            z3.sqrTo(r22, r2);
            n2 -= 2;
          }
          if (n2 > 0) z3.sqrTo(r2, r22);
          else {
            t2 = r2;
            r2 = r22;
            r22 = t2;
          }
          z3.mulTo(r22, g2[w3], r2);
        }
        while (j3 >= 0 && (e2.data[j3] & 1 << i2) == 0) {
          z3.sqrTo(r2, r22);
          t2 = r2;
          r2 = r22;
          r22 = t2;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j3;
          }
        }
      }
      return z3.revert(r2);
    }
    function bnGCD(a2) {
      var x3 = this.s < 0 ? this.negate() : this.clone();
      var y2 = a2.s < 0 ? a2.negate() : a2.clone();
      if (x3.compareTo(y2) < 0) {
        var t2 = x3;
        x3 = y2;
        y2 = t2;
      }
      var i2 = x3.getLowestSetBit(), g2 = y2.getLowestSetBit();
      if (g2 < 0) return x3;
      if (i2 < g2) g2 = i2;
      if (g2 > 0) {
        x3.rShiftTo(g2, x3);
        y2.rShiftTo(g2, y2);
      }
      while (x3.signum() > 0) {
        if ((i2 = x3.getLowestSetBit()) > 0) x3.rShiftTo(i2, x3);
        if ((i2 = y2.getLowestSetBit()) > 0) y2.rShiftTo(i2, y2);
        if (x3.compareTo(y2) >= 0) {
          x3.subTo(y2, x3);
          x3.rShiftTo(1, x3);
        } else {
          y2.subTo(x3, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g2 > 0) y2.lShiftTo(g2, y2);
      return y2;
    }
    function bnpModInt(n2) {
      if (n2 <= 0) return 0;
      var d2 = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
      if (this.t > 0)
        if (d2 == 0) r2 = this.data[0] % n2;
        else for (var i2 = this.t - 1; i2 >= 0; --i2) r2 = (d2 * r2 + this.data[i2]) % n2;
      return r2;
    }
    function bnModInverse(m3) {
      var ac = m3.isEven();
      if (this.isEven() && ac || m3.signum() == 0) return BigInteger.ZERO;
      var u2 = m3.clone(), v3 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c2 = nbv(0), d2 = nbv(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m3, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven()) b2.subTo(m3, b2);
          b2.rShiftTo(1, b2);
        }
        while (v3.isEven()) {
          v3.rShiftTo(1, v3);
          if (ac) {
            if (!c2.isEven() || !d2.isEven()) {
              c2.addTo(this, c2);
              d2.subTo(m3, d2);
            }
            c2.rShiftTo(1, c2);
          } else if (!d2.isEven()) d2.subTo(m3, d2);
          d2.rShiftTo(1, d2);
        }
        if (u2.compareTo(v3) >= 0) {
          u2.subTo(v3, u2);
          if (ac) a2.subTo(c2, a2);
          b2.subTo(d2, b2);
        } else {
          v3.subTo(u2, v3);
          if (ac) c2.subTo(a2, c2);
          d2.subTo(b2, d2);
        }
      }
      if (v3.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d2.compareTo(m3) >= 0) return d2.subtract(m3);
      if (d2.signum() < 0) d2.addTo(m3, d2);
      else return d2;
      if (d2.signum() < 0) return d2.add(m3);
      else return d2;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i2, x3 = this.abs();
      if (x3.t == 1 && x3.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x3.data[0] == lowprimes[i2]) return true;
        return false;
      }
      if (x3.isEven()) return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m3 = lowprimes[i2], j3 = i2 + 1;
        while (j3 < lowprimes.length && m3 < lplim) m3 *= lowprimes[j3++];
        m3 = x3.modInt(m3);
        while (i2 < j3) if (m3 % lowprimes[i2++] == 0) return false;
      }
      return x3.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n1 = this.subtract(BigInteger.ONE);
      var k2 = n1.getLowestSetBit();
      if (k2 <= 0) return false;
      var r2 = n1.shiftRight(k2);
      var prng = bnGetPrng();
      var a2;
      for (var i2 = 0; i2 < t2; ++i2) {
        do {
          a2 = new BigInteger(this.bitLength(), prng);
        } while (a2.compareTo(BigInteger.ONE) <= 0 || a2.compareTo(n1) >= 0);
        var y2 = a2.modPow(r2, this);
        if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n1) != 0) {
          var j3 = 1;
          while (j3++ < k2 && y2.compareTo(n1) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y2.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// ../../node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha1 = module2.exports = forge2.sha1 = forge2.sha1 || {};
    forge2.md.sha1 = forge2.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t2, a2, b2, c2, d2, e2, f3, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        e2 = s2.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t2 = bytes.getInt32();
          w3[i2] = t2;
          f3 = d2 ^ b2 & (c2 ^ d2);
          t2 = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1518500249 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 20; ++i2) {
          t2 = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t2 = t2 << 1 | t2 >>> 31;
          w3[i2] = t2;
          f3 = d2 ^ b2 & (c2 ^ d2);
          t2 = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1518500249 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 32; ++i2) {
          t2 = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t2 = t2 << 1 | t2 >>> 31;
          w3[i2] = t2;
          f3 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1859775393 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 40; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f3 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1859775393 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 60; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f3 = b2 & c2 | d2 & (b2 ^ c2);
          t2 = (a2 << 5 | a2 >>> 27) + f3 + e2 + 2400959708 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 80; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f3 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f3 + e2 + 3395469782 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "../../node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge2.pkcs1 = forge2.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge2.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge2.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge2.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge2.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge2.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y2 = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge2.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge2.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y2 !== "\0";
      for (var i2 = 0; i2 < md.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j3 = md.digestLength; j3 < db.length; j3++) {
        var code = db.charCodeAt(j3);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash) {
      if (!hash) {
        hash = forge2.md.sha1.create();
      }
      var t2 = "";
      var count = Math.ceil(maskLength / hash.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c2 = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash.start();
        hash.update(seed + c2);
        t2 += hash.digest().getBytes();
      }
      return t2.substring(0, maskLength);
    }
  }
});

// ../../node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "../../node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge2.prime) {
        module2.exports = forge2.prime;
        return;
      }
      var prime = module2.exports = forge2.prime = forge2.prime || {};
      var BigInteger = forge2.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge2.random;
        var rng2 = {
          // x is an array to fill with bytes
          nextBytes: function(x3) {
            var b2 = prng.getBytesSync(x3.length);
            for (var i2 = 0; i2 < x3.length; ++i2) {
              x3[i2] = b2.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng2, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng2, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng2, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng2, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng2, options, callback) {
        var num = generateRandom(bits, rng2);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng2, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng2, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng2);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge2.util.setImmediate(function() {
          _primeinc(num, bits, rng2, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng2, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng2, options, callback);
        }
        var num = generateRandom(bits, rng2);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range3 = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge2.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e2) {
            if (found) {
              return;
            }
            --running;
            var data = e2.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng2);
            }
            var hex = num.toString(16);
            e2.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range3, 0);
          }
        }
      }
      function generateRandom(bits, rng2) {
        var num = new BigInteger(bits, rng2);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100) return 27;
        if (bits <= 150) return 18;
        if (bits <= 200) return 15;
        if (bits <= 250) return 12;
        if (bits <= 300) return 9;
        if (bits <= 350) return 8;
        if (bits <= 400) return 7;
        if (bits <= 500) return 6;
        if (bits <= 600) return 5;
        if (bits <= 800) return 4;
        if (bits <= 1250) return 3;
        return 2;
      }
    })();
  }
});

// ../../node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "../../node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge2.util.isNodejs ? require("crypto") : null;
    var asn1 = forge2.asn1;
    var util2 = forge2.util;
    forge2.pki = forge2.pki || {};
    module2.exports = forge2.pki.rsa = forge2.rsa = forge2.rsa || {};
    var pki = forge2.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge2.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x3, key, pub) {
      if (pub) {
        return x3.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x3.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r2;
      do {
        r2 = new BigInteger(
          forge2.util.bytesToHex(forge2.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r2.compareTo(key.n) >= 0 || !r2.gcd(key.n).equals(BigInteger.ONE));
      x3 = x3.multiply(r2.modPow(key.e, key.n)).mod(key.n);
      var xp = x3.mod(key.p).modPow(key.dP, key.p);
      var xq = x3.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y2 = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y2 = y2.multiply(r2.modInverse(key.n)).mod(key.n);
      return y2;
    };
    pki.rsa.encrypt = function(m3, key, bt) {
      var pub = bt;
      var eb;
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m3, key, bt);
      } else {
        eb = forge2.util.createBuffer();
        eb.putBytes(m3);
      }
      var x3 = new BigInteger(eb.toHex(), 16);
      var y2 = _modPow(x3, key, pub);
      var yhex = y2.toString(16);
      var ed = forge2.util.createBuffer();
      var zeros = k2 - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge2.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k2) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k2;
        throw error;
      }
      var y2 = new BigInteger(forge2.util.createBuffer(ed).toHex(), 16);
      if (y2.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x3 = _modPow(y2, key, pub);
      var xhex = x3.toString(16);
      var eb = forge2.util.createBuffer();
      var zeros = k2 - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge2.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e2, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge2.random;
      var rng2 = {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          var b2 = prng.getBytesSync(x3.length);
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = b2.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng: rng2,
          eInt: e2 || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n2) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n2 <= 0 || total < n2)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d2 = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d2,
              state.p,
              state.q,
              d2.mod(state.p1),
              d2.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e2, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e2 === "function") {
            callback = e2;
            e2 = void 0;
          } else if (typeof e2 !== "number") {
            options = e2;
            e2 = void 0;
          }
        } else {
          options = bits;
          callback = e2;
          bits = void 0;
          e2 = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e2 === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e2;
          e2 = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e2 === void 0) {
        e2 = options.e || 65537;
      }
      if (!forge2.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e2 === 65537 || e2 === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util2.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge2.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e3) {
              var pair = e3.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e4) {
                var pkcs8 = e4.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge2.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e2, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n2, e2) {
      var key = {
        n: n2,
        e: e2
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m3, key2, pub) {
              return _encodePkcs1_v1_5(m3, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m3, key2) {
              return forge2.pkcs1.encode_rsa_oaep(key2, m3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e4) {
            return e4;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e3 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e3, key, true);
      };
      key.verify = function(digest, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest2, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              var obj = asn1.fromDer(d3, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge2.oids.md2 || oid === forge2.oids.md5 || oid === forge2.oids.sha1 || oid === forge2.oids.sha224 || oid === forge2.oids.sha256 || oid === forge2.oids.sha384 || oid === forge2.oids.sha512 || oid === forge2.oids["sha512-224"] || oid === forge2.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge2.oids.md2 || oid === forge2.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest2 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest2, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              return digest2 === d3;
            }
          };
        }
        var d2 = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest, d2, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n2, e2, d2, p3, q3, dP, dQ, qInv) {
      var key = {
        n: n2,
        e: e2,
        d: d2,
        p: p3,
        q: q3,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d3 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d4, key2) {
              return forge2.pkcs1.decode_rsa_oaep(key2, d4, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d4) {
            return d4;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d3, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d3 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d3, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge2.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n2, e2, d2, p3, q3, dP, dQ, qInv;
      n2 = forge2.util.createBuffer(capture.privateKeyModulus).toHex();
      e2 = forge2.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d2 = forge2.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p3 = forge2.util.createBuffer(capture.privateKeyPrime1).toHex();
      q3 = forge2.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge2.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge2.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge2.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n2, 16),
        new BigInteger(e2, 16),
        new BigInteger(d2, 16),
        new BigInteger(p3, 16),
        new BigInteger(q3, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n2 = forge2.util.createBuffer(capture.publicKeyModulus).toHex();
      var e2 = forge2.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n2, 16),
        new BigInteger(e2, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m3, key, bt) {
      var eb = forge2.util.createBuffer();
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (m3.length > k2 - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m3.length;
        error.max = k2 - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k2 - 3 - m3.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge2.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m3);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      var eb = forge2.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k2 - 3 - ml;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k2 - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge2.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d2 = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d2,
            state.p,
            state.q,
            d2.mod(state.p1),
            d2.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b2) {
      var hex = b2.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge2.util.hexToBytes(hex);
      if (bytes.length > 1 && // leading 0x00 for positive integer
      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100) return 27;
      if (bits <= 150) return 18;
      if (bits <= 200) return 15;
      if (bits <= 250) return 12;
      if (bits <= 300) return 9;
      if (bits <= 350) return 8;
      if (bits <= 400) return 7;
      if (bits <= 500) return 6;
      if (bits <= 600) return 5;
      if (bits <= 800) return 4;
      if (bits <= 1250) return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge2.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x3) {
      var bytes = forge2.util.hexToBytes(x3.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        buffer[i2] = bytes.charCodeAt(i2);
      }
      return buffer;
    }
  }
});

// ../../node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "../../node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge2.asn1;
    var pki = forge2.pki = forge2.pki || {};
    module2.exports = pki.pbe = forge2.pbe = forge2.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge2.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge2.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge2.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge2.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge2.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge2.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge2.random.getBytesSync(8);
          cipherFn = forge2.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge2.random.getBytesSync(8);
          cipherFn = forge2.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge2.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge2.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge2.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge2.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge2.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge2.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge2.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge2.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge2.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n2, md) {
      var j3, l2;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge2.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge2.md.sha1.create();
      }
      var u2 = md.digestLength;
      var v3 = md.blockLength;
      var result2 = new forge2.util.ByteBuffer();
      var passBuf = new forge2.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l2 = 0; l2 < password.length; l2++) {
          passBuf.putInt16(password.charCodeAt(l2));
        }
        passBuf.putInt16(0);
      }
      var p3 = passBuf.length();
      var s2 = salt.length();
      var D3 = new forge2.util.ByteBuffer();
      D3.fillWithByte(id, v3);
      var Slen = v3 * Math.ceil(s2 / v3);
      var S3 = new forge2.util.ByteBuffer();
      for (l2 = 0; l2 < Slen; l2++) {
        S3.putByte(salt.at(l2 % s2));
      }
      var Plen = v3 * Math.ceil(p3 / v3);
      var P3 = new forge2.util.ByteBuffer();
      for (l2 = 0; l2 < Plen; l2++) {
        P3.putByte(passBuf.at(l2 % p3));
      }
      var I3 = S3;
      I3.putBuffer(P3);
      var c2 = Math.ceil(n2 / u2);
      for (var i2 = 1; i2 <= c2; i2++) {
        var buf = new forge2.util.ByteBuffer();
        buf.putBytes(D3.bytes());
        buf.putBytes(I3.bytes());
        for (var round2 = 0; round2 < iter; round2++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B3 = new forge2.util.ByteBuffer();
        for (l2 = 0; l2 < v3; l2++) {
          B3.putByte(buf.at(l2 % u2));
        }
        var k2 = Math.ceil(s2 / v3) + Math.ceil(p3 / v3);
        var Inew = new forge2.util.ByteBuffer();
        for (j3 = 0; j3 < k2; j3++) {
          var chunk3 = new forge2.util.ByteBuffer(I3.getBytes(v3));
          var x3 = 511;
          for (l2 = B3.length() - 1; l2 >= 0; l2--) {
            x3 = x3 >> 8;
            x3 += B3.at(l2) + chunk3.at(l2);
            chunk3.setAt(l2, x3 & 255);
          }
          Inew.putBuffer(chunk3);
        }
        I3 = Inew;
        result2.putBuffer(buf);
      }
      result2.truncate(result2.length() - n2);
      return result2;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge2.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge2.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge2.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge2.util.createBuffer(capture.salt);
      var count = forge2.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge2.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge2.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge2.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge2.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash(md, password + salt)];
      for (var length = 16, i2 = 1; length < dkLen; ++i2, length += 16) {
        digests.push(hash(md, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge2.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge2.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// ../../node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "../../node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge2.asn1;
    var p7v = module2.exports = forge2.pkcs7asn1 = forge2.pkcs7asn1 || {};
    forge2.pkcs7 = forge2.pkcs7 || {};
    forge2.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// ../../node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "../../node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    forge2.mgf = forge2.mgf || {};
    var mgf1 = module2.exports = forge2.mgf.mgf1 = forge2.mgf1 = forge2.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: function(seed, maskLen) {
          var t2 = new forge2.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i2 = 0; i2 < len; i2++) {
            var c2 = new forge2.util.ByteBuffer();
            c2.putInt32(i2);
            md.start();
            md.update(seed + c2.getBytes());
            t2.putBuffer(md.digest());
          }
          t2.truncate(t2.length() - maskLen);
          return t2.getBytes();
        }
      };
      return mgf;
    };
  }
});

// ../../node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "../../node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    var forge2 = require_forge();
    require_mgf1();
    module2.exports = forge2.mgf = forge2.mgf || {};
    forge2.mgf.mgf1 = forge2.mgf1;
  }
});

// ../../node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "../../node_modules/node-forge/lib/pss.js"(exports2, module2) {
    var forge2 = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge2.pss = forge2.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash = options.md;
      var mgf = options.mgf;
      var hLen = hash.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge2.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge2.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge2.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h2 = hash.digest().getBytes();
        var ps = new forge2.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h2, maskLen);
        var maskedDB = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h2 + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h2 = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h2, maskLen);
        var db = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i2 = 0; i2 < checkLen; i2++) {
          if (db.charCodeAt(i2) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge2.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h_ = hash.digest().getBytes();
        return h2 === h_;
      };
      return pssobj;
    };
  }
});

// ../../node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "../../node_modules/node-forge/lib/x509.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge2.asn1;
    var pki = module2.exports = forge2.pki = forge2.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge2.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set2, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set2 = rdn.value[si];
        for (var i2 = 0; i2 < set2.value.length; ++i2) {
          obj = {};
          attr = set2.value[i2];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values2 = seq.value[1].value;
        for (var vi = 0; vi < values2.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values2[vi].value;
          obj.valueTagClass = values2[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
        attr = obj.attributes[i2];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        // deprecated alias
        case "sha1WithRSASignature":
          return forge2.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge2.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge2.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge2.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge2.md.sha512.create();
        case "RSASSA-PSS":
          return forge2.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        // deprecated alias
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash, mgf;
          hash = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash === void 0 || forge2.md[hash] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge2.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge2.mgf[mgf].create(forge2.md[hash].create());
          hash = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash === void 0 || forge2.md[hash] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          scheme = forge2.pss.create(
            forge2.md[hash].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge2.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes;
      switch (type) {
        case "RSAPublicKey":
          bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = /* @__PURE__ */ new Date();
      cert.validity.notAfter = /* @__PURE__ */ new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId2) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId2) {
          cert.subject.uniqueId = uniqueId2;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId2) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId2) {
          cert.issuer.uniqueId = uniqueId2;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i2 = 0; i2 < exts.length; ++i2) {
          _fillMissingExtensionFields(exts[i2], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
          ext = cert.extensions[i2];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge2.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes = asn1.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i2 = cert.issuer;
        var s2 = parent.subject;
        if (i2.hash && s2.hash) {
          rval = i2.hash === s2.hash;
        } else if (i2.attributes.length === s2.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n2 = 0; rval && n2 < i2.attributes.length; ++n2) {
            iattr = i2.attributes[n2];
            sattr = s2.attributes[n2];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
          var ext = cert.extensions[i2];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge2.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge2.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge2.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge2.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
      }
      var imd = forge2.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge2.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i2 = 0; i2 < exts.value.length; ++i2) {
        var extseq = exts.value[i2];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e2 = {};
      e2.id = asn1.derToOid(ext.value[0].value);
      e2.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e2.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e2.value = ext.value[2].value;
      } else {
        e2.value = ext.value[1].value;
      }
      if (e2.id in oids) {
        e2.name = oids[e2.id];
        if (e2.name === "keyUsage") {
          var ev = asn1.fromDer(e2.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e2.digitalSignature = (b2 & 128) === 128;
          e2.nonRepudiation = (b2 & 64) === 64;
          e2.keyEncipherment = (b2 & 32) === 32;
          e2.dataEncipherment = (b2 & 16) === 16;
          e2.keyAgreement = (b2 & 8) === 8;
          e2.keyCertSign = (b2 & 4) === 4;
          e2.cRLSign = (b2 & 2) === 2;
          e2.encipherOnly = (b2 & 1) === 1;
          e2.decipherOnly = (b3 & 128) === 128;
        } else if (e2.name === "basicConstraints") {
          var ev = asn1.fromDer(e2.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e2.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e2.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e2.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e2.name === "extKeyUsage") {
          var ev = asn1.fromDer(e2.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e2[oids[oid]] = true;
            } else {
              e2[oid] = true;
            }
          }
        } else if (e2.name === "nsCertType") {
          var ev = asn1.fromDer(e2.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e2.client = (b2 & 128) === 128;
          e2.server = (b2 & 64) === 64;
          e2.email = (b2 & 32) === 32;
          e2.objsign = (b2 & 16) === 16;
          e2.reserved = (b2 & 8) === 8;
          e2.sslCA = (b2 & 4) === 4;
          e2.emailCA = (b2 & 2) === 2;
          e2.objCA = (b2 & 1) === 1;
        } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
          e2.altNames = [];
          var gn;
          var ev = asn1.fromDer(e2.value);
          for (var n2 = 0; n2 < ev.value.length; ++n2) {
            gn = ev.value[n2];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e2.altNames.push(altName);
            switch (gn.type) {
              // rfc822Name
              case 1:
              // dNSName
              case 2:
              // uniformResourceIdentifier (URI)
              case 6:
                break;
              // IPAddress
              case 7:
                altName.ip = forge2.util.bytesToIP(gn.value);
                break;
              // registeredID
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e2.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e2.value);
          e2.subjectKeyIdentifier = forge2.util.bytesToHex(ev.value);
        }
      }
      return e2;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge2.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge2.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge2.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge2.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set2;
      var attrs = obj.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge2.util.encodeUtf8(value);
          }
        }
        set2 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set2);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e2, options) {
      options = options || {};
      if (typeof e2.name === "undefined") {
        if (e2.id && e2.id in pki.oids) {
          e2.name = pki.oids[e2.id];
        }
      }
      if (typeof e2.id === "undefined") {
        if (e2.name && e2.name in pki.oids) {
          e2.id = pki.oids[e2.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e2;
          throw error;
        }
      }
      if (typeof e2.value !== "undefined") {
        return e2;
      }
      if (e2.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e2.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e2.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e2.name === "basicConstraints") {
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e2.cA) {
          e2.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e2) {
          e2.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e2.pathLenConstraint).getBytes()
          ));
        }
      } else if (e2.name === "extKeyUsage") {
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e2.value.value;
        for (var key in e2) {
          if (e2[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e2.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e2.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
        e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n2 = 0; n2 < e2.altNames.length; ++n2) {
          altName = e2.altNames[n2];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge2.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e2;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e2.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e2.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e2.comment) || e2.comment.length < 1 || e2.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e2.comment
        );
      } else if (e2.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e2.subjectKeyIdentifier = ski.toHex();
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e2.name === "authorityKeyIdentifier" && options.cert) {
        e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e2.value.value;
        if (e2.keyIdentifier) {
          var keyIdentifier = e2.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e2.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e2.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e2.authorityCertIssuer === true ? options.cert.issuer : e2.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e2.serialNumber) {
          var serialNumber = forge2.util.hexToBytes(e2.serialNumber === true ? options.cert.serialNumber : e2.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e2.name === "cRLDistributionPoints") {
        e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e2.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n2 = 0; n2 < e2.altNames.length; ++n2) {
          altName = e2.altNames[n2];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge2.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e2;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e2.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e2;
        throw error;
      }
      return e2;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        var attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge2.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge2.util.hexToBytes(cert.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i2 = 0; i2 < exts.length; ++i2) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i2]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge2.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge2.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash)) {
            var value = caStore.certs[hash];
            if (!forge2.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i3 = 0; i3 < value.length; ++i3) {
                certList.push(value[i3]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result2;
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge2.util.isArray(match)) {
          result2 = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result2;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            result2 = match[i3];
            match.splice(i3, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result2;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge2.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i2 = 0; i2 < certs.length; ++i2) {
          var cert = certs[i2];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = /* @__PURE__ */ new Date();
      }
      var first = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge2.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent && !cert.isIssuer(parent)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se3 = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i2 = 0; error === null && i2 < cert.extensions.length; ++i2) {
            var ext = cert.extensions[i2];
            if (ext.critical && !(ext.name in se3)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// ../../node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS({
  "../../node_modules/node-forge/lib/pkcs12.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_hmac();
    require_oids();
    require_pkcs7asn1();
    require_pbe();
    require_random();
    require_rsa();
    require_sha1();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var pki = forge2.pki;
    var p12 = module2.exports = forge2.pkcs12 = forge2.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      // a ContentInfo
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            // DigestInfo
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              // DigestAlgorithmIdentifier
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        /* So far we only support X.509 certificates (which are wrapped in
           an OCTET STRING, hence hard code that here). */
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result2 = [];
      for (var i2 = 0; i2 < safeContents.length; i2++) {
        for (var j3 = 0; j3 < safeContents[i2].safeBags.length; j3++) {
          var bag = safeContents[i2].safeBags[j3];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result2.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result2.push(bag);
          }
        }
      }
      return result2;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        /**
         * Gets bags with matching attributes.
         *
         * @param filter the attributes to filter by:
         *          [localKeyId] the localKeyId to search for.
         *          [localKeyIdHex] the localKeyId in hex to search for.
         *          [friendlyName] the friendly name to search for.
         *          [bagType] bag type to narrow each attribute search by.
         *
         * @return a map of attribute type to an array of matching bags or, if no
         *           attribute was given but a bag type, the map key will be the
         *           bag type.
         */
        getBags: function(filter2) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter2) {
            localKeyId = filter2.localKeyId;
          } else if ("localKeyIdHex" in filter2) {
            localKeyId = forge2.util.hexToBytes(filter2.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter2) && "bagType" in filter2) {
            rval[filter2.bagType] = _getBagsByAttribute(
              pfx.safeContents,
              null,
              null,
              filter2.bagType
            );
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(
              pfx.safeContents,
              "localKeyId",
              localKeyId,
              filter2.bagType
            );
          }
          if ("friendlyName" in filter2) {
            rval.friendlyName = _getBagsByAttribute(
              pfx.safeContents,
              "friendlyName",
              filter2.friendlyName,
              filter2.bagType
            );
          }
          return rval;
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching friendlyName attribute.
         *
         * @param friendlyName the friendly name to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching friendlyName attribute.
         */
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "friendlyName",
            friendlyName,
            bagType
          );
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching localKeyId attribute.
         *
         * @param localKeyId the localKeyId to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching localKeyId attribute.
         */
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "localKeyId",
            localKeyId,
            bagType
          );
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md = forge2.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md = forge2.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md = forge2.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md = forge2.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md = forge2.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge2.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge2.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(
          password,
          macSalt,
          3,
          macIterations,
          macKeyBytes,
          md
        );
        var mac = forge2.hmac.create();
        mac.start(md, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge2.util.createBuffer();
        for (var i2 = 0; i2 < data.value.length; ++i2) {
          value.putBytes(data.value[i2].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i2 = 0; i2 < authSafe.value.length; i2++) {
        var contentInfo = authSafe.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error("Unsupported PKCS#12 contentType.");
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(
        data,
        forge2.pkcs7.asn1.encryptedDataValidator,
        capture,
        errors
      )) {
        var error = new Error("Cannot read EncryptedContentInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error = new Error(
          "PKCS#12 EncryptedContentInfo ContentType is not Data."
        );
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge2.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error(
          "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
        );
      }
      var res = [];
      for (var i2 = 0; i2 < safeContents.value.length; i2++) {
        var safeBag = safeContents.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error("Cannot read SafeBag.");
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error(
                "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
              );
            }
          /* fall through */
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e2) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          /* Nothing more to do. */
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error2 = new Error(
                  "Unsupported certificate type, only X.509 supported."
                );
                error2.oid = asn1.derToOid(capture.certId);
                throw error2;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e2) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error("Unsupported PKCS#12 SafeBag type.");
            error.oid = bag.type;
            throw error;
        }
        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 " + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i2 = 0; i2 < attributes.length; ++i2) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i2], attributeValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 BagAttribute.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j3 = 0; j3 < capture.values.length; ++j3) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j3].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key, cert, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
      if (!("useMac" in options)) {
        options.useMac = true;
      }
      if (!("localKeyId" in options)) {
        options.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge2.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge2.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === "string") {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha1 = forge2.md.sha1.create();
          sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha1.digest().getBytes();
        } else {
          localKeyId = forge2.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(
          // localKeyID
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.localKeyId).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                localKeyId
              )
            ])
          ])
        );
      }
      if ("friendlyName" in options) {
        attrs.push(
          // friendlyName
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.friendlyName).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BMPSTRING,
                false,
                options.friendlyName
              )
            ])
          ])
        );
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge2.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i2 = 0; i2 < chain.length; ++i2) {
        cert = chain[i2];
        if (typeof cert === "string") {
          cert = pki.certificateFromPem(cert);
        }
        var certBagAttrs = i2 === 0 ? bagAttrs : void 0;
        var certAsn1 = pki.certificateToAsn1(cert);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // bagId
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.certBag).getBytes()
          ),
          // bagValue
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            // CertBag
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // certId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.x509Certificate).getBytes()
              ),
              // certValue (x509Certificate)
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(certAsn1).getBytes()
                )
              ])
            ])
          ]),
          // bagAttributes (OPTIONAL)
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          certSafeBags
        );
        var certCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(certSafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.keyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // PrivateKeyInfo
              pkAsn1
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // EncryptedPrivateKeyInfo
              pki.encryptPrivateKeyInfo(pkAsn1, password, options)
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(keySafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(keyCI);
      }
      var safe = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        contents
      );
      var macData;
      if (options.useMac) {
        var sha1 = forge2.md.sha1.create();
        var macSalt = new forge2.util.ByteBuffer(
          forge2.random.getBytes(options.saltSize)
        );
        var count = options.count;
        var key = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge2.hmac.create();
        mac.start(sha1, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // mac DigestInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm = SHA-1
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.sha1).getBytes()
              ),
              // parameters = Null
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // digest
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              macValue.getBytes()
            )
          ]),
          // macSalt OCTET STRING
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            macSalt.getBytes()
          ),
          // iterations INTEGER (XXX: Only support count < 65536)
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(count).getBytes()
          )
        ]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (3)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(3).getBytes()
        ),
        // PKCS#7 ContentInfo
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // contentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            // OID for the content type is 'data'
            asn1.oidToDer(pki.oids.data).getBytes()
          ),
          // content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(safe).getBytes()
            )
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge2.pbe.generatePkcs12Key;
  }
});

// ../../node_modules/node-forge/lib/pki.js
var require_pki = __commonJS({
  "../../node_modules/node-forge/lib/pki.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_oids();
    require_pbe();
    require_pem();
    require_pbkdf2();
    require_pkcs12();
    require_pss();
    require_rsa();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var pki = module2.exports = forge2.pki = forge2.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge2.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki2).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
  }
});

// ../../node_modules/node-forge/lib/tls.js
var require_tls = __commonJS({
  "../../node_modules/node-forge/lib/tls.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_hmac();
    require_md5();
    require_pem();
    require_pki();
    require_random();
    require_sha1();
    require_util();
    var prf_TLS1 = function(secret, label, seed, length) {
      var rval = forge2.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge2.util.createBuffer();
      var hmac = forge2.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16);
      var sha1itr = Math.ceil(length / 20);
      hmac.start("MD5", s1);
      var md5bytes = forge2.util.createBuffer();
      ai.putBytes(seed);
      for (var i2 = 0; i2 < md5itr; ++i2) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start("SHA1", s2);
      var sha1bytes = forge2.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i2 = 0; i2 < sha1itr; ++i2) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge2.util.xorBytes(
        md5bytes.getBytes(),
        sha1bytes.getBytes(),
        length
      ));
      return rval;
    };
    var hmac_sha1 = function(key2, seqNum, record) {
      var hmac = forge2.hmac.create();
      hmac.start("SHA1", key2);
      var b2 = forge2.util.createBuffer();
      b2.putInt32(seqNum[0]);
      b2.putInt32(seqNum[1]);
      b2.putByte(record.type);
      b2.putByte(record.version.major);
      b2.putByte(record.version.minor);
      b2.putInt16(record.length);
      b2.putBytes(record.fragment.bytes());
      hmac.update(b2.getBytes());
      return hmac.digest().getBytes();
    };
    var deflate = function(c2, record, s2) {
      var rval = false;
      try {
        var bytes = c2.deflate(record.fragment.getBytes());
        record.fragment = forge2.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var inflate = function(c2, record, s2) {
      var rval = false;
      try {
        var bytes = c2.inflate(record.fragment.getBytes());
        record.fragment = forge2.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var readVector = function(b2, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b2.getByte();
          break;
        case 2:
          len = b2.getInt16();
          break;
        case 3:
          len = b2.getInt24();
          break;
        case 4:
          len = b2.getInt32();
          break;
      }
      return forge2.util.createBuffer(b2.getBytes(len));
    };
    var writeVector = function(b2, lenBytes, v3) {
      b2.putInt(v3.length(), lenBytes << 3);
      b2.putBuffer(v3);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls.SupportedVersions = [
      tls.Versions.TLS_1_1,
      tls.Versions.TLS_1_0
    ];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key2 in tls.CipherSuites) {
        var cs = tls.CipherSuites[key2];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c2, record) {
      var ignore = !c2.open && c2.entity === tls.ConnectionEnd.client;
      if (!ignore) {
        c2.error(c2, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c2, record, length) {
      if (!c2.handshaking && c2.handshakes > 0) {
        tls.queue(c2, tls.createAlert(c2, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c2);
      }
      c2.process();
    };
    tls.parseHelloMessage = function(c2, record, length) {
      var msg = null;
      var client = c2.entity === tls.ConnectionEnd.client;
      if (length < 38) {
        c2.error(c2, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b2 = record.fragment;
        var remaining = b2.length();
        msg = {
          version: {
            major: b2.getByte(),
            minor: b2.getByte()
          },
          random: forge2.util.createBuffer(b2.getBytes(32)),
          session_id: readVector(b2, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b2.getBytes(2);
          msg.compression_method = b2.getByte();
        } else {
          msg.cipher_suites = readVector(b2, 2);
          msg.compression_methods = readVector(b2, 1);
        }
        remaining = length - (remaining - b2.length());
        if (remaining > 0) {
          var exts = readVector(b2, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i2 = 0; i2 < msg.extensions.length; ++i2) {
              var ext = msg.extensions[i2];
              if (ext.type[0] === 0 && ext.type[1] === 0) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c2.session.extensions.server_name.serverNameList.push(
                    readVector(snl, 2).getBytes()
                  );
                }
              }
            }
          }
        }
        if (c2.session.version) {
          if (msg.version.major !== c2.session.version.major || msg.version.minor !== c2.session.version.minor) {
            return c2.error(c2, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c2.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge2.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c2.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c2.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c2.session.cipherSuite === null) {
          return c2.error(c2, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge2.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c2.session.compressionMethod = msg.compression_method;
        } else {
          c2.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c2, msg) {
      var client = c2.entity === tls.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c2.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c2.session.sp = {
        entity: c2.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c2.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c2, record, length) {
      var msg = tls.parseHelloMessage(c2, record, length);
      if (c2.fail) {
        return;
      }
      if (msg.version.minor <= c2.version.minor) {
        c2.version.minor = msg.version.minor;
      } else {
        return c2.error(c2, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c2.session.version = c2.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c2.session.id) {
        c2.expect = SCC;
        c2.session.resuming = true;
        c2.session.sp.server_random = msg.random.bytes();
      } else {
        c2.expect = SCE;
        c2.session.resuming = false;
        tls.createSecurityParameters(c2, msg);
      }
      c2.session.id = sessionId;
      c2.process();
    };
    tls.handleClientHello = function(c2, record, length) {
      var msg = tls.parseHelloMessage(c2, record, length);
      if (c2.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c2.sessionCache) {
        session = c2.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge2.random.getBytes(32);
      }
      c2.session.id = sessionId;
      c2.session.clientHelloVersion = msg.version;
      c2.session.sp = {};
      if (session) {
        c2.version = c2.session.version = session.version;
        c2.session.sp = session.sp;
      } else {
        var version3;
        for (var i2 = 1; i2 < tls.SupportedVersions.length; ++i2) {
          version3 = tls.SupportedVersions[i2];
          if (version3.minor <= msg.version.minor) {
            break;
          }
        }
        c2.version = { major: version3.major, minor: version3.minor };
        c2.session.version = c2.version;
      }
      if (session !== null) {
        c2.expect = CCC;
        c2.session.resuming = true;
        c2.session.sp.client_random = msg.random.bytes();
      } else {
        c2.expect = c2.verifyClient !== false ? CCE : CKE;
        c2.session.resuming = false;
        tls.createSecurityParameters(c2, msg);
      }
      c2.open = true;
      tls.queue(c2, tls.createRecord(c2, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c2)
      }));
      if (c2.session.resuming) {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.pending = tls.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
      } else {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c2)
        }));
        if (!c2.fail) {
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c2)
          }));
          if (c2.verifyClient !== false) {
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c2)
            }));
          }
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c2)
          }));
        }
      }
      tls.flush(c2);
      c2.process();
    };
    tls.handleCertificate = function(c2, record, length) {
      if (length < 3) {
        return c2.error(c2, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_list: readVector(b2, 3)
      };
      var cert, asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn1 = forge2.asn1.fromDer(cert);
          cert = forge2.pki.certificateFromAsn1(asn1, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c2.error(c2, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = c2.entity === tls.ConnectionEnd.client;
      if ((client || c2.verifyClient === true) && certs.length === 0) {
        c2.error(c2, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c2.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c2.session.serverCertificate = certs[0];
        } else {
          c2.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c2, certs)) {
          c2.expect = client ? SKE : CKE;
        }
      }
      c2.process();
    };
    tls.handleServerKeyExchange = function(c2, record, length) {
      if (length > 0) {
        return c2.error(c2, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c2.expect = SCR;
      c2.process();
    };
    tls.handleClientKeyExchange = function(c2, record, length) {
      if (length < 48) {
        return c2.error(c2, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b2, 2).getBytes()
      };
      var privateKey = null;
      if (c2.getPrivateKey) {
        try {
          privateKey = c2.getPrivateKey(c2, c2.session.serverCertificate);
          privateKey = forge2.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c2.error(c2, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c2.error(c2, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c2.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version3 = c2.session.clientHelloVersion;
        if (version3.major !== sp.pre_master_secret.charCodeAt(0) || version3.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge2.random.getBytes(48);
      }
      c2.expect = CCC;
      if (c2.session.clientCertificate !== null) {
        c2.expect = CCV;
      }
      c2.process();
    };
    tls.handleCertificateRequest = function(c2, record, length) {
      if (length < 3) {
        return c2.error(c2, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_types: readVector(b2, 1),
        certificate_authorities: readVector(b2, 2)
      };
      c2.session.certificateRequest = msg;
      c2.expect = SHD;
      c2.process();
    };
    tls.handleCertificateVerify = function(c2, record, length) {
      if (length < 2) {
        return c2.error(c2, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var msg = {
        signature: readVector(b2, 2).getBytes()
      };
      var verify = forge2.util.createBuffer();
      verify.putBuffer(c2.session.md5.digest());
      verify.putBuffer(c2.session.sha1.digest());
      verify = verify.getBytes();
      try {
        var cert = c2.session.clientCertificate;
        if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c2.session.md5.update(msgBytes);
        c2.session.sha1.update(msgBytes);
      } catch (ex) {
        return c2.error(c2, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c2.expect = CCC;
      c2.process();
    };
    tls.handleServerHelloDone = function(c2, record, length) {
      if (length > 0) {
        return c2.error(c2, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c2.serverCertificate === null) {
        var error = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c2.verify(c2, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error.alert.description = ret;
            }
          }
          return c2.error(c2, error);
        }
      }
      if (c2.session.certificateRequest !== null) {
        record = tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c2)
        });
        tls.queue(c2, record);
      }
      record = tls.createRecord(c2, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c2)
      });
      tls.queue(c2, record);
      c2.expect = SER;
      var callback = function(c3, signature) {
        if (c3.session.certificateRequest !== null && c3.session.clientCertificate !== null) {
          tls.queue(c3, tls.createRecord(c3, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c3, signature)
          }));
        }
        tls.queue(c3, tls.createRecord(c3, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c3.state.pending = tls.createConnectionState(c3);
        c3.state.current.write = c3.state.pending.write;
        tls.queue(c3, tls.createRecord(c3, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c3)
        }));
        c3.expect = SCC;
        tls.flush(c3);
        c3.process();
      };
      if (c2.session.certificateRequest === null || c2.session.clientCertificate === null) {
        return callback(c2, null);
      }
      tls.getClientSignature(c2, callback);
    };
    tls.handleChangeCipherSpec = function(c2, record) {
      if (record.fragment.getByte() !== 1) {
        return c2.error(c2, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c2.entity === tls.ConnectionEnd.client;
      if (c2.session.resuming && client || !c2.session.resuming && !client) {
        c2.state.pending = tls.createConnectionState(c2);
      }
      c2.state.current.read = c2.state.pending.read;
      if (!c2.session.resuming && client || c2.session.resuming && !client) {
        c2.state.pending = null;
      }
      c2.expect = client ? SFI : CFI;
      c2.process();
    };
    tls.handleFinished = function(c2, record, length) {
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var vd = record.fragment.getBytes();
      b2 = forge2.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      var client = c2.entity === tls.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c2.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      if (b2.getBytes() !== vd) {
        return c2.error(c2, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c2.session.md5.update(msgBytes);
      c2.session.sha1.update(msgBytes);
      if (c2.session.resuming && client || !c2.session.resuming && !client) {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.current.write = c2.state.pending.write;
        c2.state.pending = null;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
      }
      c2.expect = client ? SAD : CAD;
      c2.handshaking = false;
      ++c2.handshakes;
      c2.peerCertificate = client ? c2.session.serverCertificate : c2.session.clientCertificate;
      tls.flush(c2);
      c2.isConnected = true;
      c2.connected(c2);
      c2.process();
    };
    tls.handleAlert = function(c2, record) {
      var b2 = record.fragment;
      var alert = {
        level: b2.getByte(),
        description: b2.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c2.close();
      }
      c2.error(c2, {
        message: msg,
        send: false,
        // origin is the opposite end
        origin: c2.entity === tls.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c2.process();
    };
    tls.handleHandshake = function(c2, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length = b2.getInt24();
      if (length > b2.length()) {
        c2.fragmented = record;
        record.fragment = forge2.util.createBuffer();
        b2.read -= 4;
        return c2.process();
      }
      c2.fragmented = null;
      b2.read -= 4;
      var bytes = b2.bytes(length + 4);
      b2.read += 4;
      if (type in hsTable[c2.entity][c2.expect]) {
        if (c2.entity === tls.ConnectionEnd.server && !c2.open && !c2.fail) {
          c2.handshaking = true;
          c2.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge2.md.md5.create(),
            sha1: forge2.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c2.session.md5.update(bytes);
          c2.session.sha1.update(bytes);
        }
        hsTable[c2.entity][c2.expect][type](c2, record, length);
      } else {
        tls.handleUnexpected(c2, record);
      }
    };
    tls.handleApplicationData = function(c2, record) {
      c2.data.putBuffer(record.fragment);
      c2.dataReady(c2);
      c2.process();
    };
    tls.handleHeartbeat = function(c2, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length = b2.getInt16();
      var payload = b2.getBytes(length);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c2.handshaking || length > payload.length) {
          return c2.process();
        }
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_response,
            payload
          )
        }));
        tls.flush(c2);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c2.expectedHeartbeatPayload) {
          return c2.process();
        }
        if (c2.heartbeatReceived) {
          c2.heartbeatReceived(c2, forge2.util.createBuffer(payload));
        }
      }
      c2.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R22 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [
      //      CC,AL,HS,AD,HB
      /*SHE*/
      [__, R1, R22, __, R4],
      /*SCE*/
      [__, R1, R22, __, R4],
      /*SKE*/
      [__, R1, R22, __, R4],
      /*SCR*/
      [__, R1, R22, __, R4],
      /*SHD*/
      [__, R1, R22, __, R4],
      /*SCC*/
      [R0, R1, __, __, R4],
      /*SFI*/
      [__, R1, R22, __, R4],
      /*SAD*/
      [__, R1, R22, R3, R4],
      /*SER*/
      [__, R1, R22, __, R4]
    ];
    ctTable[tls.ConnectionEnd.server] = [
      //      CC,AL,HS,AD
      /*CHE*/
      [__, R1, R22, __, R4],
      /*CCE*/
      [__, R1, R22, __, R4],
      /*CKE*/
      [__, R1, R22, __, R4],
      /*CCV*/
      [__, R1, R22, __, R4],
      /*CCC*/
      [R0, R1, __, __, R4],
      /*CFI*/
      [__, R1, R22, __, R4],
      /*CAD*/
      [__, R1, R22, R3, R4],
      /*CER*/
      [__, R1, R22, __, R4]
    ];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H22 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [
      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
      /*SHE*/
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SCE*/
      [H0, __, __, __, __, __, __, __, __, __, __, H22, H3, H4, H5, __, __, __, __, __, __],
      /*SKE*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      /*SCR*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      /*SHD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      /*SCC*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SFI*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*SAD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SER*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [
      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
      /*CHE*/
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CCE*/
      [__, __, __, __, __, __, __, __, __, __, __, H22, __, __, __, __, __, __, __, __, __],
      /*CKE*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      /*CCV*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      /*CCC*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CFI*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*CAD*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CER*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls.generateKeys = function(c2, sp) {
      var prf = prf_TLS1;
      var random3 = sp.client_random + sp.server_random;
      if (!c2.session.resuming) {
        sp.master_secret = prf(
          sp.pre_master_secret,
          "master secret",
          random3,
          48
        ).bytes();
        sp.pre_master_secret = null;
      }
      random3 = sp.server_random + sp.client_random;
      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c2.version.major === tls.Versions.TLS_1_0.major && c2.version.minor === tls.Versions.TLS_1_0.minor;
      if (tls10) {
        length += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random3, length);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c2) {
      var client = c2.entity === tls.ConnectionEnd.client;
      var createMode = function() {
        var mode = {
          // two 32-bit numbers, first is most significant
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 4294967295) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c3, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c3.error(c3, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              // doesn't matter if decryption failed or MAC was
              // invalid, return the same error so as not to reveal
              // which one occurred
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c3, record, state.read)) {
          c3.error(c3, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c3.fail;
      };
      state.write.update = function(c3, record) {
        if (!state.write.compressFunction(c3, record, state.write)) {
          c3.error(c3, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c3.error(c3, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c3.fail;
      };
      if (c2.session) {
        var sp = c2.session.sp;
        c2.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c2, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c2.session.cipherSuite.initConnectionState(state, c2, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d2 = /* @__PURE__ */ new Date();
      var utc = +d2 + d2.getTimezoneOffset() * 6e4;
      var rval = forge2.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge2.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c2, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c2.version.major,
          minor: c2.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c2, alert) {
      var b2 = forge2.util.createBuffer();
      b2.putByte(alert.level);
      b2.putByte(alert.description);
      return tls.createRecord(c2, {
        type: tls.ContentType.alert,
        data: b2
      });
    };
    tls.createClientHello = function(c2) {
      c2.session.clientHelloVersion = {
        major: c2.version.major,
        minor: c2.version.minor
      };
      var cipherSuites = forge2.util.createBuffer();
      for (var i2 = 0; i2 < c2.cipherSuites.length; ++i2) {
        var cs = c2.cipherSuites[i2];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge2.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge2.util.createBuffer();
      if (c2.virtualHost) {
        var ext = forge2.util.createBuffer();
        ext.putByte(0);
        ext.putByte(0);
        var serverName = forge2.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge2.util.createBuffer(c2.virtualHost));
        var snList = forge2.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c2.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + cSuites + // cipher suites vector
      1 + cMethods + // compression methods vector
      extLength;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length);
      rval.putByte(c2.version.major);
      rval.putByte(c2.version.minor);
      rval.putBytes(c2.session.sp.client_random);
      writeVector(rval, 1, forge2.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c2) {
      var sessionId = c2.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + // chosen cipher suite
      1;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length);
      rval.putByte(c2.version.major);
      rval.putByte(c2.version.minor);
      rval.putBytes(c2.session.sp.server_random);
      writeVector(rval, 1, forge2.util.createBuffer(sessionId));
      rval.putByte(c2.session.cipherSuite.id[0]);
      rval.putByte(c2.session.cipherSuite.id[1]);
      rval.putByte(c2.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c2) {
      var client = c2.entity === tls.ConnectionEnd.client;
      var cert = null;
      if (c2.getCertificate) {
        var hint;
        if (client) {
          hint = c2.session.certificateRequest;
        } else {
          hint = c2.session.extensions.server_name.serverNameList;
        }
        cert = c2.getCertificate(c2, hint);
      }
      var certList = forge2.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge2.util.isArray(cert)) {
            cert = [cert];
          }
          var asn1 = null;
          for (var i2 = 0; i2 < cert.length; ++i2) {
            var msg = forge2.pem.decode(cert[i2])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge2.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge2.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge2.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge2.pki.certificateFromAsn1(asn1);
          if (client) {
            c2.session.clientCertificate = cert;
          } else {
            c2.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c2.error(c2, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length = 3 + certList.length();
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c2) {
      var b2 = forge2.util.createBuffer();
      b2.putByte(c2.session.clientHelloVersion.major);
      b2.putByte(c2.session.clientHelloVersion.minor);
      b2.putBytes(forge2.random.getBytes(46));
      var sp = c2.session.sp;
      sp.pre_master_secret = b2.getBytes();
      var key2 = c2.session.serverCertificate.publicKey;
      b2 = key2.encrypt(sp.pre_master_secret);
      var length = b2.length + 2;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length);
      rval.putInt16(b2.length);
      rval.putBytes(b2);
      return rval;
    };
    tls.createServerKeyExchange = function(c2) {
      var length = 0;
      var rval = forge2.util.createBuffer();
      if (length > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length);
      }
      return rval;
    };
    tls.getClientSignature = function(c2, callback) {
      var b2 = forge2.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      b2 = b2.getBytes();
      c2.getSignature = c2.getSignature || function(c3, b3, callback2) {
        var privateKey = null;
        if (c3.getPrivateKey) {
          try {
            privateKey = c3.getPrivateKey(c3, c3.session.clientCertificate);
            privateKey = forge2.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c3.error(c3, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c3.error(c3, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b3 = privateKey.sign(b3, null);
        }
        callback2(c3, b3);
      };
      c2.getSignature(c2, b2, callback);
    };
    tls.createCertificateVerify = function(c2, signature) {
      var length = signature.length + 2;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c2) {
      var certTypes = forge2.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge2.util.createBuffer();
      for (var key2 in c2.caStore.certs) {
        var cert = c2.caStore.certs[key2];
        var dn = forge2.pki.distinguishedNameToAsn1(cert.subject);
        var byteBuffer = forge2.asn1.toDer(dn);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c2) {
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge2.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls.createFinished = function(c2) {
      var b2 = forge2.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      var client = c2.entity === tls.ConnectionEnd.client;
      var sp = c2.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b2.length());
      rval.putBuffer(b2);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge2.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge2.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c2, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c2.session.md5.update(bytes);
        c2.session.sha1.update(bytes);
        bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c2, {
            type: record.type,
            data: forge2.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c2, {
            type: record.type,
            data: forge2.util.createBuffer(data)
          }));
        }
      }
      for (var i2 = 0; i2 < records.length && !c2.fail; ++i2) {
        var rec = records[i2];
        var s2 = c2.state.current.write;
        if (s2.update(c2, rec)) {
          c2.records.push(rec);
        }
      }
    };
    tls.flush = function(c2) {
      for (var i2 = 0; i2 < c2.records.length; ++i2) {
        var record = c2.records[i2];
        c2.tlsData.putByte(record.type);
        c2.tlsData.putByte(record.version.major);
        c2.tlsData.putByte(record.version.minor);
        c2.tlsData.putInt16(record.fragment.length());
        c2.tlsData.putBuffer(c2.records[i2].fragment);
      }
      c2.records = [];
      return c2.tlsDataReady(c2);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge2.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge2.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge2.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge2.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge2.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge2.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge2.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge2.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge2.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge2.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge2.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge2.pki.certificateError.unknown_ca;
        default:
          return forge2.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c2, chain) {
      try {
        var options = {};
        for (var key2 in c2.verifyOptions) {
          options[key2] = c2.verifyOptions[key2];
        }
        options.verify = function(vfd, depth, chain2) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c2.verify(c2, vfd, depth, chain2);
          if (ret !== true) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              var error = new Error("The application rejected the certificate.");
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge2.pki.verifyCertificateChain(c2.caStore, chain, options);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge2.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c2.error(c2, err);
      }
      return !c2.fail;
    };
    tls.createSessionCache = function(cache, capacity) {
      var rval = null;
      if (cache && cache.getSession && cache.setSession && cache.order) {
        rval = cache;
      } else {
        rval = {};
        rval.cache = cache || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key2 in cache) {
          if (rval.order.length <= capacity) {
            rval.order.push(key2);
          } else {
            delete cache[key2];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key3 = null;
          if (sessionId) {
            key3 = forge2.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key3 = rval.order[0];
          }
          if (key3 !== null && key3 in rval.cache) {
            session = rval.cache[key3];
            delete rval.cache[key3];
            for (var i2 in rval.order) {
              if (rval.order[i2] === key3) {
                rval.order.splice(i2, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key3 = rval.order.shift();
            delete rval.cache[key3];
          }
          var key3 = forge2.util.bytesToHex(sessionId);
          rval.order.push(key3);
          rval.cache[key3] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge2.util.isArray(options.caStore)) {
          caStore = forge2.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge2.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key2 in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key2]);
        }
      }
      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c2 = {
        version: { major: tls.Version.major, minor: tls.Version.minor },
        entity,
        sessionId: options.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge2.util.createBuffer(),
        tlsData: forge2.util.createBuffer(),
        data: forge2.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c3, ex) {
          ex.origin = ex.origin || (c3.entity === tls.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls.queue(c3, tls.createAlert(c3, ex.alert));
            tls.flush(c3);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c3.fail = true;
          }
          options.error(c3, ex);
          if (fatal) {
            c3.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c2.reset = function(clearFail) {
        c2.version = { major: tls.Version.major, minor: tls.Version.minor };
        c2.record = null;
        c2.session = null;
        c2.peerCertificate = null;
        c2.state = {
          pending: null,
          current: null
        };
        c2.expect = c2.entity === tls.ConnectionEnd.client ? SHE : CHE;
        c2.fragmented = null;
        c2.records = [];
        c2.open = false;
        c2.handshakes = 0;
        c2.handshaking = false;
        c2.isConnected = false;
        c2.fail = !(clearFail || typeof clearFail === "undefined");
        c2.input.clear();
        c2.tlsData.clear();
        c2.data.clear();
        c2.state.current = tls.createConnectionState(c2);
      };
      c2.reset();
      var _update = function(c3, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers2 = ctTable[c3.entity][c3.expect];
        if (aligned in handlers2) {
          handlers2[aligned](c3, record);
        } else {
          tls.handleUnexpected(c3, record);
        }
      };
      var _readRecordHeader = function(c3) {
        var rval = 0;
        var b2 = c3.input;
        var len = b2.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c3.record = {
            type: b2.getByte(),
            version: {
              major: b2.getByte(),
              minor: b2.getByte()
            },
            length: b2.getInt16(),
            fragment: forge2.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c3.record.version.major === c3.version.major;
          if (compatibleVersion && c3.session && c3.session.version) {
            compatibleVersion = c3.record.version.minor === c3.version.minor;
          }
          if (!compatibleVersion) {
            c3.error(c3, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c3) {
        var rval = 0;
        var b2 = c3.input;
        var len = b2.length();
        if (len < c3.record.length) {
          rval = c3.record.length - len;
        } else {
          c3.record.fragment.putBytes(b2.getBytes(c3.record.length));
          b2.compact();
          var s2 = c3.state.current.read;
          if (s2.update(c3, c3.record)) {
            if (c3.fragmented !== null) {
              if (c3.fragmented.type === c3.record.type) {
                c3.fragmented.fragment.putBuffer(c3.record.fragment);
                c3.record = c3.fragmented;
              } else {
                c3.error(c3, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c3.record.ready = true;
          }
        }
        return rval;
      };
      c2.handshake = function(sessionId) {
        if (c2.entity !== tls.ConnectionEnd.client) {
          c2.error(c2, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c2.handshaking) {
          c2.error(c2, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c2.fail && !c2.open && c2.handshakes === 0) {
            c2.fail = false;
          }
          c2.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c2.sessionCache) {
              session = c2.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c2.sessionCache) {
            session = c2.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c2.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge2.md.md5.create(),
            sha1: forge2.md.sha1.create()
          };
          if (session) {
            c2.version = session.version;
            c2.session.sp = session.sp;
          }
          c2.session.sp.client_random = tls.createRandom().getBytes();
          c2.open = true;
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c2)
          }));
          tls.flush(c2);
        }
      };
      c2.process = function(data) {
        var rval = 0;
        if (data) {
          c2.input.putBytes(data);
        }
        if (!c2.fail) {
          if (c2.record !== null && c2.record.ready && c2.record.fragment.isEmpty()) {
            c2.record = null;
          }
          if (c2.record === null) {
            rval = _readRecordHeader(c2);
          }
          if (!c2.fail && c2.record !== null && !c2.record.ready) {
            rval = _readRecord(c2);
          }
          if (!c2.fail && c2.record !== null && c2.record.ready) {
            _update(c2, c2.record);
          }
        }
        return rval;
      };
      c2.prepare = function(data) {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.application_data,
          data: forge2.util.createBuffer(data)
        }));
        return tls.flush(c2);
      };
      c2.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge2.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c2.expectedHeartbeatPayload = payload;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_request,
            payload,
            payloadLength
          )
        }));
        return tls.flush(c2);
      };
      c2.close = function(clearFail) {
        if (!c2.fail && c2.sessionCache && c2.session) {
          var session = {
            id: c2.session.id,
            version: c2.session.version,
            sp: c2.session.sp
          };
          session.sp.keys = null;
          c2.sessionCache.setSession(session.id, session);
        }
        if (c2.open) {
          c2.open = false;
          c2.input.clear();
          if (c2.isConnected || c2.handshaking) {
            c2.isConnected = c2.handshaking = false;
            tls.queue(c2, tls.createAlert(c2, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c2);
          }
          c2.closed(c2);
        }
        c2.reset(clearFail);
      };
      return c2;
    };
    module2.exports = forge2.tls = forge2.tls || {};
    for (key in tls) {
      if (typeof tls[key] !== "function") {
        forge2.tls[key] = tls[key];
      }
    }
    var key;
    forge2.tls.prf_tls1 = prf_TLS1;
    forge2.tls.hmac_sha1 = hmac_sha1;
    forge2.tls.createSessionCache = tls.createSessionCache;
    forge2.tls.createConnection = tls.createConnection;
  }
});

// ../../node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS({
  "../../node_modules/node-forge/lib/aesCipherSuites.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_tls();
    var tls = module2.exports = forge2.tls;
    tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    function initConnectionState(state, c2, sp) {
      var client = c2.entity === forge2.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge2.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge2.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s2) {
      var rval = false;
      var mac = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s2.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s2.cipherState.init ? null : s2.cipherState.iv;
      } else {
        iv = forge2.random.getBytesSync(16);
      }
      s2.cipherState.init = true;
      var cipher = s2.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding = blockSize - input.length() % blockSize;
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i2 = len - 1 - paddingLength; i2 < len - 1; ++i2) {
          rval = rval && output.at(i2) == paddingLength;
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    function decrypt_aes_cbc_sha1(record, s2) {
      var rval = false;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s2.cipherState.init ? null : s2.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s2.cipherState.init = true;
      var cipher = s2.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s2.macLength;
      var mac = forge2.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge2.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
      s2.updateSequenceNumber();
      rval = compareMacs(s2.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key, mac1, mac2) {
      var hmac = forge2.hmac.create();
      hmac.start("SHA1", key);
      hmac.update(mac1);
      mac1 = hmac.digest().getBytes();
      hmac.start(null, null);
      hmac.update(mac2);
      mac2 = hmac.digest().getBytes();
      return mac1 === mac2;
    }
  }
});

// ../../node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "../../node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha512 = module2.exports = forge2.sha512 = forge2.sha512 || {};
    forge2.md.sha512 = forge2.md.algorithms.sha512 = sha512;
    var sha384 = forge2.sha384 = forge2.sha512.sha384 = forge2.sha512.sha384 || {};
    sha384.create = function() {
      return sha512.create("SHA-384");
    };
    forge2.md.sha384 = forge2.md.algorithms.sha384 = sha384;
    forge2.sha512.sha256 = forge2.sha512.sha256 || {
      create: function() {
        return sha512.create("SHA-512/256");
      }
    };
    forge2.md["sha512/256"] = forge2.md.algorithms["sha512/256"] = forge2.sha512.sha256;
    forge2.sha512.sha224 = forge2.sha512.sha224 || {
      create: function() {
        return sha512.create("SHA-512/224");
      }
    };
    forge2.md["sha512/224"] = forge2.md.algorithms["sha512/224"] = forge2.sha512.sha224;
    sha512.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _h = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h[i2] = _state[i2].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h2 = new Array(_h.length);
        for (var i2 = 0; i2 < _h.length; ++i2) {
          h2[i2] = _h[i2].slice(0);
        }
        _update(h2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h2.length;
        } else if (algorithm === "SHA-384") {
          hlen = h2.length - 2;
        } else {
          hlen = h2.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h2[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h2[i2][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi, lo, w22, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2][0] = bytes.getInt32() >>> 0;
          w3[i2][1] = bytes.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w22 = w3[i2 - 2];
          hi = w22[0];
          lo = w22[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w3[i2 - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w3[i2 - 7];
          w16 = w3[i2 - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w3[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w3[i2][1] = lo >>> 0;
        }
        a_hi = s2[0][0];
        a_lo = s2[0][1];
        b_hi = s2[1][0];
        b_lo = s2[1][1];
        c_hi = s2[2][0];
        c_lo = s2[2][1];
        d_hi = s2[3][0];
        d_lo = s2[3][1];
        e_hi = s2[4][0];
        e_lo = s2[4][1];
        f_hi = s2[5][0];
        f_lo = s2[5][1];
        g_hi = s2[6][0];
        g_lo = s2[6][1];
        h_hi = s2[7][0];
        h_lo = s2[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w3[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w3[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s2[0][1] + a_lo;
        s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[0][1] = lo >>> 0;
        lo = s2[1][1] + b_lo;
        s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[1][1] = lo >>> 0;
        lo = s2[2][1] + c_lo;
        s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[2][1] = lo >>> 0;
        lo = s2[3][1] + d_lo;
        s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[3][1] = lo >>> 0;
        lo = s2[4][1] + e_lo;
        s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[4][1] = lo >>> 0;
        lo = s2[5][1] + f_lo;
        s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[5][1] = lo >>> 0;
        lo = s2[6][1] + g_lo;
        s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[6][1] = lo >>> 0;
        lo = s2[7][1] + h_lo;
        s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "../../node_modules/node-forge/lib/asn1-validator.js"(exports2) {
    var forge2 = require_forge();
    require_asn1();
    var asn1 = forge2.asn1;
    exports2.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports2.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// ../../node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "../../node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
    var forge2 = require_forge();
    require_jsbn();
    require_random();
    require_sha512();
    require_util();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge2.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge2.pki = forge2.pki || {};
    module2.exports = forge2.pki.ed25519 = forge2.ed25519 = forge2.ed25519 || {};
    var ed25519 = forge2.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge2.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < 32; ++i2) {
        sk[i2] = seed[i2];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge2.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge2.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge2.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge2.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge2.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge2.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge2.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < pk.length; ++i2) {
        pk[i2] = privateKey[32 + i2];
      }
      return pk;
    };
    ed25519.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed25519.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i2 = 0; i2 < sig.length; ++i2) {
        sig[i2] = signedMsg[i2];
      }
      return sig;
    };
    ed25519.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m3 = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i2;
      for (i2 = 0; i2 < ed25519.constants.SIGN_BYTE_LENGTH; ++i2) {
        sm[i2] = sig[i2];
      }
      for (i2 = 0; i2 < msg.length; ++i2) {
        sm[i2 + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i2];
      }
      return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message.length());
      for (var i2 = 0; i2 < buffer.length; ++i2) {
        buffer[i2] = message.at(i2);
      }
      return buffer;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D3 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X3 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y3 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L3 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I3 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha512(msg, msgLen) {
      var md = forge2.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md.update(buffer.getBytes(msgLen), "binary");
      var hash = md.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash, "binary");
      }
      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i2 = 0; i2 < 64; ++i2) {
        out[i2] = hash.charCodeAt(i2);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p3 = [gf(), gf(), gf(), gf()];
      var i2;
      var d2 = sha512(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p3, d2);
      pack(pk, p3);
      for (i2 = 0; i2 < 32; ++i2) {
        sk[i2 + 32] = pk[i2];
      }
      return 0;
    }
    function crypto_sign(sm, m3, n2, sk) {
      var i2, j3, x3 = new Float64Array(64);
      var p3 = [gf(), gf(), gf(), gf()];
      var d2 = sha512(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n2 + 64;
      for (i2 = 0; i2 < n2; ++i2) {
        sm[64 + i2] = m3[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        sm[32 + i2] = d2[32 + i2];
      }
      var r2 = sha512(sm.subarray(32), n2 + 32);
      reduce2(r2);
      scalarbase(p3, r2);
      pack(sm, p3);
      for (i2 = 32; i2 < 64; ++i2) {
        sm[i2] = sk[i2];
      }
      var h2 = sha512(sm, n2 + 64);
      reduce2(h2);
      for (i2 = 32; i2 < 64; ++i2) {
        x3[i2] = 0;
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2] = r2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        for (j3 = 0; j3 < 32; j3++) {
          x3[i2 + j3] += h2[i2] * d2[j3];
        }
      }
      modL(sm.subarray(32), x3);
      return smlen;
    }
    function crypto_sign_open(m3, sm, n2, pk) {
      var i2, mlen;
      var t2 = new NativeBuffer(32);
      var p3 = [gf(), gf(), gf(), gf()], q3 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n2 < 64) {
        return -1;
      }
      if (unpackneg(q3, pk)) {
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m3[i2] = sm[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        m3[i2 + 32] = pk[i2];
      }
      var h2 = sha512(m3, n2);
      reduce2(h2);
      scalarmult(p3, q3, h2);
      scalarbase(q3, sm.subarray(32));
      add2(p3, q3);
      pack(t2, p3);
      n2 -= 64;
      if (crypto_verify_32(sm, 0, t2, 0)) {
        for (i2 = 0; i2 < n2; ++i2) {
          m3[i2] = 0;
        }
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m3[i2] = sm[i2 + 64];
      }
      mlen = n2;
      return mlen;
    }
    function modL(r2, x3) {
      var carry, i2, j3, k2;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j3 = i2 - 32, k2 = i2 - 12; j3 < k2; ++j3) {
          x3[j3] += carry - 16 * x3[i2] * L3[j3 - (i2 - 32)];
          carry = x3[j3] + 128 >> 8;
          x3[j3] -= carry * 256;
        }
        x3[j3] += carry;
        x3[i2] = 0;
      }
      carry = 0;
      for (j3 = 0; j3 < 32; ++j3) {
        x3[j3] += carry - (x3[31] >> 4) * L3[j3];
        carry = x3[j3] >> 8;
        x3[j3] &= 255;
      }
      for (j3 = 0; j3 < 32; ++j3) {
        x3[j3] -= carry * L3[j3];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2 + 1] += x3[i2] >> 8;
        r2[i2] = x3[i2] & 255;
      }
    }
    function reduce2(r2) {
      var x3 = new Float64Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        x3[i2] = r2[i2];
        r2[i2] = 0;
      }
      modL(r2, x3);
    }
    function add2(p3, q3) {
      var a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f3 = gf(), g2 = gf(), h2 = gf(), t2 = gf();
      Z3(a2, p3[1], p3[0]);
      Z3(t2, q3[1], q3[0]);
      M3(a2, a2, t2);
      A3(b2, p3[0], p3[1]);
      A3(t2, q3[0], q3[1]);
      M3(b2, b2, t2);
      M3(c2, p3[3], q3[3]);
      M3(c2, c2, D22);
      M3(d2, p3[2], q3[2]);
      A3(d2, d2, d2);
      Z3(e2, b2, a2);
      Z3(f3, d2, c2);
      A3(g2, d2, c2);
      A3(h2, b2, a2);
      M3(p3[0], e2, f3);
      M3(p3[1], h2, g2);
      M3(p3[2], g2, f3);
      M3(p3[3], e2, h2);
    }
    function cswap(p3, q3, b2) {
      for (var i2 = 0; i2 < 4; ++i2) {
        sel25519(p3[i2], q3[i2], b2);
      }
    }
    function pack(r2, p3) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p3[2]);
      M3(tx, p3[0], zi);
      M3(ty, p3[1], zi);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function pack25519(o2, n2) {
      var i2, j3, b2;
      var m3 = gf(), t2 = gf();
      for (i2 = 0; i2 < 16; ++i2) {
        t2[i2] = n2[i2];
      }
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j3 = 0; j3 < 2; ++j3) {
        m3[0] = t2[0] - 65517;
        for (i2 = 1; i2 < 15; ++i2) {
          m3[i2] = t2[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
          m3[i2 - 1] &= 65535;
        }
        m3[15] = t2[15] - 32767 - (m3[14] >> 16 & 1);
        b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t2, m3, 1 - b2);
      }
      for (i2 = 0; i2 < 16; i2++) {
        o2[2 * i2] = t2[i2] & 255;
        o2[2 * i2 + 1] = t2[i2] >> 8;
      }
    }
    function unpackneg(r2, p3) {
      var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p3);
      S3(num, r2[1]);
      M3(den, num, D3);
      Z3(num, num, r2[2]);
      A3(den, r2[2], den);
      S3(den2, den);
      S3(den4, den2);
      M3(den6, den4, den2);
      M3(t2, den6, num);
      M3(t2, t2, den);
      pow2523(t2, t2);
      M3(t2, t2, num);
      M3(t2, t2, den);
      M3(t2, t2, den);
      M3(r2[0], t2, den);
      S3(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        M3(r2[0], r2[0], I3);
      }
      S3(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p3[31] >> 7) {
        Z3(r2[0], gf0, r2[0]);
      }
      M3(r2[3], r2[0], r2[1]);
      return 0;
    }
    function unpack25519(o2, n2) {
      var i2;
      for (i2 = 0; i2 < 16; ++i2) {
        o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function pow2523(o2, i2) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 250; a2 >= 0; --a2) {
        S3(c2, c2);
        if (a2 !== 1) {
          M3(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function neq25519(a2, b2) {
      var c2 = new NativeBuffer(32);
      var d2 = new NativeBuffer(32);
      pack25519(c2, a2);
      pack25519(d2, b2);
      return crypto_verify_32(c2, 0, d2, 0);
    }
    function crypto_verify_32(x3, xi, y2, yi) {
      return vn(x3, xi, y2, yi, 32);
    }
    function vn(x3, xi, y2, yi, n2) {
      var i2, d2 = 0;
      for (i2 = 0; i2 < n2; ++i2) {
        d2 |= x3[xi + i2] ^ y2[yi + i2];
      }
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function par25519(a2) {
      var d2 = new NativeBuffer(32);
      pack25519(d2, a2);
      return d2[0] & 1;
    }
    function scalarmult(p3, q3, s2) {
      var b2, i2;
      set25519(p3[0], gf0);
      set25519(p3[1], gf1);
      set25519(p3[2], gf1);
      set25519(p3[3], gf0);
      for (i2 = 255; i2 >= 0; --i2) {
        b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p3, q3, b2);
        add2(q3, p3);
        add2(p3, p3);
        cswap(p3, q3, b2);
      }
    }
    function scalarbase(p3, s2) {
      var q3 = [gf(), gf(), gf(), gf()];
      set25519(q3[0], X3);
      set25519(q3[1], Y3);
      set25519(q3[2], gf1);
      M3(q3[3], X3, Y3);
      scalarmult(p3, q3, s2);
    }
    function set25519(r2, a2) {
      var i2;
      for (i2 = 0; i2 < 16; i2++) {
        r2[i2] = a2[i2] | 0;
      }
    }
    function inv25519(o2, i2) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 253; a2 >= 0; --a2) {
        S3(c2, c2);
        if (a2 !== 2 && a2 !== 4) {
          M3(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function car25519(o2) {
      var i2, v3, c2 = 1;
      for (i2 = 0; i2 < 16; ++i2) {
        v3 = o2[i2] + c2 + 65535;
        c2 = Math.floor(v3 / 65536);
        o2[i2] = v3 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p3, q3, b2) {
      var t2, c2 = ~(b2 - 1);
      for (var i2 = 0; i2 < 16; ++i2) {
        t2 = c2 & (p3[i2] ^ q3[i2]);
        p3[i2] ^= t2;
        q3[i2] ^= t2;
      }
    }
    function gf(init4) {
      var i2, r2 = new Float64Array(16);
      if (init4) {
        for (i2 = 0; i2 < init4.length; ++i2) {
          r2[i2] = init4[i2];
        }
      }
      return r2;
    }
    function A3(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] + b2[i2];
      }
    }
    function Z3(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] - b2[i2];
      }
    }
    function S3(o2, a2) {
      M3(o2, a2, a2);
    }
    function M3(o2, a2, b2) {
      var v3, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v3 = a2[0];
      t0 += v3 * b0;
      t1 += v3 * b1;
      t2 += v3 * b22;
      t3 += v3 * b3;
      t4 += v3 * b4;
      t5 += v3 * b5;
      t6 += v3 * b6;
      t7 += v3 * b7;
      t8 += v3 * b8;
      t9 += v3 * b9;
      t10 += v3 * b10;
      t11 += v3 * b11;
      t12 += v3 * b12;
      t13 += v3 * b13;
      t14 += v3 * b14;
      t15 += v3 * b15;
      v3 = a2[1];
      t1 += v3 * b0;
      t2 += v3 * b1;
      t3 += v3 * b22;
      t4 += v3 * b3;
      t5 += v3 * b4;
      t6 += v3 * b5;
      t7 += v3 * b6;
      t8 += v3 * b7;
      t9 += v3 * b8;
      t10 += v3 * b9;
      t11 += v3 * b10;
      t12 += v3 * b11;
      t13 += v3 * b12;
      t14 += v3 * b13;
      t15 += v3 * b14;
      t16 += v3 * b15;
      v3 = a2[2];
      t2 += v3 * b0;
      t3 += v3 * b1;
      t4 += v3 * b22;
      t5 += v3 * b3;
      t6 += v3 * b4;
      t7 += v3 * b5;
      t8 += v3 * b6;
      t9 += v3 * b7;
      t10 += v3 * b8;
      t11 += v3 * b9;
      t12 += v3 * b10;
      t13 += v3 * b11;
      t14 += v3 * b12;
      t15 += v3 * b13;
      t16 += v3 * b14;
      t17 += v3 * b15;
      v3 = a2[3];
      t3 += v3 * b0;
      t4 += v3 * b1;
      t5 += v3 * b22;
      t6 += v3 * b3;
      t7 += v3 * b4;
      t8 += v3 * b5;
      t9 += v3 * b6;
      t10 += v3 * b7;
      t11 += v3 * b8;
      t12 += v3 * b9;
      t13 += v3 * b10;
      t14 += v3 * b11;
      t15 += v3 * b12;
      t16 += v3 * b13;
      t17 += v3 * b14;
      t18 += v3 * b15;
      v3 = a2[4];
      t4 += v3 * b0;
      t5 += v3 * b1;
      t6 += v3 * b22;
      t7 += v3 * b3;
      t8 += v3 * b4;
      t9 += v3 * b5;
      t10 += v3 * b6;
      t11 += v3 * b7;
      t12 += v3 * b8;
      t13 += v3 * b9;
      t14 += v3 * b10;
      t15 += v3 * b11;
      t16 += v3 * b12;
      t17 += v3 * b13;
      t18 += v3 * b14;
      t19 += v3 * b15;
      v3 = a2[5];
      t5 += v3 * b0;
      t6 += v3 * b1;
      t7 += v3 * b22;
      t8 += v3 * b3;
      t9 += v3 * b4;
      t10 += v3 * b5;
      t11 += v3 * b6;
      t12 += v3 * b7;
      t13 += v3 * b8;
      t14 += v3 * b9;
      t15 += v3 * b10;
      t16 += v3 * b11;
      t17 += v3 * b12;
      t18 += v3 * b13;
      t19 += v3 * b14;
      t20 += v3 * b15;
      v3 = a2[6];
      t6 += v3 * b0;
      t7 += v3 * b1;
      t8 += v3 * b22;
      t9 += v3 * b3;
      t10 += v3 * b4;
      t11 += v3 * b5;
      t12 += v3 * b6;
      t13 += v3 * b7;
      t14 += v3 * b8;
      t15 += v3 * b9;
      t16 += v3 * b10;
      t17 += v3 * b11;
      t18 += v3 * b12;
      t19 += v3 * b13;
      t20 += v3 * b14;
      t21 += v3 * b15;
      v3 = a2[7];
      t7 += v3 * b0;
      t8 += v3 * b1;
      t9 += v3 * b22;
      t10 += v3 * b3;
      t11 += v3 * b4;
      t12 += v3 * b5;
      t13 += v3 * b6;
      t14 += v3 * b7;
      t15 += v3 * b8;
      t16 += v3 * b9;
      t17 += v3 * b10;
      t18 += v3 * b11;
      t19 += v3 * b12;
      t20 += v3 * b13;
      t21 += v3 * b14;
      t22 += v3 * b15;
      v3 = a2[8];
      t8 += v3 * b0;
      t9 += v3 * b1;
      t10 += v3 * b22;
      t11 += v3 * b3;
      t12 += v3 * b4;
      t13 += v3 * b5;
      t14 += v3 * b6;
      t15 += v3 * b7;
      t16 += v3 * b8;
      t17 += v3 * b9;
      t18 += v3 * b10;
      t19 += v3 * b11;
      t20 += v3 * b12;
      t21 += v3 * b13;
      t22 += v3 * b14;
      t23 += v3 * b15;
      v3 = a2[9];
      t9 += v3 * b0;
      t10 += v3 * b1;
      t11 += v3 * b22;
      t12 += v3 * b3;
      t13 += v3 * b4;
      t14 += v3 * b5;
      t15 += v3 * b6;
      t16 += v3 * b7;
      t17 += v3 * b8;
      t18 += v3 * b9;
      t19 += v3 * b10;
      t20 += v3 * b11;
      t21 += v3 * b12;
      t22 += v3 * b13;
      t23 += v3 * b14;
      t24 += v3 * b15;
      v3 = a2[10];
      t10 += v3 * b0;
      t11 += v3 * b1;
      t12 += v3 * b22;
      t13 += v3 * b3;
      t14 += v3 * b4;
      t15 += v3 * b5;
      t16 += v3 * b6;
      t17 += v3 * b7;
      t18 += v3 * b8;
      t19 += v3 * b9;
      t20 += v3 * b10;
      t21 += v3 * b11;
      t22 += v3 * b12;
      t23 += v3 * b13;
      t24 += v3 * b14;
      t25 += v3 * b15;
      v3 = a2[11];
      t11 += v3 * b0;
      t12 += v3 * b1;
      t13 += v3 * b22;
      t14 += v3 * b3;
      t15 += v3 * b4;
      t16 += v3 * b5;
      t17 += v3 * b6;
      t18 += v3 * b7;
      t19 += v3 * b8;
      t20 += v3 * b9;
      t21 += v3 * b10;
      t22 += v3 * b11;
      t23 += v3 * b12;
      t24 += v3 * b13;
      t25 += v3 * b14;
      t26 += v3 * b15;
      v3 = a2[12];
      t12 += v3 * b0;
      t13 += v3 * b1;
      t14 += v3 * b22;
      t15 += v3 * b3;
      t16 += v3 * b4;
      t17 += v3 * b5;
      t18 += v3 * b6;
      t19 += v3 * b7;
      t20 += v3 * b8;
      t21 += v3 * b9;
      t22 += v3 * b10;
      t23 += v3 * b11;
      t24 += v3 * b12;
      t25 += v3 * b13;
      t26 += v3 * b14;
      t27 += v3 * b15;
      v3 = a2[13];
      t13 += v3 * b0;
      t14 += v3 * b1;
      t15 += v3 * b22;
      t16 += v3 * b3;
      t17 += v3 * b4;
      t18 += v3 * b5;
      t19 += v3 * b6;
      t20 += v3 * b7;
      t21 += v3 * b8;
      t22 += v3 * b9;
      t23 += v3 * b10;
      t24 += v3 * b11;
      t25 += v3 * b12;
      t26 += v3 * b13;
      t27 += v3 * b14;
      t28 += v3 * b15;
      v3 = a2[14];
      t14 += v3 * b0;
      t15 += v3 * b1;
      t16 += v3 * b22;
      t17 += v3 * b3;
      t18 += v3 * b4;
      t19 += v3 * b5;
      t20 += v3 * b6;
      t21 += v3 * b7;
      t22 += v3 * b8;
      t23 += v3 * b9;
      t24 += v3 * b10;
      t25 += v3 * b11;
      t26 += v3 * b12;
      t27 += v3 * b13;
      t28 += v3 * b14;
      t29 += v3 * b15;
      v3 = a2[15];
      t15 += v3 * b0;
      t16 += v3 * b1;
      t17 += v3 * b22;
      t18 += v3 * b3;
      t19 += v3 * b4;
      t20 += v3 * b5;
      t21 += v3 * b6;
      t22 += v3 * b7;
      t23 += v3 * b8;
      t24 += v3 * b9;
      t25 += v3 * b10;
      t26 += v3 * b11;
      t27 += v3 * b12;
      t28 += v3 * b13;
      t29 += v3 * b14;
      t30 += v3 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v3 = t0 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t0 = v3 - c2 * 65536;
      v3 = t1 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t1 = v3 - c2 * 65536;
      v3 = t2 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t2 = v3 - c2 * 65536;
      v3 = t3 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t3 = v3 - c2 * 65536;
      v3 = t4 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t4 = v3 - c2 * 65536;
      v3 = t5 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t5 = v3 - c2 * 65536;
      v3 = t6 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t6 = v3 - c2 * 65536;
      v3 = t7 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t7 = v3 - c2 * 65536;
      v3 = t8 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t8 = v3 - c2 * 65536;
      v3 = t9 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t9 = v3 - c2 * 65536;
      v3 = t10 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t10 = v3 - c2 * 65536;
      v3 = t11 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t11 = v3 - c2 * 65536;
      v3 = t12 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t12 = v3 - c2 * 65536;
      v3 = t13 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t13 = v3 - c2 * 65536;
      v3 = t14 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t14 = v3 - c2 * 65536;
      v3 = t15 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t15 = v3 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v3 = t0 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t0 = v3 - c2 * 65536;
      v3 = t1 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t1 = v3 - c2 * 65536;
      v3 = t2 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t2 = v3 - c2 * 65536;
      v3 = t3 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t3 = v3 - c2 * 65536;
      v3 = t4 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t4 = v3 - c2 * 65536;
      v3 = t5 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t5 = v3 - c2 * 65536;
      v3 = t6 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t6 = v3 - c2 * 65536;
      v3 = t7 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t7 = v3 - c2 * 65536;
      v3 = t8 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t8 = v3 - c2 * 65536;
      v3 = t9 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t9 = v3 - c2 * 65536;
      v3 = t10 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t10 = v3 - c2 * 65536;
      v3 = t11 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t11 = v3 - c2 * 65536;
      v3 = t12 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t12 = v3 - c2 * 65536;
      v3 = t13 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t13 = v3 - c2 * 65536;
      v3 = t14 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t14 = v3 - c2 * 65536;
      v3 = t15 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t15 = v3 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t0;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
  }
});

// ../../node_modules/node-forge/lib/kem.js
var require_kem = __commonJS({
  "../../node_modules/node-forge/lib/kem.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_random();
    require_jsbn();
    module2.exports = forge2.kem = forge2.kem || {};
    var BigInteger = forge2.jsbn.BigInteger;
    forge2.kem.rsa = {};
    forge2.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge2.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r2;
        do {
          r2 = new BigInteger(
            forge2.util.bytesToHex(prng.getBytesSync(byteLength)),
            16
          ).mod(publicKey.n);
        } while (r2.compareTo(BigInteger.ONE) <= 0);
        r2 = forge2.util.hexToBytes(r2.toString(16));
        var zeros = byteLength - r2.length;
        if (zeros > 0) {
          r2 = forge2.util.fillString(String.fromCharCode(0), zeros) + r2;
        }
        var encapsulation = publicKey.encrypt(r2, "NONE");
        var key = kdf.generate(r2, keyLength);
        return { encapsulation, key };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r2 = privateKey.decrypt(encapsulation, "NONE");
        return kdf.generate(r2, keyLength);
      };
      return kem;
    };
    forge2.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge2.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x3, length) {
        var key = new forge2.util.ByteBuffer();
        var k2 = Math.ceil(length / digestLength) + counterStart;
        var c2 = new forge2.util.ByteBuffer();
        for (var i2 = counterStart; i2 < k2; ++i2) {
          c2.putInt32(i2);
          md.start();
          md.update(x3 + c2.getBytes());
          var hash = md.digest();
          key.putBytes(hash.getBytes(digestLength));
        }
        key.truncate(key.length() - length);
        return key.getBytes();
      };
    }
  }
});

// ../../node_modules/node-forge/lib/log.js
var require_log = __commonJS({
  "../../node_modules/node-forge/lib/log.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    module2.exports = forge2.log = forge2.log || {};
    forge2.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge2.log.LEVEL_LOCKED = 1 << 1;
    forge2.log.NO_LEVEL_CHECK = 1 << 2;
    forge2.log.INTERPOLATE = 1 << 3;
    for (i2 = 0; i2 < forge2.log.levels.length; ++i2) {
      level = forge2.log.levels[i2];
      sLevelInfo[level] = {
        index: i2,
        name: level.toUpperCase()
      };
    }
    var level;
    var i2;
    forge2.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i3 = 0; i3 < sLoggers.length; ++i3) {
        var logger3 = sLoggers[i3];
        if (logger3.flags & forge2.log.NO_LEVEL_CHECK) {
          logger3.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger3.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger3.f(logger3, message);
          }
        }
      }
    };
    forge2.log.prepareStandard = function(message) {
      if (!("standard" in message)) {
        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
        " [" + message.category + "] " + message.message;
      }
    };
    forge2.log.prepareFull = function(message) {
      if (!("full" in message)) {
        var args = [message.message];
        args = args.concat([]);
        message.full = forge2.util.format.apply(this, args);
      }
    };
    forge2.log.prepareStandardFull = function(message) {
      if (!("standardFull" in message)) {
        forge2.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i2 = 0; i2 < levels.length; ++i2) {
        (function(level2) {
          forge2.log[level2] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: /* @__PURE__ */ new Date(),
              level: level2,
              category,
              message,
              "arguments": args
              /*standard*/
              /*full*/
              /*fullMessage*/
            };
            forge2.log.logMessage(msg);
          };
        })(levels[i2]);
      }
    }
    var levels;
    var i2;
    forge2.log.makeLogger = function(logFunction) {
      var logger3 = {
        flags: 0,
        f: logFunction
      };
      forge2.log.setLevel(logger3, "none");
      return logger3;
    };
    forge2.log.setLevel = function(logger3, level2) {
      var rval = false;
      if (logger3 && !(logger3.flags & forge2.log.LEVEL_LOCKED)) {
        for (var i3 = 0; i3 < forge2.log.levels.length; ++i3) {
          var aValidLevel = forge2.log.levels[i3];
          if (level2 == aValidLevel) {
            logger3.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge2.log.lock = function(logger3, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger3.flags |= forge2.log.LEVEL_LOCKED;
      } else {
        logger3.flags &= ~forge2.log.LEVEL_LOCKED;
      }
    };
    forge2.log.addLogger = function(logger3) {
      sLoggers.push(logger3);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f3 = function(logger3, message) {
          forge2.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message["arguments"].slice());
          handler.apply(console, args);
        };
        logger2 = forge2.log.makeLogger(f3);
      } else {
        f3 = function(logger3, message) {
          forge2.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger2 = forge2.log.makeLogger(f3);
      }
      forge2.log.setLevel(logger2, "debug");
      forge2.log.addLogger(logger2);
      sConsoleLogger = logger2;
    } else {
      console = {
        log: function() {
        }
      };
    }
    var logger2;
    var levelHandlers;
    var f3;
    if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
      query = new URL(window.location.href).searchParams;
      if (query.has("console.level")) {
        forge2.log.setLevel(
          sConsoleLogger,
          query.get("console.level").slice(-1)[0]
        );
      }
      if (query.has("console.lock")) {
        lock = query.get("console.lock").slice(-1)[0];
        if (lock == "true") {
          forge2.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge2.log.consoleLogger = sConsoleLogger;
  }
});

// ../../node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS({
  "../../node_modules/node-forge/lib/md.all.js"(exports2, module2) {
    module2.exports = require_md();
    require_md5();
    require_sha1();
    require_sha256();
    require_sha512();
  }
});

// ../../node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "../../node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var p7 = module2.exports = forge2.pkcs7 = forge2.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge2.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge2.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge2.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge2.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i2 = 0; i2 < certs.length; ++i2) {
              msg.certificates.push(forge2.pki.certificateFromAsn1(certs[i2]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
            certs.push(forge2.pki.certificateToAsn1(msg.certificates[i2]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        },
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge2.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge2.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge2.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge2.pki.oids.sha1:
            case forge2.pki.oids.sha256:
            case forge2.pki.oids.sha384:
            case forge2.pki.oids.sha512:
            case forge2.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
              var attr = authenticatedAttributes[i2];
              if (!contentType && attr.type === forge2.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge2.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge2.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge2.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge2.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge2.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge2.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge2.md[forge2.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge2.md[forge2.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes = asn1.toDer(content);
        bytes.getByte();
        asn1.getBerValueLength(bytes);
        bytes = bytes.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes);
        }
        var signingTime = /* @__PURE__ */ new Date();
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge2.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge2.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge2.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge2.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge2.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var r2 = msg.recipients[i2];
            var rAttr = r2.issuer;
            if (r2.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j3 = 0; j3 < sAttr.length; ++j3) {
              if (rAttr[j3].type !== sAttr[j3].type || rAttr[j3].value !== sAttr[j3].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r2;
            }
          }
          return null;
        },
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge2.pki.oids.rsaEncryption:
              case forge2.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge2.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge2.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge2.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge2.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge2.util.createBuffer(forge2.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge2.util.createBuffer(
              forge2.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var recipient = msg.recipients[i2];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge2.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge2.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge2.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i2 = 0; i2 < infos.length; ++i2) {
        ret.push(_recipientFromAsn1(infos[i2]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i2 = 0; i2 < recipients.length; ++i2) {
        ret.push(_recipientToAsn1(recipients[i2]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
          var attr = obj.unauthenticatedAttributes[i2];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i2 = 0; i2 < signers.length; ++i2) {
        ret.push(_signerToAsn1(signers[i2]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge2.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge2.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge2.pki.oids.signingTime) {
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge2.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge2.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge2.util.isArray(capture.encryptedContent)) {
          for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
            if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i2].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge2.util.createBuffer(capture.encParameter.value),
          content: forge2.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge2.util.isArray(capture.content)) {
          for (var i2 = 0; i2 < capture.content.length; ++i2) {
            if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i2].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge2.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge2.pki.oids["aes128-CBC"]:
          case forge2.pki.oids["aes192-CBC"]:
          case forge2.pki.oids["aes256-CBC"]:
            ciph = forge2.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge2.pki.oids["desCBC"]:
          case forge2.pki.oids["des-EDE3-CBC"]:
            ciph = forge2.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS({
  "../../node_modules/node-forge/lib/ssh.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_hmac();
    require_md5();
    require_sha1();
    require_util();
    var ssh = module2.exports = forge2.ssh = forge2.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment + "\r\n";
      var pubbuffer = forge2.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge2.util.encode64(pubbuffer.bytes(), 64);
      var length = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length + "\r\n";
      ppk += pub;
      var privbuffer = forge2.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge2.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge2.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge2.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge2.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge2.util.encode64(encrypted.bytes(), 64);
      }
      length = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge2.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge2.hmac.create();
      hmac.start("sha1", mackey);
      hmac.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment) {
      var type = "ssh-rsa";
      comment = comment || "";
      var buffer = forge2.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      return type + " " + forge2.util.encode64(buffer.bytes()) + " " + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge2.pki.privateKeyToPem(privateKey);
      }
      return forge2.pki.encryptRsaPrivateKey(
        privateKey,
        passphrase,
        { legacy: true, algorithm: "aes128" }
      );
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge2.md.md5.create();
      var type = "ssh-rsa";
      var buffer = forge2.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      md.start();
      md.update(buffer.getBytes());
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes = forge2.util.hexToBytes(hexVal);
      buffer.putInt32(bytes.length);
      buffer.putBytes(bytes);
    }
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    function _sha1() {
      var sha = forge2.md.sha1.create();
      var num = arguments.length;
      for (var i2 = 0; i2 < num; ++i2) {
        sha.update(arguments[i2]);
      }
      return sha.digest();
    }
  }
});

// ../../node_modules/node-forge/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/node-forge/lib/index.js"(exports2, module2) {
    module2.exports = require_forge();
    require_aes();
    require_aesCipherSuites();
    require_asn1();
    require_cipher();
    require_des();
    require_ed25519();
    require_hmac();
    require_kem();
    require_log();
    require_md_all();
    require_mgf1();
    require_pbkdf2();
    require_pem();
    require_pkcs1();
    require_pkcs12();
    require_pkcs7();
    require_pki();
    require_prime();
    require_prng();
    require_pss();
    require_random();
    require_rc2();
    require_ssh();
    require_tls();
    require_util();
  }
});

// src/account/crypt.ts
var import_hkdf, import_node_forge;
var init_crypt = __esm({
  "src/account/crypt.ts"() {
    "use strict";
    import_hkdf = __toESM(require_hkdf2());
    import_node_forge = __toESM(require_lib2());
  }
});

// src/utils/vault.ts
var init_vault = __esm({
  "src/utils/vault.ts"() {
    "use strict";
    init_constants();
    init_models();
  }
});

// src/models/environment.ts
var import_json_order;
var init_environment = __esm({
  "src/models/environment.ts"() {
    "use strict";
    import_json_order = __toESM(require_dist());
    init_crypt();
    init_constants();
    init_database();
    init_misc();
    init_vault();
    init_models();
  }
});

// src/models/git-credentials.ts
var init_git_credentials = __esm({
  "src/models/git-credentials.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/git-repository.ts
var init_git_repository = __esm({
  "src/models/git-repository.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/grpc-request.ts
var init_grpc_request = __esm({
  "src/models/grpc-request.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/grpc-request-meta.ts
var init_grpc_request_meta = __esm({
  "src/models/grpc-request-meta.ts"() {
    "use strict";
    init_database();
    init_grpc_request();
  }
});

// src/utils/invariant.ts
function invariant(condition, message) {
  if (condition) {
    return;
  }
  throw new Error(typeof message === "function" ? message() : message);
}
var init_invariant = __esm({
  "src/utils/invariant.ts"() {
    "use strict";
  }
});

// src/models/mcp-request.ts
var TRANSPORT_TYPES, MCP_TRANSPORT_TYPES;
var init_mcp_request = __esm({
  "src/models/mcp-request.ts"() {
    "use strict";
    init_invariant();
    init_database();
    init_environment();
    TRANSPORT_TYPES = {
      STDIO: "stdio",
      HTTP: "streamable-http"
    };
    MCP_TRANSPORT_TYPES = [TRANSPORT_TYPES.HTTP, TRANSPORT_TYPES.STDIO];
  }
});

// src/models/mcp-request-payload.ts
var init_mcp_request_payload = __esm({
  "src/models/mcp-request-payload.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/socket-io-request.ts
var init_socket_io_request = __esm({
  "src/models/socket-io-request.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/websocket-request.ts
var init_websocket_request = __esm({
  "src/models/websocket-request.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/helpers/request-operations.ts
var init_request_operations = __esm({
  "src/models/helpers/request-operations.ts"() {
    "use strict";
    init_grpc_request();
    init_models();
    init_mcp_request();
    init_socket_io_request();
    init_websocket_request();
  }
});

// src/models/mcp-response.ts
var init_mcp_response = __esm({
  "src/models/mcp-response.ts"() {
    "use strict";
    init_database();
    init_request_operations();
    init_models();
    init_mcp_request();
  }
});

// src/models/mock-route.ts
var init_mock_route = __esm({
  "src/models/mock-route.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/mock-server.ts
var init_mock_server = __esm({
  "src/models/mock-server.ts"() {
    "use strict";
    init_database();
    init_models();
  }
});

// src/models/o-auth-2-token.ts
var init_o_auth_2_token = __esm({
  "src/models/o-auth-2-token.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/plugin-data.ts
var init_plugin_data = __esm({
  "src/models/plugin-data.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/project.ts
var prefix, SCRATCHPAD_PROJECT_ID;
var init_project = __esm({
  "src/models/project.ts"() {
    "use strict";
    init_database();
    init_misc();
    init_models();
    prefix = "proj";
    SCRATCHPAD_PROJECT_ID = `${prefix}_scratchpad`;
  }
});

// src/models/proto-directory.ts
var init_proto_directory = __esm({
  "src/models/proto-directory.ts"() {
    "use strict";
    init_database();
    init_misc();
  }
});

// src/models/proto-file.ts
var init_proto_file = __esm({
  "src/models/proto-file.ts"() {
    "use strict";
    init_database();
  }
});

// src/utils/graph-ql.ts
var init_graph_ql = __esm({
  "src/utils/graph-ql.ts"() {
    "use strict";
    init_constants();
  }
});

// src/utils/url/protocol.ts
var setDefaultProtocol;
var init_protocol = __esm({
  "src/utils/url/protocol.ts"() {
    "use strict";
    setDefaultProtocol = (url, defaultProto) => {
      const trimmedUrl = url.trim();
      defaultProto = defaultProto || "http:";
      if (!trimmedUrl) {
        return "";
      }
      if (!trimmedUrl.includes("://")) {
        return `${defaultProto}//${trimmedUrl}`;
      }
      return trimmedUrl;
    };
  }
});

// src/utils/url/querystring.ts
var RFC_3986_GENERAL_DELIMITERS, RFC_3986_SUB_DELIMITERS, URL_PATH_CHARACTER_WHITELIST;
var init_querystring = __esm({
  "src/utils/url/querystring.ts"() {
    "use strict";
    init_protocol();
    RFC_3986_GENERAL_DELIMITERS = ":@";
    RFC_3986_SUB_DELIMITERS = "$+,;=";
    URL_PATH_CHARACTER_WHITELIST = `${RFC_3986_GENERAL_DELIMITERS}${RFC_3986_SUB_DELIMITERS}`;
  }
});

// src/models/request.ts
var init_request = __esm({
  "src/models/request.ts"() {
    "use strict";
    init_constants();
    init_database();
    init_graph_ql();
    init_querystring();
  }
});

// src/models/request-group.ts
var init_request_group = __esm({
  "src/models/request-group.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/request-group-meta.ts
var init_request_group_meta = __esm({
  "src/models/request-group-meta.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/request-meta.ts
var init_request_meta = __esm({
  "src/models/request-meta.ts"() {
    "use strict";
    init_constants();
    init_database();
  }
});

// ../../node_modules/deep-equal/index.js
var require_deep_equal2 = __commonJS({
  "../../node_modules/deep-equal/index.js"(exports2, module2) {
    var objectKeys = require_object_keys();
    var isArguments2 = require_is_arguments();
    var is = require_object_is();
    var isRegex = require_is_regex();
    var flags = require_regexp_prototype();
    var isDate4 = require_is_date_object();
    var getTime = Date.prototype.getTime;
    function deepEqual2(actual, expected, options) {
      var opts = options || {};
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is(actual, expected) : actual == expected;
      }
      return objEquiv(actual, expected, opts);
    }
    function isUndefinedOrNull(value) {
      return value === null || value === void 0;
    }
    function isBuffer3(x3) {
      if (!x3 || typeof x3 !== "object" || typeof x3.length !== "number") {
        return false;
      }
      if (typeof x3.copy !== "function" || typeof x3.slice !== "function") {
        return false;
      }
      if (x3.length > 0 && typeof x3[0] !== "number") {
        return false;
      }
      return true;
    }
    function objEquiv(a2, b2, opts) {
      var i2, key;
      if (typeof a2 !== typeof b2) {
        return false;
      }
      if (isUndefinedOrNull(a2) || isUndefinedOrNull(b2)) {
        return false;
      }
      if (a2.prototype !== b2.prototype) {
        return false;
      }
      if (isArguments2(a2) !== isArguments2(b2)) {
        return false;
      }
      var aIsRegex = isRegex(a2);
      var bIsRegex = isRegex(b2);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if (aIsRegex || bIsRegex) {
        return a2.source === b2.source && flags(a2) === flags(b2);
      }
      if (isDate4(a2) && isDate4(b2)) {
        return getTime.call(a2) === getTime.call(b2);
      }
      var aIsBuffer = isBuffer3(a2);
      var bIsBuffer = isBuffer3(b2);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a2.length !== b2.length) {
          return false;
        }
        for (i2 = 0; i2 < a2.length; i2++) {
          if (a2[i2] !== b2[i2]) {
            return false;
          }
        }
        return true;
      }
      if (typeof a2 !== typeof b2) {
        return false;
      }
      try {
        var ka2 = objectKeys(a2);
        var kb = objectKeys(b2);
      } catch (e2) {
        return false;
      }
      if (ka2.length !== kb.length) {
        return false;
      }
      ka2.sort();
      kb.sort();
      for (i2 = ka2.length - 1; i2 >= 0; i2--) {
        if (ka2[i2] != kb[i2]) {
          return false;
        }
      }
      for (i2 = ka2.length - 1; i2 >= 0; i2--) {
        key = ka2[i2];
        if (!deepEqual2(a2[key], b2[key], opts)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = deepEqual2;
  }
});

// src/models/request-version.ts
var import_deep_equal2;
var init_request_version = __esm({
  "src/models/request-version.ts"() {
    "use strict";
    import_deep_equal2 = __toESM(require_deep_equal2());
    init_database();
    init_misc();
    init_request_operations();
    init_mcp_request();
    init_request();
    init_socket_io_request();
    init_websocket_request();
  }
});

// src/utils/ndjson.ts
var init_ndjson = __esm({
  "src/utils/ndjson.ts"() {
    "use strict";
  }
});

// src/models/response.ts
var import_node_fs, import_node_zlib, readCurlResponse, getBodyBuffer;
var init_response = __esm({
  "src/models/response.ts"() {
    "use strict";
    import_node_fs = __toESM(require("node:fs"));
    import_node_zlib = __toESM(require("node:zlib"));
    init_database();
    init_request_operations();
    init_ndjson();
    init_models();
    readCurlResponse = async (options) => {
      const readFailureMsg = "[main/curlBridgeAPI] failed to read response body message";
      const bodyBufferOrErrMsg = await getBodyBuffer(options, readFailureMsg);
      if (!bodyBufferOrErrMsg) {
        return { body: "", error: readFailureMsg };
      } else if (typeof bodyBufferOrErrMsg === "string") {
        if (bodyBufferOrErrMsg === readFailureMsg) {
          return { body: "", error: readFailureMsg };
        }
        return { body: "", error: `unknown error in loading response body: ${bodyBufferOrErrMsg}` };
      }
      return { body: bodyBufferOrErrMsg.toString("utf8"), error: "" };
    };
    getBodyBuffer = async (response, readFailureValue) => {
      if (!response?.bodyPath) {
        return Buffer.alloc(0);
      }
      try {
        const rawBuffer = await import_node_fs.default.promises.readFile(response?.bodyPath);
        if (response?.bodyCompression === "zip") {
          return new Promise(
            (resolve, reject2) => import_node_zlib.default.gunzip(rawBuffer, (err, buffer) => err ? reject2(err) : resolve(buffer))
          );
        }
        return rawBuffer;
      } catch (err) {
        console.warn("Failed to read response body", err.message);
        return readFailureValue === void 0 ? Buffer.alloc(0) : readFailureValue;
      }
    };
  }
});

// src/models/runner-test-result.ts
var init_runner_test_result = __esm({
  "src/models/runner-test-result.ts"() {
    "use strict";
    init_database();
  }
});

// src/common/keyboard-keys.ts
var keyboardKeys;
var init_keyboard_keys = __esm({
  "src/common/keyboard-keys.ts"() {
    "use strict";
    keyboardKeys = {
      backspace: {
        keyCode: 8,
        code: "Backspace",
        label: "Backspace"
      },
      tab: {
        keyCode: 9,
        code: "Tab",
        label: "Tab"
      },
      enter: {
        keyCode: 13,
        code: "Enter",
        label: "Enter"
      },
      shift: {
        keyCode: 16,
        code: "Shift",
        label: "Shift"
      },
      ctrl: {
        keyCode: 17,
        code: "Control",
        label: "Ctrl"
      },
      alt: {
        keyCode: 18,
        code: "Alt",
        label: "Alt"
      },
      pausebreak: {
        keyCode: 19,
        code: "Pause",
        label: "PauseBreak"
      },
      capslock: {
        keyCode: 20,
        code: "CapsLock",
        label: "CapsLock"
      },
      esc: {
        keyCode: 27,
        code: "Escape",
        label: "Escape"
      },
      space: {
        keyCode: 32,
        code: "Space",
        label: "Space"
      },
      pageup: {
        keyCode: 33,
        code: "PageUp",
        label: "PageUp"
      },
      pagedown: {
        keyCode: 34,
        code: "PageDown",
        label: "PageDown"
      },
      end: {
        keyCode: 35,
        code: "End",
        label: "End"
      },
      home: {
        keyCode: 36,
        code: "Home",
        label: "Home"
      },
      leftarrow: {
        keyCode: 37,
        code: "ArrowLeft",
        label: "Left"
      },
      uparrow: {
        keyCode: 38,
        code: "ArrowUp",
        label: "Up"
      },
      rightarrow: {
        keyCode: 39,
        code: "ArrowRight",
        label: "Right"
      },
      downarrow: {
        keyCode: 40,
        code: "ArrowDown",
        label: "Down"
      },
      insert: {
        keyCode: 45,
        code: "Numpad0",
        label: "Insert"
      },
      delete: {
        keyCode: 46,
        code: "Delete",
        label: "Delete"
      },
      num0: {
        keyCode: 48,
        code: "Digit0",
        label: "0"
      },
      num1: {
        keyCode: 49,
        code: "Digit1",
        label: "1"
      },
      num2: {
        keyCode: 50,
        code: "Digit2",
        label: "2"
      },
      num3: {
        keyCode: 51,
        code: "Digit3",
        label: "3"
      },
      num4: {
        keyCode: 52,
        code: "Digit4",
        label: "4"
      },
      num5: {
        keyCode: 53,
        code: "Digit5",
        label: "5"
      },
      num6: {
        keyCode: 54,
        code: "Digit6",
        label: "6"
      },
      num7: {
        keyCode: 55,
        code: "Digit7",
        label: "7"
      },
      num8: {
        keyCode: 56,
        code: "Digit8",
        label: "8"
      },
      num9: {
        keyCode: 57,
        code: "Digit9",
        label: "9"
      },
      a: {
        keyCode: 65,
        code: "KeyA",
        label: "A"
      },
      b: {
        keyCode: 66,
        code: "KeyB",
        label: "B"
      },
      c: {
        keyCode: 67,
        code: "KeyC",
        label: "C"
      },
      d: {
        keyCode: 68,
        code: "KeyD",
        label: "D"
      },
      e: {
        keyCode: 69,
        code: "KeyE",
        label: "E"
      },
      f: {
        keyCode: 70,
        code: "KeyF",
        label: "F"
      },
      g: {
        keyCode: 71,
        code: "KeyG",
        label: "G"
      },
      h: {
        keyCode: 72,
        code: "KeyH",
        label: "H"
      },
      i: {
        keyCode: 73,
        code: "KeyI",
        label: "I"
      },
      j: {
        keyCode: 74,
        code: "KeyJ",
        label: "J"
      },
      k: {
        keyCode: 75,
        code: "KeyK",
        label: "K"
      },
      l: {
        keyCode: 76,
        code: "KeyL",
        label: "L"
      },
      m: {
        keyCode: 77,
        code: "KeyM",
        label: "M"
      },
      n: {
        keyCode: 78,
        code: "KeyN",
        label: "N"
      },
      o: {
        keyCode: 79,
        code: "KeyO",
        label: "O"
      },
      p: {
        keyCode: 80,
        code: "KeyP",
        label: "P"
      },
      q: {
        keyCode: 81,
        code: "KeyQ",
        label: "Q"
      },
      r: {
        keyCode: 82,
        code: "KeyR",
        label: "R"
      },
      s: {
        keyCode: 83,
        code: "KeyS",
        label: "S"
      },
      t: {
        keyCode: 84,
        code: "KeyT",
        label: "T"
      },
      u: {
        keyCode: 85,
        code: "KeyU",
        label: "U"
      },
      v: {
        keyCode: 86,
        code: "KeyV",
        label: "V"
      },
      w: {
        keyCode: 87,
        code: "KeyW",
        label: "W"
      },
      x: {
        keyCode: 88,
        code: "KeyX",
        label: "X"
      },
      y: {
        keyCode: 89,
        code: "KeyY",
        label: "Y"
      },
      z: {
        keyCode: 90,
        code: "KeyZ",
        label: "Z"
      },
      leftwindowkey: {
        keyCode: 91,
        code: "MetaLeft",
        label: "LeftWindow"
      },
      rightwindowkey: {
        keyCode: 92,
        code: "MetaRight",
        label: "RightWindow"
      },
      selectkey: {
        keyCode: 93,
        code: "ContextMenu",
        label: "Select"
      },
      numpad0: {
        keyCode: 96,
        code: "Numpad0",
        label: "NumPad0"
      },
      numpad1: {
        keyCode: 97,
        code: "Numpad1",
        label: "NumPad1"
      },
      numpad2: {
        keyCode: 98,
        code: "Numpad2",
        label: "NumPad2"
      },
      numpad3: {
        keyCode: 99,
        code: "Numpad3",
        label: "NumPad3"
      },
      numpad4: {
        keyCode: 100,
        code: "Numpad4",
        label: "NumPad4"
      },
      numpad5: {
        keyCode: 101,
        code: "Numpad5",
        label: "NumPad5"
      },
      numpad6: {
        keyCode: 102,
        code: "Numpad6",
        label: "NumPad6"
      },
      numpad7: {
        keyCode: 103,
        code: "Numpad7",
        label: "NumPad7"
      },
      numpad8: {
        keyCode: 104,
        code: "Numpad8",
        label: "NumPad8"
      },
      numpad9: {
        keyCode: 105,
        code: "Numpad9",
        label: "NumPad9"
      },
      multiply: {
        keyCode: 106,
        code: "NumpadMultiply",
        label: "NumPad_Multiply"
      },
      add: {
        keyCode: 107,
        code: "NumpadAdd",
        label: "NumPad_Add"
      },
      separator: {
        keyCode: 108,
        code: "NumpadDecimal",
        label: "NumPad_Separator"
      },
      subtract: {
        keyCode: 109,
        code: "NumpadSubtract",
        label: "NumPad_Subtract"
      },
      decimalpoint: {
        keyCode: 110,
        code: "NumpadDecimal",
        label: "NumPad_Decimal"
      },
      divide: {
        keyCode: 111,
        code: "NumpadDivide",
        label: "NumPad_Divide"
      },
      f1: {
        keyCode: 112,
        code: "F1",
        label: "F1"
      },
      f2: {
        keyCode: 113,
        code: "F2",
        label: "F2"
      },
      f3: {
        keyCode: 114,
        code: "F3",
        label: "F3"
      },
      f4: {
        keyCode: 115,
        code: "F4",
        label: "F4"
      },
      f5: {
        keyCode: 116,
        code: "F5",
        label: "F5"
      },
      f6: {
        keyCode: 117,
        code: "F6",
        label: "F6"
      },
      f7: {
        keyCode: 118,
        code: "F7",
        label: "F7"
      },
      f8: {
        keyCode: 119,
        code: "F8",
        label: "F8"
      },
      f9: {
        keyCode: 120,
        code: "F9",
        label: "F9"
      },
      f10: {
        keyCode: 121,
        code: "F10",
        label: "F10"
      },
      f11: {
        keyCode: 122,
        code: "F11",
        label: "F11"
      },
      f12: {
        keyCode: 123,
        code: "F12",
        label: "F12"
      },
      numlock: {
        keyCode: 144,
        code: "NumLock",
        label: "NumLock"
      },
      scrolllock: {
        keyCode: 145,
        code: "ScrollLock",
        label: "ScrollLock"
      },
      semicolon: {
        keyCode: 186,
        code: "Semicolon",
        label: ";"
      },
      equalsign: {
        keyCode: 187,
        code: "Equal",
        label: "="
      },
      comma: {
        keyCode: 188,
        code: "Comma",
        label: ","
      },
      dash: {
        keyCode: 189,
        code: "Minus",
        label: "-"
      },
      period: {
        keyCode: 190,
        code: "Period",
        label: "."
      },
      forwardslash: {
        keyCode: 191,
        code: "Slash",
        label: "/"
      },
      graveaccent: {
        keyCode: 192,
        code: "IntlBackslash",
        label: "`"
      },
      openbracket: {
        keyCode: 219,
        code: "BracketLeft",
        label: "["
      },
      backslash: {
        keyCode: 220,
        code: "Backslash",
        label: "\\"
      },
      closebracket: {
        keyCode: 221,
        code: "BracketRight",
        label: "]"
      },
      singlequote: {
        keyCode: 222,
        code: "Quote",
        label: "'"
      }
    };
  }
});

// src/common/hotkeys.ts
var keyboardShortcutDescriptions, defaultRegistry;
var init_hotkeys = __esm({
  "src/common/hotkeys.ts"() {
    "use strict";
    init_constants();
    init_keyboard_keys();
    init_strings();
    keyboardShortcutDescriptions = {
      workspace_showSettings: `Show ${strings.document.singular} / ${strings.collection.singular} Settings`,
      request_showSettings: "Show Request Settings",
      preferences_showKeyboardShortcuts: "Show Keyboard Shortcuts",
      preferences_showGeneral: "Show App Preferences",
      request_quickSwitch: "Quick search",
      plugin_reload: "Reload Plugins",
      showAutocomplete: "Show Autocomplete",
      request_send: "Send Request",
      request_showOptions: "Send Request (Options)",
      environment_showEditor: "Show Environment Editor",
      environment_showSwitchMenu: "Switch Environments",
      request_toggleHttpMethodMenu: "Change HTTP Method",
      request_toggleHistory: "Show Request History",
      request_focusUrl: "Focus URL",
      request_showGenerateCodeEditor: "Generate Code",
      sidebar_focusFilter: "Filter Sidebar",
      sidebar_toggle: "Toggle Sidebar",
      response_focus: "Focus Response",
      showCookiesEditor: "Edit Cookies",
      request_createHTTP: "Create HTTP Request",
      request_showDelete: "Delete Request",
      request_showCreateFolder: "Create Folder",
      request_showDuplicate: "Duplicate Request",
      request_togglePin: "Pin/Unpin Request",
      environment_showVariableSourceAndValue: "Show variable source and value",
      beautifyRequestBody: "Beautify Active Code Editors",
      graphql_explorer_focus_filter: "Focus GraphQL Explorer Filter",
      close_tab: "Close Tab"
    };
    defaultRegistry = {
      workspace_showSettings: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.comma.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.comma.keyCode }]
      },
      request_showSettings: {
        macKeys: [{ alt: true, shift: true, meta: true, keyCode: keyboardKeys.comma.keyCode }],
        winLinuxKeys: [{ ctrl: true, alt: true, shift: true, keyCode: keyboardKeys.comma.keyCode }]
      },
      preferences_showKeyboardShortcuts: {
        macKeys: [{ ctrl: true, shift: true, meta: true, keyCode: keyboardKeys.forwardslash.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.forwardslash.keyCode }]
      },
      preferences_showGeneral: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.comma.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.comma.keyCode }]
      },
      request_quickSwitch: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.p.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.p.keyCode }]
      },
      plugin_reload: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.r.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.r.keyCode }]
      },
      showAutocomplete: {
        macKeys: [{ ctrl: true, keyCode: keyboardKeys.space.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.space.keyCode }]
      },
      request_send: {
        macKeys: [
          { meta: true, keyCode: keyboardKeys.enter.keyCode },
          { meta: true, keyCode: keyboardKeys.r.keyCode },
          { keyCode: keyboardKeys.f5.keyCode }
        ],
        winLinuxKeys: [
          { ctrl: true, keyCode: keyboardKeys.enter.keyCode },
          { ctrl: true, keyCode: keyboardKeys.r.keyCode },
          { keyCode: keyboardKeys.f5.keyCode }
        ]
      },
      request_showOptions: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.enter.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.enter.keyCode }]
      },
      environment_showEditor: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.e.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.e.keyCode }]
      },
      environment_showSwitchMenu: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.e.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.e.keyCode }]
      },
      request_toggleHttpMethodMenu: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.l.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.l.keyCode }]
      },
      request_toggleHistory: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.h.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.h.keyCode }]
      },
      request_focusUrl: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.l.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.l.keyCode }]
      },
      request_showGenerateCodeEditor: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.g.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.g.keyCode }]
      },
      sidebar_focusFilter: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.f.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.f.keyCode }]
      },
      sidebar_toggle: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.backslash.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.backslash.keyCode }]
      },
      response_focus: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.singlequote.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.singlequote.keyCode }]
      },
      showCookiesEditor: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.k.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.k.keyCode }]
      },
      request_createHTTP: {
        macKeys: [
          { meta: true, keyCode: keyboardKeys.n.keyCode },
          { alt: true, meta: true, keyCode: keyboardKeys.n.keyCode }
        ],
        winLinuxKeys: [
          { ctrl: true, keyCode: keyboardKeys.n.keyCode },
          { ctrl: true, alt: true, keyCode: keyboardKeys.n.keyCode }
        ]
      },
      request_showDelete: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.backspace.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.backspace.keyCode }]
      },
      request_showCreateFolder: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.n.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.n.keyCode }]
      },
      request_showDuplicate: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.d.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.d.keyCode }]
      },
      request_togglePin: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.p.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.p.keyCode }]
      },
      environment_showVariableSourceAndValue: {
        macKeys: [{ alt: true, shift: true, keyCode: keyboardKeys.u.keyCode }],
        winLinuxKeys: [{ alt: true, shift: true, keyCode: keyboardKeys.u.keyCode }]
      },
      beautifyRequestBody: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.f.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.f.keyCode }]
      },
      graphql_explorer_focus_filter: {
        macKeys: [{ shift: true, meta: true, keyCode: keyboardKeys.i.keyCode }],
        winLinuxKeys: [{ ctrl: true, shift: true, keyCode: keyboardKeys.i.keyCode }]
      },
      close_tab: {
        macKeys: [{ meta: true, keyCode: keyboardKeys.w.keyCode }],
        winLinuxKeys: [{ ctrl: true, keyCode: keyboardKeys.w.keyCode }]
      }
    };
  }
});

// src/common/settings.ts
var init_settings = __esm({
  "src/common/settings.ts"() {
    "use strict";
  }
});

// src/models/settings.ts
var forceVerticalLayout;
var init_settings2 = __esm({
  "src/models/settings.ts"() {
    "use strict";
    init_constants();
    init_database();
    init_hotkeys();
    init_settings();
    forceVerticalLayout = process.env.PLAYWRIGHT ? true : false;
  }
});

// src/models/socket-io-payload.ts
var init_socket_io_payload = __esm({
  "src/models/socket-io-payload.ts"() {
    "use strict";
    init_constants();
    init_database();
  }
});

// src/models/socket-io-response.ts
var init_socket_io_response = __esm({
  "src/models/socket-io-response.ts"() {
    "use strict";
    init_database();
    init_request_operations();
    init_models();
  }
});

// src/models/stats.ts
var init_stats = __esm({
  "src/models/stats.ts"() {
    "use strict";
    init_database();
    init_grpc_request();
    init_models();
    init_request();
    init_socket_io_request();
    init_websocket_request();
  }
});

// src/models/unit-test.ts
var init_unit_test = __esm({
  "src/models/unit-test.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/unit-test-result.ts
var init_unit_test_result = __esm({
  "src/models/unit-test-result.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/unit-test-suite.ts
var init_unit_test_suite = __esm({
  "src/models/unit-test-suite.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/user-session.ts
var init_user_session = __esm({
  "src/models/user-session.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/websocket-payload.ts
var init_websocket_payload = __esm({
  "src/models/websocket-payload.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/websocket-response.ts
var init_websocket_response = __esm({
  "src/models/websocket-response.ts"() {
    "use strict";
    init_database();
    init_request_operations();
    init_models();
  }
});

// src/models/workspace.ts
var init_workspace = __esm({
  "src/models/workspace.ts"() {
    "use strict";
    init_database();
    init_strings();
    init_models();
    init_project();
  }
});

// src/models/workspace-meta.ts
var init_workspace_meta = __esm({
  "src/models/workspace-meta.ts"() {
    "use strict";
    init_database();
  }
});

// src/models/organization.ts
var init_organization = __esm({
  "src/models/organization.ts"() {
    "use strict";
  }
});

// src/models/index.ts
var init_models = __esm({
  "src/models/index.ts"() {
    "use strict";
    init_misc();
    init_utils();
    init_api_spec();
    init_ca_certificate();
    init_client_certificate();
    init_cloud_credential();
    init_cookie_jar();
    init_environment();
    init_git_credentials();
    init_git_repository();
    init_grpc_request();
    init_grpc_request_meta();
    init_mcp_request();
    init_mcp_request_payload();
    init_mcp_response();
    init_mock_route();
    init_mock_server();
    init_o_auth_2_token();
    init_plugin_data();
    init_project();
    init_proto_directory();
    init_proto_file();
    init_request();
    init_request_group();
    init_request_group_meta();
    init_request_meta();
    init_request_version();
    init_response();
    init_runner_test_result();
    init_settings2();
    init_socket_io_payload();
    init_socket_io_request();
    init_socket_io_response();
    init_stats();
    init_unit_test();
    init_unit_test_result();
    init_unit_test_suite();
    init_user_session();
    init_websocket_payload();
    init_websocket_request();
    init_websocket_response();
    init_workspace();
    init_workspace_meta();
    init_organization();
  }
});

// src/common/database.ts
var import_nedb, import_electron;
var init_database = __esm({
  "src/common/database.ts"() {
    "use strict";
    import_nedb = __toESM(require_nedb());
    import_electron = __toESM(require("electron"));
    init_models();
    init_environment();
    init_models();
    init_misc();
  }
});

// src/models/client-certificate.ts
function init3() {
  return {
    parentId: "",
    host: "",
    passphrase: null,
    disabled: false,
    cert: null,
    key: null,
    pfx: null,
    isPrivate: false
  };
}
var init_client_certificate = __esm({
  "src/models/client-certificate.ts"() {
    "use strict";
    init_database();
  }
});

// ../../node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "../../node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports2.IDENTIFIER.test(s2))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c2) => {
          if (c2 instanceof Name)
            names[c2.str] = (names[c2.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _2(strs, ...args) {
      const code = [strs[0]];
      let i2 = 0;
      while (i2 < args.length) {
        addCodeArg(code, args[i2]);
        code.push(strs[++i2]);
      }
      return new _Code(code);
    }
    exports2._ = _2;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i2 = 0;
      while (i2 < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i2]);
        expr.push(plus, safeStringify(strs[++i2]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i2 = 1;
      while (i2 < expr.length - 1) {
        if (expr[i2] === plus) {
          const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
          if (res !== void 0) {
            expr.splice(i2 - 1, 3, res);
            continue;
          }
          expr[i2++] = "+";
        }
        i2++;
      }
    }
    function mergeExprItems(a2, b2) {
      if (b2 === '""')
        return a2;
      if (a2 === '""')
        return b2;
      if (typeof a2 == "string") {
        if (b2 instanceof Name || a2[a2.length - 1] !== '"')
          return;
        if (typeof b2 != "string")
          return `${a2.slice(0, -1)}${b2}"`;
        if (b2[0] === '"')
          return a2.slice(0, -1) + b2.slice(1);
        return;
      }
      if (typeof b2 == "string" && b2[0] === '"' && !(a2 instanceof Name))
        return `"${a2}${b2.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x3) {
      return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
    }
    function stringify(x3) {
      return new _Code(safeStringify(x3));
    }
    exports2.stringify = stringify;
    function safeStringify(x3) {
      return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// ../../node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "../../node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope2 = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix2) {
        return new code_1.Name(this._newName(prefix2));
      }
      _newName(prefix2) {
        const ng = this._names[prefix2] || this._nameGroup(prefix2);
        return `${prefix2}${ng.index++}`;
      }
      _nameGroup(prefix2) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix2)) || this._prefixes && !this._prefixes.has(prefix2)) {
          throw new Error(`CodeGen: prefix "${prefix2}" is not allowed in this scope`);
        }
        return this._names[prefix2] = { prefix: prefix2, index: 0 };
      }
    };
    exports2.Scope = Scope2;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix2, nameStr) {
        super(nameStr);
        this.prefix = prefix2;
      }
      setValue(value, { property: property2, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property2)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope2 {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix2) {
        return new ValueScopeName(prefix2, this._newName(prefix2));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix: prefix2 } = name;
        const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
        let vs = this._values[prefix2];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix2] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s2 = this._scope[prefix2] || (this._scope[prefix2] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name.setValue(value, { property: prefix2, itemIndex });
        return name;
      }
      getValue(prefix2, keyOrRef) {
        const vs = this._values[prefix2];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values2 = this._values) {
        return this._reduceValues(values2, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values2 = this._values, usedValues, getCode) {
        return this._reduceValues(values2, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values2, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix2 in values2) {
          const vs = values2[prefix2];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix2] = usedValues[prefix2] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c2 = valueCode(name);
            if (c2) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
            } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c2}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// ../../node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "../../node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n2) => code + n2.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i2 = nodes.length;
        while (i2--) {
          const n2 = nodes[i2].optimizeNodes();
          if (Array.isArray(n2))
            nodes.splice(i2, 1, ...n2);
          else if (n2)
            nodes[i2] = n2;
          else
            nodes.splice(i2, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i2 = nodes.length;
        while (i2--) {
          const n2 = nodes[i2];
          if (n2.optimizeNames(names, constants))
            continue;
          subtractNames(names, n2.names);
          nodes.splice(i2, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n2) => addNames(names, n2.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond2 = this.condition;
        if (cond2 === true)
          return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e2) {
          if (cond2 === false)
            return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond2), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond2 === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        super.optimizeNames(names, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix2) {
        return this._scope.name(prefix2);
      }
      // reserves unique name in the external scope
      scopeName(prefix2) {
        return this._extScope.name(prefix2);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix2, keyOrRef) {
        return this._extScope.getValue(prefix2, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant2) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant2)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c2) {
        if (typeof c2 == "function")
          c2();
        else if (c2 !== code_1.nil)
          this._leafNode(new AnyCode(c2));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node3, forBody) {
        this._blockNode(node3);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i2) => {
            this.var(name, (0, code_1._)`${arr}[${i2}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node3 = new Return();
        this._blockNode(node3);
        this.code(value);
        if (node3.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node3 = new Try();
        this._blockNode(node3);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node3.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node3.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n2 = 1) {
        while (n2-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node3) {
        this._currNode.nodes.push(node3);
        return this;
      }
      _blockNode(node3) {
        this._currNode.nodes.push(node3);
        this._nodes.push(node3);
      }
      _endBlockNode(N1, N2) {
        const n2 = this._currNode;
        if (n2 instanceof N1 || N2 && n2 instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node3) {
        const n2 = this._currNode;
        if (!(n2 instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n2.else = node3;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node3) {
        const ns = this._nodes;
        ns[ns.length - 1] = node3;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) + (from[n2] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c2) => {
        if (c2 instanceof code_1.Name)
          c2 = replaceName(c2);
        if (c2 instanceof code_1._Code)
          items.push(...c2._items);
        else
          items.push(c2);
        return items;
      }, []));
      function replaceName(n2) {
        const c2 = constants[n2.str];
        if (c2 === void 0 || names[n2.str] !== 1)
          return n2;
        delete names[n2.str];
        return c2;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) - (from[n2] || 0);
    }
    function not(x3) {
      return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_1._)`!${par(x3)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or3(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or3;
    function mappend(op) {
      return (x3, y2) => x3 === code_1.nil ? y2 : y2 === code_1.nil ? x3 : (0, code_1._)`${par(x3)} ${op} ${par(y2)}`;
    }
    function par(x3) {
      return x3 instanceof code_1.Name ? x3 : (0, code_1._)`(${x3})`;
    }
  }
});

// ../../node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS({
  "../../node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it2, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it2, schema);
      return !schemaHasRules(schema, it2.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it2, schema = it2.schema) {
      const { opts, self: self2 } = it2;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it2, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f3) {
      if (Array.isArray(xs)) {
        for (const x3 of xs)
          f3(x3);
      } else {
        f3(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p3) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p3)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f3) {
      return gen.scopeValue("func", {
        ref: f3,
        code: snippets[f3.code] || (snippets[f3.code] = new code_1._Code(f3.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber2 = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it2.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// ../../node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "../../node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// ../../node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "../../node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it2, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it: it2 }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i2) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i2}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword}`);
        if (it2.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it2, errs) {
      const { gen, validateName, schemaEnv } = it2;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E2 = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it: it2 } = cxt;
      const keyValues = [
        errorInstancePath(it2, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E2.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it: it2 } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it2;
      keyValues.push([E2.keyword, keyword], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E2.propertyName, propertyName]);
    }
  }
});

// ../../node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "../../node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it2) {
      const { gen, schema, validateName } = it2;
      if (schema === false) {
        falseSchemaError(it2, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it2, valid) {
      const { gen, schema } = it2;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it2);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it2, overrideAllErrors) {
      const { gen, data } = it2;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it2
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// ../../node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "../../node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x3) {
      return typeof x3 == "string" && jsonTypes.has(x3);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// ../../node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "../../node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// ../../node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "../../node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it2, types) {
      const { gen, data, opts } = it2;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it2, types, coerceTo);
          else
            reportTypeError(it2);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
    }
    function coerceData(it2, types, coerceTo) {
      const { gen, data, opts } = it2;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t2 of coerceTo) {
        if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t2);
        }
      }
      gen.else();
      reportTypeError(it2);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it2, coerced);
      });
      function coerceSpecificType(t2) {
        switch (t2) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond2;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond2 = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond2 = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond2 = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond2 = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond2 : (0, codegen_1.not)(cond2);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond2;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond2 = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond2 = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t2 in types)
        cond2 = (0, codegen_1.and)(cond2, checkDataType(t2, data, strictNums, correct));
      return cond2;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it2) {
      const cxt = getTypeErrorContext(it2);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it2) {
      const { gen, data, schema } = it2;
      const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it: it2
      };
    }
  }
});

// ../../node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    function assignDefaults(it2, ty) {
      const { properties, items } = it2.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it2, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i2) => assignDefault(it2, i2, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it2, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it2;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// ../../node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var names_1 = require_names();
    var util_2 = require_util2();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it: it2 } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property2) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property2})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property2, ownProperties) {
      const cond2 = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property2)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond2} && ${isOwnProperty(gen, data, property2)}` : cond2;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property2, ownProperties) {
      const cond2 = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property2)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond2, (0, codegen_1.not)(isOwnProperty(gen, data, property2))) : cond2;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p3) => p3 !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it2, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p3]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it2.parentData],
        [names_1.default.parentDataProperty, it2.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it2.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u2 = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u2);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u2})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      if (it2.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i2) => {
          cxt.subschema({
            keyword,
            dataProp: i2,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
      if (alwaysValid && !it2.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i2) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i2,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// ../../node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it: it2 } = cxt;
      const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it2.opts.validateSchema !== false)
        it2.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      const { gen, keyword, schema, parentSchema, $data, it: it2 } = cxt;
      checkAsyncKeyword(it2, def);
      const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it: it2 } = cxt;
      gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result2) {
      if (result2 === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result2 == "function" ? { ref: result2 } : { ref: result2, code: (0, codegen_1.stringify)(result2) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// ../../node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "../../node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    function getSubschema(it2, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it2.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it2;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it2;
        const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it2.dataLevel + 1;
        subschema.dataTypes = [];
        it2.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it2.data;
        subschema.dataNames = [...it2.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// ../../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal2(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length, i2, keys2;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal2(a2[i2], b2[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys2 = Object.keys(a2);
        length = keys2.length;
        if (length !== Object.keys(b2).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!equal2(a2[key], b2[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// ../../node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../../node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i2 = 0; i2 < sch.length; i2++)
                _traverse(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../../node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "../../node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util2();
    var equal2 = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize2) {
      if (normalize2 !== false)
        id = normalizeId(id);
      const p3 = resolver.parse(id);
      return _getFullPath(resolver, p3);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p3) {
      const serialized = resolver.serialize(p3);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal2(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// ../../node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "../../node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util2();
    var errors_1 = require_errors();
    function validateFunctionCode(it2) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          topSchemaObjCode(it2);
          return;
        }
      }
      validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it2) {
      const { schema, opts, gen } = it2;
      validateFunction(it2, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it2);
        checkNoDefault(it2);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it2);
        typeAndKeywords(it2);
        returnResults(it2);
      });
      return;
    }
    function resetEvaluated(it2) {
      const { gen, validateName } = it2;
      it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it2, valid) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          subSchemaObjCode(it2, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it2) {
      return typeof it2.schema != "boolean";
    }
    function subSchemaObjCode(it2, valid) {
      const { schema, gen, opts } = it2;
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      updateContext(it2);
      checkAsyncSchema(it2);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it2, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it2) {
      (0, util_1.checkUnknownRules)(it2);
      checkRefsAndKeywords(it2);
    }
    function typeAndKeywords(it2, errsCount) {
      if (it2.opts.jtd)
        return schemaKeywords(it2, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it2.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types);
      schemaKeywords(it2, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it2) {
      const { schema, errSchemaPath, opts, self: self2 } = it2;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it2) {
      const { schema, opts } = it2;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
      }
    }
    function updateContext(it2) {
      const schId = it2.schema[it2.opts.schemaId];
      if (schId)
        it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
    }
    function checkAsyncSchema(it2) {
      if (it2.schema.$async && !it2.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it2) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it2);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it2, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it2;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it2, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it2, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it2);
          }
          gen.endIf();
        } else {
          iterateKeywords(it2, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it2, group) {
      const { gen, schema, opts: { useDefaults } } = it2;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it2, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it2, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it2, types) {
      if (it2.schemaEnv.meta || !it2.opts.strictTypes)
        return;
      checkContextTypes(it2, types);
      if (!it2.opts.allowUnionTypes)
        checkMultipleTypes(it2, types);
      checkKeywordTypes(it2, it2.dataTypes);
    }
    function checkContextTypes(it2, types) {
      if (!types.length)
        return;
      if (!it2.dataTypes.length) {
        it2.dataTypes = types;
        return;
      }
      types.forEach((t2) => {
        if (!includesType(it2.dataTypes, t2)) {
          strictTypesError(it2, `type "${t2}" not allowed by context "${it2.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it2, types);
    }
    function checkMultipleTypes(it2, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it2, ts) {
      const rules = it2.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t2) => hasApplicableType(ts, t2))) {
            strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t2) {
      return ts.includes(t2) || t2 === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it2, withTypes) {
      const ts = [];
      for (const t2 of it2.dataTypes) {
        if (includesType(withTypes, t2))
          ts.push(t2);
        else if (withTypes.includes("integer") && t2 === "number")
          ts.push("integer");
      }
      it2.dataTypes = ts;
    }
    function strictTypesError(it2, msg) {
      const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it2, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it2, def, keyword);
        this.gen = it2.gen;
        this.allErrors = it2.allErrors;
        this.keyword = keyword;
        this.data = it2.data;
        this.schema = it2.schema[keyword];
        this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it2.schema;
        this.params = {};
        this.it = it2;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it2.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond2) {
        if (!this.allErrors)
          this.gen.if(cond2);
      }
      setParams(obj, assign2) {
        if (assign2)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it: it2 } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it2, gen } = this;
        if (!it2.opts.unevaluated)
          return;
        if (it2.props !== true && schemaCxt.props !== void 0) {
          it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
        }
        if (it2.items !== true && schemaCxt.items !== void 0) {
          it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it2, gen } = this;
        if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it2, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it2, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches2 = RELATIVE_JSON_POINTER.exec($data);
        if (!matches2)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches2[1];
        jsonPointer = matches2[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// ../../node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "../../node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// ../../node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "../../node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// ../../node_modules/ajv/dist/compile/index.js
var require_compile2 = __commonJS({
  "../../node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util2();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env2) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env2.schema == "object")
          schema = env2.schema;
        this.schema = env2.schema;
        this.schemaId = env2.schemaId;
        this.root = env2.root || this;
        this.baseId = (_a2 = env2.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
        this.schemaPath = env2.schemaPath;
        this.localRefs = env2.localRefs;
        this.meta = env2.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p3 = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p3);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p3, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p3, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p3, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env2;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env2 = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env2 = env2 || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env2.schema !== env2.root.schema)
        return env2;
      return void 0;
    }
  }
});

// ../../node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "../../node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// ../../node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "../../node_modules/fast-uri/lib/scopedChars.js"(exports2, module2) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module2.exports = {
      HEX
    };
  }
});

// ../../node_modules/fast-uri/lib/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var { HEX } = require_scopedChars();
    var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches2 = host.match(IPV4_REG) || [];
      const [address] = matches2;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c2 of input) {
        if (HEX[c2] === void 0) return void 0;
        if (c2 !== "0" && strip === true) strip = false;
        if (!strip) acc += c2;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i2 = 0; i2 < input.length; i2++) {
        const cursor = input[i2];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i2 - 1 >= 0 && input[i2 - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip2 = true;
      const l2 = str.length;
      for (let i2 = 0; i2 < l2; i2++) {
        const c2 = str[i2];
        if (c2 === "0" && skip2) {
          if (i2 + 1 <= l2 && str[i2 + 1] === token || i2 + 1 === l2) {
            out += c2;
            skip2 = false;
          }
        } else {
          if (c2 === token) {
            skip2 = true;
          } else {
            skip2 = false;
          }
          out += c2;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i2 = 0; i2 < str.length; i2++) {
        if (str[i2] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s2 = im[0];
            input = input.slice(s2.length);
            output.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// ../../node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "../../node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path4, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path4 && path4 !== "/" ? path4 : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches2 = urnComponents.path.match(URN_REG);
      if (matches2) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches2[1].toLowerCase();
        urnComponents.nss = matches2[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module2.exports = SCHEMES;
  }
});

// ../../node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "../../node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils4();
    var SCHEMES = require_schemes();
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal2(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (_v, k2) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k2)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i2 = 0, len = value.length; i2 < len; ++i2) {
        code = value.charCodeAt(i2);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches2 = uri.match(URI_PARSE);
      if (matches2) {
        parsed.scheme = matches2[1];
        parsed.userinfo = matches2[3];
        parsed.host = matches2[4];
        parsed.port = parseInt(matches2[5], 10);
        parsed.path = matches2[6] || "";
        parsed.query = matches2[7];
        parsed.fragment = matches2[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches2[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e2) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize: normalize2,
      resolve,
      resolveComponents,
      equal: equal2,
      serialize,
      parse
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// ../../node_modules/ajv/dist/runtime/uri.js
var require_uri2 = __commonJS({
  "../../node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// ../../node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "../../node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile2();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util2();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri2();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o2) {
      var _a2, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r2, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s2 = o2.strict;
      const _optz = (_a2 = o2.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o2.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e3 = o2.strictSchema) !== null && _e3 !== void 0 ? _e3 : s2) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== void 0 ? _g : s2) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== void 0 ? _l : s2) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== void 0 ? _o : s2) !== null && _p !== void 0 ? _p : false,
        code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r2 = o2.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
        meta: (_s = o2.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o2.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o2.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o2.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v3;
        if (typeof schemaKeyRef == "string") {
          v3 = this.getSchema(schemaKeyRef);
          if (!v3)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v3 = this.compile(schemaKeyRef);
        }
        const valid = v3(data);
        if (!("$async" in v3))
          this.errors = v3.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e2) {
            if (!(e2 instanceof ref_error_1.default))
              throw e2;
            checkLoaded.call(this, e2);
            await loadMissingSchema.call(this, e2.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p3 = this._loading[ref];
          if (p3)
            return p3;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t2) => addRule.call(this, k2, definition, t2)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i2 = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i2 >= 0)
            group.rules.splice(i2, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports2.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger2) {
      if (logger2 === false)
        return noLogs;
      if (logger2 === void 0)
        return console;
      if (logger2.log && logger2.warn && logger2.error)
        return logger2;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before2) {
      const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before2);
      if (i2 >= 0) {
        ruleGroup.rules.splice(i2, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before2} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// ../../node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref2 = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile2();
    var util_1 = require_util2();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it: it2 } = cxt;
        const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it2;
        const { root } = env2;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env2 === root)
            return callRef(cxt, validateName, env2, env2.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v3 = getValidate(cxt, sch);
          callRef(cxt, v3, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v3, sch, $async) {
      const { gen, it: it2 } = cxt;
      const { allErrors, schemaEnv: env2, opts } = it2;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env2.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v3, passCxt)}`);
          addEvaluatedFrom(v3);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e2) => {
          gen.if((0, codegen_1._)`!(${e2} instanceof ${it2.ValidationError})`, () => gen.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v3, passCxt), () => addEvaluatedFrom(v3), () => addErrorsFrom(v3));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it2.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it2.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
          }
        }
        if (it2.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref2();
    var core2 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core2;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it: it2 } = cxt;
        const prec = it2.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "../../node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it: it2 } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it: it2 } = cxt;
        const u2 = it2.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
        const { opts } = it2;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it2.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "../../node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal2 = require_fast_deep_equal();
    equal2.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal2;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i: i2, j: j3 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j3} and ${i2} are identical)`,
      params: ({ params: { i: i2, j: j3 } }) => (0, codegen_1._)`{i: ${i2}, j: ${j3}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i2 = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j3 = gen.let("j");
          cxt.setParams({ i: i2, j: j3 });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j3));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
        }
        function loopN(i2, j3) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i2}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i2}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j3, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i2}`);
          });
        }
        function loopN2(i2, j3) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i2}--;`, () => gen.for((0, codegen_1._)`${j3} = ${i2}; ${j3}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i2}], ${data}[${j3}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it2.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i2) => equalCode(vSchema, i2)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v3) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v3})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i2) {
          const sch = schema[i2];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i2}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it: it2 } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it: it2 } = cxt;
      it2.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i2) => {
          cxt.subschema({ keyword, dataProp: i2, dataPropType: util_1.Type.Num }, valid);
          if (!it2.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it: it2 } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it: it2 } = cxt;
      checkStrictTuple(parentSchema);
      if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
        it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i2) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i2}`, () => cxt.subschema({
          keyword,
          schemaProp: i2,
          dataProp: i2
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it2;
        const l2 = schArr.length;
        const fullTuple = l2 === sch.minItems && (l2 === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l2}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it: it2 } = cxt;
        const { prefixItems } = parentSchema;
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1.str)`must contain at least ${min2} valid item(s)` : (0, codegen_1.str)`must contain at least ${min2} and no more than ${max2} valid item(s)`,
      params: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1._)`{minContains: ${min2}}` : (0, codegen_1._)`{minContains: ${min2}, maxContains: ${max2}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        let min2;
        let max2;
        const { minContains, maxContains } = parentSchema;
        if (it2.opts.next) {
          min2 = minContains === void 0 ? 1 : minContains;
          max2 = maxContains;
        } else {
          min2 = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min: min2, max: max2 });
        if (max2 === void 0 && min2 === 0) {
          (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max2 !== void 0 && min2 > max2) {
          (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          let cond2 = (0, codegen_1._)`${len} >= ${min2}`;
          if (max2 !== void 0)
            cond2 = (0, codegen_1._)`${cond2} && ${len} <= ${max2}`;
          cxt.pass(cond2);
          return;
        }
        it2.items = true;
        const valid = gen.name("valid");
        if (max2 === void 0 && min2 === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min2 === 0) {
          gen.let(valid, true);
          if (max2 !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i2) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i2,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max2 === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min2}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max2}`, () => gen.assign(valid, false).break());
            if (min2 === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min2}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property: property2, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property2} is present`;
      },
      params: ({ params: { property: property2, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property2},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it: it2 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it2.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it2.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util2();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it2;
        it2.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p3) => (0, codegen_1._)`${key} === ${p3}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p3) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p3)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util2();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it2.definedProperties.add(prop);
        }
        if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
          it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
        }
        const properties = allProps.filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schema[p3]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it2.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var util_2 = require_util2();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it: it2 } = cxt;
        const { opts } = it2;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p3) => (0, util_1.alwaysValidSchema)(it2, schema[p3]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
          it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
        }
        const { props } = it2;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it2.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it2.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it2.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it2.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i2) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it2, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i2,
                compositeRule: true
              }, schValid);
            }
            if (i2 > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i2}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i2);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i2) => {
          if ((0, util_1.alwaysValidSchema)(it2, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it: it2 } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it2, "then");
        const hasElse = hasSchema(it2, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it2, keyword) {
      const schema = it2.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it2, schema);
    }
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it: it2 }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it2, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// ../../node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// ../../node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// ../../node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// ../../node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// ../../node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "../../node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile2();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it: it2 } = cxt;
        const { oneOf } = parentSchema;
        if (!it2.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a2;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i2 = 0; i2 < oneOf.length; i2++) {
            let sch = oneOf[i2];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref);
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i2);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i2) {
            if (sch.const) {
              addMapping(sch.const, i2);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i2);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i2) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i2;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../../node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// ../../node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v3) => this.addVocabulary(v3));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv2;
    module2.exports = exports2 = Ajv2;
    module2.exports.Ajv = Ajv2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// ../../node_modules/assertion-error/index.js
var require_assertion_error = __commonJS({
  "../../node_modules/assertion-error/index.js"(exports2, module2) {
    function exclude() {
      var excludes = [].slice.call(arguments);
      function excludeProps(res, obj) {
        Object.keys(obj).forEach(function(key) {
          if (!~excludes.indexOf(key)) res[key] = obj[key];
        });
      }
      return function extendExclude() {
        var args = [].slice.call(arguments), i2 = 0, res = {};
        for (; i2 < args.length; i2++) {
          excludeProps(res, args[i2]);
        }
        return res;
      };
    }
    module2.exports = AssertionError2;
    function AssertionError2(message, _props, ssf) {
      var extend = exclude("name", "message", "stack", "constructor", "toJSON"), props = extend(_props || {});
      this.message = message || "Unspecified AssertionError";
      this.showDiff = false;
      for (var key in props) {
        this[key] = props[key];
      }
      ssf = ssf || AssertionError2;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf);
      } else {
        try {
          throw new Error();
        } catch (e2) {
          this.stack = e2.stack;
        }
      }
    }
    AssertionError2.prototype = Object.create(Error.prototype);
    AssertionError2.prototype.name = "AssertionError";
    AssertionError2.prototype.constructor = AssertionError2;
    AssertionError2.prototype.toJSON = function(stack) {
      var extend = exclude("constructor", "toJSON", "stack"), props = extend({ name: this.name }, this);
      if (false !== stack && this.stack) {
        props.stack = this.stack;
      }
      return props;
    };
  }
});

// ../../node_modules/pathval/index.js
var require_pathval = __commonJS({
  "../../node_modules/pathval/index.js"(exports2, module2) {
    "use strict";
    function hasProperty(obj, name) {
      if (typeof obj === "undefined" || obj === null) {
        return false;
      }
      return name in Object(obj);
    }
    function parsePath(path4) {
      var str = path4.replace(/([^\\])\[/g, "$1.[");
      var parts = str.match(/(\\\.|[^.]+?)+/g);
      return parts.map(function mapMatches(value) {
        if (value === "constructor" || value === "__proto__" || value === "prototype") {
          return {};
        }
        var regexp = /^\[(\d+)\]$/;
        var mArr = regexp.exec(value);
        var parsed = null;
        if (mArr) {
          parsed = { i: parseFloat(mArr[1]) };
        } else {
          parsed = { p: value.replace(/\\([.[\]])/g, "$1") };
        }
        return parsed;
      });
    }
    function internalGetPathValue(obj, parsed, pathDepth) {
      var temporaryValue = obj;
      var res = null;
      pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
      for (var i2 = 0; i2 < pathDepth; i2++) {
        var part = parsed[i2];
        if (temporaryValue) {
          if (typeof part.p === "undefined") {
            temporaryValue = temporaryValue[part.i];
          } else {
            temporaryValue = temporaryValue[part.p];
          }
          if (i2 === pathDepth - 1) {
            res = temporaryValue;
          }
        }
      }
      return res;
    }
    function internalSetPathValue(obj, val, parsed) {
      var tempObj = obj;
      var pathDepth = parsed.length;
      var part = null;
      for (var i2 = 0; i2 < pathDepth; i2++) {
        var propName = null;
        var propVal = null;
        part = parsed[i2];
        if (i2 === pathDepth - 1) {
          propName = typeof part.p === "undefined" ? part.i : part.p;
          tempObj[propName] = val;
        } else if (typeof part.p !== "undefined" && tempObj[part.p]) {
          tempObj = tempObj[part.p];
        } else if (typeof part.i !== "undefined" && tempObj[part.i]) {
          tempObj = tempObj[part.i];
        } else {
          var next = parsed[i2 + 1];
          propName = typeof part.p === "undefined" ? part.i : part.p;
          propVal = typeof next.p === "undefined" ? [] : {};
          tempObj[propName] = propVal;
          tempObj = tempObj[propName];
        }
      }
    }
    function getPathInfo(obj, path4) {
      var parsed = parsePath(path4);
      var last3 = parsed[parsed.length - 1];
      var info = {
        parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
        name: last3.p || last3.i,
        value: internalGetPathValue(obj, parsed)
      };
      info.exists = hasProperty(info.parent, info.name);
      return info;
    }
    function getPathValue(obj, path4) {
      var info = getPathInfo(obj, path4);
      return info.value;
    }
    function setPathValue(obj, path4, val) {
      var parsed = parsePath(path4);
      internalSetPathValue(obj, val, parsed);
      return obj;
    }
    module2.exports = {
      hasProperty,
      getPathInfo,
      getPathValue,
      setPathValue
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/flag.js
var require_flag = __commonJS({
  "../../node_modules/chai/lib/chai/utils/flag.js"(exports2, module2) {
    module2.exports = function flag(obj, key, value) {
      var flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
      if (arguments.length === 3) {
        flags[key] = value;
      } else {
        return flags[key];
      }
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/test.js
var require_test = __commonJS({
  "../../node_modules/chai/lib/chai/utils/test.js"(exports2, module2) {
    var flag = require_flag();
    module2.exports = function test2(obj, args) {
      var negate3 = flag(obj, "negate"), expr = args[0];
      return negate3 ? !expr : expr;
    };
  }
});

// ../../node_modules/type-detect/type-detect.js
var require_type_detect = __commonJS({
  "../../node_modules/type-detect/type-detect.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.typeDetect = factory());
    })(exports2, (function() {
      "use strict";
      var promiseExists = typeof Promise === "function";
      var globalObject = (function(Obj) {
        if (typeof globalThis === "object") {
          return globalThis;
        }
        Object.defineProperty(Obj, "typeDetectGlobalObject", {
          get: function get2() {
            return this;
          },
          configurable: true
        });
        var global2 = typeDetectGlobalObject;
        delete Obj.typeDetectGlobalObject;
        return global2;
      })(Object.prototype);
      var symbolExists = typeof Symbol !== "undefined";
      var mapExists = typeof Map !== "undefined";
      var setExists = typeof Set !== "undefined";
      var weakMapExists = typeof WeakMap !== "undefined";
      var weakSetExists = typeof WeakSet !== "undefined";
      var dataViewExists = typeof DataView !== "undefined";
      var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
      var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
      var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
      var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
      var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
      var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
      var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
      var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
      var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
      var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
      var toStringLeftSliceLength = 8;
      var toStringRightSliceLength = -1;
      function typeDetect(obj) {
        var typeofObj = typeof obj;
        if (typeofObj !== "object") {
          return typeofObj;
        }
        if (obj === null) {
          return "null";
        }
        if (obj === globalObject) {
          return "global";
        }
        if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
          return "Array";
        }
        if (typeof window === "object" && window !== null) {
          if (typeof window.location === "object" && obj === window.location) {
            return "Location";
          }
          if (typeof window.document === "object" && obj === window.document) {
            return "Document";
          }
          if (typeof window.navigator === "object") {
            if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) {
              return "MimeTypeArray";
            }
            if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) {
              return "PluginArray";
            }
          }
          if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
            if (obj.tagName === "BLOCKQUOTE") {
              return "HTMLQuoteElement";
            }
            if (obj.tagName === "TD") {
              return "HTMLTableDataCellElement";
            }
            if (obj.tagName === "TH") {
              return "HTMLTableHeaderCellElement";
            }
          }
        }
        var stringTag2 = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag2 === "string") {
          return stringTag2;
        }
        var objPrototype = Object.getPrototypeOf(obj);
        if (objPrototype === RegExp.prototype) {
          return "RegExp";
        }
        if (objPrototype === Date.prototype) {
          return "Date";
        }
        if (promiseExists && objPrototype === Promise.prototype) {
          return "Promise";
        }
        if (setExists && objPrototype === Set.prototype) {
          return "Set";
        }
        if (mapExists && objPrototype === Map.prototype) {
          return "Map";
        }
        if (weakSetExists && objPrototype === WeakSet.prototype) {
          return "WeakSet";
        }
        if (weakMapExists && objPrototype === WeakMap.prototype) {
          return "WeakMap";
        }
        if (dataViewExists && objPrototype === DataView.prototype) {
          return "DataView";
        }
        if (mapExists && objPrototype === mapIteratorPrototype) {
          return "Map Iterator";
        }
        if (setExists && objPrototype === setIteratorPrototype) {
          return "Set Iterator";
        }
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
          return "Array Iterator";
        }
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
          return "String Iterator";
        }
        if (objPrototype === null) {
          return "Object";
        }
        return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
      }
      return typeDetect;
    }));
  }
});

// ../../node_modules/chai/lib/chai/utils/expectTypes.js
var require_expectTypes = __commonJS({
  "../../node_modules/chai/lib/chai/utils/expectTypes.js"(exports2, module2) {
    var AssertionError2 = require_assertion_error();
    var flag = require_flag();
    var type = require_type_detect();
    module2.exports = function expectTypes(obj, types) {
      var flagMsg = flag(obj, "message");
      var ssfi = flag(obj, "ssfi");
      flagMsg = flagMsg ? flagMsg + ": " : "";
      obj = flag(obj, "object");
      types = types.map(function(t2) {
        return t2.toLowerCase();
      });
      types.sort();
      var str = types.map(function(t2, index) {
        var art = ~["a", "e", "i", "o", "u"].indexOf(t2.charAt(0)) ? "an" : "a";
        var or3 = types.length > 1 && index === types.length - 1 ? "or " : "";
        return or3 + art + " " + t2;
      }).join(", ");
      var objType = type(obj).toLowerCase();
      if (!types.some(function(expected) {
        return objType === expected;
      })) {
        throw new AssertionError2(
          flagMsg + "object tested must be " + str + ", but " + objType + " given",
          void 0,
          ssfi
        );
      }
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/getActual.js
var require_getActual = __commonJS({
  "../../node_modules/chai/lib/chai/utils/getActual.js"(exports2, module2) {
    module2.exports = function getActual(obj, args) {
      return args.length > 4 ? args[4] : obj._obj;
    };
  }
});

// ../../node_modules/get-func-name/index.js
var require_get_func_name = __commonJS({
  "../../node_modules/get-func-name/index.js"(exports2, module2) {
    "use strict";
    var toString2 = Function.prototype.toString;
    var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
    var maxFunctionSourceLength = 512;
    function getFuncName(aFunc) {
      if (typeof aFunc !== "function") {
        return null;
      }
      var name = "";
      if (typeof Function.prototype.name === "undefined" && typeof aFunc.name === "undefined") {
        var functionSource = toString2.call(aFunc);
        if (functionSource.indexOf("(") > maxFunctionSourceLength) {
          return name;
        }
        var match = functionSource.match(functionNameMatch);
        if (match) {
          name = match[1];
        }
      } else {
        name = aFunc.name;
      }
      return name;
    }
    module2.exports = getFuncName;
  }
});

// ../../node_modules/loupe/loupe.js
var require_loupe = __commonJS({
  "../../node_modules/loupe/loupe.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.loupe = {}));
    })(exports2, (function(exports3) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _slicedToArray(arr, i2) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _iterableToArrayLimit(arr, i2) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e3 = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2) break;
          }
        } catch (err) {
          _d = true;
          _e3 = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e3;
          }
        }
        return _arr;
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2) return;
        if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set") return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
        return arr2;
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var ansiColors = {
        bold: ["1", "22"],
        dim: ["2", "22"],
        italic: ["3", "23"],
        underline: ["4", "24"],
        // 5 & 6 are blinking
        inverse: ["7", "27"],
        hidden: ["8", "28"],
        strike: ["9", "29"],
        // 10-20 are fonts
        // 21-29 are resets for 1-9
        black: ["30", "39"],
        red: ["31", "39"],
        green: ["32", "39"],
        yellow: ["33", "39"],
        blue: ["34", "39"],
        magenta: ["35", "39"],
        cyan: ["36", "39"],
        white: ["37", "39"],
        brightblack: ["30;1", "39"],
        brightred: ["31;1", "39"],
        brightgreen: ["32;1", "39"],
        brightyellow: ["33;1", "39"],
        brightblue: ["34;1", "39"],
        brightmagenta: ["35;1", "39"],
        brightcyan: ["36;1", "39"],
        brightwhite: ["37;1", "39"],
        grey: ["90", "39"]
      };
      var styles = {
        special: "cyan",
        number: "yellow",
        bigint: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        symbol: "green",
        date: "magenta",
        regexp: "red"
      };
      var truncator = "\u2026";
      function colorise(value, styleType) {
        var color = ansiColors[styles[styleType]] || ansiColors[styleType];
        if (!color) {
          return String(value);
        }
        return "\x1B[".concat(color[0], "m").concat(String(value), "\x1B[").concat(color[1], "m");
      }
      function normaliseOptions() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$showHidden = _ref.showHidden, showHidden = _ref$showHidden === void 0 ? false : _ref$showHidden, _ref$depth = _ref.depth, depth = _ref$depth === void 0 ? 2 : _ref$depth, _ref$colors = _ref.colors, colors = _ref$colors === void 0 ? false : _ref$colors, _ref$customInspect = _ref.customInspect, customInspect = _ref$customInspect === void 0 ? true : _ref$customInspect, _ref$showProxy = _ref.showProxy, showProxy = _ref$showProxy === void 0 ? false : _ref$showProxy, _ref$maxArrayLength = _ref.maxArrayLength, maxArrayLength = _ref$maxArrayLength === void 0 ? Infinity : _ref$maxArrayLength, _ref$breakLength = _ref.breakLength, breakLength = _ref$breakLength === void 0 ? Infinity : _ref$breakLength, _ref$seen = _ref.seen, seen = _ref$seen === void 0 ? [] : _ref$seen, _ref$truncate = _ref.truncate, truncate4 = _ref$truncate === void 0 ? Infinity : _ref$truncate, _ref$stylize = _ref.stylize, stylize = _ref$stylize === void 0 ? String : _ref$stylize;
        var options = {
          showHidden: Boolean(showHidden),
          depth: Number(depth),
          colors: Boolean(colors),
          customInspect: Boolean(customInspect),
          showProxy: Boolean(showProxy),
          maxArrayLength: Number(maxArrayLength),
          breakLength: Number(breakLength),
          truncate: Number(truncate4),
          seen,
          stylize
        };
        if (options.colors) {
          options.stylize = colorise;
        }
        return options;
      }
      function truncate3(string, length) {
        var tail3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : truncator;
        string = String(string);
        var tailLength = tail3.length;
        var stringLength = string.length;
        if (tailLength > length && stringLength > tailLength) {
          return tail3;
        }
        if (stringLength > length && stringLength > tailLength) {
          return "".concat(string.slice(0, length - tailLength)).concat(tail3);
        }
        return string;
      }
      function inspectList(list, options, inspectItem) {
        var separator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ", ";
        inspectItem = inspectItem || options.inspect;
        var size2 = list.length;
        if (size2 === 0) return "";
        var originalLength = options.truncate;
        var output = "";
        var peek = "";
        var truncated = "";
        for (var i2 = 0; i2 < size2; i2 += 1) {
          var last3 = i2 + 1 === list.length;
          var secondToLast = i2 + 2 === list.length;
          truncated = "".concat(truncator, "(").concat(list.length - i2, ")");
          var value = list[i2];
          options.truncate = originalLength - output.length - (last3 ? 0 : separator.length);
          var string = peek || inspectItem(value, options) + (last3 ? "" : separator);
          var nextLength = output.length + string.length;
          var truncatedLength = nextLength + truncated.length;
          if (last3 && nextLength > originalLength && output.length + truncated.length <= originalLength) {
            break;
          }
          if (!last3 && !secondToLast && truncatedLength > originalLength) {
            break;
          }
          peek = last3 ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator);
          if (!last3 && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
            break;
          }
          output += string;
          if (!last3 && !secondToLast && nextLength + peek.length >= originalLength) {
            truncated = "".concat(truncator, "(").concat(list.length - i2 - 1, ")");
            break;
          }
          truncated = "";
        }
        return "".concat(output).concat(truncated);
      }
      function quoteComplexKey(key) {
        if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
          return key;
        }
        return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      }
      function inspectProperty(_ref2, options) {
        var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], value = _ref3[1];
        options.truncate -= 2;
        if (typeof key === "string") {
          key = quoteComplexKey(key);
        } else if (typeof key !== "number") {
          key = "[".concat(options.inspect(key, options), "]");
        }
        options.truncate -= key.length;
        value = options.inspect(value, options);
        return "".concat(key, ": ").concat(value);
      }
      function inspectArray(array, options) {
        var nonIndexProperties = Object.keys(array).slice(array.length);
        if (!array.length && !nonIndexProperties.length) return "[]";
        options.truncate -= 4;
        var listContents = inspectList(array, options);
        options.truncate -= listContents.length;
        var propertyContents = "";
        if (nonIndexProperties.length) {
          propertyContents = inspectList(nonIndexProperties.map(function(key) {
            return [key, array[key]];
          }), options, inspectProperty);
        }
        return "[ ".concat(listContents).concat(propertyContents ? ", ".concat(propertyContents) : "", " ]");
      }
      var toString2 = Function.prototype.toString;
      var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
      var maxFunctionSourceLength = 512;
      function getFuncName(aFunc) {
        if (typeof aFunc !== "function") {
          return null;
        }
        var name = "";
        if (typeof Function.prototype.name === "undefined" && typeof aFunc.name === "undefined") {
          var functionSource = toString2.call(aFunc);
          if (functionSource.indexOf("(") > maxFunctionSourceLength) {
            return name;
          }
          var match = functionSource.match(functionNameMatch);
          if (match) {
            name = match[1];
          }
        } else {
          name = aFunc.name;
        }
        return name;
      }
      var getFuncName_1 = getFuncName;
      var getArrayName = function getArrayName2(array) {
        if (typeof Buffer === "function" && array instanceof Buffer) {
          return "Buffer";
        }
        if (array[Symbol.toStringTag]) {
          return array[Symbol.toStringTag];
        }
        return getFuncName_1(array.constructor);
      };
      function inspectTypedArray(array, options) {
        var name = getArrayName(array);
        options.truncate -= name.length + 4;
        var nonIndexProperties = Object.keys(array).slice(array.length);
        if (!array.length && !nonIndexProperties.length) return "".concat(name, "[]");
        var output = "";
        for (var i2 = 0; i2 < array.length; i2++) {
          var string = "".concat(options.stylize(truncate3(array[i2], options.truncate), "number")).concat(i2 === array.length - 1 ? "" : ", ");
          options.truncate -= string.length;
          if (array[i2] !== array.length && options.truncate <= 3) {
            output += "".concat(truncator, "(").concat(array.length - array[i2] + 1, ")");
            break;
          }
          output += string;
        }
        var propertyContents = "";
        if (nonIndexProperties.length) {
          propertyContents = inspectList(nonIndexProperties.map(function(key) {
            return [key, array[key]];
          }), options, inspectProperty);
        }
        return "".concat(name, "[ ").concat(output).concat(propertyContents ? ", ".concat(propertyContents) : "", " ]");
      }
      function inspectDate(dateObject, options) {
        var stringRepresentation = dateObject.toJSON();
        if (stringRepresentation === null) {
          return "Invalid Date";
        }
        var split2 = stringRepresentation.split("T");
        var date = split2[0];
        return options.stylize("".concat(date, "T").concat(truncate3(split2[1], options.truncate - date.length - 1)), "date");
      }
      function inspectFunction(func, options) {
        var name = getFuncName_1(func);
        if (!name) {
          return options.stylize("[Function]", "special");
        }
        return options.stylize("[Function ".concat(truncate3(name, options.truncate - 11), "]"), "special");
      }
      function inspectMapEntry(_ref, options) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
        options.truncate -= 4;
        key = options.inspect(key, options);
        options.truncate -= key.length;
        value = options.inspect(value, options);
        return "".concat(key, " => ").concat(value);
      }
      function mapToEntries2(map2) {
        var entries = [];
        map2.forEach(function(value, key) {
          entries.push([key, value]);
        });
        return entries;
      }
      function inspectMap(map2, options) {
        var size2 = map2.size - 1;
        if (size2 <= 0) {
          return "Map{}";
        }
        options.truncate -= 7;
        return "Map{ ".concat(inspectList(mapToEntries2(map2), options, inspectMapEntry), " }");
      }
      var isNaN3 = Number.isNaN || function(i2) {
        return i2 !== i2;
      };
      function inspectNumber(number, options) {
        if (isNaN3(number)) {
          return options.stylize("NaN", "number");
        }
        if (number === Infinity) {
          return options.stylize("Infinity", "number");
        }
        if (number === -Infinity) {
          return options.stylize("-Infinity", "number");
        }
        if (number === 0) {
          return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
        }
        return options.stylize(truncate3(number, options.truncate), "number");
      }
      function inspectBigInt(number, options) {
        var nums = truncate3(number.toString(), options.truncate - 1);
        if (nums !== truncator) nums += "n";
        return options.stylize(nums, "bigint");
      }
      function inspectRegExp(value, options) {
        var flags = value.toString().split("/")[2];
        var sourceLength = options.truncate - (2 + flags.length);
        var source = value.source;
        return options.stylize("/".concat(truncate3(source, sourceLength), "/").concat(flags), "regexp");
      }
      function arrayFromSet(set2) {
        var values2 = [];
        set2.forEach(function(value) {
          values2.push(value);
        });
        return values2;
      }
      function inspectSet(set2, options) {
        if (set2.size === 0) return "Set{}";
        options.truncate -= 7;
        return "Set{ ".concat(inspectList(arrayFromSet(set2), options), " }");
      }
      var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
      var escapeCharacters = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        "'": "\\'",
        "\\": "\\\\"
      };
      var hex = 16;
      var unicodeLength = 4;
      function escape4(char) {
        return escapeCharacters[char] || "\\u".concat("0000".concat(char.charCodeAt(0).toString(hex)).slice(-unicodeLength));
      }
      function inspectString(string, options) {
        if (stringEscapeChars.test(string)) {
          string = string.replace(stringEscapeChars, escape4);
        }
        return options.stylize("'".concat(truncate3(string, options.truncate - 2), "'"), "string");
      }
      function inspectSymbol(value) {
        if ("description" in Symbol.prototype) {
          return value.description ? "Symbol(".concat(value.description, ")") : "Symbol()";
        }
        return value.toString();
      }
      var getPromiseValue = function getPromiseValue2() {
        return "Promise{\u2026}";
      };
      try {
        var _process$binding = process.binding("util"), getPromiseDetails = _process$binding.getPromiseDetails, kPending = _process$binding.kPending, kRejected = _process$binding.kRejected;
        if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
          getPromiseValue = function getPromiseValue2(value, options) {
            var _getPromiseDetails = getPromiseDetails(value), _getPromiseDetails2 = _slicedToArray(_getPromiseDetails, 2), state = _getPromiseDetails2[0], innerValue = _getPromiseDetails2[1];
            if (state === kPending) {
              return "Promise{<pending>}";
            }
            return "Promise".concat(state === kRejected ? "!" : "", "{").concat(options.inspect(innerValue, options), "}");
          };
        }
      } catch (notNode) {
      }
      var inspectPromise = getPromiseValue;
      function inspectObject(object, options) {
        var properties = Object.getOwnPropertyNames(object);
        var symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
        if (properties.length === 0 && symbols.length === 0) {
          return "{}";
        }
        options.truncate -= 4;
        options.seen = options.seen || [];
        if (options.seen.indexOf(object) >= 0) {
          return "[Circular]";
        }
        options.seen.push(object);
        var propertyContents = inspectList(properties.map(function(key) {
          return [key, object[key]];
        }), options, inspectProperty);
        var symbolContents = inspectList(symbols.map(function(key) {
          return [key, object[key]];
        }), options, inspectProperty);
        options.seen.pop();
        var sep = "";
        if (propertyContents && symbolContents) {
          sep = ", ";
        }
        return "{ ".concat(propertyContents).concat(sep).concat(symbolContents, " }");
      }
      var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
      function inspectClass(value, options) {
        var name = "";
        if (toStringTag && toStringTag in value) {
          name = value[toStringTag];
        }
        name = name || getFuncName_1(value.constructor);
        if (!name || name === "_class") {
          name = "<Anonymous Class>";
        }
        options.truncate -= name.length;
        return "".concat(name).concat(inspectObject(value, options));
      }
      function inspectArguments(args, options) {
        if (args.length === 0) return "Arguments[]";
        options.truncate -= 13;
        return "Arguments[ ".concat(inspectList(args, options), " ]");
      }
      var errorKeys = ["stack", "line", "column", "name", "message", "fileName", "lineNumber", "columnNumber", "number", "description"];
      function inspectObject$1(error, options) {
        var properties = Object.getOwnPropertyNames(error).filter(function(key) {
          return errorKeys.indexOf(key) === -1;
        });
        var name = error.name;
        options.truncate -= name.length;
        var message = "";
        if (typeof error.message === "string") {
          message = truncate3(error.message, options.truncate);
        } else {
          properties.unshift("message");
        }
        message = message ? ": ".concat(message) : "";
        options.truncate -= message.length + 5;
        var propertyContents = inspectList(properties.map(function(key) {
          return [key, error[key]];
        }), options, inspectProperty);
        return "".concat(name).concat(message).concat(propertyContents ? " { ".concat(propertyContents, " }") : "");
      }
      function inspectAttribute(_ref, options) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
        options.truncate -= 3;
        if (!value) {
          return "".concat(options.stylize(key, "yellow"));
        }
        return "".concat(options.stylize(key, "yellow"), "=").concat(options.stylize('"'.concat(value, '"'), "string"));
      }
      function inspectHTMLCollection(collection, options) {
        return inspectList(collection, options, inspectHTML, "\n");
      }
      function inspectHTML(element, options) {
        var properties = element.getAttributeNames();
        var name = element.tagName.toLowerCase();
        var head3 = options.stylize("<".concat(name), "special");
        var headClose = options.stylize(">", "special");
        var tail3 = options.stylize("</".concat(name, ">"), "special");
        options.truncate -= name.length * 2 + 5;
        var propertyContents = "";
        if (properties.length > 0) {
          propertyContents += " ";
          propertyContents += inspectList(properties.map(function(key) {
            return [key, element.getAttribute(key)];
          }), options, inspectAttribute, " ");
        }
        options.truncate -= propertyContents.length;
        var truncate4 = options.truncate;
        var children = inspectHTMLCollection(element.children, options);
        if (children && children.length > truncate4) {
          children = "".concat(truncator, "(").concat(element.children.length, ")");
        }
        return "".concat(head3).concat(propertyContents).concat(headClose).concat(children).concat(tail3);
      }
      var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
      var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
      var nodeInspect = false;
      try {
        var nodeUtil = require("util");
        nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
      } catch (noNodeInspect) {
        nodeInspect = false;
      }
      function FakeMap() {
        this.key = "chai/loupe__" + Math.random() + Date.now();
      }
      FakeMap.prototype = {
        // eslint-disable-next-line object-shorthand
        get: function get2(key) {
          return key[this.key];
        },
        // eslint-disable-next-line object-shorthand
        has: function has2(key) {
          return this.key in key;
        },
        // eslint-disable-next-line object-shorthand
        set: function set2(key, value) {
          if (Object.isExtensible(key)) {
            Object.defineProperty(key, this.key, {
              // eslint-disable-next-line object-shorthand
              value,
              configurable: true
            });
          }
        }
      };
      var constructorMap = new (typeof WeakMap === "function" ? WeakMap : FakeMap)();
      var stringTagMap = {};
      var baseTypesMap = {
        undefined: function undefined$1(value, options) {
          return options.stylize("undefined", "undefined");
        },
        null: function _null(value, options) {
          return options.stylize(null, "null");
        },
        boolean: function boolean(value, options) {
          return options.stylize(value, "boolean");
        },
        Boolean: function Boolean2(value, options) {
          return options.stylize(value, "boolean");
        },
        number: inspectNumber,
        Number: inspectNumber,
        bigint: inspectBigInt,
        BigInt: inspectBigInt,
        string: inspectString,
        String: inspectString,
        function: inspectFunction,
        Function: inspectFunction,
        symbol: inspectSymbol,
        // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
        Symbol: inspectSymbol,
        Array: inspectArray,
        Date: inspectDate,
        Map: inspectMap,
        Set: inspectSet,
        RegExp: inspectRegExp,
        Promise: inspectPromise,
        // WeakSet, WeakMap are totally opaque to us
        WeakSet: function WeakSet2(value, options) {
          return options.stylize("WeakSet{\u2026}", "special");
        },
        WeakMap: function WeakMap2(value, options) {
          return options.stylize("WeakMap{\u2026}", "special");
        },
        Arguments: inspectArguments,
        Int8Array: inspectTypedArray,
        Uint8Array: inspectTypedArray,
        Uint8ClampedArray: inspectTypedArray,
        Int16Array: inspectTypedArray,
        Uint16Array: inspectTypedArray,
        Int32Array: inspectTypedArray,
        Uint32Array: inspectTypedArray,
        Float32Array: inspectTypedArray,
        Float64Array: inspectTypedArray,
        Generator: function Generator() {
          return "";
        },
        DataView: function DataView2() {
          return "";
        },
        ArrayBuffer: function ArrayBuffer2() {
          return "";
        },
        Error: inspectObject$1,
        HTMLCollection: inspectHTMLCollection,
        NodeList: inspectHTMLCollection
      };
      var inspectCustom = function inspectCustom2(value, options, type) {
        if (chaiInspect in value && typeof value[chaiInspect] === "function") {
          return value[chaiInspect](options);
        }
        if (nodeInspect && nodeInspect in value && typeof value[nodeInspect] === "function") {
          return value[nodeInspect](options.depth, options);
        }
        if ("inspect" in value && typeof value.inspect === "function") {
          return value.inspect(options.depth, options);
        }
        if ("constructor" in value && constructorMap.has(value.constructor)) {
          return constructorMap.get(value.constructor)(value, options);
        }
        if (stringTagMap[type]) {
          return stringTagMap[type](value, options);
        }
        return "";
      };
      var toString$1 = Object.prototype.toString;
      function inspect(value, options) {
        options = normaliseOptions(options);
        options.inspect = inspect;
        var _options = options, customInspect = _options.customInspect;
        var type = value === null ? "null" : _typeof(value);
        if (type === "object") {
          type = toString$1.call(value).slice(8, -1);
        }
        if (baseTypesMap[type]) {
          return baseTypesMap[type](value, options);
        }
        if (customInspect && value) {
          var output = inspectCustom(value, options, type);
          if (output) {
            if (typeof output === "string") return output;
            return inspect(output, options);
          }
        }
        var proto = value ? Object.getPrototypeOf(value) : false;
        if (proto === Object.prototype || proto === null) {
          return inspectObject(value, options);
        }
        if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
          return inspectHTML(value, options);
        }
        if ("constructor" in value) {
          if (value.constructor !== Object) {
            return inspectClass(value, options);
          }
          return inspectObject(value, options);
        }
        if (value === Object(value)) {
          return inspectObject(value, options);
        }
        return options.stylize(String(value), type);
      }
      function registerConstructor(constructor, inspector) {
        if (constructorMap.has(constructor)) {
          return false;
        }
        constructorMap.set(constructor, inspector);
        return true;
      }
      function registerStringTag(stringTag2, inspector) {
        if (stringTag2 in stringTagMap) {
          return false;
        }
        stringTagMap[stringTag2] = inspector;
        return true;
      }
      var custom = chaiInspect;
      exports3.custom = custom;
      exports3.default = inspect;
      exports3.inspect = inspect;
      exports3.registerConstructor = registerConstructor;
      exports3.registerStringTag = registerStringTag;
      Object.defineProperty(exports3, "__esModule", { value: true });
    }));
  }
});

// ../../node_modules/chai/lib/chai/config.js
var require_config = __commonJS({
  "../../node_modules/chai/lib/chai/config.js"(exports2, module2) {
    module2.exports = {
      /**
       * ### config.includeStack
       *
       * User configurable property, influences whether stack trace
       * is included in Assertion error message. Default of false
       * suppresses stack trace in the error message.
       *
       *     chai.config.includeStack = true;  // enable stack on error
       *
       * @param {Boolean}
       * @api public
       */
      includeStack: false,
      /**
       * ### config.showDiff
       *
       * User configurable property, influences whether or not
       * the `showDiff` flag should be included in the thrown
       * AssertionErrors. `false` will always be `false`; `true`
       * will be true when the assertion has requested a diff
       * be shown.
       *
       * @param {Boolean}
       * @api public
       */
      showDiff: true,
      /**
       * ### config.truncateThreshold
       *
       * User configurable property, sets length threshold for actual and
       * expected values in assertion errors. If this threshold is exceeded, for
       * example for large data structures, the value is replaced with something
       * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
       *
       * Set it to zero if you want to disable truncating altogether.
       *
       * This is especially userful when doing assertions on arrays: having this
       * set to a reasonable large value makes the failure messages readily
       * inspectable.
       *
       *     chai.config.truncateThreshold = 0;  // disable truncating
       *
       * @param {Number}
       * @api public
       */
      truncateThreshold: 40,
      /**
       * ### config.useProxy
       *
       * User configurable property, defines if chai will use a Proxy to throw
       * an error when a non-existent property is read, which protects users
       * from typos when using property-based assertions.
       *
       * Set it to false if you want to disable this feature.
       *
       *     chai.config.useProxy = false;  // disable use of Proxy
       *
       * This feature is automatically disabled regardless of this config value
       * in environments that don't support proxies.
       *
       * @param {Boolean}
       * @api public
       */
      useProxy: true,
      /**
       * ### config.proxyExcludedKeys
       *
       * User configurable property, defines which properties should be ignored
       * instead of throwing an error if they do not exist on the assertion.
       * This is only applied if the environment Chai is running in supports proxies and
       * if the `useProxy` configuration setting is enabled.
       * By default, `then` and `inspect` will not throw an error if they do not exist on the
       * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
       * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
       *
       *     // By default these keys will not throw an error if they do not exist on the assertion object
       *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
       *
       * @param {Array}
       * @api public
       */
      proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
      /**
       * ### config.deepEqual
       *
       * User configurable property, defines which a custom function to use for deepEqual
       * comparisons.
       * By default, the function used is the one from the `deep-eql` package without custom comparator.
       *
       *     // use a custom comparator
       *     chai.config.deepEqual = (expected, actual) => {
       *        return chai.util.eql(expected, actual, {
       *           comparator: (expected, actual) => {
       *              // for non number comparison, use the default behavior
       *              if(typeof expected !== 'number') return null;
       *              // allow a difference of 10 between compared numbers
       *              return typeof actual === 'number' && Math.abs(actual - expected) < 10
       *           }
       *        })
       *     };
       *
       * @param {Function}
       * @api public
       */
      deepEqual: null
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/inspect.js
var require_inspect = __commonJS({
  "../../node_modules/chai/lib/chai/utils/inspect.js"(exports2, module2) {
    var getName = require_get_func_name();
    var loupe = require_loupe();
    var config2 = require_config();
    module2.exports = inspect;
    function inspect(obj, showHidden, depth, colors) {
      var options = {
        colors,
        depth: typeof depth === "undefined" ? 2 : depth,
        showHidden,
        truncate: config2.truncateThreshold ? config2.truncateThreshold : Infinity
      };
      return loupe.inspect(obj, options);
    }
  }
});

// ../../node_modules/chai/lib/chai/utils/objDisplay.js
var require_objDisplay = __commonJS({
  "../../node_modules/chai/lib/chai/utils/objDisplay.js"(exports2, module2) {
    var inspect = require_inspect();
    var config2 = require_config();
    module2.exports = function objDisplay(obj) {
      var str = inspect(obj), type = Object.prototype.toString.call(obj);
      if (config2.truncateThreshold && str.length >= config2.truncateThreshold) {
        if (type === "[object Function]") {
          return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
        } else if (type === "[object Array]") {
          return "[ Array(" + obj.length + ") ]";
        } else if (type === "[object Object]") {
          var keys2 = Object.keys(obj), kstr = keys2.length > 2 ? keys2.splice(0, 2).join(", ") + ", ..." : keys2.join(", ");
          return "{ Object (" + kstr + ") }";
        } else {
          return str;
        }
      } else {
        return str;
      }
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/getMessage.js
var require_getMessage = __commonJS({
  "../../node_modules/chai/lib/chai/utils/getMessage.js"(exports2, module2) {
    var flag = require_flag();
    var getActual = require_getActual();
    var objDisplay = require_objDisplay();
    module2.exports = function getMessage(obj, args) {
      var negate3 = flag(obj, "negate"), val = flag(obj, "object"), expected = args[3], actual = getActual(obj, args), msg = negate3 ? args[2] : args[1], flagMsg = flag(obj, "message");
      if (typeof msg === "function") msg = msg();
      msg = msg || "";
      msg = msg.replace(/#\{this\}/g, function() {
        return objDisplay(val);
      }).replace(/#\{act\}/g, function() {
        return objDisplay(actual);
      }).replace(/#\{exp\}/g, function() {
        return objDisplay(expected);
      });
      return flagMsg ? flagMsg + ": " + msg : msg;
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/transferFlags.js
var require_transferFlags = __commonJS({
  "../../node_modules/chai/lib/chai/utils/transferFlags.js"(exports2, module2) {
    module2.exports = function transferFlags(assertion, object, includeAll) {
      var flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
      if (!object.__flags) {
        object.__flags = /* @__PURE__ */ Object.create(null);
      }
      includeAll = arguments.length === 3 ? includeAll : true;
      for (var flag in flags) {
        if (includeAll || flag !== "object" && flag !== "ssfi" && flag !== "lockSsfi" && flag != "message") {
          object.__flags[flag] = flags[flag];
        }
      }
    };
  }
});

// ../../node_modules/deep-eql/index.js
var require_deep_eql = __commonJS({
  "../../node_modules/deep-eql/index.js"(exports2, module2) {
    "use strict";
    var type = require_type_detect();
    function FakeMap() {
      this._key = "chai/deep-eql__" + Math.random() + Date.now();
    }
    FakeMap.prototype = {
      get: function get2(key) {
        return key[this._key];
      },
      set: function set2(key, value) {
        if (Object.isExtensible(key)) {
          Object.defineProperty(key, this._key, {
            value,
            configurable: true
          });
        }
      }
    };
    var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
    function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
      if (!memoizeMap || isPrimitive3(leftHandOperand) || isPrimitive3(rightHandOperand)) {
        return null;
      }
      var leftHandMap = memoizeMap.get(leftHandOperand);
      if (leftHandMap) {
        var result2 = leftHandMap.get(rightHandOperand);
        if (typeof result2 === "boolean") {
          return result2;
        }
      }
      return null;
    }
    function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result2) {
      if (!memoizeMap || isPrimitive3(leftHandOperand) || isPrimitive3(rightHandOperand)) {
        return;
      }
      var leftHandMap = memoizeMap.get(leftHandOperand);
      if (leftHandMap) {
        leftHandMap.set(rightHandOperand, result2);
      } else {
        leftHandMap = new MemoizeMap();
        leftHandMap.set(rightHandOperand, result2);
        memoizeMap.set(leftHandOperand, leftHandMap);
      }
    }
    module2.exports = deepEqual2;
    module2.exports.MemoizeMap = MemoizeMap;
    function deepEqual2(leftHandOperand, rightHandOperand, options) {
      if (options && options.comparator) {
        return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
      }
      var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
      if (simpleResult !== null) {
        return simpleResult;
      }
      return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
    }
    function simpleEqual(leftHandOperand, rightHandOperand) {
      if (leftHandOperand === rightHandOperand) {
        return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
      }
      if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
      rightHandOperand !== rightHandOperand) {
        return true;
      }
      if (isPrimitive3(leftHandOperand) || isPrimitive3(rightHandOperand)) {
        return false;
      }
      return null;
    }
    function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
      options = options || {};
      options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
      var comparator = options && options.comparator;
      var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
      if (memoizeResultLeft !== null) {
        return memoizeResultLeft;
      }
      var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
      if (memoizeResultRight !== null) {
        return memoizeResultRight;
      }
      if (comparator) {
        var comparatorResult = comparator(leftHandOperand, rightHandOperand);
        if (comparatorResult === false || comparatorResult === true) {
          memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
          return comparatorResult;
        }
        var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
        if (simpleResult !== null) {
          return simpleResult;
        }
      }
      var leftHandType = type(leftHandOperand);
      if (leftHandType !== type(rightHandOperand)) {
        memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
        return false;
      }
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
      var result2 = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result2);
      return result2;
    }
    function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
      switch (leftHandType) {
        case "String":
        case "Number":
        case "Boolean":
        case "Date":
          return deepEqual2(leftHandOperand.valueOf(), rightHandOperand.valueOf());
        case "Promise":
        case "Symbol":
        case "function":
        case "WeakMap":
        case "WeakSet":
          return leftHandOperand === rightHandOperand;
        case "Error":
          return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
        case "Arguments":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "Array":
          return iterableEqual(leftHandOperand, rightHandOperand, options);
        case "RegExp":
          return regexpEqual(leftHandOperand, rightHandOperand);
        case "Generator":
          return generatorEqual(leftHandOperand, rightHandOperand, options);
        case "DataView":
          return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
        case "ArrayBuffer":
          return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
        case "Set":
          return entriesEqual(leftHandOperand, rightHandOperand, options);
        case "Map":
          return entriesEqual(leftHandOperand, rightHandOperand, options);
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.Instant":
        case "Temporal.ZonedDateTime":
        case "Temporal.PlainYearMonth":
        case "Temporal.PlainMonthDay":
          return leftHandOperand.equals(rightHandOperand);
        case "Temporal.Duration":
          return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
        case "Temporal.TimeZone":
        case "Temporal.Calendar":
          return leftHandOperand.toString() === rightHandOperand.toString();
        default:
          return objectEqual(leftHandOperand, rightHandOperand, options);
      }
    }
    function regexpEqual(leftHandOperand, rightHandOperand) {
      return leftHandOperand.toString() === rightHandOperand.toString();
    }
    function entriesEqual(leftHandOperand, rightHandOperand, options) {
      try {
        if (leftHandOperand.size !== rightHandOperand.size) {
          return false;
        }
        if (leftHandOperand.size === 0) {
          return true;
        }
      } catch (sizeError) {
        return false;
      }
      var leftHandItems = [];
      var rightHandItems = [];
      leftHandOperand.forEach(function gatherEntries(key, value) {
        leftHandItems.push([key, value]);
      });
      rightHandOperand.forEach(function gatherEntries(key, value) {
        rightHandItems.push([key, value]);
      });
      return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
    }
    function iterableEqual(leftHandOperand, rightHandOperand, options) {
      var length = leftHandOperand.length;
      if (length !== rightHandOperand.length) {
        return false;
      }
      if (length === 0) {
        return true;
      }
      var index = -1;
      while (++index < length) {
        if (deepEqual2(leftHandOperand[index], rightHandOperand[index], options) === false) {
          return false;
        }
      }
      return true;
    }
    function generatorEqual(leftHandOperand, rightHandOperand, options) {
      return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
    }
    function hasIteratorFunction(target) {
      return typeof Symbol !== "undefined" && typeof target === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
    }
    function getIteratorEntries(target) {
      if (hasIteratorFunction(target)) {
        try {
          return getGeneratorEntries(target[Symbol.iterator]());
        } catch (iteratorError) {
          return [];
        }
      }
      return [];
    }
    function getGeneratorEntries(generator) {
      var generatorResult = generator.next();
      var accumulator = [generatorResult.value];
      while (generatorResult.done === false) {
        generatorResult = generator.next();
        accumulator.push(generatorResult.value);
      }
      return accumulator;
    }
    function getEnumerableKeys(target) {
      var keys2 = [];
      for (var key in target) {
        keys2.push(key);
      }
      return keys2;
    }
    function getEnumerableSymbols(target) {
      var keys2 = [];
      var allKeys = Object.getOwnPropertySymbols(target);
      for (var i2 = 0; i2 < allKeys.length; i2 += 1) {
        var key = allKeys[i2];
        if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
          keys2.push(key);
        }
      }
      return keys2;
    }
    function keysEqual(leftHandOperand, rightHandOperand, keys2, options) {
      var length = keys2.length;
      if (length === 0) {
        return true;
      }
      for (var i2 = 0; i2 < length; i2 += 1) {
        if (deepEqual2(leftHandOperand[keys2[i2]], rightHandOperand[keys2[i2]], options) === false) {
          return false;
        }
      }
      return true;
    }
    function objectEqual(leftHandOperand, rightHandOperand, options) {
      var leftHandKeys = getEnumerableKeys(leftHandOperand);
      var rightHandKeys = getEnumerableKeys(rightHandOperand);
      var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
      var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
      leftHandKeys = leftHandKeys.concat(leftHandSymbols);
      rightHandKeys = rightHandKeys.concat(rightHandSymbols);
      if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
        if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
          return false;
        }
        return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
      }
      var leftHandEntries = getIteratorEntries(leftHandOperand);
      var rightHandEntries = getIteratorEntries(rightHandOperand);
      if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
        leftHandEntries.sort();
        rightHandEntries.sort();
        return iterableEqual(leftHandEntries, rightHandEntries, options);
      }
      if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
        return true;
      }
      return false;
    }
    function isPrimitive3(value) {
      return value === null || typeof value !== "object";
    }
    function mapSymbols(arr) {
      return arr.map(function mapSymbol(entry) {
        if (typeof entry === "symbol") {
          return entry.toString();
        }
        return entry;
      });
    }
  }
});

// ../../node_modules/chai/lib/chai/utils/isProxyEnabled.js
var require_isProxyEnabled = __commonJS({
  "../../node_modules/chai/lib/chai/utils/isProxyEnabled.js"(exports2, module2) {
    var config2 = require_config();
    module2.exports = function isProxyEnabled() {
      return config2.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/addProperty.js
var require_addProperty = __commonJS({
  "../../node_modules/chai/lib/chai/utils/addProperty.js"(exports2, module2) {
    var chai2 = require_chai();
    var flag = require_flag();
    var isProxyEnabled = require_isProxyEnabled();
    var transferFlags = require_transferFlags();
    module2.exports = function addProperty(ctx, name, getter) {
      getter = getter === void 0 ? function() {
      } : getter;
      Object.defineProperty(
        ctx,
        name,
        {
          get: function propertyGetter() {
            if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
              flag(this, "ssfi", propertyGetter);
            }
            var result2 = getter.call(this);
            if (result2 !== void 0)
              return result2;
            var newAssertion = new chai2.Assertion();
            transferFlags(this, newAssertion);
            return newAssertion;
          },
          configurable: true
        }
      );
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/addLengthGuard.js
var require_addLengthGuard = __commonJS({
  "../../node_modules/chai/lib/chai/utils/addLengthGuard.js"(exports2, module2) {
    var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
    }, "length");
    module2.exports = function addLengthGuard(fn, assertionName, isChainable) {
      if (!fnLengthDesc.configurable) return fn;
      Object.defineProperty(fn, "length", {
        get: function() {
          if (isChainable) {
            throw Error("Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
          }
          throw Error("Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".');
        }
      });
      return fn;
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/getProperties.js
var require_getProperties = __commonJS({
  "../../node_modules/chai/lib/chai/utils/getProperties.js"(exports2, module2) {
    module2.exports = function getProperties(object) {
      var result2 = Object.getOwnPropertyNames(object);
      function addProperty(property2) {
        if (result2.indexOf(property2) === -1) {
          result2.push(property2);
        }
      }
      var proto = Object.getPrototypeOf(object);
      while (proto !== null) {
        Object.getOwnPropertyNames(proto).forEach(addProperty);
        proto = Object.getPrototypeOf(proto);
      }
      return result2;
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/proxify.js
var require_proxify = __commonJS({
  "../../node_modules/chai/lib/chai/utils/proxify.js"(exports2, module2) {
    var config2 = require_config();
    var flag = require_flag();
    var getProperties = require_getProperties();
    var isProxyEnabled = require_isProxyEnabled();
    var builtins = ["__flags", "__methods", "_obj", "assert"];
    module2.exports = function proxify(obj, nonChainableMethodName) {
      if (!isProxyEnabled()) return obj;
      return new Proxy(obj, {
        get: function proxyGetter(target, property2) {
          if (typeof property2 === "string" && config2.proxyExcludedKeys.indexOf(property2) === -1 && !Reflect.has(target, property2)) {
            if (nonChainableMethodName) {
              throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property2 + '. See docs for proper usage of "' + nonChainableMethodName + '".');
            }
            var suggestion = null;
            var suggestionDistance = 4;
            getProperties(target).forEach(function(prop) {
              if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
                var dist = stringDistanceCapped(
                  property2,
                  prop,
                  suggestionDistance
                );
                if (dist < suggestionDistance) {
                  suggestion = prop;
                  suggestionDistance = dist;
                }
              }
            });
            if (suggestion !== null) {
              throw Error("Invalid Chai property: " + property2 + '. Did you mean "' + suggestion + '"?');
            } else {
              throw Error("Invalid Chai property: " + property2);
            }
          }
          if (builtins.indexOf(property2) === -1 && !flag(target, "lockSsfi")) {
            flag(target, "ssfi", proxyGetter);
          }
          return Reflect.get(target, property2);
        }
      });
    };
    function stringDistanceCapped(strA, strB, cap) {
      if (Math.abs(strA.length - strB.length) >= cap) {
        return cap;
      }
      var memo = [];
      for (var i2 = 0; i2 <= strA.length; i2++) {
        memo[i2] = Array(strB.length + 1).fill(0);
        memo[i2][0] = i2;
      }
      for (var j3 = 0; j3 < strB.length; j3++) {
        memo[0][j3] = j3;
      }
      for (var i2 = 1; i2 <= strA.length; i2++) {
        var ch = strA.charCodeAt(i2 - 1);
        for (var j3 = 1; j3 <= strB.length; j3++) {
          if (Math.abs(i2 - j3) >= cap) {
            memo[i2][j3] = cap;
            continue;
          }
          memo[i2][j3] = Math.min(
            memo[i2 - 1][j3] + 1,
            memo[i2][j3 - 1] + 1,
            memo[i2 - 1][j3 - 1] + (ch === strB.charCodeAt(j3 - 1) ? 0 : 1)
          );
        }
      }
      return memo[strA.length][strB.length];
    }
  }
});

// ../../node_modules/chai/lib/chai/utils/addMethod.js
var require_addMethod = __commonJS({
  "../../node_modules/chai/lib/chai/utils/addMethod.js"(exports2, module2) {
    var addLengthGuard = require_addLengthGuard();
    var chai2 = require_chai();
    var flag = require_flag();
    var proxify = require_proxify();
    var transferFlags = require_transferFlags();
    module2.exports = function addMethod(ctx, name, method2) {
      var methodWrapper = function() {
        if (!flag(this, "lockSsfi")) {
          flag(this, "ssfi", methodWrapper);
        }
        var result2 = method2.apply(this, arguments);
        if (result2 !== void 0)
          return result2;
        var newAssertion = new chai2.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };
      addLengthGuard(methodWrapper, name, false);
      ctx[name] = proxify(methodWrapper, name);
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/overwriteProperty.js
var require_overwriteProperty = __commonJS({
  "../../node_modules/chai/lib/chai/utils/overwriteProperty.js"(exports2, module2) {
    var chai2 = require_chai();
    var flag = require_flag();
    var isProxyEnabled = require_isProxyEnabled();
    var transferFlags = require_transferFlags();
    module2.exports = function overwriteProperty(ctx, name, getter) {
      var _get = Object.getOwnPropertyDescriptor(ctx, name), _super = function() {
      };
      if (_get && "function" === typeof _get.get)
        _super = _get.get;
      Object.defineProperty(
        ctx,
        name,
        {
          get: function overwritingPropertyGetter() {
            if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
              flag(this, "ssfi", overwritingPropertyGetter);
            }
            var origLockSsfi = flag(this, "lockSsfi");
            flag(this, "lockSsfi", true);
            var result2 = getter(_super).call(this);
            flag(this, "lockSsfi", origLockSsfi);
            if (result2 !== void 0) {
              return result2;
            }
            var newAssertion = new chai2.Assertion();
            transferFlags(this, newAssertion);
            return newAssertion;
          },
          configurable: true
        }
      );
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/overwriteMethod.js
var require_overwriteMethod = __commonJS({
  "../../node_modules/chai/lib/chai/utils/overwriteMethod.js"(exports2, module2) {
    var addLengthGuard = require_addLengthGuard();
    var chai2 = require_chai();
    var flag = require_flag();
    var proxify = require_proxify();
    var transferFlags = require_transferFlags();
    module2.exports = function overwriteMethod(ctx, name, method2) {
      var _method = ctx[name], _super = function() {
        throw new Error(name + " is not a function");
      };
      if (_method && "function" === typeof _method)
        _super = _method;
      var overwritingMethodWrapper = function() {
        if (!flag(this, "lockSsfi")) {
          flag(this, "ssfi", overwritingMethodWrapper);
        }
        var origLockSsfi = flag(this, "lockSsfi");
        flag(this, "lockSsfi", true);
        var result2 = method2(_super).apply(this, arguments);
        flag(this, "lockSsfi", origLockSsfi);
        if (result2 !== void 0) {
          return result2;
        }
        var newAssertion = new chai2.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };
      addLengthGuard(overwritingMethodWrapper, name, false);
      ctx[name] = proxify(overwritingMethodWrapper, name);
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/addChainableMethod.js
var require_addChainableMethod = __commonJS({
  "../../node_modules/chai/lib/chai/utils/addChainableMethod.js"(exports2, module2) {
    var addLengthGuard = require_addLengthGuard();
    var chai2 = require_chai();
    var flag = require_flag();
    var proxify = require_proxify();
    var transferFlags = require_transferFlags();
    var canSetPrototype = typeof Object.setPrototypeOf === "function";
    var testFn = function() {
    };
    var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
      var propDesc = Object.getOwnPropertyDescriptor(testFn, name);
      if (typeof propDesc !== "object")
        return true;
      return !propDesc.configurable;
    });
    var call = Function.prototype.call;
    var apply = Function.prototype.apply;
    module2.exports = function addChainableMethod(ctx, name, method2, chainingBehavior) {
      if (typeof chainingBehavior !== "function") {
        chainingBehavior = function() {
        };
      }
      var chainableBehavior = {
        method: method2,
        chainingBehavior
      };
      if (!ctx.__methods) {
        ctx.__methods = {};
      }
      ctx.__methods[name] = chainableBehavior;
      Object.defineProperty(
        ctx,
        name,
        {
          get: function chainableMethodGetter() {
            chainableBehavior.chainingBehavior.call(this);
            var chainableMethodWrapper = function() {
              if (!flag(this, "lockSsfi")) {
                flag(this, "ssfi", chainableMethodWrapper);
              }
              var result2 = chainableBehavior.method.apply(this, arguments);
              if (result2 !== void 0) {
                return result2;
              }
              var newAssertion = new chai2.Assertion();
              transferFlags(this, newAssertion);
              return newAssertion;
            };
            addLengthGuard(chainableMethodWrapper, name, true);
            if (canSetPrototype) {
              var prototype = Object.create(this);
              prototype.call = call;
              prototype.apply = apply;
              Object.setPrototypeOf(chainableMethodWrapper, prototype);
            } else {
              var asserterNames = Object.getOwnPropertyNames(ctx);
              asserterNames.forEach(function(asserterName) {
                if (excludeNames.indexOf(asserterName) !== -1) {
                  return;
                }
                var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
                Object.defineProperty(chainableMethodWrapper, asserterName, pd);
              });
            }
            transferFlags(this, chainableMethodWrapper);
            return proxify(chainableMethodWrapper);
          },
          configurable: true
        }
      );
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js
var require_overwriteChainableMethod = __commonJS({
  "../../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js"(exports2, module2) {
    var chai2 = require_chai();
    var transferFlags = require_transferFlags();
    module2.exports = function overwriteChainableMethod(ctx, name, method2, chainingBehavior) {
      var chainableBehavior = ctx.__methods[name];
      var _chainingBehavior = chainableBehavior.chainingBehavior;
      chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
        var result2 = chainingBehavior(_chainingBehavior).call(this);
        if (result2 !== void 0) {
          return result2;
        }
        var newAssertion = new chai2.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };
      var _method = chainableBehavior.method;
      chainableBehavior.method = function overwritingChainableMethodWrapper() {
        var result2 = method2(_method).apply(this, arguments);
        if (result2 !== void 0) {
          return result2;
        }
        var newAssertion = new chai2.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/compareByInspect.js
var require_compareByInspect = __commonJS({
  "../../node_modules/chai/lib/chai/utils/compareByInspect.js"(exports2, module2) {
    var inspect = require_inspect();
    module2.exports = function compareByInspect(a2, b2) {
      return inspect(a2) < inspect(b2) ? -1 : 1;
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js
var require_getOwnEnumerablePropertySymbols = __commonJS({
  "../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js"(exports2, module2) {
    module2.exports = function getOwnEnumerablePropertySymbols(obj) {
      if (typeof Object.getOwnPropertySymbols !== "function") return [];
      return Object.getOwnPropertySymbols(obj).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
      });
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js
var require_getOwnEnumerableProperties = __commonJS({
  "../../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js"(exports2, module2) {
    var getOwnEnumerablePropertySymbols = require_getOwnEnumerablePropertySymbols();
    module2.exports = function getOwnEnumerableProperties(obj) {
      return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
    };
  }
});

// ../../node_modules/check-error/index.js
var require_check_error = __commonJS({
  "../../node_modules/check-error/index.js"(exports2, module2) {
    "use strict";
    var getFunctionName2 = require_get_func_name();
    function compatibleInstance(thrown, errorLike) {
      return errorLike instanceof Error && thrown === errorLike;
    }
    function compatibleConstructor(thrown, errorLike) {
      if (errorLike instanceof Error) {
        return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
      } else if (errorLike.prototype instanceof Error || errorLike === Error) {
        return thrown.constructor === errorLike || thrown instanceof errorLike;
      }
      return false;
    }
    function compatibleMessage(thrown, errMatcher) {
      var comparisonString = typeof thrown === "string" ? thrown : thrown.message;
      if (errMatcher instanceof RegExp) {
        return errMatcher.test(comparisonString);
      } else if (typeof errMatcher === "string") {
        return comparisonString.indexOf(errMatcher) !== -1;
      }
      return false;
    }
    function getConstructorName2(errorLike) {
      var constructorName = errorLike;
      if (errorLike instanceof Error) {
        constructorName = getFunctionName2(errorLike.constructor);
      } else if (typeof errorLike === "function") {
        constructorName = getFunctionName2(errorLike);
        if (constructorName === "") {
          var newConstructorName = getFunctionName2(new errorLike());
          constructorName = newConstructorName || constructorName;
        }
      }
      return constructorName;
    }
    function getMessage(errorLike) {
      var msg = "";
      if (errorLike && errorLike.message) {
        msg = errorLike.message;
      } else if (typeof errorLike === "string") {
        msg = errorLike;
      }
      return msg;
    }
    module2.exports = {
      compatibleInstance,
      compatibleConstructor,
      compatibleMessage,
      getMessage,
      getConstructorName: getConstructorName2
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/isNaN.js
var require_isNaN2 = __commonJS({
  "../../node_modules/chai/lib/chai/utils/isNaN.js"(exports2, module2) {
    function isNaN3(value) {
      return value !== value;
    }
    module2.exports = Number.isNaN || isNaN3;
  }
});

// ../../node_modules/chai/lib/chai/utils/getOperator.js
var require_getOperator = __commonJS({
  "../../node_modules/chai/lib/chai/utils/getOperator.js"(exports2, module2) {
    var type = require_type_detect();
    var flag = require_flag();
    function isObjectType(obj) {
      var objectType = type(obj);
      var objectTypes = ["Array", "Object", "function"];
      return objectTypes.indexOf(objectType) !== -1;
    }
    module2.exports = function getOperator(obj, args) {
      var operator = flag(obj, "operator");
      var negate3 = flag(obj, "negate");
      var expected = args[3];
      var msg = negate3 ? args[2] : args[1];
      if (operator) {
        return operator;
      }
      if (typeof msg === "function") msg = msg();
      msg = msg || "";
      if (!msg) {
        return void 0;
      }
      if (/\shave\s/.test(msg)) {
        return void 0;
      }
      var isObject2 = isObjectType(expected);
      if (/\snot\s/.test(msg)) {
        return isObject2 ? "notDeepStrictEqual" : "notStrictEqual";
      }
      return isObject2 ? "deepStrictEqual" : "strictEqual";
    };
  }
});

// ../../node_modules/chai/lib/chai/utils/index.js
var require_utils5 = __commonJS({
  "../../node_modules/chai/lib/chai/utils/index.js"(exports2) {
    var pathval = require_pathval();
    exports2.test = require_test();
    exports2.type = require_type_detect();
    exports2.expectTypes = require_expectTypes();
    exports2.getMessage = require_getMessage();
    exports2.getActual = require_getActual();
    exports2.inspect = require_inspect();
    exports2.objDisplay = require_objDisplay();
    exports2.flag = require_flag();
    exports2.transferFlags = require_transferFlags();
    exports2.eql = require_deep_eql();
    exports2.getPathInfo = pathval.getPathInfo;
    exports2.hasProperty = pathval.hasProperty;
    exports2.getName = require_get_func_name();
    exports2.addProperty = require_addProperty();
    exports2.addMethod = require_addMethod();
    exports2.overwriteProperty = require_overwriteProperty();
    exports2.overwriteMethod = require_overwriteMethod();
    exports2.addChainableMethod = require_addChainableMethod();
    exports2.overwriteChainableMethod = require_overwriteChainableMethod();
    exports2.compareByInspect = require_compareByInspect();
    exports2.getOwnEnumerablePropertySymbols = require_getOwnEnumerablePropertySymbols();
    exports2.getOwnEnumerableProperties = require_getOwnEnumerableProperties();
    exports2.checkError = require_check_error();
    exports2.proxify = require_proxify();
    exports2.addLengthGuard = require_addLengthGuard();
    exports2.isProxyEnabled = require_isProxyEnabled();
    exports2.isNaN = require_isNaN2();
    exports2.getOperator = require_getOperator();
  }
});

// ../../node_modules/chai/lib/chai/assertion.js
var require_assertion = __commonJS({
  "../../node_modules/chai/lib/chai/assertion.js"(exports2, module2) {
    var config2 = require_config();
    module2.exports = function(_chai, util2) {
      var AssertionError2 = _chai.AssertionError, flag = util2.flag;
      _chai.Assertion = Assertion2;
      function Assertion2(obj, msg, ssfi, lockSsfi) {
        flag(this, "ssfi", ssfi || Assertion2);
        flag(this, "lockSsfi", lockSsfi);
        flag(this, "object", obj);
        flag(this, "message", msg);
        flag(this, "eql", config2.deepEqual || util2.eql);
        return util2.proxify(this);
      }
      Object.defineProperty(Assertion2, "includeStack", {
        get: function() {
          console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
          return config2.includeStack;
        },
        set: function(value) {
          console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
          config2.includeStack = value;
        }
      });
      Object.defineProperty(Assertion2, "showDiff", {
        get: function() {
          console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
          return config2.showDiff;
        },
        set: function(value) {
          console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
          config2.showDiff = value;
        }
      });
      Assertion2.addProperty = function(name, fn) {
        util2.addProperty(this.prototype, name, fn);
      };
      Assertion2.addMethod = function(name, fn) {
        util2.addMethod(this.prototype, name, fn);
      };
      Assertion2.addChainableMethod = function(name, fn, chainingBehavior) {
        util2.addChainableMethod(this.prototype, name, fn, chainingBehavior);
      };
      Assertion2.overwriteProperty = function(name, fn) {
        util2.overwriteProperty(this.prototype, name, fn);
      };
      Assertion2.overwriteMethod = function(name, fn) {
        util2.overwriteMethod(this.prototype, name, fn);
      };
      Assertion2.overwriteChainableMethod = function(name, fn, chainingBehavior) {
        util2.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
      };
      Assertion2.prototype.assert = function(expr, msg, negateMsg, expected, _actual, showDiff) {
        var ok = util2.test(this, arguments);
        if (false !== showDiff) showDiff = true;
        if (void 0 === expected && void 0 === _actual) showDiff = false;
        if (true !== config2.showDiff) showDiff = false;
        if (!ok) {
          msg = util2.getMessage(this, arguments);
          var actual = util2.getActual(this, arguments);
          var assertionErrorObjectProperties = {
            actual,
            expected,
            showDiff
          };
          var operator = util2.getOperator(this, arguments);
          if (operator) {
            assertionErrorObjectProperties.operator = operator;
          }
          throw new AssertionError2(
            msg,
            assertionErrorObjectProperties,
            config2.includeStack ? this.assert : flag(this, "ssfi")
          );
        }
      };
      Object.defineProperty(
        Assertion2.prototype,
        "_obj",
        {
          get: function() {
            return flag(this, "object");
          },
          set: function(val) {
            flag(this, "object", val);
          }
        }
      );
    };
  }
});

// ../../node_modules/chai/lib/chai/core/assertions.js
var require_assertions = __commonJS({
  "../../node_modules/chai/lib/chai/core/assertions.js"(exports2, module2) {
    module2.exports = function(chai2, _2) {
      var Assertion2 = chai2.Assertion, AssertionError2 = chai2.AssertionError, flag = _2.flag;
      [
        "to",
        "be",
        "been",
        "is",
        "and",
        "has",
        "have",
        "with",
        "that",
        "which",
        "at",
        "of",
        "same",
        "but",
        "does",
        "still",
        "also"
      ].forEach(function(chain) {
        Assertion2.addProperty(chain);
      });
      Assertion2.addProperty("not", function() {
        flag(this, "negate", true);
      });
      Assertion2.addProperty("deep", function() {
        flag(this, "deep", true);
      });
      Assertion2.addProperty("nested", function() {
        flag(this, "nested", true);
      });
      Assertion2.addProperty("own", function() {
        flag(this, "own", true);
      });
      Assertion2.addProperty("ordered", function() {
        flag(this, "ordered", true);
      });
      Assertion2.addProperty("any", function() {
        flag(this, "any", true);
        flag(this, "all", false);
      });
      Assertion2.addProperty("all", function() {
        flag(this, "all", true);
        flag(this, "any", false);
      });
      function an(type, msg) {
        if (msg) flag(this, "message", msg);
        type = type.toLowerCase();
        var obj = flag(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type.charAt(0)) ? "an " : "a ";
        this.assert(
          type === _2.type(obj).toLowerCase(),
          "expected #{this} to be " + article + type,
          "expected #{this} not to be " + article + type
        );
      }
      Assertion2.addChainableMethod("an", an);
      Assertion2.addChainableMethod("a", an);
      function SameValueZero(a2, b2) {
        return _2.isNaN(a2) && _2.isNaN(b2) || a2 === b2;
      }
      function includeChainingBehavior() {
        flag(this, "contains", true);
      }
      function include(val, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), objType = _2.type(obj).toLowerCase(), flagMsg = flag(this, "message"), negate3 = flag(this, "negate"), ssfi = flag(this, "ssfi"), isDeep = flag(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag(this, "eql") : SameValueZero;
        flagMsg = flagMsg ? flagMsg + ": " : "";
        var included = false;
        switch (objType) {
          case "string":
            included = obj.indexOf(val) !== -1;
            break;
          case "weakset":
            if (isDeep) {
              throw new AssertionError2(
                flagMsg + "unable to use .deep.include with WeakSet",
                void 0,
                ssfi
              );
            }
            included = obj.has(val);
            break;
          case "map":
            obj.forEach(function(item) {
              included = included || isEql(item, val);
            });
            break;
          case "set":
            if (isDeep) {
              obj.forEach(function(item) {
                included = included || isEql(item, val);
              });
            } else {
              included = obj.has(val);
            }
            break;
          case "array":
            if (isDeep) {
              included = obj.some(function(item) {
                return isEql(item, val);
              });
            } else {
              included = obj.indexOf(val) !== -1;
            }
            break;
          default:
            if (val !== Object(val)) {
              throw new AssertionError2(
                flagMsg + "the given combination of arguments (" + objType + " and " + _2.type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + _2.type(val).toLowerCase(),
                void 0,
                ssfi
              );
            }
            var props = Object.keys(val), firstErr = null, numErrs = 0;
            props.forEach(function(prop) {
              var propAssertion = new Assertion2(obj);
              _2.transferFlags(this, propAssertion, true);
              flag(propAssertion, "lockSsfi", true);
              if (!negate3 || props.length === 1) {
                propAssertion.property(prop, val[prop]);
                return;
              }
              try {
                propAssertion.property(prop, val[prop]);
              } catch (err) {
                if (!_2.checkError.compatibleConstructor(err, AssertionError2)) {
                  throw err;
                }
                if (firstErr === null) firstErr = err;
                numErrs++;
              }
            }, this);
            if (negate3 && props.length > 1 && numErrs === props.length) {
              throw firstErr;
            }
            return;
        }
        this.assert(
          included,
          "expected #{this} to " + descriptor + "include " + _2.inspect(val),
          "expected #{this} to not " + descriptor + "include " + _2.inspect(val)
        );
      }
      Assertion2.addChainableMethod("include", include, includeChainingBehavior);
      Assertion2.addChainableMethod("contain", include, includeChainingBehavior);
      Assertion2.addChainableMethod("contains", include, includeChainingBehavior);
      Assertion2.addChainableMethod("includes", include, includeChainingBehavior);
      Assertion2.addProperty("ok", function() {
        this.assert(
          flag(this, "object"),
          "expected #{this} to be truthy",
          "expected #{this} to be falsy"
        );
      });
      Assertion2.addProperty("true", function() {
        this.assert(
          true === flag(this, "object"),
          "expected #{this} to be true",
          "expected #{this} to be false",
          flag(this, "negate") ? false : true
        );
      });
      Assertion2.addProperty("false", function() {
        this.assert(
          false === flag(this, "object"),
          "expected #{this} to be false",
          "expected #{this} to be true",
          flag(this, "negate") ? true : false
        );
      });
      Assertion2.addProperty("null", function() {
        this.assert(
          null === flag(this, "object"),
          "expected #{this} to be null",
          "expected #{this} not to be null"
        );
      });
      Assertion2.addProperty("undefined", function() {
        this.assert(
          void 0 === flag(this, "object"),
          "expected #{this} to be undefined",
          "expected #{this} not to be undefined"
        );
      });
      Assertion2.addProperty("NaN", function() {
        this.assert(
          _2.isNaN(flag(this, "object")),
          "expected #{this} to be NaN",
          "expected #{this} not to be NaN"
        );
      });
      function assertExist() {
        var val = flag(this, "object");
        this.assert(
          val !== null && val !== void 0,
          "expected #{this} to exist",
          "expected #{this} to not exist"
        );
      }
      Assertion2.addProperty("exist", assertExist);
      Assertion2.addProperty("exists", assertExist);
      Assertion2.addProperty("empty", function() {
        var val = flag(this, "object"), ssfi = flag(this, "ssfi"), flagMsg = flag(this, "message"), itemsCount;
        flagMsg = flagMsg ? flagMsg + ": " : "";
        switch (_2.type(val).toLowerCase()) {
          case "array":
          case "string":
            itemsCount = val.length;
            break;
          case "map":
          case "set":
            itemsCount = val.size;
            break;
          case "weakmap":
          case "weakset":
            throw new AssertionError2(
              flagMsg + ".empty was passed a weak collection",
              void 0,
              ssfi
            );
          case "function":
            var msg = flagMsg + ".empty was passed a function " + _2.getName(val);
            throw new AssertionError2(msg.trim(), void 0, ssfi);
          default:
            if (val !== Object(val)) {
              throw new AssertionError2(
                flagMsg + ".empty was passed non-string primitive " + _2.inspect(val),
                void 0,
                ssfi
              );
            }
            itemsCount = Object.keys(val).length;
        }
        this.assert(
          0 === itemsCount,
          "expected #{this} to be empty",
          "expected #{this} not to be empty"
        );
      });
      function checkArguments() {
        var obj = flag(this, "object"), type = _2.type(obj);
        this.assert(
          "Arguments" === type,
          "expected #{this} to be arguments but got " + type,
          "expected #{this} to not be arguments"
        );
      }
      Assertion2.addProperty("arguments", checkArguments);
      Assertion2.addProperty("Arguments", checkArguments);
      function assertEqual(val, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        if (flag(this, "deep")) {
          var prevLockSsfi = flag(this, "lockSsfi");
          flag(this, "lockSsfi", true);
          this.eql(val);
          flag(this, "lockSsfi", prevLockSsfi);
        } else {
          this.assert(
            val === obj,
            "expected #{this} to equal #{exp}",
            "expected #{this} to not equal #{exp}",
            val,
            this._obj,
            true
          );
        }
      }
      Assertion2.addMethod("equal", assertEqual);
      Assertion2.addMethod("equals", assertEqual);
      Assertion2.addMethod("eq", assertEqual);
      function assertEql(obj, msg) {
        if (msg) flag(this, "message", msg);
        var eql = flag(this, "eql");
        this.assert(
          eql(obj, flag(this, "object")),
          "expected #{this} to deeply equal #{exp}",
          "expected #{this} to not deeply equal #{exp}",
          obj,
          this._obj,
          true
        );
      }
      Assertion2.addMethod("eql", assertEql);
      Assertion2.addMethod("eqls", assertEql);
      function assertAbove(n2, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _2.type(obj).toLowerCase(), nType = _2.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
        if (doLength && objType !== "map" && objType !== "set") {
          new Assertion2(obj, flagMsg, ssfi, true).to.have.property("length");
        }
        if (!doLength && (objType === "date" && nType !== "date")) {
          errorMessage = msgPrefix + "the argument to above must be a date";
        } else if (nType !== "number" && (doLength || objType === "number")) {
          errorMessage = msgPrefix + "the argument to above must be a number";
        } else if (!doLength && (objType !== "date" && objType !== "number")) {
          var printObj = objType === "string" ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
        } else {
          shouldThrow = false;
        }
        if (shouldThrow) {
          throw new AssertionError2(errorMessage, void 0, ssfi);
        }
        if (doLength) {
          var descriptor = "length", itemsCount;
          if (objType === "map" || objType === "set") {
            descriptor = "size";
            itemsCount = obj.size;
          } else {
            itemsCount = obj.length;
          }
          this.assert(
            itemsCount > n2,
            "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
            "expected #{this} to not have a " + descriptor + " above #{exp}",
            n2,
            itemsCount
          );
        } else {
          this.assert(
            obj > n2,
            "expected #{this} to be above #{exp}",
            "expected #{this} to be at most #{exp}",
            n2
          );
        }
      }
      Assertion2.addMethod("above", assertAbove);
      Assertion2.addMethod("gt", assertAbove);
      Assertion2.addMethod("greaterThan", assertAbove);
      function assertLeast(n2, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _2.type(obj).toLowerCase(), nType = _2.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
        if (doLength && objType !== "map" && objType !== "set") {
          new Assertion2(obj, flagMsg, ssfi, true).to.have.property("length");
        }
        if (!doLength && (objType === "date" && nType !== "date")) {
          errorMessage = msgPrefix + "the argument to least must be a date";
        } else if (nType !== "number" && (doLength || objType === "number")) {
          errorMessage = msgPrefix + "the argument to least must be a number";
        } else if (!doLength && (objType !== "date" && objType !== "number")) {
          var printObj = objType === "string" ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
        } else {
          shouldThrow = false;
        }
        if (shouldThrow) {
          throw new AssertionError2(errorMessage, void 0, ssfi);
        }
        if (doLength) {
          var descriptor = "length", itemsCount;
          if (objType === "map" || objType === "set") {
            descriptor = "size";
            itemsCount = obj.size;
          } else {
            itemsCount = obj.length;
          }
          this.assert(
            itemsCount >= n2,
            "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
            "expected #{this} to have a " + descriptor + " below #{exp}",
            n2,
            itemsCount
          );
        } else {
          this.assert(
            obj >= n2,
            "expected #{this} to be at least #{exp}",
            "expected #{this} to be below #{exp}",
            n2
          );
        }
      }
      Assertion2.addMethod("least", assertLeast);
      Assertion2.addMethod("gte", assertLeast);
      Assertion2.addMethod("greaterThanOrEqual", assertLeast);
      function assertBelow(n2, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _2.type(obj).toLowerCase(), nType = _2.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
        if (doLength && objType !== "map" && objType !== "set") {
          new Assertion2(obj, flagMsg, ssfi, true).to.have.property("length");
        }
        if (!doLength && (objType === "date" && nType !== "date")) {
          errorMessage = msgPrefix + "the argument to below must be a date";
        } else if (nType !== "number" && (doLength || objType === "number")) {
          errorMessage = msgPrefix + "the argument to below must be a number";
        } else if (!doLength && (objType !== "date" && objType !== "number")) {
          var printObj = objType === "string" ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
        } else {
          shouldThrow = false;
        }
        if (shouldThrow) {
          throw new AssertionError2(errorMessage, void 0, ssfi);
        }
        if (doLength) {
          var descriptor = "length", itemsCount;
          if (objType === "map" || objType === "set") {
            descriptor = "size";
            itemsCount = obj.size;
          } else {
            itemsCount = obj.length;
          }
          this.assert(
            itemsCount < n2,
            "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
            "expected #{this} to not have a " + descriptor + " below #{exp}",
            n2,
            itemsCount
          );
        } else {
          this.assert(
            obj < n2,
            "expected #{this} to be below #{exp}",
            "expected #{this} to be at least #{exp}",
            n2
          );
        }
      }
      Assertion2.addMethod("below", assertBelow);
      Assertion2.addMethod("lt", assertBelow);
      Assertion2.addMethod("lessThan", assertBelow);
      function assertMost(n2, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _2.type(obj).toLowerCase(), nType = _2.type(n2).toLowerCase(), errorMessage, shouldThrow = true;
        if (doLength && objType !== "map" && objType !== "set") {
          new Assertion2(obj, flagMsg, ssfi, true).to.have.property("length");
        }
        if (!doLength && (objType === "date" && nType !== "date")) {
          errorMessage = msgPrefix + "the argument to most must be a date";
        } else if (nType !== "number" && (doLength || objType === "number")) {
          errorMessage = msgPrefix + "the argument to most must be a number";
        } else if (!doLength && (objType !== "date" && objType !== "number")) {
          var printObj = objType === "string" ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
        } else {
          shouldThrow = false;
        }
        if (shouldThrow) {
          throw new AssertionError2(errorMessage, void 0, ssfi);
        }
        if (doLength) {
          var descriptor = "length", itemsCount;
          if (objType === "map" || objType === "set") {
            descriptor = "size";
            itemsCount = obj.size;
          } else {
            itemsCount = obj.length;
          }
          this.assert(
            itemsCount <= n2,
            "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
            "expected #{this} to have a " + descriptor + " above #{exp}",
            n2,
            itemsCount
          );
        } else {
          this.assert(
            obj <= n2,
            "expected #{this} to be at most #{exp}",
            "expected #{this} to be above #{exp}",
            n2
          );
        }
      }
      Assertion2.addMethod("most", assertMost);
      Assertion2.addMethod("lte", assertMost);
      Assertion2.addMethod("lessThanOrEqual", assertMost);
      Assertion2.addMethod("within", function(start, finish, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), doLength = flag(this, "doLength"), flagMsg = flag(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag(this, "ssfi"), objType = _2.type(obj).toLowerCase(), startType = _2.type(start).toLowerCase(), finishType = _2.type(finish).toLowerCase(), errorMessage, shouldThrow = true, range3 = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
        if (doLength && objType !== "map" && objType !== "set") {
          new Assertion2(obj, flagMsg, ssfi, true).to.have.property("length");
        }
        if (!doLength && (objType === "date" && (startType !== "date" || finishType !== "date"))) {
          errorMessage = msgPrefix + "the arguments to within must be dates";
        } else if ((startType !== "number" || finishType !== "number") && (doLength || objType === "number")) {
          errorMessage = msgPrefix + "the arguments to within must be numbers";
        } else if (!doLength && (objType !== "date" && objType !== "number")) {
          var printObj = objType === "string" ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
        } else {
          shouldThrow = false;
        }
        if (shouldThrow) {
          throw new AssertionError2(errorMessage, void 0, ssfi);
        }
        if (doLength) {
          var descriptor = "length", itemsCount;
          if (objType === "map" || objType === "set") {
            descriptor = "size";
            itemsCount = obj.size;
          } else {
            itemsCount = obj.length;
          }
          this.assert(
            itemsCount >= start && itemsCount <= finish,
            "expected #{this} to have a " + descriptor + " within " + range3,
            "expected #{this} to not have a " + descriptor + " within " + range3
          );
        } else {
          this.assert(
            obj >= start && obj <= finish,
            "expected #{this} to be within " + range3,
            "expected #{this} to not be within " + range3
          );
        }
      });
      function assertInstanceOf(constructor, msg) {
        if (msg) flag(this, "message", msg);
        var target = flag(this, "object");
        var ssfi = flag(this, "ssfi");
        var flagMsg = flag(this, "message");
        try {
          var isInstanceOf2 = target instanceof constructor;
        } catch (err) {
          if (err instanceof TypeError) {
            flagMsg = flagMsg ? flagMsg + ": " : "";
            throw new AssertionError2(
              flagMsg + "The instanceof assertion needs a constructor but " + _2.type(constructor) + " was given.",
              void 0,
              ssfi
            );
          }
          throw err;
        }
        var name = _2.getName(constructor);
        if (name === null) {
          name = "an unnamed constructor";
        }
        this.assert(
          isInstanceOf2,
          "expected #{this} to be an instance of " + name,
          "expected #{this} to not be an instance of " + name
        );
      }
      ;
      Assertion2.addMethod("instanceof", assertInstanceOf);
      Assertion2.addMethod("instanceOf", assertInstanceOf);
      function assertProperty(name, val, msg) {
        if (msg) flag(this, "message", msg);
        var isNested = flag(this, "nested"), isOwn = flag(this, "own"), flagMsg = flag(this, "message"), obj = flag(this, "object"), ssfi = flag(this, "ssfi"), nameType = typeof name;
        flagMsg = flagMsg ? flagMsg + ": " : "";
        if (isNested) {
          if (nameType !== "string") {
            throw new AssertionError2(
              flagMsg + "the argument to property must be a string when using nested syntax",
              void 0,
              ssfi
            );
          }
        } else {
          if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") {
            throw new AssertionError2(
              flagMsg + "the argument to property must be a string, number, or symbol",
              void 0,
              ssfi
            );
          }
        }
        if (isNested && isOwn) {
          throw new AssertionError2(
            flagMsg + 'The "nested" and "own" flags cannot be combined.',
            void 0,
            ssfi
          );
        }
        if (obj === null || obj === void 0) {
          throw new AssertionError2(
            flagMsg + "Target cannot be null or undefined.",
            void 0,
            ssfi
          );
        }
        var isDeep = flag(this, "deep"), negate3 = flag(this, "negate"), pathInfo = isNested ? _2.getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag(this, "eql") : (val1, val2) => val1 === val2;
        ;
        var descriptor = "";
        if (isDeep) descriptor += "deep ";
        if (isOwn) descriptor += "own ";
        if (isNested) descriptor += "nested ";
        descriptor += "property ";
        var hasProperty;
        if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);
        else if (isNested) hasProperty = pathInfo.exists;
        else hasProperty = _2.hasProperty(obj, name);
        if (!negate3 || arguments.length === 1) {
          this.assert(
            hasProperty,
            "expected #{this} to have " + descriptor + _2.inspect(name),
            "expected #{this} to not have " + descriptor + _2.inspect(name)
          );
        }
        if (arguments.length > 1) {
          this.assert(
            hasProperty && isEql(val, value),
            "expected #{this} to have " + descriptor + _2.inspect(name) + " of #{exp}, but got #{act}",
            "expected #{this} to not have " + descriptor + _2.inspect(name) + " of #{act}",
            val,
            value
          );
        }
        flag(this, "object", value);
      }
      Assertion2.addMethod("property", assertProperty);
      function assertOwnProperty(name, value, msg) {
        flag(this, "own", true);
        assertProperty.apply(this, arguments);
      }
      Assertion2.addMethod("ownProperty", assertOwnProperty);
      Assertion2.addMethod("haveOwnProperty", assertOwnProperty);
      function assertOwnPropertyDescriptor(name, descriptor, msg) {
        if (typeof descriptor === "string") {
          msg = descriptor;
          descriptor = null;
        }
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
        var eql = flag(this, "eql");
        if (actualDescriptor && descriptor) {
          this.assert(
            eql(descriptor, actualDescriptor),
            "expected the own property descriptor for " + _2.inspect(name) + " on #{this} to match " + _2.inspect(descriptor) + ", got " + _2.inspect(actualDescriptor),
            "expected the own property descriptor for " + _2.inspect(name) + " on #{this} to not match " + _2.inspect(descriptor),
            descriptor,
            actualDescriptor,
            true
          );
        } else {
          this.assert(
            actualDescriptor,
            "expected #{this} to have an own property descriptor for " + _2.inspect(name),
            "expected #{this} to not have an own property descriptor for " + _2.inspect(name)
          );
        }
        flag(this, "object", actualDescriptor);
      }
      Assertion2.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
      Assertion2.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
      function assertLengthChain() {
        flag(this, "doLength", true);
      }
      function assertLength(n2, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), objType = _2.type(obj).toLowerCase(), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi"), descriptor = "length", itemsCount;
        switch (objType) {
          case "map":
          case "set":
            descriptor = "size";
            itemsCount = obj.size;
            break;
          default:
            new Assertion2(obj, flagMsg, ssfi, true).to.have.property("length");
            itemsCount = obj.length;
        }
        this.assert(
          itemsCount == n2,
          "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
          "expected #{this} to not have a " + descriptor + " of #{act}",
          n2,
          itemsCount
        );
      }
      Assertion2.addChainableMethod("length", assertLength, assertLengthChain);
      Assertion2.addChainableMethod("lengthOf", assertLength, assertLengthChain);
      function assertMatch(re3, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        this.assert(
          re3.exec(obj),
          "expected #{this} to match " + re3,
          "expected #{this} not to match " + re3
        );
      }
      Assertion2.addMethod("match", assertMatch);
      Assertion2.addMethod("matches", assertMatch);
      Assertion2.addMethod("string", function(str, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
        new Assertion2(obj, flagMsg, ssfi, true).is.a("string");
        this.assert(
          ~obj.indexOf(str),
          "expected #{this} to contain " + _2.inspect(str),
          "expected #{this} to not contain " + _2.inspect(str)
        );
      });
      function assertKeys(keys2) {
        var obj = flag(this, "object"), objType = _2.type(obj), keysType = _2.type(keys2), ssfi = flag(this, "ssfi"), isDeep = flag(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag(this, "message");
        flagMsg = flagMsg ? flagMsg + ": " : "";
        var mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
        if (objType === "Map" || objType === "Set") {
          deepStr = isDeep ? "deeply " : "";
          actual = [];
          obj.forEach(function(val, key) {
            actual.push(key);
          });
          if (keysType !== "Array") {
            keys2 = Array.prototype.slice.call(arguments);
          }
        } else {
          actual = _2.getOwnEnumerableProperties(obj);
          switch (keysType) {
            case "Array":
              if (arguments.length > 1) {
                throw new AssertionError2(mixedArgsMsg, void 0, ssfi);
              }
              break;
            case "Object":
              if (arguments.length > 1) {
                throw new AssertionError2(mixedArgsMsg, void 0, ssfi);
              }
              keys2 = Object.keys(keys2);
              break;
            default:
              keys2 = Array.prototype.slice.call(arguments);
          }
          keys2 = keys2.map(function(val) {
            return typeof val === "symbol" ? val : String(val);
          });
        }
        if (!keys2.length) {
          throw new AssertionError2(flagMsg + "keys required", void 0, ssfi);
        }
        var len = keys2.length, any = flag(this, "any"), all = flag(this, "all"), expected = keys2, isEql = isDeep ? flag(this, "eql") : (val1, val2) => val1 === val2;
        if (!any && !all) {
          all = true;
        }
        if (any) {
          ok = expected.some(function(expectedKey) {
            return actual.some(function(actualKey) {
              return isEql(expectedKey, actualKey);
            });
          });
        }
        if (all) {
          ok = expected.every(function(expectedKey) {
            return actual.some(function(actualKey) {
              return isEql(expectedKey, actualKey);
            });
          });
          if (!flag(this, "contains")) {
            ok = ok && keys2.length == actual.length;
          }
        }
        if (len > 1) {
          keys2 = keys2.map(function(key) {
            return _2.inspect(key);
          });
          var last3 = keys2.pop();
          if (all) {
            str = keys2.join(", ") + ", and " + last3;
          }
          if (any) {
            str = keys2.join(", ") + ", or " + last3;
          }
        } else {
          str = _2.inspect(keys2[0]);
        }
        str = (len > 1 ? "keys " : "key ") + str;
        str = (flag(this, "contains") ? "contain " : "have ") + str;
        this.assert(
          ok,
          "expected #{this} to " + deepStr + str,
          "expected #{this} to not " + deepStr + str,
          expected.slice(0).sort(_2.compareByInspect),
          actual.sort(_2.compareByInspect),
          true
        );
      }
      Assertion2.addMethod("keys", assertKeys);
      Assertion2.addMethod("key", assertKeys);
      function assertThrows(errorLike, errMsgMatcher, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), ssfi = flag(this, "ssfi"), flagMsg = flag(this, "message"), negate3 = flag(this, "negate") || false;
        new Assertion2(obj, flagMsg, ssfi, true).is.a("function");
        if (errorLike instanceof RegExp || typeof errorLike === "string") {
          errMsgMatcher = errorLike;
          errorLike = null;
        }
        var caughtErr;
        try {
          obj();
        } catch (err) {
          caughtErr = err;
        }
        var everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
        var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
        var errorLikeFail = false;
        var errMsgMatcherFail = false;
        if (everyArgIsUndefined || !everyArgIsUndefined && !negate3) {
          var errorLikeString = "an error";
          if (errorLike instanceof Error) {
            errorLikeString = "#{exp}";
          } else if (errorLike) {
            errorLikeString = _2.checkError.getConstructorName(errorLike);
          }
          this.assert(
            caughtErr,
            "expected #{this} to throw " + errorLikeString,
            "expected #{this} to not throw an error but #{act} was thrown",
            errorLike && errorLike.toString(),
            caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === "string" ? caughtErr : caughtErr && _2.checkError.getConstructorName(caughtErr)
          );
        }
        if (errorLike && caughtErr) {
          if (errorLike instanceof Error) {
            var isCompatibleInstance = _2.checkError.compatibleInstance(caughtErr, errorLike);
            if (isCompatibleInstance === negate3) {
              if (everyArgIsDefined && negate3) {
                errorLikeFail = true;
              } else {
                this.assert(
                  negate3,
                  "expected #{this} to throw #{exp} but #{act} was thrown",
                  "expected #{this} to not throw #{exp}" + (caughtErr && !negate3 ? " but #{act} was thrown" : ""),
                  errorLike.toString(),
                  caughtErr.toString()
                );
              }
            }
          }
          var isCompatibleConstructor = _2.checkError.compatibleConstructor(caughtErr, errorLike);
          if (isCompatibleConstructor === negate3) {
            if (everyArgIsDefined && negate3) {
              errorLikeFail = true;
            } else {
              this.assert(
                negate3,
                "expected #{this} to throw #{exp} but #{act} was thrown",
                "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
                errorLike instanceof Error ? errorLike.toString() : errorLike && _2.checkError.getConstructorName(errorLike),
                caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _2.checkError.getConstructorName(caughtErr)
              );
            }
          }
        }
        if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
          var placeholder = "including";
          if (errMsgMatcher instanceof RegExp) {
            placeholder = "matching";
          }
          var isCompatibleMessage = _2.checkError.compatibleMessage(caughtErr, errMsgMatcher);
          if (isCompatibleMessage === negate3) {
            if (everyArgIsDefined && negate3) {
              errMsgMatcherFail = true;
            } else {
              this.assert(
                negate3,
                "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
                "expected #{this} to throw error not " + placeholder + " #{exp}",
                errMsgMatcher,
                _2.checkError.getMessage(caughtErr)
              );
            }
          }
        }
        if (errorLikeFail && errMsgMatcherFail) {
          this.assert(
            negate3,
            "expected #{this} to throw #{exp} but #{act} was thrown",
            "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
            errorLike instanceof Error ? errorLike.toString() : errorLike && _2.checkError.getConstructorName(errorLike),
            caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _2.checkError.getConstructorName(caughtErr)
          );
        }
        flag(this, "object", caughtErr);
      }
      ;
      Assertion2.addMethod("throw", assertThrows);
      Assertion2.addMethod("throws", assertThrows);
      Assertion2.addMethod("Throw", assertThrows);
      function respondTo(method2, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), itself = flag(this, "itself"), context = "function" === typeof obj && !itself ? obj.prototype[method2] : obj[method2];
        this.assert(
          "function" === typeof context,
          "expected #{this} to respond to " + _2.inspect(method2),
          "expected #{this} to not respond to " + _2.inspect(method2)
        );
      }
      Assertion2.addMethod("respondTo", respondTo);
      Assertion2.addMethod("respondsTo", respondTo);
      Assertion2.addProperty("itself", function() {
        flag(this, "itself", true);
      });
      function satisfy(matcher, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        var result2 = matcher(obj);
        this.assert(
          result2,
          "expected #{this} to satisfy " + _2.objDisplay(matcher),
          "expected #{this} to not satisfy" + _2.objDisplay(matcher),
          flag(this, "negate") ? false : true,
          result2
        );
      }
      Assertion2.addMethod("satisfy", satisfy);
      Assertion2.addMethod("satisfies", satisfy);
      function closeTo(expected, delta, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
        new Assertion2(obj, flagMsg, ssfi, true).is.a("number");
        if (typeof expected !== "number" || typeof delta !== "number") {
          flagMsg = flagMsg ? flagMsg + ": " : "";
          var deltaMessage = delta === void 0 ? ", and a delta is required" : "";
          throw new AssertionError2(
            flagMsg + "the arguments to closeTo or approximately must be numbers" + deltaMessage,
            void 0,
            ssfi
          );
        }
        this.assert(
          Math.abs(obj - expected) <= delta,
          "expected #{this} to be close to " + expected + " +/- " + delta,
          "expected #{this} not to be close to " + expected + " +/- " + delta
        );
      }
      Assertion2.addMethod("closeTo", closeTo);
      Assertion2.addMethod("approximately", closeTo);
      function isSubsetOf(subset, superset, cmp, contains, ordered) {
        if (!contains) {
          if (subset.length !== superset.length) return false;
          superset = superset.slice();
        }
        return subset.every(function(elem, idx) {
          if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
          if (!cmp) {
            var matchIdx = superset.indexOf(elem);
            if (matchIdx === -1) return false;
            if (!contains) superset.splice(matchIdx, 1);
            return true;
          }
          return superset.some(function(elem2, matchIdx2) {
            if (!cmp(elem, elem2)) return false;
            if (!contains) superset.splice(matchIdx2, 1);
            return true;
          });
        });
      }
      Assertion2.addMethod("members", function(subset, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
        new Assertion2(obj, flagMsg, ssfi, true).to.be.an("array");
        new Assertion2(subset, flagMsg, ssfi, true).to.be.an("array");
        var contains = flag(this, "contains");
        var ordered = flag(this, "ordered");
        var subject, failMsg, failNegateMsg;
        if (contains) {
          subject = ordered ? "an ordered superset" : "a superset";
          failMsg = "expected #{this} to be " + subject + " of #{exp}";
          failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
        } else {
          subject = ordered ? "ordered members" : "members";
          failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
          failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
        }
        var cmp = flag(this, "deep") ? flag(this, "eql") : void 0;
        this.assert(
          isSubsetOf(subset, obj, cmp, contains, ordered),
          failMsg,
          failNegateMsg,
          subset,
          obj,
          true
        );
      });
      function oneOf(list, msg) {
        if (msg) flag(this, "message", msg);
        var expected = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi"), contains = flag(this, "contains"), isDeep = flag(this, "deep"), eql = flag(this, "eql");
        new Assertion2(list, flagMsg, ssfi, true).to.be.an("array");
        if (contains) {
          this.assert(
            list.some(function(possibility) {
              return expected.indexOf(possibility) > -1;
            }),
            "expected #{this} to contain one of #{exp}",
            "expected #{this} to not contain one of #{exp}",
            list,
            expected
          );
        } else {
          if (isDeep) {
            this.assert(
              list.some(function(possibility) {
                return eql(expected, possibility);
              }),
              "expected #{this} to deeply equal one of #{exp}",
              "expected #{this} to deeply equal one of #{exp}",
              list,
              expected
            );
          } else {
            this.assert(
              list.indexOf(expected) > -1,
              "expected #{this} to be one of #{exp}",
              "expected #{this} to not be one of #{exp}",
              list,
              expected
            );
          }
        }
      }
      Assertion2.addMethod("oneOf", oneOf);
      function assertChanges(subject, prop, msg) {
        if (msg) flag(this, "message", msg);
        var fn = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
        new Assertion2(fn, flagMsg, ssfi, true).is.a("function");
        var initial3;
        if (!prop) {
          new Assertion2(subject, flagMsg, ssfi, true).is.a("function");
          initial3 = subject();
        } else {
          new Assertion2(subject, flagMsg, ssfi, true).to.have.property(prop);
          initial3 = subject[prop];
        }
        fn();
        var final = prop === void 0 || prop === null ? subject() : subject[prop];
        var msgObj = prop === void 0 || prop === null ? initial3 : "." + prop;
        flag(this, "deltaMsgObj", msgObj);
        flag(this, "initialDeltaValue", initial3);
        flag(this, "finalDeltaValue", final);
        flag(this, "deltaBehavior", "change");
        flag(this, "realDelta", final !== initial3);
        this.assert(
          initial3 !== final,
          "expected " + msgObj + " to change",
          "expected " + msgObj + " to not change"
        );
      }
      Assertion2.addMethod("change", assertChanges);
      Assertion2.addMethod("changes", assertChanges);
      function assertIncreases(subject, prop, msg) {
        if (msg) flag(this, "message", msg);
        var fn = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
        new Assertion2(fn, flagMsg, ssfi, true).is.a("function");
        var initial3;
        if (!prop) {
          new Assertion2(subject, flagMsg, ssfi, true).is.a("function");
          initial3 = subject();
        } else {
          new Assertion2(subject, flagMsg, ssfi, true).to.have.property(prop);
          initial3 = subject[prop];
        }
        new Assertion2(initial3, flagMsg, ssfi, true).is.a("number");
        fn();
        var final = prop === void 0 || prop === null ? subject() : subject[prop];
        var msgObj = prop === void 0 || prop === null ? initial3 : "." + prop;
        flag(this, "deltaMsgObj", msgObj);
        flag(this, "initialDeltaValue", initial3);
        flag(this, "finalDeltaValue", final);
        flag(this, "deltaBehavior", "increase");
        flag(this, "realDelta", final - initial3);
        this.assert(
          final - initial3 > 0,
          "expected " + msgObj + " to increase",
          "expected " + msgObj + " to not increase"
        );
      }
      Assertion2.addMethod("increase", assertIncreases);
      Assertion2.addMethod("increases", assertIncreases);
      function assertDecreases(subject, prop, msg) {
        if (msg) flag(this, "message", msg);
        var fn = flag(this, "object"), flagMsg = flag(this, "message"), ssfi = flag(this, "ssfi");
        new Assertion2(fn, flagMsg, ssfi, true).is.a("function");
        var initial3;
        if (!prop) {
          new Assertion2(subject, flagMsg, ssfi, true).is.a("function");
          initial3 = subject();
        } else {
          new Assertion2(subject, flagMsg, ssfi, true).to.have.property(prop);
          initial3 = subject[prop];
        }
        new Assertion2(initial3, flagMsg, ssfi, true).is.a("number");
        fn();
        var final = prop === void 0 || prop === null ? subject() : subject[prop];
        var msgObj = prop === void 0 || prop === null ? initial3 : "." + prop;
        flag(this, "deltaMsgObj", msgObj);
        flag(this, "initialDeltaValue", initial3);
        flag(this, "finalDeltaValue", final);
        flag(this, "deltaBehavior", "decrease");
        flag(this, "realDelta", initial3 - final);
        this.assert(
          final - initial3 < 0,
          "expected " + msgObj + " to decrease",
          "expected " + msgObj + " to not decrease"
        );
      }
      Assertion2.addMethod("decrease", assertDecreases);
      Assertion2.addMethod("decreases", assertDecreases);
      function assertDelta(delta, msg) {
        if (msg) flag(this, "message", msg);
        var msgObj = flag(this, "deltaMsgObj");
        var initial3 = flag(this, "initialDeltaValue");
        var final = flag(this, "finalDeltaValue");
        var behavior = flag(this, "deltaBehavior");
        var realDelta = flag(this, "realDelta");
        var expression;
        if (behavior === "change") {
          expression = Math.abs(final - initial3) === Math.abs(delta);
        } else {
          expression = realDelta === Math.abs(delta);
        }
        this.assert(
          expression,
          "expected " + msgObj + " to " + behavior + " by " + delta,
          "expected " + msgObj + " to not " + behavior + " by " + delta
        );
      }
      Assertion2.addMethod("by", assertDelta);
      Assertion2.addProperty("extensible", function() {
        var obj = flag(this, "object");
        var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
        this.assert(
          isExtensible,
          "expected #{this} to be extensible",
          "expected #{this} to not be extensible"
        );
      });
      Assertion2.addProperty("sealed", function() {
        var obj = flag(this, "object");
        var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
        this.assert(
          isSealed,
          "expected #{this} to be sealed",
          "expected #{this} to not be sealed"
        );
      });
      Assertion2.addProperty("frozen", function() {
        var obj = flag(this, "object");
        var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
        this.assert(
          isFrozen,
          "expected #{this} to be frozen",
          "expected #{this} to not be frozen"
        );
      });
      Assertion2.addProperty("finite", function(msg) {
        var obj = flag(this, "object");
        this.assert(
          typeof obj === "number" && isFinite(obj),
          "expected #{this} to be a finite number",
          "expected #{this} to not be a finite number"
        );
      });
    };
  }
});

// ../../node_modules/chai/lib/chai/interface/expect.js
var require_expect = __commonJS({
  "../../node_modules/chai/lib/chai/interface/expect.js"(exports2, module2) {
    module2.exports = function(chai2, util2) {
      chai2.expect = function(val, message) {
        return new chai2.Assertion(val, message);
      };
      chai2.expect.fail = function(actual, expected, message, operator) {
        if (arguments.length < 2) {
          message = actual;
          actual = void 0;
        }
        message = message || "expect.fail()";
        throw new chai2.AssertionError(message, {
          actual,
          expected,
          operator
        }, chai2.expect.fail);
      };
    };
  }
});

// ../../node_modules/chai/lib/chai/interface/should.js
var require_should = __commonJS({
  "../../node_modules/chai/lib/chai/interface/should.js"(exports2, module2) {
    module2.exports = function(chai2, util2) {
      var Assertion2 = chai2.Assertion;
      function loadShould() {
        function shouldGetter() {
          if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol || typeof BigInt === "function" && this instanceof BigInt) {
            return new Assertion2(this.valueOf(), null, shouldGetter);
          }
          return new Assertion2(this, null, shouldGetter);
        }
        function shouldSetter(value) {
          Object.defineProperty(this, "should", {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        }
        Object.defineProperty(Object.prototype, "should", {
          set: shouldSetter,
          get: shouldGetter,
          configurable: true
        });
        var should2 = {};
        should2.fail = function(actual, expected, message, operator) {
          if (arguments.length < 2) {
            message = actual;
            actual = void 0;
          }
          message = message || "should.fail()";
          throw new chai2.AssertionError(message, {
            actual,
            expected,
            operator
          }, should2.fail);
        };
        should2.equal = function(val1, val2, msg) {
          new Assertion2(val1, msg).to.equal(val2);
        };
        should2.Throw = function(fn, errt, errs, msg) {
          new Assertion2(fn, msg).to.Throw(errt, errs);
        };
        should2.exist = function(val, msg) {
          new Assertion2(val, msg).to.exist;
        };
        should2.not = {};
        should2.not.equal = function(val1, val2, msg) {
          new Assertion2(val1, msg).to.not.equal(val2);
        };
        should2.not.Throw = function(fn, errt, errs, msg) {
          new Assertion2(fn, msg).to.not.Throw(errt, errs);
        };
        should2.not.exist = function(val, msg) {
          new Assertion2(val, msg).to.not.exist;
        };
        should2["throw"] = should2["Throw"];
        should2.not["throw"] = should2.not["Throw"];
        return should2;
      }
      ;
      chai2.should = loadShould;
      chai2.Should = loadShould;
    };
  }
});

// ../../node_modules/chai/lib/chai/interface/assert.js
var require_assert = __commonJS({
  "../../node_modules/chai/lib/chai/interface/assert.js"(exports2, module2) {
    module2.exports = function(chai2, util2) {
      var Assertion2 = chai2.Assertion, flag = util2.flag;
      var assert2 = chai2.assert = function(express, errmsg) {
        var test2 = new Assertion2(null, null, chai2.assert, true);
        test2.assert(
          express,
          errmsg,
          "[ negation message unavailable ]"
        );
      };
      assert2.fail = function(actual, expected, message, operator) {
        if (arguments.length < 2) {
          message = actual;
          actual = void 0;
        }
        message = message || "assert.fail()";
        throw new chai2.AssertionError(message, {
          actual,
          expected,
          operator
        }, assert2.fail);
      };
      assert2.isOk = function(val, msg) {
        new Assertion2(val, msg, assert2.isOk, true).is.ok;
      };
      assert2.isNotOk = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotOk, true).is.not.ok;
      };
      assert2.equal = function(act, exp, msg) {
        var test2 = new Assertion2(act, msg, assert2.equal, true);
        test2.assert(
          exp == flag(test2, "object"),
          "expected #{this} to equal #{exp}",
          "expected #{this} to not equal #{act}",
          exp,
          act,
          true
        );
      };
      assert2.notEqual = function(act, exp, msg) {
        var test2 = new Assertion2(act, msg, assert2.notEqual, true);
        test2.assert(
          exp != flag(test2, "object"),
          "expected #{this} to not equal #{exp}",
          "expected #{this} to equal #{act}",
          exp,
          act,
          true
        );
      };
      assert2.strictEqual = function(act, exp, msg) {
        new Assertion2(act, msg, assert2.strictEqual, true).to.equal(exp);
      };
      assert2.notStrictEqual = function(act, exp, msg) {
        new Assertion2(act, msg, assert2.notStrictEqual, true).to.not.equal(exp);
      };
      assert2.deepEqual = assert2.deepStrictEqual = function(act, exp, msg) {
        new Assertion2(act, msg, assert2.deepEqual, true).to.eql(exp);
      };
      assert2.notDeepEqual = function(act, exp, msg) {
        new Assertion2(act, msg, assert2.notDeepEqual, true).to.not.eql(exp);
      };
      assert2.isAbove = function(val, abv, msg) {
        new Assertion2(val, msg, assert2.isAbove, true).to.be.above(abv);
      };
      assert2.isAtLeast = function(val, atlst, msg) {
        new Assertion2(val, msg, assert2.isAtLeast, true).to.be.least(atlst);
      };
      assert2.isBelow = function(val, blw, msg) {
        new Assertion2(val, msg, assert2.isBelow, true).to.be.below(blw);
      };
      assert2.isAtMost = function(val, atmst, msg) {
        new Assertion2(val, msg, assert2.isAtMost, true).to.be.most(atmst);
      };
      assert2.isTrue = function(val, msg) {
        new Assertion2(val, msg, assert2.isTrue, true).is["true"];
      };
      assert2.isNotTrue = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotTrue, true).to.not.equal(true);
      };
      assert2.isFalse = function(val, msg) {
        new Assertion2(val, msg, assert2.isFalse, true).is["false"];
      };
      assert2.isNotFalse = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotFalse, true).to.not.equal(false);
      };
      assert2.isNull = function(val, msg) {
        new Assertion2(val, msg, assert2.isNull, true).to.equal(null);
      };
      assert2.isNotNull = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotNull, true).to.not.equal(null);
      };
      assert2.isNaN = function(val, msg) {
        new Assertion2(val, msg, assert2.isNaN, true).to.be.NaN;
      };
      assert2.isNotNaN = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotNaN, true).not.to.be.NaN;
      };
      assert2.exists = function(val, msg) {
        new Assertion2(val, msg, assert2.exists, true).to.exist;
      };
      assert2.notExists = function(val, msg) {
        new Assertion2(val, msg, assert2.notExists, true).to.not.exist;
      };
      assert2.isUndefined = function(val, msg) {
        new Assertion2(val, msg, assert2.isUndefined, true).to.equal(void 0);
      };
      assert2.isDefined = function(val, msg) {
        new Assertion2(val, msg, assert2.isDefined, true).to.not.equal(void 0);
      };
      assert2.isFunction = function(val, msg) {
        new Assertion2(val, msg, assert2.isFunction, true).to.be.a("function");
      };
      assert2.isNotFunction = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotFunction, true).to.not.be.a("function");
      };
      assert2.isObject = function(val, msg) {
        new Assertion2(val, msg, assert2.isObject, true).to.be.a("object");
      };
      assert2.isNotObject = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotObject, true).to.not.be.a("object");
      };
      assert2.isArray = function(val, msg) {
        new Assertion2(val, msg, assert2.isArray, true).to.be.an("array");
      };
      assert2.isNotArray = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotArray, true).to.not.be.an("array");
      };
      assert2.isString = function(val, msg) {
        new Assertion2(val, msg, assert2.isString, true).to.be.a("string");
      };
      assert2.isNotString = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotString, true).to.not.be.a("string");
      };
      assert2.isNumber = function(val, msg) {
        new Assertion2(val, msg, assert2.isNumber, true).to.be.a("number");
      };
      assert2.isNotNumber = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotNumber, true).to.not.be.a("number");
      };
      assert2.isFinite = function(val, msg) {
        new Assertion2(val, msg, assert2.isFinite, true).to.be.finite;
      };
      assert2.isBoolean = function(val, msg) {
        new Assertion2(val, msg, assert2.isBoolean, true).to.be.a("boolean");
      };
      assert2.isNotBoolean = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotBoolean, true).to.not.be.a("boolean");
      };
      assert2.typeOf = function(val, type, msg) {
        new Assertion2(val, msg, assert2.typeOf, true).to.be.a(type);
      };
      assert2.notTypeOf = function(val, type, msg) {
        new Assertion2(val, msg, assert2.notTypeOf, true).to.not.be.a(type);
      };
      assert2.instanceOf = function(val, type, msg) {
        new Assertion2(val, msg, assert2.instanceOf, true).to.be.instanceOf(type);
      };
      assert2.notInstanceOf = function(val, type, msg) {
        new Assertion2(val, msg, assert2.notInstanceOf, true).to.not.be.instanceOf(type);
      };
      assert2.include = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.include, true).include(inc);
      };
      assert2.notInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.notInclude, true).not.include(inc);
      };
      assert2.deepInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.deepInclude, true).deep.include(inc);
      };
      assert2.notDeepInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.notDeepInclude, true).not.deep.include(inc);
      };
      assert2.nestedInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.nestedInclude, true).nested.include(inc);
      };
      assert2.notNestedInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.notNestedInclude, true).not.nested.include(inc);
      };
      assert2.deepNestedInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.deepNestedInclude, true).deep.nested.include(inc);
      };
      assert2.notDeepNestedInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.notDeepNestedInclude, true).not.deep.nested.include(inc);
      };
      assert2.ownInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.ownInclude, true).own.include(inc);
      };
      assert2.notOwnInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.notOwnInclude, true).not.own.include(inc);
      };
      assert2.deepOwnInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.deepOwnInclude, true).deep.own.include(inc);
      };
      assert2.notDeepOwnInclude = function(exp, inc, msg) {
        new Assertion2(exp, msg, assert2.notDeepOwnInclude, true).not.deep.own.include(inc);
      };
      assert2.match = function(exp, re3, msg) {
        new Assertion2(exp, msg, assert2.match, true).to.match(re3);
      };
      assert2.notMatch = function(exp, re3, msg) {
        new Assertion2(exp, msg, assert2.notMatch, true).to.not.match(re3);
      };
      assert2.property = function(obj, prop, msg) {
        new Assertion2(obj, msg, assert2.property, true).to.have.property(prop);
      };
      assert2.notProperty = function(obj, prop, msg) {
        new Assertion2(obj, msg, assert2.notProperty, true).to.not.have.property(prop);
      };
      assert2.propertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.propertyVal, true).to.have.property(prop, val);
      };
      assert2.notPropertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.notPropertyVal, true).to.not.have.property(prop, val);
      };
      assert2.deepPropertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.deepPropertyVal, true).to.have.deep.property(prop, val);
      };
      assert2.notDeepPropertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
      };
      assert2.ownProperty = function(obj, prop, msg) {
        new Assertion2(obj, msg, assert2.ownProperty, true).to.have.own.property(prop);
      };
      assert2.notOwnProperty = function(obj, prop, msg) {
        new Assertion2(obj, msg, assert2.notOwnProperty, true).to.not.have.own.property(prop);
      };
      assert2.ownPropertyVal = function(obj, prop, value, msg) {
        new Assertion2(obj, msg, assert2.ownPropertyVal, true).to.have.own.property(prop, value);
      };
      assert2.notOwnPropertyVal = function(obj, prop, value, msg) {
        new Assertion2(obj, msg, assert2.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
      };
      assert2.deepOwnPropertyVal = function(obj, prop, value, msg) {
        new Assertion2(obj, msg, assert2.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
      };
      assert2.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
        new Assertion2(obj, msg, assert2.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
      };
      assert2.nestedProperty = function(obj, prop, msg) {
        new Assertion2(obj, msg, assert2.nestedProperty, true).to.have.nested.property(prop);
      };
      assert2.notNestedProperty = function(obj, prop, msg) {
        new Assertion2(obj, msg, assert2.notNestedProperty, true).to.not.have.nested.property(prop);
      };
      assert2.nestedPropertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.nestedPropertyVal, true).to.have.nested.property(prop, val);
      };
      assert2.notNestedPropertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
      };
      assert2.deepNestedPropertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
      };
      assert2.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
        new Assertion2(obj, msg, assert2.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
      };
      assert2.lengthOf = function(exp, len, msg) {
        new Assertion2(exp, msg, assert2.lengthOf, true).to.have.lengthOf(len);
      };
      assert2.hasAnyKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.hasAnyKeys, true).to.have.any.keys(keys2);
      };
      assert2.hasAllKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.hasAllKeys, true).to.have.all.keys(keys2);
      };
      assert2.containsAllKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.containsAllKeys, true).to.contain.all.keys(keys2);
      };
      assert2.doesNotHaveAnyKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys2);
      };
      assert2.doesNotHaveAllKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.doesNotHaveAllKeys, true).to.not.have.all.keys(keys2);
      };
      assert2.hasAnyDeepKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.hasAnyDeepKeys, true).to.have.any.deep.keys(keys2);
      };
      assert2.hasAllDeepKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.hasAllDeepKeys, true).to.have.all.deep.keys(keys2);
      };
      assert2.containsAllDeepKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.containsAllDeepKeys, true).to.contain.all.deep.keys(keys2);
      };
      assert2.doesNotHaveAnyDeepKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys2);
      };
      assert2.doesNotHaveAllDeepKeys = function(obj, keys2, msg) {
        new Assertion2(obj, msg, assert2.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys2);
      };
      assert2.throws = function(fn, errorLike, errMsgMatcher, msg) {
        if ("string" === typeof errorLike || errorLike instanceof RegExp) {
          errMsgMatcher = errorLike;
          errorLike = null;
        }
        var assertErr = new Assertion2(fn, msg, assert2.throws, true).to.throw(errorLike, errMsgMatcher);
        return flag(assertErr, "object");
      };
      assert2.doesNotThrow = function(fn, errorLike, errMsgMatcher, msg) {
        if ("string" === typeof errorLike || errorLike instanceof RegExp) {
          errMsgMatcher = errorLike;
          errorLike = null;
        }
        new Assertion2(fn, msg, assert2.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
      };
      assert2.operator = function(val, operator, val2, msg) {
        var ok;
        switch (operator) {
          case "==":
            ok = val == val2;
            break;
          case "===":
            ok = val === val2;
            break;
          case ">":
            ok = val > val2;
            break;
          case ">=":
            ok = val >= val2;
            break;
          case "<":
            ok = val < val2;
            break;
          case "<=":
            ok = val <= val2;
            break;
          case "!=":
            ok = val != val2;
            break;
          case "!==":
            ok = val !== val2;
            break;
          default:
            msg = msg ? msg + ": " : msg;
            throw new chai2.AssertionError(
              msg + 'Invalid operator "' + operator + '"',
              void 0,
              assert2.operator
            );
        }
        var test2 = new Assertion2(ok, msg, assert2.operator, true);
        test2.assert(
          true === flag(test2, "object"),
          "expected " + util2.inspect(val) + " to be " + operator + " " + util2.inspect(val2),
          "expected " + util2.inspect(val) + " to not be " + operator + " " + util2.inspect(val2)
        );
      };
      assert2.closeTo = function(act, exp, delta, msg) {
        new Assertion2(act, msg, assert2.closeTo, true).to.be.closeTo(exp, delta);
      };
      assert2.approximately = function(act, exp, delta, msg) {
        new Assertion2(act, msg, assert2.approximately, true).to.be.approximately(exp, delta);
      };
      assert2.sameMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.sameMembers, true).to.have.same.members(set2);
      };
      assert2.notSameMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.notSameMembers, true).to.not.have.same.members(set2);
      };
      assert2.sameDeepMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.sameDeepMembers, true).to.have.same.deep.members(set2);
      };
      assert2.notSameDeepMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
      };
      assert2.sameOrderedMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.sameOrderedMembers, true).to.have.same.ordered.members(set2);
      };
      assert2.notSameOrderedMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
      };
      assert2.sameDeepOrderedMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
      };
      assert2.notSameDeepOrderedMembers = function(set1, set2, msg) {
        new Assertion2(set1, msg, assert2.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
      };
      assert2.includeMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.includeMembers, true).to.include.members(subset);
      };
      assert2.notIncludeMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.notIncludeMembers, true).to.not.include.members(subset);
      };
      assert2.includeDeepMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.includeDeepMembers, true).to.include.deep.members(subset);
      };
      assert2.notIncludeDeepMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
      };
      assert2.includeOrderedMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.includeOrderedMembers, true).to.include.ordered.members(subset);
      };
      assert2.notIncludeOrderedMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
      };
      assert2.includeDeepOrderedMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
      };
      assert2.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
        new Assertion2(superset, msg, assert2.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
      };
      assert2.oneOf = function(inList, list, msg) {
        new Assertion2(inList, msg, assert2.oneOf, true).to.be.oneOf(list);
      };
      assert2.changes = function(fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === "function") {
          msg = prop;
          prop = null;
        }
        new Assertion2(fn, msg, assert2.changes, true).to.change(obj, prop);
      };
      assert2.changesBy = function(fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === "function") {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }
        new Assertion2(fn, msg, assert2.changesBy, true).to.change(obj, prop).by(delta);
      };
      assert2.doesNotChange = function(fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === "function") {
          msg = prop;
          prop = null;
        }
        return new Assertion2(fn, msg, assert2.doesNotChange, true).to.not.change(obj, prop);
      };
      assert2.changesButNotBy = function(fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === "function") {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }
        new Assertion2(fn, msg, assert2.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
      };
      assert2.increases = function(fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === "function") {
          msg = prop;
          prop = null;
        }
        return new Assertion2(fn, msg, assert2.increases, true).to.increase(obj, prop);
      };
      assert2.increasesBy = function(fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === "function") {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }
        new Assertion2(fn, msg, assert2.increasesBy, true).to.increase(obj, prop).by(delta);
      };
      assert2.doesNotIncrease = function(fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === "function") {
          msg = prop;
          prop = null;
        }
        return new Assertion2(fn, msg, assert2.doesNotIncrease, true).to.not.increase(obj, prop);
      };
      assert2.increasesButNotBy = function(fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === "function") {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }
        new Assertion2(fn, msg, assert2.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
      };
      assert2.decreases = function(fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === "function") {
          msg = prop;
          prop = null;
        }
        return new Assertion2(fn, msg, assert2.decreases, true).to.decrease(obj, prop);
      };
      assert2.decreasesBy = function(fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === "function") {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }
        new Assertion2(fn, msg, assert2.decreasesBy, true).to.decrease(obj, prop).by(delta);
      };
      assert2.doesNotDecrease = function(fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === "function") {
          msg = prop;
          prop = null;
        }
        return new Assertion2(fn, msg, assert2.doesNotDecrease, true).to.not.decrease(obj, prop);
      };
      assert2.doesNotDecreaseBy = function(fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === "function") {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }
        return new Assertion2(fn, msg, assert2.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
      };
      assert2.decreasesButNotBy = function(fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === "function") {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }
        new Assertion2(fn, msg, assert2.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
      };
      assert2.ifError = function(val) {
        if (val) {
          throw val;
        }
      };
      assert2.isExtensible = function(obj, msg) {
        new Assertion2(obj, msg, assert2.isExtensible, true).to.be.extensible;
      };
      assert2.isNotExtensible = function(obj, msg) {
        new Assertion2(obj, msg, assert2.isNotExtensible, true).to.not.be.extensible;
      };
      assert2.isSealed = function(obj, msg) {
        new Assertion2(obj, msg, assert2.isSealed, true).to.be.sealed;
      };
      assert2.isNotSealed = function(obj, msg) {
        new Assertion2(obj, msg, assert2.isNotSealed, true).to.not.be.sealed;
      };
      assert2.isFrozen = function(obj, msg) {
        new Assertion2(obj, msg, assert2.isFrozen, true).to.be.frozen;
      };
      assert2.isNotFrozen = function(obj, msg) {
        new Assertion2(obj, msg, assert2.isNotFrozen, true).to.not.be.frozen;
      };
      assert2.isEmpty = function(val, msg) {
        new Assertion2(val, msg, assert2.isEmpty, true).to.be.empty;
      };
      assert2.isNotEmpty = function(val, msg) {
        new Assertion2(val, msg, assert2.isNotEmpty, true).to.not.be.empty;
      };
      (function alias(name, as) {
        assert2[as] = assert2[name];
        return alias;
      })("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty");
    };
  }
});

// ../../node_modules/chai/lib/chai.js
var require_chai = __commonJS({
  "../../node_modules/chai/lib/chai.js"(exports2) {
    var used = [];
    exports2.version = "4.3.8";
    exports2.AssertionError = require_assertion_error();
    var util2 = require_utils5();
    exports2.use = function(fn) {
      if (!~used.indexOf(fn)) {
        fn(exports2, util2);
        used.push(fn);
      }
      return exports2;
    };
    exports2.util = util2;
    var config2 = require_config();
    exports2.config = config2;
    var assertion = require_assertion();
    exports2.use(assertion);
    var core2 = require_assertions();
    exports2.use(core2);
    var expect2 = require_expect();
    exports2.use(expect2);
    var should2 = require_should();
    exports2.use(should2);
    var assert2 = require_assert();
    exports2.use(assert2);
  }
});

// ../../node_modules/chai/index.js
var require_chai2 = __commonJS({
  "../../node_modules/chai/index.js"(exports2, module2) {
    module2.exports = require_chai();
  }
});

// ../../node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v3) {
          return exports3[id] = previous ? previous(id, v3) : v3;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d2[p3] = b2[p3];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3)) t2[p3] = s2[p3];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
          t2[p3] = s2[p3];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
            if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
              t2[p3[i2]] = s2[p3[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject2) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject2(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject2(e2);
            }
          }
          function step(result2) {
            result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _2 = { label: 0, sent: function() {
          if (t2[0] & 1) throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f3, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v3) {
            return step([n2, v3]);
          };
        }
        function step(op) {
          if (f3) throw new TypeError("Generator is already executing.");
          while (_2) try {
            if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
            if (y2 = 0, t2) op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2]) _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f3 = t2 = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m3, o2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p3)) __createBinding(o2, m3, p3);
      };
      __createBinding = Object.create ? (function(o2, m3, k2, k22) {
        if (k22 === void 0) k22 = k2;
        Object.defineProperty(o2, k22, { enumerable: true, get: function() {
          return m3[k2];
        } });
      }) : (function(o2, m3, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m3[k2];
      });
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i2 = 0;
        if (m3) return m3.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m3) return o2;
        var i2 = m3.call(o2), r2, ar3 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar3.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar3;
      };
      __spread = function() {
        for (var ar3 = [], i2 = 0; i2 < arguments.length; i2++)
          ar3 = ar3.concat(__read(arguments[i2]));
        return ar3;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j3 = 0, jl = a2.length; j3 < jl; j3++, k2++)
            r2[k2] = a2[j3];
        return r2;
      };
      __await = function(v3) {
        return this instanceof __await ? (this.v = v3, this) : new __await(v3);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2]) i2[n2] = function(v3) {
            return new Promise(function(a2, b2) {
              q3.push([n2, v3, a2, b2]) > 1 || resume(n2, v3);
            });
          };
        }
        function resume(n2, v3) {
          try {
            step(g2[n2](v3));
          } catch (e2) {
            settle(q3[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q3[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject2(value) {
          resume("throw", value);
        }
        function settle(f3, v3) {
          if (f3(v3), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p3;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f3) {
          i2[n2] = o2[n2] ? function(v3) {
            return (p3 = !p3) ? { value: __await(o2[n2](v3)), done: n2 === "return" } : f3 ? f3(v3) : v3;
          } : f3;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o2[Symbol.asyncIterator], i2;
        return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v3) {
            return new Promise(function(resolve, reject2) {
              v3 = o2[n2](v3), settle(resolve, reject2, v3.done, v3.value);
            });
          };
        }
        function settle(resolve, reject2, d2, v3) {
          Promise.resolve(v3).then(function(v5) {
            resolve({ value: v5, done: d2 });
          }, reject2);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? (function(o2, v3) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
      }) : function(o2, v3) {
        o2["default"] = v3;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result2, mod, k2);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/package.json
var require_package = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/package.json"(exports2, module2) {
    module2.exports = {
      name: "@getinsomnia/node-libcurl",
      version: "3.1.0",
      description: "The fastest http(s) client (and much more) for Node.js - Node.js bindings for libcurl",
      keywords: [
        "node-curl",
        "curl",
        "libcurl",
        "node-libcurl",
        "axios",
        "request"
      ],
      homepage: "https://github.com/Kong/node-libcurl",
      bugs: {
        url: "https://github.com/Kong/node-libcurl/issues"
      },
      repository: {
        type: "git",
        url: "git://github.com/Kong/node-libcurl.git"
      },
      license: "MIT",
      author: "Jonathan Cardoso <me@jonathancardoso.com>",
      main: "./dist/index.js",
      types: "./dist/index.d.ts",
      binary: {
        module_name: "node_libcurl",
        module_path: "./lib/binding/",
        remote_path: "./v{version}/",
        package_name: "{module_name}-v{version}-{node_abi}-{platform}-{arch}-{libc}.tar.gz",
        host: "https://github.com/Kong/node-libcurl/releases/download"
      },
      scripts: {
        ae: "api-extractor run --local --verbose",
        "brute-force-leak-test:run": "node --inspect --expose_gc -r ts-node/register ./tools/brute-force-leak-test.ts",
        "brute-force-leak-test:run:debug:gdb": "gdb --args node --inspect --expose_gc -r ts-node/register ./tools/brute-force-leak-test.ts",
        "brute-force-leak-test:server": "http-server ./tools/brute-force-server-static-folder -p 8080 -s",
        "build:dist": "tsc",
        clean: "npm run clean:build && npm run clean:dist",
        "clean:build": "rimraf build",
        "clean:dist": "rimraf dist tsconfig.tsbuildinfo",
        "gen:compile_commands:debug": 'npm run pregyp -- configure --debug -- --format="gyp.generator.compile_commands_json.py"',
        "gen:compile_commands:release": 'npm run pregyp -- configure --release -- --format="gyp.generator.compile_commands_json.py"',
        "gen:constants": "node scripts/build-constants.js",
        install: "node-pre-gyp install --fallback-to-build",
        postinstall: "node scripts/postinstall",
        lint: "eslint lib/ scripts/ test/ examples/",
        pregyp: "node-pre-gyp",
        prettier: "prettier --write",
        "prettier:all": "npm run prettier lib/**/*.ts tools/**/*.js scripts/**/*.js test/**/*.ts examples/**/*.js",
        test: "mocha --require ts-node/register test/**/*.spec.ts --reporter spec --timeout 60000",
        "test:coverage": "nyc npm run test",
        "test:debug:gdb": "gdb --args node ./node_modules/.bin/mocha -r ts-node/register test/curl/hsts.spec.ts",
        "test:electron": "electron-mocha --require ts-node/register test/**/*.spec.ts --reporter spec --timeout 60000",
        "test:watch": "npm run test --watch --watch-files lib/*.ts lib/**/*.ts test/**/*.spec.ts",
        "type-check": "tsc --noEmit --project tsconfig.json",
        preversion: "npm run lint && npm run clean:dist && npm run build:dist"
      },
      dependencies: {
        "@mapbox/node-pre-gyp": "2.0.0",
        "env-paths": "2.2.0",
        nan: "2.23.0",
        "node-gyp": "11.3.0",
        rimraf: "^3.0.2",
        tslib: "2.0.1",
        consola: "^3.2.3"
      },
      devDependencies: {
        "@commitlint/cli": "^11.0.0",
        "@microsoft/api-documenter": "^7.9.10",
        "@microsoft/api-extractor": "^7.10.4",
        "@types/body-parser": "^1.19.0",
        "@types/cookie-parser": "^1.4.2",
        "@types/express": "4.17.4",
        "@types/formidable": "^1.0.31",
        "@types/mocha": "^7.0.2",
        "@types/node": "^14.11.8",
        "@types/should": "^13.0.0",
        "@typescript-eslint/eslint-plugin": "^4.4.1",
        "@typescript-eslint/parser": "^4.4.1",
        "body-parser": "^1.20.2",
        cheerio: "^1.0.0-rc.3",
        "clang-format": "^1.4.0",
        "cookie-parser": "^1.4.6",
        "electron-mocha": "jackkav/electron-mocha#fix/windows-spawn-einval",
        eslint: "^7.11.0",
        "eslint-config-prettier": "^6.12.0",
        "eslint-formatter-friendly": "^7.0.0",
        "eslint-plugin-import": "^2.22.1",
        "eslint-plugin-prettier": "^3.1.4",
        express: "^4.19.2",
        formidable: "^1.2.2",
        "http-auth": "^4.1.2",
        "http-auth-connect": "^1.0.4",
        mocha: "^7.1.1",
        nyc: "^15.1.0",
        octonode: "^0.9.5",
        prettier: "^2.1.2",
        progress: "^2.0.3",
        should: "^13.2.3",
        "sort-package-json": "^1.46.0",
        "ts-node": "^8.8.2",
        typescript: "^4.0.3"
      },
      engines: {
        node: ">= 22.18.0"
      }
    };
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/Easy.js
var require_Easy = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/Easy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Easy = void 0;
    var bindings = require("./node_libcurl-KNXTHJ25.node");
    var Easy = class extends bindings.Easy {
    };
    exports2.Easy = Easy;
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/Multi.js
var require_Multi = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/Multi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Multi = void 0;
    var bindings = require("./node_libcurl-KNXTHJ25.node");
    var Multi = class extends bindings.Multi {
    };
    exports2.Multi = Multi;
    Multi.option = bindings.Curl.multi;
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/mergeChunks.js
var require_mergeChunks = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/mergeChunks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeChunks = void 0;
    function mergeChunks(chunks, length) {
      const buffer = Buffer.allocUnsafe(length);
      const chunksLen = chunks.length;
      let currentPos = 0;
      for (let i2 = 0; i2 < chunksLen; i2 += 1) {
        const chunk3 = chunks[i2];
        chunk3.copy(buffer, currentPos);
        currentPos += chunk3.length;
      }
      return buffer;
    }
    exports2.mergeChunks = mergeChunks;
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/parseHeaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseHeaders = void 0;
    function parseHeaders(headersString) {
      const headers = headersString.split(/\r?\n|\r/g);
      const len = headers.length;
      const result2 = [];
      let isStatusLine = true;
      let currHeaders = {};
      for (let i2 = 0; i2 < len; i2 += 1) {
        if (isStatusLine) {
          const header2 = headers[i2].split(" ");
          currHeaders.result = {
            version: header2.shift() || "",
            code: parseInt(header2.shift() || "0", 10),
            reason: header2.join(" ")
          };
          isStatusLine = false;
          continue;
        }
        if (headers[i2] === "") {
          result2.push(currHeaders);
          currHeaders = {};
          isStatusLine = true;
          continue;
        }
        const header = headers[i2].split(/:\s(.+)/);
        if (header[0].toUpperCase() === "SET-COOKIE") {
          if (!currHeaders["Set-Cookie"]) {
            currHeaders["Set-Cookie"] = [];
          }
          currHeaders["Set-Cookie"].push(header[1]);
        } else {
          currHeaders[header[0]] = header[1];
        }
      }
      return result2;
    }
    exports2.parseHeaders = parseHeaders;
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlCode.js
var require_CurlCode = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlShareCode = exports2.CurlCode = exports2.CurlMultiCode = void 0;
    var CurlMultiCode;
    (function(CurlMultiCode2) {
      CurlMultiCode2[CurlMultiCode2["CURLM_CALL_MULTI_PERFORM"] = -1] = "CURLM_CALL_MULTI_PERFORM";
      CurlMultiCode2[CurlMultiCode2["CURLM_OK"] = 0] = "CURLM_OK";
      CurlMultiCode2[CurlMultiCode2["CURLM_BAD_HANDLE"] = 1] = "CURLM_BAD_HANDLE";
      CurlMultiCode2[CurlMultiCode2["CURLM_BAD_EASY_HANDLE"] = 2] = "CURLM_BAD_EASY_HANDLE";
      CurlMultiCode2[CurlMultiCode2["CURLM_OUT_OF_MEMORY"] = 3] = "CURLM_OUT_OF_MEMORY";
      CurlMultiCode2[CurlMultiCode2["CURLM_INTERNAL_ERROR"] = 4] = "CURLM_INTERNAL_ERROR";
      CurlMultiCode2[CurlMultiCode2["CURLM_BAD_SOCKET"] = 5] = "CURLM_BAD_SOCKET";
      CurlMultiCode2[CurlMultiCode2["CURLM_UNKNOWN_OPTION"] = 6] = "CURLM_UNKNOWN_OPTION";
      CurlMultiCode2[CurlMultiCode2["CURLM_ADDED_ALREADY"] = 7] = "CURLM_ADDED_ALREADY";
      CurlMultiCode2[CurlMultiCode2["CURLM_RECURSIVE_API_CALL"] = 8] = "CURLM_RECURSIVE_API_CALL";
      CurlMultiCode2[CurlMultiCode2["CURLM_WAKEUP_FAILURE"] = 9] = "CURLM_WAKEUP_FAILURE";
      CurlMultiCode2[CurlMultiCode2["CURLM_BAD_FUNCTION_ARGUMENT"] = 10] = "CURLM_BAD_FUNCTION_ARGUMENT";
      CurlMultiCode2[CurlMultiCode2["CURLM_LAST"] = 11] = "CURLM_LAST";
      CurlMultiCode2[CurlMultiCode2["CURLM_CALL_MULTI_SOCKET"] = -1] = "CURLM_CALL_MULTI_SOCKET";
    })(CurlMultiCode = exports2.CurlMultiCode || (exports2.CurlMultiCode = {}));
    var CurlCode2;
    (function(CurlCode3) {
      CurlCode3[CurlCode3["CURLE_OK"] = 0] = "CURLE_OK";
      CurlCode3[CurlCode3["CURLE_UNSUPPORTED_PROTOCOL"] = 1] = "CURLE_UNSUPPORTED_PROTOCOL";
      CurlCode3[CurlCode3["CURLE_FAILED_INIT"] = 2] = "CURLE_FAILED_INIT";
      CurlCode3[CurlCode3["CURLE_URL_MALFORMAT"] = 3] = "CURLE_URL_MALFORMAT";
      CurlCode3[CurlCode3["CURLE_NOT_BUILT_IN"] = 4] = "CURLE_NOT_BUILT_IN";
      CurlCode3[CurlCode3["CURLE_COULDNT_RESOLVE_PROXY"] = 5] = "CURLE_COULDNT_RESOLVE_PROXY";
      CurlCode3[CurlCode3["CURLE_COULDNT_RESOLVE_HOST"] = 6] = "CURLE_COULDNT_RESOLVE_HOST";
      CurlCode3[CurlCode3["CURLE_COULDNT_CONNECT"] = 7] = "CURLE_COULDNT_CONNECT";
      CurlCode3[CurlCode3["CURLE_WEIRD_SERVER_REPLY"] = 8] = "CURLE_WEIRD_SERVER_REPLY";
      CurlCode3[CurlCode3["CURLE_REMOTE_ACCESS_DENIED"] = 9] = "CURLE_REMOTE_ACCESS_DENIED";
      CurlCode3[CurlCode3["CURLE_FTP_ACCEPT_FAILED"] = 10] = "CURLE_FTP_ACCEPT_FAILED";
      CurlCode3[CurlCode3["CURLE_FTP_WEIRD_PASS_REPLY"] = 11] = "CURLE_FTP_WEIRD_PASS_REPLY";
      CurlCode3[CurlCode3["CURLE_FTP_ACCEPT_TIMEOUT"] = 12] = "CURLE_FTP_ACCEPT_TIMEOUT";
      CurlCode3[CurlCode3["CURLE_FTP_WEIRD_PASV_REPLY"] = 13] = "CURLE_FTP_WEIRD_PASV_REPLY";
      CurlCode3[CurlCode3["CURLE_FTP_WEIRD_227_FORMAT"] = 14] = "CURLE_FTP_WEIRD_227_FORMAT";
      CurlCode3[CurlCode3["CURLE_FTP_CANT_GET_HOST"] = 15] = "CURLE_FTP_CANT_GET_HOST";
      CurlCode3[CurlCode3["CURLE_HTTP2"] = 16] = "CURLE_HTTP2";
      CurlCode3[CurlCode3["CURLE_FTP_COULDNT_SET_TYPE"] = 17] = "CURLE_FTP_COULDNT_SET_TYPE";
      CurlCode3[CurlCode3["CURLE_PARTIAL_FILE"] = 18] = "CURLE_PARTIAL_FILE";
      CurlCode3[CurlCode3["CURLE_FTP_COULDNT_RETR_FILE"] = 19] = "CURLE_FTP_COULDNT_RETR_FILE";
      CurlCode3[CurlCode3["CURLE_OBSOLETE20"] = 20] = "CURLE_OBSOLETE20";
      CurlCode3[CurlCode3["CURLE_QUOTE_ERROR"] = 21] = "CURLE_QUOTE_ERROR";
      CurlCode3[CurlCode3["CURLE_HTTP_RETURNED_ERROR"] = 22] = "CURLE_HTTP_RETURNED_ERROR";
      CurlCode3[CurlCode3["CURLE_WRITE_ERROR"] = 23] = "CURLE_WRITE_ERROR";
      CurlCode3[CurlCode3["CURLE_OBSOLETE24"] = 24] = "CURLE_OBSOLETE24";
      CurlCode3[CurlCode3["CURLE_UPLOAD_FAILED"] = 25] = "CURLE_UPLOAD_FAILED";
      CurlCode3[CurlCode3["CURLE_READ_ERROR"] = 26] = "CURLE_READ_ERROR";
      CurlCode3[CurlCode3["CURLE_OUT_OF_MEMORY"] = 27] = "CURLE_OUT_OF_MEMORY";
      CurlCode3[CurlCode3["CURLE_OPERATION_TIMEDOUT"] = 28] = "CURLE_OPERATION_TIMEDOUT";
      CurlCode3[CurlCode3["CURLE_OBSOLETE29"] = 29] = "CURLE_OBSOLETE29";
      CurlCode3[CurlCode3["CURLE_FTP_PORT_FAILED"] = 30] = "CURLE_FTP_PORT_FAILED";
      CurlCode3[CurlCode3["CURLE_FTP_COULDNT_USE_REST"] = 31] = "CURLE_FTP_COULDNT_USE_REST";
      CurlCode3[CurlCode3["CURLE_OBSOLETE32"] = 32] = "CURLE_OBSOLETE32";
      CurlCode3[CurlCode3["CURLE_RANGE_ERROR"] = 33] = "CURLE_RANGE_ERROR";
      CurlCode3[CurlCode3["CURLE_HTTP_POST_ERROR"] = 34] = "CURLE_HTTP_POST_ERROR";
      CurlCode3[CurlCode3["CURLE_SSL_CONNECT_ERROR"] = 35] = "CURLE_SSL_CONNECT_ERROR";
      CurlCode3[CurlCode3["CURLE_BAD_DOWNLOAD_RESUME"] = 36] = "CURLE_BAD_DOWNLOAD_RESUME";
      CurlCode3[CurlCode3["CURLE_FILE_COULDNT_READ_FILE"] = 37] = "CURLE_FILE_COULDNT_READ_FILE";
      CurlCode3[CurlCode3["CURLE_LDAP_CANNOT_BIND"] = 38] = "CURLE_LDAP_CANNOT_BIND";
      CurlCode3[CurlCode3["CURLE_LDAP_SEARCH_FAILED"] = 39] = "CURLE_LDAP_SEARCH_FAILED";
      CurlCode3[CurlCode3["CURLE_OBSOLETE40"] = 40] = "CURLE_OBSOLETE40";
      CurlCode3[CurlCode3["CURLE_FUNCTION_NOT_FOUND"] = 41] = "CURLE_FUNCTION_NOT_FOUND";
      CurlCode3[CurlCode3["CURLE_ABORTED_BY_CALLBACK"] = 42] = "CURLE_ABORTED_BY_CALLBACK";
      CurlCode3[CurlCode3["CURLE_BAD_FUNCTION_ARGUMENT"] = 43] = "CURLE_BAD_FUNCTION_ARGUMENT";
      CurlCode3[CurlCode3["CURLE_OBSOLETE44"] = 44] = "CURLE_OBSOLETE44";
      CurlCode3[CurlCode3["CURLE_INTERFACE_FAILED"] = 45] = "CURLE_INTERFACE_FAILED";
      CurlCode3[CurlCode3["CURLE_OBSOLETE46"] = 46] = "CURLE_OBSOLETE46";
      CurlCode3[CurlCode3["CURLE_TOO_MANY_REDIRECTS"] = 47] = "CURLE_TOO_MANY_REDIRECTS";
      CurlCode3[CurlCode3["CURLE_UNKNOWN_OPTION"] = 48] = "CURLE_UNKNOWN_OPTION";
      CurlCode3[CurlCode3["CURLE_SETOPT_OPTION_SYNTAX"] = 49] = "CURLE_SETOPT_OPTION_SYNTAX";
      CurlCode3[CurlCode3["CURLE_OBSOLETE50"] = 50] = "CURLE_OBSOLETE50";
      CurlCode3[CurlCode3["CURLE_OBSOLETE51"] = 51] = "CURLE_OBSOLETE51";
      CurlCode3[CurlCode3["CURLE_GOT_NOTHING"] = 52] = "CURLE_GOT_NOTHING";
      CurlCode3[CurlCode3["CURLE_SSL_ENGINE_NOTFOUND"] = 53] = "CURLE_SSL_ENGINE_NOTFOUND";
      CurlCode3[CurlCode3["CURLE_SSL_ENGINE_SETFAILED"] = 54] = "CURLE_SSL_ENGINE_SETFAILED";
      CurlCode3[CurlCode3["CURLE_SEND_ERROR"] = 55] = "CURLE_SEND_ERROR";
      CurlCode3[CurlCode3["CURLE_RECV_ERROR"] = 56] = "CURLE_RECV_ERROR";
      CurlCode3[CurlCode3["CURLE_OBSOLETE57"] = 57] = "CURLE_OBSOLETE57";
      CurlCode3[CurlCode3["CURLE_SSL_CERTPROBLEM"] = 58] = "CURLE_SSL_CERTPROBLEM";
      CurlCode3[CurlCode3["CURLE_SSL_CIPHER"] = 59] = "CURLE_SSL_CIPHER";
      CurlCode3[CurlCode3["CURLE_PEER_FAILED_VERIFICATION"] = 60] = "CURLE_PEER_FAILED_VERIFICATION";
      CurlCode3[CurlCode3["CURLE_BAD_CONTENT_ENCODING"] = 61] = "CURLE_BAD_CONTENT_ENCODING";
      CurlCode3[CurlCode3["CURLE_LDAP_INVALID_URL"] = 62] = "CURLE_LDAP_INVALID_URL";
      CurlCode3[CurlCode3["CURLE_FILESIZE_EXCEEDED"] = 63] = "CURLE_FILESIZE_EXCEEDED";
      CurlCode3[CurlCode3["CURLE_USE_SSL_FAILED"] = 64] = "CURLE_USE_SSL_FAILED";
      CurlCode3[CurlCode3["CURLE_SEND_FAIL_REWIND"] = 65] = "CURLE_SEND_FAIL_REWIND";
      CurlCode3[CurlCode3["CURLE_SSL_ENGINE_INITFAILED"] = 66] = "CURLE_SSL_ENGINE_INITFAILED";
      CurlCode3[CurlCode3["CURLE_LOGIN_DENIED"] = 67] = "CURLE_LOGIN_DENIED";
      CurlCode3[CurlCode3["CURLE_TFTP_NOTFOUND"] = 68] = "CURLE_TFTP_NOTFOUND";
      CurlCode3[CurlCode3["CURLE_TFTP_PERM"] = 69] = "CURLE_TFTP_PERM";
      CurlCode3[CurlCode3["CURLE_REMOTE_DISK_FULL"] = 70] = "CURLE_REMOTE_DISK_FULL";
      CurlCode3[CurlCode3["CURLE_TFTP_ILLEGAL"] = 71] = "CURLE_TFTP_ILLEGAL";
      CurlCode3[CurlCode3["CURLE_TFTP_UNKNOWNID"] = 72] = "CURLE_TFTP_UNKNOWNID";
      CurlCode3[CurlCode3["CURLE_REMOTE_FILE_EXISTS"] = 73] = "CURLE_REMOTE_FILE_EXISTS";
      CurlCode3[CurlCode3["CURLE_TFTP_NOSUCHUSER"] = 74] = "CURLE_TFTP_NOSUCHUSER";
      CurlCode3[CurlCode3["CURLE_CONV_FAILED"] = 75] = "CURLE_CONV_FAILED";
      CurlCode3[CurlCode3["CURLE_CONV_REQD"] = 76] = "CURLE_CONV_REQD";
      CurlCode3[CurlCode3["CURLE_SSL_CACERT_BADFILE"] = 77] = "CURLE_SSL_CACERT_BADFILE";
      CurlCode3[CurlCode3["CURLE_REMOTE_FILE_NOT_FOUND"] = 78] = "CURLE_REMOTE_FILE_NOT_FOUND";
      CurlCode3[CurlCode3["CURLE_SSH"] = 79] = "CURLE_SSH";
      CurlCode3[CurlCode3["CURLE_SSL_SHUTDOWN_FAILED"] = 80] = "CURLE_SSL_SHUTDOWN_FAILED";
      CurlCode3[CurlCode3["CURLE_AGAIN"] = 81] = "CURLE_AGAIN";
      CurlCode3[CurlCode3["CURLE_SSL_CRL_BADFILE"] = 82] = "CURLE_SSL_CRL_BADFILE";
      CurlCode3[CurlCode3["CURLE_SSL_ISSUER_ERROR"] = 83] = "CURLE_SSL_ISSUER_ERROR";
      CurlCode3[CurlCode3["CURLE_FTP_PRET_FAILED"] = 84] = "CURLE_FTP_PRET_FAILED";
      CurlCode3[CurlCode3["CURLE_RTSP_CSEQ_ERROR"] = 85] = "CURLE_RTSP_CSEQ_ERROR";
      CurlCode3[CurlCode3["CURLE_RTSP_SESSION_ERROR"] = 86] = "CURLE_RTSP_SESSION_ERROR";
      CurlCode3[CurlCode3["CURLE_FTP_BAD_FILE_LIST"] = 87] = "CURLE_FTP_BAD_FILE_LIST";
      CurlCode3[CurlCode3["CURLE_CHUNK_FAILED"] = 88] = "CURLE_CHUNK_FAILED";
      CurlCode3[CurlCode3["CURLE_NO_CONNECTION_AVAILABLE"] = 89] = "CURLE_NO_CONNECTION_AVAILABLE";
      CurlCode3[CurlCode3["CURLE_SSL_PINNEDPUBKEYNOTMATCH"] = 90] = "CURLE_SSL_PINNEDPUBKEYNOTMATCH";
      CurlCode3[CurlCode3["CURLE_SSL_INVALIDCERTSTATUS"] = 91] = "CURLE_SSL_INVALIDCERTSTATUS";
      CurlCode3[CurlCode3["CURLE_HTTP2_STREAM"] = 92] = "CURLE_HTTP2_STREAM";
      CurlCode3[CurlCode3["CURLE_RECURSIVE_API_CALL"] = 93] = "CURLE_RECURSIVE_API_CALL";
      CurlCode3[CurlCode3["CURLE_AUTH_ERROR"] = 94] = "CURLE_AUTH_ERROR";
      CurlCode3[CurlCode3["CURLE_HTTP3"] = 95] = "CURLE_HTTP3";
      CurlCode3[CurlCode3["CURLE_QUIC_CONNECT_ERROR"] = 96] = "CURLE_QUIC_CONNECT_ERROR";
      CurlCode3[CurlCode3["CURLE_PROXY"] = 97] = "CURLE_PROXY";
      CurlCode3[CurlCode3["CURLE_SSL_CLIENTCERT"] = 98] = "CURLE_SSL_CLIENTCERT";
      CurlCode3[CurlCode3["CURLE_LAST"] = 99] = "CURLE_LAST";
      CurlCode3[CurlCode3["CURLE_FTP_WEIRD_SERVER_REPLY"] = 8] = "CURLE_FTP_WEIRD_SERVER_REPLY";
      CurlCode3[CurlCode3["CURLE_SSL_CACERT"] = 60] = "CURLE_SSL_CACERT";
      CurlCode3[CurlCode3["CURLE_UNKNOWN_TELNET_OPTION"] = 48] = "CURLE_UNKNOWN_TELNET_OPTION";
      CurlCode3[CurlCode3["CURLE_SSL_PEER_CERTIFICATE"] = 60] = "CURLE_SSL_PEER_CERTIFICATE";
      CurlCode3[CurlCode3["CURLE_TELNET_OPTION_SYNTAX"] = 49] = "CURLE_TELNET_OPTION_SYNTAX";
      CurlCode3[CurlCode3["CURLE_FTP_ACCESS_DENIED"] = 9] = "CURLE_FTP_ACCESS_DENIED";
      CurlCode3[CurlCode3["CURLE_FTP_COULDNT_SET_BINARY"] = 17] = "CURLE_FTP_COULDNT_SET_BINARY";
      CurlCode3[CurlCode3["CURLE_FTP_QUOTE_ERROR"] = 21] = "CURLE_FTP_QUOTE_ERROR";
      CurlCode3[CurlCode3["CURLE_TFTP_DISKFULL"] = 70] = "CURLE_TFTP_DISKFULL";
      CurlCode3[CurlCode3["CURLE_TFTP_EXISTS"] = 73] = "CURLE_TFTP_EXISTS";
      CurlCode3[CurlCode3["CURLE_HTTP_RANGE_ERROR"] = 33] = "CURLE_HTTP_RANGE_ERROR";
      CurlCode3[CurlCode3["CURLE_FTP_SSL_FAILED"] = 64] = "CURLE_FTP_SSL_FAILED";
      CurlCode3[CurlCode3["CURLE_OPERATION_TIMEOUTED"] = 28] = "CURLE_OPERATION_TIMEOUTED";
      CurlCode3[CurlCode3["CURLE_HTTP_NOT_FOUND"] = 22] = "CURLE_HTTP_NOT_FOUND";
      CurlCode3[CurlCode3["CURLE_HTTP_PORT_FAILED"] = 45] = "CURLE_HTTP_PORT_FAILED";
      CurlCode3[CurlCode3["CURLE_FTP_COULDNT_STOR_FILE"] = 25] = "CURLE_FTP_COULDNT_STOR_FILE";
      CurlCode3[CurlCode3["CURLE_FTP_PARTIAL_FILE"] = 18] = "CURLE_FTP_PARTIAL_FILE";
      CurlCode3[CurlCode3["CURLE_FTP_BAD_DOWNLOAD_RESUME"] = 36] = "CURLE_FTP_BAD_DOWNLOAD_RESUME";
    })(CurlCode2 = exports2.CurlCode || (exports2.CurlCode = {}));
    var CurlShareCode;
    (function(CurlShareCode2) {
      CurlShareCode2[CurlShareCode2["CURLSHE_OK"] = 0] = "CURLSHE_OK";
      CurlShareCode2[CurlShareCode2["CURLSHE_BAD_OPTION"] = 1] = "CURLSHE_BAD_OPTION";
      CurlShareCode2[CurlShareCode2["CURLSHE_IN_USE"] = 2] = "CURLSHE_IN_USE";
      CurlShareCode2[CurlShareCode2["CURLSHE_INVALID"] = 3] = "CURLSHE_INVALID";
      CurlShareCode2[CurlShareCode2["CURLSHE_NOMEM"] = 4] = "CURLSHE_NOMEM";
      CurlShareCode2[CurlShareCode2["CURLSHE_NOT_BUILT_IN"] = 5] = "CURLSHE_NOT_BUILT_IN";
      CurlShareCode2[CurlShareCode2["CURLSHE_LAST"] = 6] = "CURLSHE_LAST";
    })(CurlShareCode = exports2.CurlShareCode || (exports2.CurlShareCode = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFeature.js
var require_CurlFeature = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFeature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlFeature = void 0;
    var CurlFeature2;
    (function(CurlFeature3) {
      CurlFeature3[CurlFeature3["NoDataParsing"] = 1] = "NoDataParsing";
      CurlFeature3[CurlFeature3["NoHeaderParsing"] = 2] = "NoHeaderParsing";
      CurlFeature3[CurlFeature3["Raw"] = 3] = "Raw";
      CurlFeature3[CurlFeature3["NoDataStorage"] = 4] = "NoDataStorage";
      CurlFeature3[CurlFeature3["NoHeaderStorage"] = 8] = "NoHeaderStorage";
      CurlFeature3[CurlFeature3["NoStorage"] = 12] = "NoStorage";
      CurlFeature3[CurlFeature3["StreamResponse"] = 16] = "StreamResponse";
    })(CurlFeature2 = exports2.CurlFeature || (exports2.CurlFeature = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPause.js
var require_CurlPause = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPause.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlPause = void 0;
    var CurlPause;
    (function(CurlPause2) {
      CurlPause2[CurlPause2["Recv"] = 1] = "Recv";
      CurlPause2[CurlPause2["RecvCont"] = 0] = "RecvCont";
      CurlPause2[CurlPause2["Send"] = 4] = "Send";
      CurlPause2[CurlPause2["SendCont"] = 0] = "SendCont";
      CurlPause2[CurlPause2["All"] = 5] = "All";
      CurlPause2[CurlPause2["Cont"] = 0] = "Cont";
    })(CurlPause = exports2.CurlPause || (exports2.CurlPause = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlWriteFunc.js
var require_CurlWriteFunc = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlWriteFunc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlWriteFunc = void 0;
    var CurlWriteFunc;
    (function(CurlWriteFunc2) {
      CurlWriteFunc2[CurlWriteFunc2["Pause"] = 268435457] = "Pause";
    })(CurlWriteFunc = exports2.CurlWriteFunc || (exports2.CurlWriteFunc = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlReadFunc.js
var require_CurlReadFunc = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlReadFunc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlReadFunc = void 0;
    var CurlReadFunc;
    (function(CurlReadFunc2) {
      CurlReadFunc2[CurlReadFunc2["Abort"] = 268435456] = "Abort";
      CurlReadFunc2[CurlReadFunc2["Pause"] = 268435457] = "Pause";
    })(CurlReadFunc = exports2.CurlReadFunc || (exports2.CurlReadFunc = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/Curl.js
var require_Curl = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/Curl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Curl = void 0;
    var tslib_1 = require_tslib();
    var events_1 = require("events");
    var string_decoder_1 = require("string_decoder");
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var stream_1 = require("stream");
    var pkg = require_package();
    var Easy_1 = require_Easy();
    var Multi_1 = require_Multi();
    var mergeChunks_1 = require_mergeChunks();
    var parseHeaders_1 = require_parseHeaders();
    var CurlCode_1 = require_CurlCode();
    var CurlFeature_1 = require_CurlFeature();
    var CurlPause_1 = require_CurlPause();
    var CurlWriteFunc_1 = require_CurlWriteFunc();
    var CurlReadFunc_1 = require_CurlReadFunc();
    var bindings = require("./node_libcurl-KNXTHJ25.node");
    var { Curl: _Curl, CurlVersionInfo } = bindings;
    if (!process.env.NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL || process.env.NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL !== "true") {
      const globalInitResult = _Curl.globalInit(
        3
        /* CurlGlobalInit.All */
      );
      (0, assert_1.default)(globalInitResult === 0 || "Libcurl global init failed.");
    }
    var decoder = new string_decoder_1.StringDecoder("utf8");
    var multiHandle = new Multi_1.Multi();
    var curlInstanceMap = /* @__PURE__ */ new WeakMap();
    multiHandle.onMessage((error, handle, errorCode) => {
      multiHandle.removeHandle(handle);
      const curlInstance = curlInstanceMap.get(handle);
      (0, assert_1.default)(curlInstance, "Could not retrieve curl instance from easy handle on onMessage callback");
      if (error) {
        curlInstance.onError(error, errorCode);
      } else {
        curlInstance.onEnd();
      }
    });
    var Curl2 = class _Curl2 extends events_1.EventEmitter {
      /**
       * Whether this instance is closed or not ({@link close | `close()`} was called).
       *
       * Make sure to not change their value, otherwise unexpected behavior would happen.
       */
      get isOpen() {
        return this.handle.isOpen;
      }
      /**
       * @param cloneHandle {@link "Easy".Easy | `Easy`} handle that should be used instead of creating a new one.
       */
      constructor(cloneHandle) {
        super();
        this.isRunning = false;
        this.chunks = [];
        this.chunksLength = 0;
        this.headerChunks = [];
        this.headerChunksLength = 0;
        this.features = 0;
        this.writeFunctionStream = null;
        this.readFunctionStream = null;
        this.streamReadFunctionCallbacksToClean = [];
        this.streamReadFunctionShouldEnd = false;
        this.streamReadFunctionShouldPause = false;
        this.streamReadFunctionPaused = false;
        this.streamWriteFunctionShouldPause = false;
        this.streamWriteFunctionPaused = false;
        this.streamWriteFunctionFirstRun = true;
        this.streamPauseNext = false;
        this.streamContinueNext = false;
        this.streamError = false;
        this.streamUserSuppliedProgressFunction = null;
        const handle = cloneHandle || new Easy_1.Easy();
        this.handle = handle;
        handle.setOpt(_Curl2.option.WRITEFUNCTION, this.defaultWriteFunction.bind(this));
        handle.setOpt(_Curl2.option.HEADERFUNCTION, this.defaultHeaderFunction.bind(this));
        handle.setOpt(_Curl2.option.USERAGENT, _Curl2.defaultUserAgent);
        curlInstanceMap.set(handle, this);
      }
      /**
       * Callback called when an error is thrown on this handle.
       *
       * This is called from the internal callback we use with the {@link "Multi".Multi.onMessage | `onMessage`}
       *  method of the global {@link "Multi".Multi | `Multi`} handle used by all `Curl` instances.
       *
       * @protected
       */
      onError(error, errorCode) {
        this.resetInternalState();
        this.emit("error", error, errorCode, this);
      }
      /**
       * Callback called when this handle has finished the request.
       *
       * This is called from the internal callback we use with the {@link "Multi".Multi.onMessage | `onMessage`}
       *  method of the global {@link "Multi".Multi | `Multi`} handle used by all `Curl` instances.
       *
       * This should not be called in any other way.
       *
       * @protected
       */
      onEnd() {
        const isStreamResponse = !!(this.features & CurlFeature_1.CurlFeature.StreamResponse);
        const isDataStorageEnabled = !isStreamResponse && !(this.features & CurlFeature_1.CurlFeature.NoDataStorage);
        const isDataParsingEnabled = !isStreamResponse && !(this.features & CurlFeature_1.CurlFeature.NoDataParsing) && isDataStorageEnabled;
        const dataRaw = isDataStorageEnabled ? (0, mergeChunks_1.mergeChunks)(this.chunks, this.chunksLength) : Buffer.alloc(0);
        const data = isDataParsingEnabled ? decoder.write(dataRaw) : dataRaw;
        const headers = this.getHeaders();
        const { code, data: status } = this.handle.getInfo(_Curl2.info.RESPONSE_CODE);
        if (isStreamResponse) {
          if (!this.writeFunctionStream) {
            const noopStream = new stream_1.Readable({
              read() {
                setImmediate(() => {
                  this.push(null);
                });
              }
            });
            process.nextTick(() => this.emit("stream", noopStream, status, headers, this));
          } else {
            this.writeFunctionStream.push(null);
          }
        }
        const wrapper = isStreamResponse ? setImmediate : (fn) => fn();
        wrapper(() => {
          this.resetInternalState();
          if (code !== CurlCode_1.CurlCode.CURLE_OK) {
            const error = new Error("Could not get status code of request");
            this.emit("error", error, code, this);
          } else {
            this.emit("end", status, data, headers, this);
          }
        });
      }
      /**
       * Enables a feature, must not be used while a request is running.
       *
       * Use {@link CurlFeature | `CurlFeature`} for predefined constants.
       */
      enable(bitmask) {
        if (this.isRunning) {
          throw new Error("You should not change the features while a request is running.");
        }
        this.features |= bitmask;
        return this;
      }
      /**
       * Disables a feature, must not be used while a request is running.
       *
       * Use {@link CurlFeature | `CurlFeature`} for predefined constants.
       */
      disable(bitmask) {
        if (this.isRunning) {
          throw new Error("You should not change the features while a request is running.");
        }
        this.features &= ~bitmask;
        return this;
      }
      /**
       * Sets an option the handle.
       *
       * This overloaded method has `never` as type for the arguments
       *  because one of the other overloaded signatures must be used.
       *
       *
       * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)
       *
       * @param optionIdOrName Option name or integer value. Use {@link Curl.option | `Curl.option`} for predefined constants.
       * @param optionValue The value of the option, value type depends on the option being set.
       */
      setOpt(optionIdOrName, optionValue) {
        let value = optionValue;
        if ((optionIdOrName === _Curl2.option.WRITEFUNCTION || optionIdOrName === "WRITEFUNCTION") && !optionValue) {
          value = this.defaultWriteFunction.bind(this);
        } else if ((optionIdOrName === _Curl2.option.HEADERFUNCTION || optionIdOrName === "HEADERFUNCTION") && !optionValue) {
          value = this.defaultHeaderFunction.bind(this);
        }
        const code = this.handle.setOpt(optionIdOrName, value);
        if (code !== CurlCode_1.CurlCode.CURLE_OK) {
          throw new Error(code === CurlCode_1.CurlCode.CURLE_UNKNOWN_OPTION ? "Unknown option given. First argument must be the option internal id or the option name. You can use the Curl.option constants." : Easy_1.Easy.strError(code));
        }
        return this;
      }
      /**
       * Retrieves some information about the last request made by a handle.
       *
       * This overloaded method has `never` as type for the argument
       *  because one of the other overloaded signatures must be used.
       *
       * Official libcurl documentation: [`curl_easy_getinfo()`](http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html)
       *
       * @param infoNameOrId Info name or integer value. Use {@link Curl.info | `Curl.info`} for predefined constants.
       */
      getInfo(infoNameOrId) {
        const { code, data } = this.handle.getInfo(infoNameOrId);
        if (code !== CurlCode_1.CurlCode.CURLE_OK) {
          throw new Error(`getInfo failed. Error: ${Easy_1.Easy.strError(code)}`);
        }
        return data;
      }
      /**
       * This will set an internal `READFUNCTION` callback that will read all the data from this stream.
       *
       * One usage for that is to upload data directly from streams. Example:
       *
       * ```typescript
       *  const curl = new Curl()
       *  curl.setOpt('URL', 'https://some-domain/upload')
       *  curl.setOpt('UPLOAD', true)
       *  // so we do not need to set the content length
       *  curl.setOpt('HTTPHEADER', ['Transfer-Encoding: chunked'])
       *
       *  const filePath = './test.zip'
       *  const stream = fs.createReadStream(filePath)
       *  curl.setUploadStream(stream)
       *
       *  curl.setStreamProgressCallback(() => {
       *    // this will use the default progress callback from libcurl
       *    return CurlProgressFunc.Continue
       *  })
       *
       *  curl.on('end', (statusCode, data) => {
       *    console.log('\n'.repeat(5))
       *    // data length should be 0, as it was sent using the response stream
       *    console.log(
       *      `curl - end - status: ${statusCode} - data length: ${data.length}`,
       *    )
       *    curl.close()
       *  })
       *  curl.on('error', (error, errorCode) => {
       *    console.log('\n'.repeat(5))
       *    console.error('curl - error: ', error, errorCode)
       *    curl.close()
       *  })
       *  curl.perform()
       * ```
       *
       * Multiple calls with the same stream that was previously set has no effect.
       *
       * Setting this to `null` will remove the `READFUNCTION` callback and disable this behavior.
       *
       * @remarks
       *
       * This option is reset after each request, so if you want to upload the same data again using the same
       * `Curl` instance, you will need to provide a new stream.
       *
       * Make sure your libcurl version is greater than or equal 7.69.1.
       * Versions older than that one are not reliable for streams usage.
       */
      setUploadStream(stream) {
        if (!stream) {
          if (this.readFunctionStream) {
            this.cleanupReadFunctionStreamEvents();
            this.readFunctionStream = null;
            this.setOpt("READFUNCTION", null);
          }
          return this;
        }
        if (this.readFunctionStream === stream)
          return this;
        if (typeof (stream === null || stream === void 0 ? void 0 : stream.on) !== "function" || typeof (stream === null || stream === void 0 ? void 0 : stream.read) !== "function") {
          throw new Error("The passed value to setUploadStream does not looks like a stream object");
        }
        this.readFunctionStream = stream;
        const resumeIfPaused = () => {
          if (this.streamReadFunctionPaused) {
            this.streamReadFunctionPaused = false;
            setImmediate(() => {
              if (this.isRunning) {
                this.pause(CurlPause_1.CurlPause.Cont);
              }
            });
          }
        };
        const attachEventListenerToStream = (event, cb) => {
          this.readFunctionStream.on(event, cb);
          this.streamReadFunctionCallbacksToClean.push([
            this.readFunctionStream,
            event,
            cb
          ]);
        };
        attachEventListenerToStream("readable", () => {
          resumeIfPaused();
        });
        attachEventListenerToStream("close", () => {
          if (!this.streamReadFunctionShouldEnd && !this.streamError) {
            this.streamError = new Error("Curl upload stream was unexpectedly destroyed");
            this.streamReadFunctionShouldPause = true;
            resumeIfPaused();
          }
        });
        attachEventListenerToStream("error", (error) => {
          this.streamError = error;
          this.streamReadFunctionShouldPause = true;
          resumeIfPaused();
        });
        attachEventListenerToStream("end", () => {
          this.streamReadFunctionShouldEnd = true;
          resumeIfPaused();
        });
        this.setOpt("READFUNCTION", (buffer, size2, nmemb) => {
          if (this.streamReadFunctionShouldPause) {
            this.streamReadFunctionShouldPause = false;
            this.streamReadFunctionPaused = true;
            return CurlReadFunc_1.CurlReadFunc.Pause;
          }
          const amountToRead = size2 * nmemb;
          const data = stream.read(amountToRead);
          if (!data) {
            if (this.streamReadFunctionShouldEnd) {
              return 0;
            } else {
              this.streamReadFunctionPaused = true;
              return CurlReadFunc_1.CurlReadFunc.Pause;
            }
          }
          const totalWritten = data.copy(buffer);
          return totalWritten;
        });
        return this;
      }
      /**
       * Set the param to `null` to use the Node.js default value.
       *
       * @param highWaterMark This will passed directly to the `Readable` stream created to be returned as the response'
       *
       * @remarks
       * Only useful when the {@link CurlFeature.StreamResponse | `StreamResponse`} feature flag is enabled.
       */
      setStreamResponseHighWaterMark(highWaterMark) {
        this.streamWriteFunctionHighWaterMark = highWaterMark || void 0;
        return this;
      }
      /**
       * This sets the callback to be used as the progress function when using any of the stream features.
       *
       * This is needed because when this `Curl` instance is enabled to use streams for upload/download, it needs
       * to set the libcurl progress function option to an internal function.
       *
       * If you are using any of the streams features, do not overwrite the progress callback to something else,
       * be it using {@link setOpt | `setOpt`} or {@link setProgressCallback | `setProgressCallback`}, as this would
       * cause undefined behavior.
       *
       * If are using this callback, there is no need to set the `NOPROGRESS` option to false (as you normally would).
       */
      setStreamProgressCallback(cb) {
        this.streamUserSuppliedProgressFunction = cb;
        return this;
      }
      /**
       * The option `XFERINFOFUNCTION` was introduced in curl version `7.32.0`,
       *  versions older than that should use `PROGRESSFUNCTION`.
       * If you don't want to mess with version numbers you can use this method,
       * instead of directly calling {@link Curl.setOpt | `Curl#setOpt`}.
       *
       * `NOPROGRESS` should be set to false to make this function actually get called.
       */
      setProgressCallback(cb) {
        if (_Curl2.VERSION_NUM >= 466944) {
          this.handle.setOpt(_Curl2.option.XFERINFOFUNCTION, cb);
        } else {
          this.handle.setOpt(_Curl2.option.PROGRESSFUNCTION, cb);
        }
        return this;
      }
      /**
       * Add this instance to the processing queue.
       * This method should be called only one time per request,
       *  otherwise it will throw an error.
       *
       * @remarks
       *
       * This basically calls the {@link "Multi".Multi.addHandle | `Multi#addHandle`} method.
       */
      perform() {
        if (this.isRunning) {
          throw new Error("Handle already running!");
        }
        this.isRunning = true;
        const isStreamEnabled = this.features & CurlFeature_1.CurlFeature.StreamResponse || this.readFunctionStream;
        if (isStreamEnabled) {
          this.setProgressCallback(this.streamModeProgressFunction.bind(this));
          this.setOpt("NOPROGRESS", false);
        }
        multiHandle.addHandle(this.handle);
        return this;
      }
      /**
       * Perform any connection upkeep checks.
       *
       *
       * Official libcurl documentation: [`curl_easy_upkeep()`](http://curl.haxx.se/libcurl/c/curl_easy_upkeep.html)
       */
      upkeep() {
        const code = this.handle.upkeep();
        if (code !== CurlCode_1.CurlCode.CURLE_OK) {
          throw new Error(Easy_1.Easy.strError(code));
        }
        return this;
      }
      /**
       * Use this function to pause / unpause a connection.
       *
       * The bitmask argument is a set of bits that sets the new state of the connection.
       *
       * Use {@link CurlPause | `CurlPause`} for predefined constants.
       *
       *
       * Official libcurl documentation: [`curl_easy_pause()`](http://curl.haxx.se/libcurl/c/curl_easy_pause.html)
       */
      pause(bitmask) {
        const code = this.handle.pause(bitmask);
        if (code !== CurlCode_1.CurlCode.CURLE_OK) {
          throw new Error(Easy_1.Easy.strError(code));
        }
        return this;
      }
      /**
       * Reset this handle options to their defaults.
       *
       * This will put the handle in a clean state, as if it was just created.
       *
       *
       * Official libcurl documentation: [`curl_easy_reset()`](http://curl.haxx.se/libcurl/c/curl_easy_reset.html)
       */
      reset() {
        this.removeAllListeners();
        this.handle.reset();
        this.handle.setOpt(_Curl2.option.WRITEFUNCTION, this.defaultWriteFunction.bind(this));
        this.handle.setOpt(_Curl2.option.HEADERFUNCTION, this.defaultHeaderFunction.bind(this));
        return this;
      }
      /**
       * Duplicate this handle with all their options.
       * Keep in mind that, by default, this also means all event listeners.
       *
       *
       * Official libcurl documentation: [`curl_easy_duphandle()`](http://curl.haxx.se/libcurl/c/curl_easy_duphandle.html)
       *
       * @param shouldCopyEventListeners If you don't want to copy the event listeners, set this to `false`.
       */
      dupHandle(shouldCopyEventListeners = true) {
        const duplicatedHandle = new _Curl2(this.handle.dupHandle());
        const eventsToCopy = ["end", "error", "data", "header"];
        duplicatedHandle.features = this.features;
        if (shouldCopyEventListeners) {
          for (let i2 = 0; i2 < eventsToCopy.length; i2 += 1) {
            const listeners = this.listeners(eventsToCopy[i2]);
            for (let j3 = 0; j3 < listeners.length; j3 += 1) {
              duplicatedHandle.on(eventsToCopy[i2], listeners[j3]);
            }
          }
        }
        return duplicatedHandle;
      }
      /**
       * Close this handle.
       *
       * **NOTE:** After closing the handle, it must not be used anymore. Doing so will throw an error.
       *
       *
       * Official libcurl documentation: [`curl_easy_cleanup()`](http://curl.haxx.se/libcurl/c/curl_easy_cleanup.html)
       */
      close() {
        curlInstanceMap.delete(this.handle);
        this.removeAllListeners();
        if (this.handle.isInsideMultiHandle) {
          multiHandle.removeHandle(this.handle);
        }
        this.handle.setOpt(_Curl2.option.WRITEFUNCTION, null);
        this.handle.setOpt(_Curl2.option.HEADERFUNCTION, null);
        this.handle.close();
      }
      /**
       * This is used to reset a few properties to their pre-request state.
       */
      resetInternalState() {
        this.isRunning = false;
        this.chunks = [];
        this.chunksLength = 0;
        this.headerChunks = [];
        this.headerChunksLength = 0;
        const wasStreamEnabled = this.writeFunctionStream || this.readFunctionStream;
        if (wasStreamEnabled) {
          this.setProgressCallback(null);
        }
        if (this.readFunctionStream) {
          this.setOpt("READFUNCTION", null);
        }
        this.writeFunctionStream = null;
        this.readFunctionStream = null;
        this.streamReadFunctionShouldEnd = false;
        this.streamReadFunctionShouldPause = false;
        this.streamReadFunctionPaused = false;
        this.streamWriteFunctionShouldPause = false;
        this.streamWriteFunctionPaused = false;
        this.streamWriteFunctionFirstRun = true;
        this.streamPauseNext = false;
        this.streamContinueNext = false;
        this.streamError = false;
        this.streamUserSuppliedProgressFunction = null;
        this.cleanupReadFunctionStreamEvents();
      }
      /**
       * When uploading a stream (by calling {@link setUploadStream | `setUploadStream`})
       * some event listeners are attached to the stream instance.
       * This will remove them so our callbacks are not called anymore.
       */
      cleanupReadFunctionStreamEvents() {
        this.streamReadFunctionCallbacksToClean.forEach(([stream, event, cb]) => {
          stream.off(event, cb);
        });
        this.streamReadFunctionCallbacksToClean = [];
      }
      /**
       * Returns headers from the current stored chunks - if any
       */
      getHeaders() {
        const isHeaderStorageEnabled = !(this.features & CurlFeature_1.CurlFeature.NoHeaderStorage);
        const isHeaderParsingEnabled = !(this.features & CurlFeature_1.CurlFeature.NoHeaderParsing) && isHeaderStorageEnabled;
        const headersRaw = isHeaderStorageEnabled ? (0, mergeChunks_1.mergeChunks)(this.headerChunks, this.headerChunksLength) : Buffer.alloc(0);
        return isHeaderParsingEnabled ? (0, parseHeaders_1.parseHeaders)(decoder.write(headersRaw)) : headersRaw;
      }
      /**
       * The internal function passed to `PROGRESSFUNCTION` (`XFERINFOFUNCTION` on most recent libcurl versions)
       * when using any of the stream features.
       */
      streamModeProgressFunction(dltotal, dlnow, ultotal, ulnow) {
        if (this.streamError)
          throw this.streamError;
        const ret = this.streamUserSuppliedProgressFunction ? this.streamUserSuppliedProgressFunction.call(this.handle, dltotal, dlnow, ultotal, ulnow) : 0;
        return ret;
      }
      /**
       * This is the default callback passed to {@link setOpt | `setOpt('WRITEFUNCTION', cb)`}.
       */
      defaultWriteFunction(chunk3, size2, nmemb) {
        if (this.features & CurlFeature_1.CurlFeature.StreamResponse) {
          return this.defaultWriteFunctionStreamBased(chunk3, size2, nmemb);
        }
        if (!(this.features & CurlFeature_1.CurlFeature.NoDataStorage)) {
          this.chunks.push(chunk3);
          this.chunksLength += chunk3.length;
        }
        this.emit("data", chunk3, this);
        return size2 * nmemb;
      }
      /**
       * This is used by the default callback passed to {@link setOpt | `setOpt('WRITEFUNCTION', cb)`}
       * when the feature to stream response is enabled.
       */
      defaultWriteFunctionStreamBased(chunk3, size2, nmemb) {
        if (!this.writeFunctionStream) {
          const handle = this;
          this.writeFunctionStream = new stream_1.Readable({
            highWaterMark: this.streamWriteFunctionHighWaterMark,
            destroy(error, cb) {
              handle.streamError = error || new Error("Curl response stream was unexpectedly destroyed");
              setImmediate(() => {
                if (handle.isRunning && handle.streamWriteFunctionPaused) {
                  handle.streamWriteFunctionPaused = false;
                  handle.streamWriteFunctionShouldPause = true;
                  try {
                    handle.pause(CurlPause_1.CurlPause.RecvCont);
                  } catch (error2) {
                    cb(error2);
                    return;
                  }
                }
                cb(null);
              });
            },
            read(_size) {
              if (handle.streamWriteFunctionFirstRun || handle.streamWriteFunctionPaused) {
                if (handle.streamWriteFunctionFirstRun) {
                  handle.streamWriteFunctionFirstRun = false;
                }
                setImmediate(() => {
                  if (handle.isRunning) {
                    handle.streamWriteFunctionPaused = false;
                    handle.pause(CurlPause_1.CurlPause.RecvCont);
                  }
                });
              }
            }
          });
          const headers = this.getHeaders();
          const { code, data: status } = this.handle.getInfo(_Curl2.info.RESPONSE_CODE);
          if (code !== CurlCode_1.CurlCode.CURLE_OK) {
            const error = new Error("Could not get status code of request");
            this.emit("error", error, code, this);
            return 0;
          }
          setImmediate(() => this.emit("stream", this.writeFunctionStream, status, headers, this));
          this.streamWriteFunctionPaused = true;
          return CurlWriteFunc_1.CurlWriteFunc.Pause;
        }
        if (this.streamWriteFunctionShouldPause) {
          this.streamWriteFunctionShouldPause = false;
          this.streamWriteFunctionPaused = true;
          return CurlWriteFunc_1.CurlWriteFunc.Pause;
        }
        const ok = this.writeFunctionStream.push(chunk3);
        if (!ok) {
          this.streamWriteFunctionPaused = true;
          this.pause(CurlPause_1.CurlPause.Recv);
        }
        return size2 * nmemb;
      }
      /**
       * This is the default callback passed to {@link setOpt | `setOpt('HEADERFUNCTION', cb)`}.
       */
      defaultHeaderFunction(chunk3, size2, nmemb) {
        if (!(this.features & CurlFeature_1.CurlFeature.NoHeaderStorage)) {
          this.headerChunks.push(chunk3);
          this.headerChunksLength += chunk3.length;
        }
        this.emit("header", chunk3, this);
        return size2 * nmemb;
      }
    };
    exports2.Curl = Curl2;
    Curl2.globalInit = _Curl.globalInit;
    Curl2.globalCleanup = _Curl.globalCleanup;
    Curl2.getVersion = _Curl.getVersion;
    Curl2.defaultUserAgent = `node-libcurl/${pkg.version}`;
    Curl2.VERSION_NUM = _Curl.VERSION_NUM;
    Curl2.info = _Curl.info;
    Curl2.option = _Curl.option;
    Curl2.getCount = multiHandle.getCount;
    Curl2.getVersionInfo = () => CurlVersionInfo;
    Curl2.getVersionInfoString = () => {
      const version3 = Curl2.getVersion();
      const protocols = CurlVersionInfo.protocols.join(", ");
      const features = CurlVersionInfo.features.join(", ");
      return [
        `Version: ${version3}`,
        `Protocols: ${protocols}`,
        `Features: ${features}`
      ].join("\n");
    };
    Curl2.isVersionGreaterOrEqualThan = (x3, y2, z3 = 0) => {
      return _Curl.VERSION_NUM >= (x3 << 16) + (y2 << 8) + z3;
    };
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlShareOption.js
var require_CurlShareOption = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlShareOption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlShareOption = void 0;
    var CurlShareOption;
    (function(CurlShareOption2) {
      CurlShareOption2[CurlShareOption2["SHARE"] = 1] = "SHARE";
      CurlShareOption2[CurlShareOption2["UNSHARE"] = 2] = "UNSHARE";
    })(CurlShareOption = exports2.CurlShareOption || (exports2.CurlShareOption = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/Share.js
var require_Share = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/Share.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Share = void 0;
    var CurlShareOption_1 = require_CurlShareOption();
    var bindings = require("./node_libcurl-KNXTHJ25.node");
    var Share = class extends bindings.Share {
    };
    exports2.Share = Share;
    Share.option = CurlShareOption_1.CurlShareOption;
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/generated/CurlOption.js
var require_CurlOption = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/generated/CurlOption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlOptionCamelCaseMap = void 0;
    exports2.CurlOptionCamelCaseMap = {
      /**
       * Path to an abstract Unix domain socket.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ABSTRACT_UNIX_SOCKET.html](https://curl.haxx.se/libcurl/c/CURLOPT_ABSTRACT_UNIX_SOCKET.html)
       */
      abstractUnixSocket: "ABSTRACT_UNIX_SOCKET",
      /**
       * Accept-Encoding and automatic decompressing data.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html](https://curl.haxx.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html)
       */
      acceptEncoding: "ACCEPT_ENCODING",
      /**
       * Timeout for waiting for the server's connect back to be accepted.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ACCEPTTIMEOUT_MS.html](https://curl.haxx.se/libcurl/c/CURLOPT_ACCEPTTIMEOUT_MS.html)
       */
      acceptTimeoutMs: "ACCEPTTIMEOUT_MS",
      /**
       * IPv6 scope for local addresses.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ADDRESS_SCOPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_ADDRESS_SCOPE.html)
       */
      addressScope: "ADDRESS_SCOPE",
      /**
       * Specify the Alt-Svc: cache file name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ALTSVC.html](https://curl.haxx.se/libcurl/c/CURLOPT_ALTSVC.html)
       */
      altSvc: "ALTSVC",
      /**
       * Enable and configure Alt-Svc: treatment.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ALTSVC_CTRL.html](https://curl.haxx.se/libcurl/c/CURLOPT_ALTSVC_CTRL.html)
       */
      altSvcCtrl: "ALTSVC_CTRL",
      /**
       * Append to remote file.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_APPEND.html](https://curl.haxx.se/libcurl/c/CURLOPT_APPEND.html)
       */
      append: "APPEND",
      /**
       * Automatically set Referer: header.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_AUTOREFERER.html](https://curl.haxx.se/libcurl/c/CURLOPT_AUTOREFERER.html)
       */
      autoReferer: "AUTOREFERER",
      /**
       * AWS HTTP V4 Signature.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_AWS_SIGV4.html](https://curl.haxx.se/libcurl/c/CURLOPT_AWS_SIGV4.html)
       */
      awsSigV4: "AWS_SIGV4",
      /**
       * Ask for alternate buffer size.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_BUFFERSIZE.html](https://curl.haxx.se/libcurl/c/CURLOPT_BUFFERSIZE.html)
       */
      bufferSize: "BUFFERSIZE",
      /**
       * CA cert bundle.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CAINFO.html](https://curl.haxx.se/libcurl/c/CURLOPT_CAINFO.html)
       */
      caInfo: "CAINFO",
      /**
       * CA cert bundle memory buffer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CAINFO_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_CAINFO_BLOB.html)
       */
      caInfoBlob: "CAINFO_BLOB",
      /**
       * Path to CA cert bundle.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CAPATH.html](https://curl.haxx.se/libcurl/c/CURLOPT_CAPATH.html)
       */
      caPath: "CAPATH",
      /**
       * Extract certificate info.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CERTINFO.html](https://curl.haxx.se/libcurl/c/CURLOPT_CERTINFO.html)
       */
      certInfo: "CERTINFO",
      /**
       * Callback for wildcard download start of chunk.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CHUNK_BGN_FUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_CHUNK_BGN_FUNCTION.html)
       */
      chunkBgnFunction: "CHUNK_BGN_FUNCTION",
      /**
       * Callback for wildcard download end of chunk.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CHUNK_END_FUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_CHUNK_END_FUNCTION.html)
       */
      chunkEndFunction: "CHUNK_END_FUNCTION",
      /**
       * Only connect, nothing else.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CONNECT_ONLY.html](https://curl.haxx.se/libcurl/c/CURLOPT_CONNECT_ONLY.html)
       */
      connectOnly: "CONNECT_ONLY",
      /**
       * Connect to a specific host and port.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CONNECT_TO.html](https://curl.haxx.se/libcurl/c/CURLOPT_CONNECT_TO.html)
       */
      connectTo: "CONNECT_TO",
      /**
       * Timeout for the connection phase.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CONNECTTIMEOUT.html](https://curl.haxx.se/libcurl/c/CURLOPT_CONNECTTIMEOUT.html)
       */
      connectTimeout: "CONNECTTIMEOUT",
      /**
       * Millisecond timeout for the connection phase.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CONNECTTIMEOUT_MS.html](https://curl.haxx.se/libcurl/c/CURLOPT_CONNECTTIMEOUT_MS.html)
       */
      connectTimeoutMs: "CONNECTTIMEOUT_MS",
      /**
       * Cookie(s) to send.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_COOKIE.html](https://curl.haxx.se/libcurl/c/CURLOPT_COOKIE.html)
       */
      cookie: "COOKIE",
      /**
       * File to read cookies from.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_COOKIEFILE.html](https://curl.haxx.se/libcurl/c/CURLOPT_COOKIEFILE.html)
       */
      cookieFile: "COOKIEFILE",
      /**
       * File to write cookies to.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_COOKIEJAR.html](https://curl.haxx.se/libcurl/c/CURLOPT_COOKIEJAR.html)
       */
      cookieJar: "COOKIEJAR",
      /**
       * Add or control cookies.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_COOKIELIST.html](https://curl.haxx.se/libcurl/c/CURLOPT_COOKIELIST.html)
       */
      cookieList: "COOKIELIST",
      /**
       * Start a new cookie session.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_COOKIESESSION.html](https://curl.haxx.se/libcurl/c/CURLOPT_COOKIESESSION.html)
       */
      cookieSession: "COOKIESESSION",
      /**
       * Convert newlines.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CRLF.html](https://curl.haxx.se/libcurl/c/CURLOPT_CRLF.html)
       */
      crlf: "CRLF",
      /**
       * Certificate Revocation List.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CRLFILE.html](https://curl.haxx.se/libcurl/c/CURLOPT_CRLFILE.html)
       */
      crlFile: "CRLFILE",
      /**
       * Custom request/method.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_CUSTOMREQUEST.html](https://curl.haxx.se/libcurl/c/CURLOPT_CUSTOMREQUEST.html)
       */
      customRequest: "CUSTOMREQUEST",
      /**
       * Callback for debug information.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html)
       */
      debugFunction: "DEBUGFUNCTION",
      /**
       * Default protocol.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DEFAULT_PROTOCOL.html](https://curl.haxx.se/libcurl/c/CURLOPT_DEFAULT_PROTOCOL.html)
       */
      defaultProtocol: "DEFAULT_PROTOCOL",
      /**
       * List only.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DIRLISTONLY.html](https://curl.haxx.se/libcurl/c/CURLOPT_DIRLISTONLY.html)
       */
      dirListOnly: "DIRLISTONLY",
      /**
       * Don't allow username in URL.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DISALLOW_USERNAME_IN_URL.html](https://curl.haxx.se/libcurl/c/CURLOPT_DISALLOW_USERNAME_IN_URL.html)
       */
      disallowUsernameInUrl: "DISALLOW_USERNAME_IN_URL",
      /**
       * Timeout for DNS cache.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DNS_CACHE_TIMEOUT.html](https://curl.haxx.se/libcurl/c/CURLOPT_DNS_CACHE_TIMEOUT.html)
       */
      dnsCacheTimeout: "DNS_CACHE_TIMEOUT",
      /**
       * Bind name resolves to this interface.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DNS_INTERFACE.html](https://curl.haxx.se/libcurl/c/CURLOPT_DNS_INTERFACE.html)
       */
      dnsInterface: "DNS_INTERFACE",
      /**
       * Bind name resolves to this IP4 address.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DNS_LOCAL_IP4.html](https://curl.haxx.se/libcurl/c/CURLOPT_DNS_LOCAL_IP4.html)
       */
      dnsLocalIp4: "DNS_LOCAL_IP4",
      /**
       * Bind name resolves to this IP6 address.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DNS_LOCAL_IP6.html](https://curl.haxx.se/libcurl/c/CURLOPT_DNS_LOCAL_IP6.html)
       */
      dnsLocalIp6: "DNS_LOCAL_IP6",
      /**
       * Preferred DNS servers.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DNS_SERVERS.html](https://curl.haxx.se/libcurl/c/CURLOPT_DNS_SERVERS.html)
       */
      dnsServers: "DNS_SERVERS",
      /**
       * Shuffle addresses before use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DNS_SHUFFLE_ADDRESSES.html](https://curl.haxx.se/libcurl/c/CURLOPT_DNS_SHUFFLE_ADDRESSES.html)
       */
      dnsShuffleAddresses: "DNS_SHUFFLE_ADDRESSES",
      /**
       * OBSOLETE Enable global DNS cache.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DNS_USE_GLOBAL_CACHE.html](https://curl.haxx.se/libcurl/c/CURLOPT_DNS_USE_GLOBAL_CACHE.html)
       */
      dnsUseGlobalCache: "DNS_USE_GLOBAL_CACHE",
      /**
       * Verify the host name in the DoH (DNS-over-HTTPS) SSL certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DOH_SSL_VERIFYHOST.html](https://curl.haxx.se/libcurl/c/CURLOPT_DOH_SSL_VERIFYHOST.html)
       */
      dohSslVerifyHost: "DOH_SSL_VERIFYHOST",
      /**
       * Verify the DoH (DNS-over-HTTPS) SSL certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DOH_SSL_VERIFYPEER.html](https://curl.haxx.se/libcurl/c/CURLOPT_DOH_SSL_VERIFYPEER.html)
       */
      dohSslVerifyPeer: "DOH_SSL_VERIFYPEER",
      /**
       * Verify the DoH (DNS-over-HTTPS) SSL certificate's status.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DOH_SSL_VERIFYSTATUS.html](https://curl.haxx.se/libcurl/c/CURLOPT_DOH_SSL_VERIFYSTATUS.html)
       */
      dohSslVerifyStatus: "DOH_SSL_VERIFYSTATUS",
      /**
       * Use this DoH server for name resolves.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_DOH_URL.html](https://curl.haxx.se/libcurl/c/CURLOPT_DOH_URL.html)
       */
      dohUrl: "DOH_URL",
      /**
       * Identify EGD socket for entropy.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_EGDSOCKET.html](https://curl.haxx.se/libcurl/c/CURLOPT_EGDSOCKET.html)
       */
      egdSocket: "EGDSOCKET",
      /**
       * 100-continue timeout.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_EXPECT_100_TIMEOUT_MS.html](https://curl.haxx.se/libcurl/c/CURLOPT_EXPECT_100_TIMEOUT_MS.html)
       */
      expect100TimeoutMs: "EXPECT_100_TIMEOUT_MS",
      /**
       * Fail on HTTP 4xx errors.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FAILONERROR.html](https://curl.haxx.se/libcurl/c/CURLOPT_FAILONERROR.html)
       */
      failOnError: "FAILONERROR",
      /**
       * Request file modification date and time.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FILETIME.html](https://curl.haxx.se/libcurl/c/CURLOPT_FILETIME.html)
       */
      fileTime: "FILETIME",
      /**
       * Callback for wildcard matching.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FNMATCH_FUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_FNMATCH_FUNCTION.html)
       */
      fnMatchFunction: "FNMATCH_FUNCTION",
      /**
       * Follow HTTP redirects.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FOLLOWLOCATION.html](https://curl.haxx.se/libcurl/c/CURLOPT_FOLLOWLOCATION.html)
       */
      followLocation: "FOLLOWLOCATION",
      /**
       * Prevent subsequent connections from re-using this.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FORBID_REUSE.html](https://curl.haxx.se/libcurl/c/CURLOPT_FORBID_REUSE.html)
       */
      forbIdReuse: "FORBID_REUSE",
      /**
       * Use a new connection.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FRESH_CONNECT.html](https://curl.haxx.se/libcurl/c/CURLOPT_FRESH_CONNECT.html)
       */
      freshConnect: "FRESH_CONNECT",
      /**
       * Send ACCT command.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_ACCOUNT.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_ACCOUNT.html)
       */
      ftpAccount: "FTP_ACCOUNT",
      /**
       * Alternative to USER.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_ALTERNATIVE_TO_USER.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_ALTERNATIVE_TO_USER.html)
       */
      ftpAlternativeToUser: "FTP_ALTERNATIVE_TO_USER",
      /**
       * Create missing directories on the remote server.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_CREATE_MISSING_DIRS.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_CREATE_MISSING_DIRS.html)
       */
      ftpCreateMissingDirs: "FTP_CREATE_MISSING_DIRS",
      /**
       * Specify how to reach files.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_FILEMETHOD.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_FILEMETHOD.html)
       */
      ftpFileMethod: "FTP_FILEMETHOD",
      /**
       * Timeout for FTP responses.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_RESPONSE_TIMEOUT.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_RESPONSE_TIMEOUT.html)
       */
      ftpResponseTimeout: "FTP_RESPONSE_TIMEOUT",
      /**
       * Ignore the IP address in the PASV response.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_SKIP_PASV_IP.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_SKIP_PASV_IP.html)
       */
      ftpSkipPasvIp: "FTP_SKIP_PASV_IP",
      /**
       * Back to non-TLS again after authentication.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_SSL_CCC.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_SSL_CCC.html)
       */
      ftpSslCcc: "FTP_SSL_CCC",
      /**
       * Use EPTR.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_USE_EPRT.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_USE_EPRT.html)
       */
      ftpUseEprt: "FTP_USE_EPRT",
      /**
       * Use EPSV.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_USE_EPSV.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_USE_EPSV.html)
       */
      ftpUseEpsv: "FTP_USE_EPSV",
      /**
       * Use PRET.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTP_USE_PRET.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTP_USE_PRET.html)
       */
      ftpUsePret: "FTP_USE_PRET",
      /**
       * Use active FTP.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTPPORT.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTPPORT.html)
       */
      ftpPort: "FTPPORT",
      /**
       * Control how to do TLS.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_FTPSSLAUTH.html](https://curl.haxx.se/libcurl/c/CURLOPT_FTPSSLAUTH.html)
       */
      ftpSslAuth: "FTPSSLAUTH",
      /**
       * Disable GSS-API delegation.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_GSSAPI_DELEGATION.html](https://curl.haxx.se/libcurl/c/CURLOPT_GSSAPI_DELEGATION.html)
       */
      gssapiDelegation: "GSSAPI_DELEGATION",
      /**
       * Timeout for happy eyeballs.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.html](https://curl.haxx.se/libcurl/c/CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.html)
       */
      happyEyeballsTimeoutMs: "HAPPY_EYEBALLS_TIMEOUT_MS",
      /**
       * Send an HAProxy PROXY protocol v1 header.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HAPROXYPROTOCOL.html](https://curl.haxx.se/libcurl/c/CURLOPT_HAPROXYPROTOCOL.html)
       */
      haProxyProtocol: "HAPROXYPROTOCOL",
      /**
       * Include the header in the body output.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HEADER.html](https://curl.haxx.se/libcurl/c/CURLOPT_HEADER.html)
       */
      header: "HEADER",
      /**
       * Callback for writing received headers.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HEADERFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_HEADERFUNCTION.html)
       */
      headerFunction: "HEADERFUNCTION",
      /**
       * Control custom headers.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HEADEROPT.html](https://curl.haxx.se/libcurl/c/CURLOPT_HEADEROPT.html)
       */
      headerOpt: "HEADEROPT",
      /**
       * Set HSTS cache file.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HSTS.html](https://curl.haxx.se/libcurl/c/CURLOPT_HSTS.html)
       */
      hsts: "HSTS",
      /**
       * Enable HSTS.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HSTS_CTRL.html](https://curl.haxx.se/libcurl/c/CURLOPT_HSTS_CTRL.html)
       */
      hstsCtrl: "HSTS_CTRL",
      /**
       * Set HSTS read callback.
       *
       * You can either return a single `CurlHstsReadCallbackResult` object or an array of `CurlHstsReadCallbackResult` objects.
       * If returning an array, the callback will only be called once per request.
       * If returning a single object, the callback will be called multiple times until `null` is returned.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HSTSREADFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_HSTSREADFUNCTION.html)
       */
      hstsReadFunction: "HSTSREADFUNCTION",
      /**
       * Set HSTS write callback.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HSTSWRITEFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_HSTSWRITEFUNCTION.html)
       */
      hstsWriteFunction: "HSTSWRITEFUNCTION",
      /**
       * Disable Content decoding.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_CONTENT_DECODING.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_CONTENT_DECODING.html)
       */
      httpContentDecoding: "HTTP_CONTENT_DECODING",
      /**
       * Disable Transfer decoding.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_TRANSFER_DECODING.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_TRANSFER_DECODING.html)
       */
      httpTransferDecoding: "HTTP_TRANSFER_DECODING",
      /**
       * HTTP version to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_VERSION.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_VERSION.html)
       */
      httpVersion: "HTTP_VERSION",
      /**
       * Allow HTTP/0.9 responses.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTP09_ALLOWED.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTP09_ALLOWED.html)
       */
      http09Allowed: "HTTP09_ALLOWED",
      /**
       * Alternative versions of 200 OK.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTP200ALIASES.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTP200ALIASES.html)
       */
      http200aliases: "HTTP200ALIASES",
      /**
       * HTTP server authentication methods.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTPAUTH.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTPAUTH.html)
       */
      httpAuth: "HTTPAUTH",
      /**
       * Do an HTTP GET request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTPGET.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTPGET.html)
       */
      httpGet: "HTTPGET",
      /**
       * Custom HTTP headers.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTPHEADER.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTPHEADER.html)
       */
      httpHeader: "HTTPHEADER",
      /**
       * Multipart formpost HTTP POST.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTPPOST.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTPPOST.html)
       */
      httpPost: "HTTPPOST",
      /**
       * Tunnel through the HTTP proxy.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_HTTPPROXYTUNNEL.html](https://curl.haxx.se/libcurl/c/CURLOPT_HTTPPROXYTUNNEL.html)
       */
      httpProxyTunnel: "HTTPPROXYTUNNEL",
      /**
       * Ignore Content-Length.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_IGNORE_CONTENT_LENGTH.html](https://curl.haxx.se/libcurl/c/CURLOPT_IGNORE_CONTENT_LENGTH.html)
       */
      ignoreContentLength: "IGNORE_CONTENT_LENGTH",
      /**
       * Size of file to send.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_INFILESIZE.html](https://curl.haxx.se/libcurl/c/CURLOPT_INFILESIZE.html)
       */
      inFileSize: "INFILESIZE",
      /**
       * Size of file to send.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_INFILESIZE_LARGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_INFILESIZE_LARGE.html)
       */
      inFileSizeLarge: "INFILESIZE_LARGE",
      /**
       * Bind connection locally to this.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_INTERFACE.html](https://curl.haxx.se/libcurl/c/CURLOPT_INTERFACE.html)
       */
      interface: "INTERFACE",
      /**
       * IP version to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_IPRESOLVE.html](https://curl.haxx.se/libcurl/c/CURLOPT_IPRESOLVE.html)
       */
      ipResolve: "IPRESOLVE",
      /**
       * Issuer certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ISSUERCERT.html](https://curl.haxx.se/libcurl/c/CURLOPT_ISSUERCERT.html)
       */
      issuerCert: "ISSUERCERT",
      /**
       * Issuer certificate memory buffer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_ISSUERCERT_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_ISSUERCERT_BLOB.html)
       */
      issuerCertBlob: "ISSUERCERT_BLOB",
      /**
       * Keep sending on HTTP \>= 300 errors.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_KEEP_SENDING_ON_ERROR.html](https://curl.haxx.se/libcurl/c/CURLOPT_KEEP_SENDING_ON_ERROR.html)
       */
      keepSendingOnError: "KEEP_SENDING_ON_ERROR",
      /**
       * Client key password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_KEYPASSWD.html](https://curl.haxx.se/libcurl/c/CURLOPT_KEYPASSWD.html)
       */
      keyPasswd: "KEYPASSWD",
      /**
       * Kerberos security level.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_KRBLEVEL.html](https://curl.haxx.se/libcurl/c/CURLOPT_KRBLEVEL.html)
       */
      krbLevel: "KRBLEVEL",
      /**
       * Bind connection locally to this port.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_LOCALPORT.html](https://curl.haxx.se/libcurl/c/CURLOPT_LOCALPORT.html)
       */
      localPort: "LOCALPORT",
      /**
       * Bind connection locally to port range.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_LOCALPORTRANGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_LOCALPORTRANGE.html)
       */
      localPortRange: "LOCALPORTRANGE",
      /**
       * Login options.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_LOGIN_OPTIONS.html](https://curl.haxx.se/libcurl/c/CURLOPT_LOGIN_OPTIONS.html)
       */
      loginOptions: "LOGIN_OPTIONS",
      /**
       * Low speed limit to abort transfer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html](https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html)
       */
      lowSpeedLimit: "LOW_SPEED_LIMIT",
      /**
       * Time to be below the speed to trigger low speed abort.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html](https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html)
       */
      lowSpeedTime: "LOW_SPEED_TIME",
      /**
       * Authentication address.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_AUTH.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_AUTH.html)
       */
      mailAuth: "MAIL_AUTH",
      /**
       * Address of the sender.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_FROM.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_FROM.html)
       */
      mailFrom: "MAIL_FROM",
      /**
       * Address of the recipients.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_RCPT.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_RCPT.html)
       */
      mailRcpt: "MAIL_RCPT",
      /**
       * Allow RCPT TO command to fail for some recipients.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_RCPT_ALLLOWFAILS.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAIL_RCPT_ALLLOWFAILS.html)
       */
      mailRcptAlllowfails: "MAIL_RCPT_ALLLOWFAILS",
      /**
       * Cap the download speed to this.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAX_RECV_SPEED_LARGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAX_RECV_SPEED_LARGE.html)
       */
      maxRecvSpeedLarge: "MAX_RECV_SPEED_LARGE",
      /**
       * Cap the upload speed to this.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAX_SEND_SPEED_LARGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAX_SEND_SPEED_LARGE.html)
       */
      maxSendSpeedLarge: "MAX_SEND_SPEED_LARGE",
      /**
       * Limit the age of connections for reuse.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAXAGE_CONN.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAXAGE_CONN.html)
       */
      maxAgeConn: "MAXAGE_CONN",
      /**
       * Maximum number of connections in the connection pool.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAXCONNECTS.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAXCONNECTS.html)
       */
      maxConnects: "MAXCONNECTS",
      /**
       * Maximum file size to get.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAXFILESIZE.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAXFILESIZE.html)
       */
      maxFileSize: "MAXFILESIZE",
      /**
       * Maximum file size to get.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAXFILESIZE_LARGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAXFILESIZE_LARGE.html)
       */
      maxFileSizeLarge: "MAXFILESIZE_LARGE",
      /**
       * Maximum number of redirects to follow.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MAXREDIRS.html](https://curl.haxx.se/libcurl/c/CURLOPT_MAXREDIRS.html)
       */
      maxRedirs: "MAXREDIRS",
      /**
       * Post/send MIME data.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_MIMEPOST.html](https://curl.haxx.se/libcurl/c/CURLOPT_MIMEPOST.html)
       */
      mimePost: "MIMEPOST",
      /**
       * Enable .netrc parsing.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NETRC.html](https://curl.haxx.se/libcurl/c/CURLOPT_NETRC.html)
       */
      netrc: "NETRC",
      /**
       * .netrc file name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NETRC_FILE.html](https://curl.haxx.se/libcurl/c/CURLOPT_NETRC_FILE.html)
       */
      netrcFile: "NETRC_FILE",
      /**
       * Mode for creating new remote directories.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NEW_DIRECTORY_PERMS.html](https://curl.haxx.se/libcurl/c/CURLOPT_NEW_DIRECTORY_PERMS.html)
       */
      newDirectoryPerms: "NEW_DIRECTORY_PERMS",
      /**
       * Mode for creating new remote files.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NEW_FILE_PERMS.html](https://curl.haxx.se/libcurl/c/CURLOPT_NEW_FILE_PERMS.html)
       */
      newFilePerms: "NEW_FILE_PERMS",
      /**
       * Do not get the body contents.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NOBODY.html](https://curl.haxx.se/libcurl/c/CURLOPT_NOBODY.html)
       */
      nobody: "NOBODY",
      /**
       * Shut off the progress meter.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NOPROGRESS.html](https://curl.haxx.se/libcurl/c/CURLOPT_NOPROGRESS.html)
       */
      noProgress: "NOPROGRESS",
      /**
       * Filter out hosts from proxy use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html](https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html)
       */
      noProxy: "NOPROXY",
      /**
       * Do not install signal handlers.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_NOSIGNAL.html](https://curl.haxx.se/libcurl/c/CURLOPT_NOSIGNAL.html)
       */
      noSignal: "NOSIGNAL",
      /**
       * Password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PASSWORD.html](https://curl.haxx.se/libcurl/c/CURLOPT_PASSWORD.html)
       */
      password: "PASSWORD",
      /**
       * Disable squashing /../ and /./ sequences in the path.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PATH_AS_IS.html](https://curl.haxx.se/libcurl/c/CURLOPT_PATH_AS_IS.html)
       */
      pathAsIs: "PATH_AS_IS",
      /**
       * Set pinned SSL public key .
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PINNEDPUBLICKEY.html](https://curl.haxx.se/libcurl/c/CURLOPT_PINNEDPUBLICKEY.html)
       */
      pinnedPublicKey: "PINNEDPUBLICKEY",
      /**
       * Wait on connection to pipeline on it.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PIPEWAIT.html](https://curl.haxx.se/libcurl/c/CURLOPT_PIPEWAIT.html)
       */
      pipeWait: "PIPEWAIT",
      /**
       * Port number to connect to.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PORT.html](https://curl.haxx.se/libcurl/c/CURLOPT_PORT.html)
       */
      port: "PORT",
      /**
       * Issue an HTTP POST request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_POST.html](https://curl.haxx.se/libcurl/c/CURLOPT_POST.html)
       */
      post: "POST",
      /**
       * Send a POST with this data.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_POSTFIELDS.html](https://curl.haxx.se/libcurl/c/CURLOPT_POSTFIELDS.html)
       */
      postFields: "POSTFIELDS",
      /**
       * The POST data is this big.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_POSTFIELDSIZE.html](https://curl.haxx.se/libcurl/c/CURLOPT_POSTFIELDSIZE.html)
       */
      postFieldSize: "POSTFIELDSIZE",
      /**
       * The POST data is this big.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_POSTFIELDSIZE_LARGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_POSTFIELDSIZE_LARGE.html)
       */
      postFieldSizeLarge: "POSTFIELDSIZE_LARGE",
      /**
       * Commands to run after transfer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_POSTQUOTE.html](https://curl.haxx.se/libcurl/c/CURLOPT_POSTQUOTE.html)
       */
      postQuote: "POSTQUOTE",
      /**
       * How to act on redirects after POST.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_POSTREDIR.html](https://curl.haxx.se/libcurl/c/CURLOPT_POSTREDIR.html)
       */
      postRedir: "POSTREDIR",
      /**
       * Socks proxy to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PRE_PROXY.html](https://curl.haxx.se/libcurl/c/CURLOPT_PRE_PROXY.html)
       */
      preProxy: "PRE_PROXY",
      /**
       * Commands to run just before transfer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PREQUOTE.html](https://curl.haxx.se/libcurl/c/CURLOPT_PREQUOTE.html)
       */
      preQuote: "PREQUOTE",
      /**
       * OBSOLETE callback for progress meter.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROGRESSFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROGRESSFUNCTION.html)
       */
      progressFunction: "PROGRESSFUNCTION",
      /**
       * Allowed protocols.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROTOCOLS.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROTOCOLS.html)
       */
      protocols: "PROTOCOLS",
      /**
       * Proxy to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY.html)
       */
      proxy: "PROXY",
      /**
       * Proxy CA cert bundle.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CAINFO.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CAINFO.html)
       */
      proxyCaInfo: "PROXY_CAINFO",
      /**
       * Proxy CA cert bundle memory buffer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CAINFO_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CAINFO_BLOB.html)
       */
      proxyCaInfoBlob: "PROXY_CAINFO_BLOB",
      /**
       * Path to proxy CA cert bundle.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CAPATH.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CAPATH.html)
       */
      proxyCaPath: "PROXY_CAPATH",
      /**
       * Proxy Certificate Revocation List.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CRLFILE.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_CRLFILE.html)
       */
      proxyCrlFile: "PROXY_CRLFILE",
      /**
       * Proxy issuer certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_ISSUERCERT.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_ISSUERCERT.html)
       */
      proxyIssuerCert: "PROXY_ISSUERCERT",
      /**
       * Proxy issuer certificate memory buffer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_ISSUERCERT_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_ISSUERCERT_BLOB.html)
       */
      proxyIssuerCertBlob: "PROXY_ISSUERCERT_BLOB",
      /**
       * Proxy client key password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_KEYPASSWD.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_KEYPASSWD.html)
       */
      proxyKeyPasswd: "PROXY_KEYPASSWD",
      /**
       * Set the proxy's pinned SSL public key.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_PINNEDPUBLICKEY.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_PINNEDPUBLICKEY.html)
       */
      proxyPinnedPublicKey: "PROXY_PINNEDPUBLICKEY",
      /**
       * Proxy authentication service name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SERVICE_NAME.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SERVICE_NAME.html)
       */
      proxyServiceName: "PROXY_SERVICE_NAME",
      /**
       * Proxy ciphers to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_CIPHER_LIST.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_CIPHER_LIST.html)
       */
      proxySslCipherList: "PROXY_SSL_CIPHER_LIST",
      /**
       * Control proxy SSL behavior.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_OPTIONS.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_OPTIONS.html)
       */
      proxySslOptions: "PROXY_SSL_OPTIONS",
      /**
       * Verify the host name in the proxy SSL certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_VERIFYHOST.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_VERIFYHOST.html)
       */
      proxySslVerifyHost: "PROXY_SSL_VERIFYHOST",
      /**
       * Verify the proxy SSL certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_VERIFYPEER.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSL_VERIFYPEER.html)
       */
      proxySslVerifyPeer: "PROXY_SSL_VERIFYPEER",
      /**
       * Proxy client cert.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLCERT.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLCERT.html)
       */
      proxySslCert: "PROXY_SSLCERT",
      /**
       * Proxy client cert memory buffer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLCERT_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLCERT_BLOB.html)
       */
      proxySslCertBlob: "PROXY_SSLCERT_BLOB",
      /**
       * Proxy client cert type.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLCERTTYPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLCERTTYPE.html)
       */
      proxySslCertType: "PROXY_SSLCERTTYPE",
      /**
       * Proxy client key.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLKEY.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLKEY.html)
       */
      proxySslKey: "PROXY_SSLKEY",
      /**
       * Proxy client key.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLKEY_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLKEY_BLOB.html)
       */
      proxySslKeyBlob: "PROXY_SSLKEY_BLOB",
      /**
       * Proxy client key type.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLKEYTYPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLKEYTYPE.html)
       */
      proxySslKeyType: "PROXY_SSLKEYTYPE",
      /**
       * Proxy SSL version to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLVERSION.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_SSLVERSION.html)
       */
      proxySslversion: "PROXY_SSLVERSION",
      /**
       * Proxy TLS 1.3 cipher suites to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLS13_CIPHERS.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLS13_CIPHERS.html)
       */
      proxyTls13Ciphers: "PROXY_TLS13_CIPHERS",
      /**
       * Proxy TLS authentication password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLSAUTH_PASSWORD.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLSAUTH_PASSWORD.html)
       */
      proxyTlsAuthPassword: "PROXY_TLSAUTH_PASSWORD",
      /**
       * Proxy TLS authentication methods.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLSAUTH_TYPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLSAUTH_TYPE.html)
       */
      proxyTlsAuthType: "PROXY_TLSAUTH_TYPE",
      /**
       * Proxy TLS authentication user name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLSAUTH_USERNAME.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TLSAUTH_USERNAME.html)
       */
      proxyTlsAuthUsername: "PROXY_TLSAUTH_USERNAME",
      /**
       * Add transfer mode to URL over proxy.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TRANSFER_MODE.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXY_TRANSFER_MODE.html)
       */
      proxyTransferMode: "PROXY_TRANSFER_MODE",
      /**
       * HTTP proxy authentication methods.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXYAUTH.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXYAUTH.html)
       */
      proxyAuth: "PROXYAUTH",
      /**
       * Custom HTTP headers sent to proxy.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXYHEADER.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXYHEADER.html)
       */
      proxyHeader: "PROXYHEADER",
      /**
       * Proxy password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPASSWORD.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPASSWORD.html)
       */
      proxyPassword: "PROXYPASSWORD",
      /**
       * Proxy port to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPORT.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXYPORT.html)
       */
      proxyPort: "PROXYPORT",
      /**
       * Proxy type.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXYTYPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXYTYPE.html)
       */
      proxyType: "PROXYTYPE",
      /**
       * Proxy user name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXYUSERNAME.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXYUSERNAME.html)
       */
      proxyUsername: "PROXYUSERNAME",
      /**
       * Proxy user name and password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PROXYUSERPWD.html](https://curl.haxx.se/libcurl/c/CURLOPT_PROXYUSERPWD.html)
       */
      proxyUserpwd: "PROXYUSERPWD",
      /**
       * Issue an HTTP PUT request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_PUT.html](https://curl.haxx.se/libcurl/c/CURLOPT_PUT.html)
       */
      put: "PUT",
      /**
       * Commands to run before transfer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_QUOTE.html](https://curl.haxx.se/libcurl/c/CURLOPT_QUOTE.html)
       */
      quote: "QUOTE",
      /**
       * Provide source for entropy random data.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RANDOM_FILE.html](https://curl.haxx.se/libcurl/c/CURLOPT_RANDOM_FILE.html)
       */
      randomFile: "RANDOM_FILE",
      /**
       * Range requests.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RANGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_RANGE.html)
       */
      range: "RANGE",
      /**
       * Data pointer to pass to the read callback.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_READDATA.html](https://curl.haxx.se/libcurl/c/CURLOPT_READDATA.html)
       */
      readData: "READDATA",
      /**
       * Callback for reading data.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_READFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_READFUNCTION.html)
       */
      readFunction: "READFUNCTION",
      /**
       * Protocols to allow redirects to.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_REDIR_PROTOCOLS.html](https://curl.haxx.se/libcurl/c/CURLOPT_REDIR_PROTOCOLS.html)
       */
      redirProtocols: "REDIR_PROTOCOLS",
      /**
       * Referer: header.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_REFERER.html](https://curl.haxx.se/libcurl/c/CURLOPT_REFERER.html)
       */
      referer: "REFERER",
      /**
       * Set the request target.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_REQUEST_TARGET.html](https://curl.haxx.se/libcurl/c/CURLOPT_REQUEST_TARGET.html)
       */
      requestTarget: "REQUEST_TARGET",
      /**
       * Provide fixed/fake name resolves.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RESOLVE.html](https://curl.haxx.se/libcurl/c/CURLOPT_RESOLVE.html)
       */
      resolve: "RESOLVE",
      /**
       * Resume a transfer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RESUME_FROM.html](https://curl.haxx.se/libcurl/c/CURLOPT_RESUME_FROM.html)
       */
      resumeFrom: "RESUME_FROM",
      /**
       * Resume a transfer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RESUME_FROM_LARGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_RESUME_FROM_LARGE.html)
       */
      resumeFromLarge: "RESUME_FROM_LARGE",
      /**
       * Client CSEQ number.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_CLIENT_CSEQ.html](https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_CLIENT_CSEQ.html)
       */
      rtspClientCseq: "RTSP_CLIENT_CSEQ",
      /**
       * RTSP request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_REQUEST.html](https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_REQUEST.html)
       */
      rtspRequest: "RTSP_REQUEST",
      /**
       * CSEQ number for RTSP Server-\>Client request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_SERVER_CSEQ.html](https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_SERVER_CSEQ.html)
       */
      rtspServerCseq: "RTSP_SERVER_CSEQ",
      /**
       * RTSP session-id.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_SESSION_ID.html](https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_SESSION_ID.html)
       */
      rtspSessionId: "RTSP_SESSION_ID",
      /**
       * RTSP stream URI.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_STREAM_URI.html](https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_STREAM_URI.html)
       */
      rtspStreamUri: "RTSP_STREAM_URI",
      /**
       * RTSP Transport: header.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_TRANSPORT.html](https://curl.haxx.se/libcurl/c/CURLOPT_RTSP_TRANSPORT.html)
       */
      rtspTransPort: "RTSP_TRANSPORT",
      /**
       * SASL authorisation identity (identity to act as).
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SASL_AUTHZID.html](https://curl.haxx.se/libcurl/c/CURLOPT_SASL_AUTHZID.html)
       */
      saslAuthzId: "SASL_AUTHZID",
      /**
       * Enable SASL initial response.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SASL_IR.html](https://curl.haxx.se/libcurl/c/CURLOPT_SASL_IR.html)
       */
      saslIr: "SASL_IR",
      /**
       * Callback for seek operations.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SEEKFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_SEEKFUNCTION.html)
       */
      seekFunction: "SEEKFUNCTION",
      /**
       * Authentication service name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SERVICE_NAME.html](https://curl.haxx.se/libcurl/c/CURLOPT_SERVICE_NAME.html)
       */
      serviceName: "SERVICE_NAME",
      /**
       * Share object to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SHARE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SHARE.html)
       */
      share: "SHARE",
      /**
       * Socks5 authentication methods.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SOCKS5_AUTH.html](https://curl.haxx.se/libcurl/c/CURLOPT_SOCKS5_AUTH.html)
       */
      socks5Auth: "SOCKS5_AUTH",
      /**
       * Socks5 GSSAPI NEC mode.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SOCKS5_GSSAPI_NEC.html](https://curl.haxx.se/libcurl/c/CURLOPT_SOCKS5_GSSAPI_NEC.html)
       */
      socks5GssapiNec: "SOCKS5_GSSAPI_NEC",
      /**
       * Socks5 GSSAPI service name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SOCKS5_GSSAPI_SERVICE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SOCKS5_GSSAPI_SERVICE.html)
       */
      socks5GssapiService: "SOCKS5_GSSAPI_SERVICE",
      /**
       * SSH authentication types.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSH_AUTH_TYPES.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSH_AUTH_TYPES.html)
       */
      sshAuthTypes: "SSH_AUTH_TYPES",
      /**
       * Enable SSH compression.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSH_COMPRESSION.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSH_COMPRESSION.html)
       */
      sshCompression: "SSH_COMPRESSION",
      /**
       * MD5 of host's public key.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSH_HOST_PUBLIC_KEY_MD5.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSH_HOST_PUBLIC_KEY_MD5.html)
       */
      sshHostPublicKeyMd5: "SSH_HOST_PUBLIC_KEY_MD5",
      /**
       * File name with known hosts.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSH_KNOWNHOSTS.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSH_KNOWNHOSTS.html)
       */
      sshKnownHosts: "SSH_KNOWNHOSTS",
      /**
       * File name of private key.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSH_PRIVATE_KEYFILE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSH_PRIVATE_KEYFILE.html)
       */
      sshPrivateKeyFile: "SSH_PRIVATE_KEYFILE",
      /**
       * File name of public key.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSH_PUBLIC_KEYFILE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSH_PUBLIC_KEYFILE.html)
       */
      sshPublicKeyFile: "SSH_PUBLIC_KEYFILE",
      /**
       * Ciphers to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_CIPHER_LIST.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_CIPHER_LIST.html)
       */
      sslCipherList: "SSL_CIPHER_LIST",
      /**
       * Set key exchange curves.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_EC_CURVES.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_EC_CURVES.html)
       */
      sslEcCurves: "SSL_EC_CURVES",
      /**
       * Enable use of ALPN.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_ENABLE_ALPN.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_ENABLE_ALPN.html)
       */
      sslEnableAlpn: "SSL_ENABLE_ALPN",
      /**
       * Enable use of NPN.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_ENABLE_NPN.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_ENABLE_NPN.html)
       */
      sslEnableNpn: "SSL_ENABLE_NPN",
      /**
       * Enable TLS False Start.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_FALSESTART.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_FALSESTART.html)
       */
      sslFalsestart: "SSL_FALSESTART",
      /**
       * Control SSL behavior.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_OPTIONS.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_OPTIONS.html)
       */
      sslOptions: "SSL_OPTIONS",
      /**
       * Disable SSL session-id cache.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_SESSIONID_CACHE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_SESSIONID_CACHE.html)
       */
      sslSessionIdCache: "SSL_SESSIONID_CACHE",
      /**
       * Verify the host name in the SSL certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html)
       */
      sslVerifyHost: "SSL_VERIFYHOST",
      /**
       * Verify the SSL certificate.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html)
       */
      sslVerifyPeer: "SSL_VERIFYPEER",
      /**
       * Verify the SSL certificate's status.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYSTATUS.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYSTATUS.html)
       */
      sslVerifyStatus: "SSL_VERIFYSTATUS",
      /**
       * Client cert.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html)
       */
      sslCert: "SSLCERT",
      /**
       * Client cert memory buffer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT_BLOB.html)
       */
      sslCertBlob: "SSLCERT_BLOB",
      /**
       * Client cert type.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERTTYPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERTTYPE.html)
       */
      sslCertType: "SSLCERTTYPE",
      /**
       * Use identifier with SSL engine.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLENGINE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLENGINE.html)
       */
      sslEngine: "SSLENGINE",
      /**
       * Default SSL engine.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLENGINE_DEFAULT.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLENGINE_DEFAULT.html)
       */
      sslEngineDefault: "SSLENGINE_DEFAULT",
      /**
       * Client key.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html)
       */
      sslKey: "SSLKEY",
      /**
       * Client key memory buffer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY_BLOB.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY_BLOB.html)
       */
      sslKeyBlob: "SSLKEY_BLOB",
      /**
       * Client key type.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEYTYPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEYTYPE.html)
       */
      sslKeyType: "SSLKEYTYPE",
      /**
       * SSL version to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SSLVERSION.html](https://curl.haxx.se/libcurl/c/CURLOPT_SSLVERSION.html)
       */
      sslversion: "SSLVERSION",
      /**
       * Suppress proxy CONNECT response headers from user callbacks.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_SUPPRESS_CONNECT_HEADERS.html](https://curl.haxx.se/libcurl/c/CURLOPT_SUPPRESS_CONNECT_HEADERS.html)
       */
      suppressConnectHeaders: "SUPPRESS_CONNECT_HEADERS",
      /**
       * Enable TFO, TCP Fast Open.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TCP_FASTOPEN.html](https://curl.haxx.se/libcurl/c/CURLOPT_TCP_FASTOPEN.html)
       */
      tcpFastOpen: "TCP_FASTOPEN",
      /**
       * Enable TCP keep-alive.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html](https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html)
       */
      tcpKeepAlive: "TCP_KEEPALIVE",
      /**
       * Idle time before sending keep-alive.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html](https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html)
       */
      tcpKeepIdle: "TCP_KEEPIDLE",
      /**
       * Interval between keep-alive probes.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html](https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html)
       */
      tcpKeepIntvl: "TCP_KEEPINTVL",
      /**
       * Disable the Nagle algorithm.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TCP_NODELAY.html](https://curl.haxx.se/libcurl/c/CURLOPT_TCP_NODELAY.html)
       */
      tcpNoDelay: "TCP_NODELAY",
      /**
       * TELNET options.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TELNETOPTIONS.html](https://curl.haxx.se/libcurl/c/CURLOPT_TELNETOPTIONS.html)
       */
      telnetOptions: "TELNETOPTIONS",
      /**
       * TFTP block size.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TFTP_BLKSIZE.html](https://curl.haxx.se/libcurl/c/CURLOPT_TFTP_BLKSIZE.html)
       */
      tftpBlkSize: "TFTP_BLKSIZE",
      /**
       * Do not send TFTP options requests.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TFTP_NO_OPTIONS.html](https://curl.haxx.se/libcurl/c/CURLOPT_TFTP_NO_OPTIONS.html)
       */
      tftpNoOptions: "TFTP_NO_OPTIONS",
      /**
       * Make a time conditional request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TIMECONDITION.html](https://curl.haxx.se/libcurl/c/CURLOPT_TIMECONDITION.html)
       */
      timeCondition: "TIMECONDITION",
      /**
       * Timeout for the entire request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TIMEOUT.html](https://curl.haxx.se/libcurl/c/CURLOPT_TIMEOUT.html)
       */
      timeout: "TIMEOUT",
      /**
       * Millisecond timeout for the entire request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TIMEOUT_MS.html](https://curl.haxx.se/libcurl/c/CURLOPT_TIMEOUT_MS.html)
       */
      timeoutMs: "TIMEOUT_MS",
      /**
       * Time value for the time conditional request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TIMEVALUE.html](https://curl.haxx.se/libcurl/c/CURLOPT_TIMEVALUE.html)
       */
      timeValue: "TIMEVALUE",
      /**
       * Time value for the time conditional request.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TIMEVALUE_LARGE.html](https://curl.haxx.se/libcurl/c/CURLOPT_TIMEVALUE_LARGE.html)
       */
      timeValueLarge: "TIMEVALUE_LARGE",
      /**
       * TLS 1.3 cipher suites to use.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TLS13_CIPHERS.html](https://curl.haxx.se/libcurl/c/CURLOPT_TLS13_CIPHERS.html)
       */
      tls13Ciphers: "TLS13_CIPHERS",
      /**
       * TLS authentication password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TLSAUTH_PASSWORD.html](https://curl.haxx.se/libcurl/c/CURLOPT_TLSAUTH_PASSWORD.html)
       */
      tlsAuthPassword: "TLSAUTH_PASSWORD",
      /**
       * TLS authentication methods.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TLSAUTH_TYPE.html](https://curl.haxx.se/libcurl/c/CURLOPT_TLSAUTH_TYPE.html)
       */
      tlsAuthType: "TLSAUTH_TYPE",
      /**
       * TLS authentication user name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TLSAUTH_USERNAME.html](https://curl.haxx.se/libcurl/c/CURLOPT_TLSAUTH_USERNAME.html)
       */
      tlsAuthUsername: "TLSAUTH_USERNAME",
      /**
       * Set callback for sending trailing headers.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TRAILERFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_TRAILERFUNCTION.html)
       */
      trailerFunction: "TRAILERFUNCTION",
      /**
       * Request Transfer-Encoding.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TRANSFER_ENCODING.html](https://curl.haxx.se/libcurl/c/CURLOPT_TRANSFER_ENCODING.html)
       */
      transferEncoding: "TRANSFER_ENCODING",
      /**
       * Use text transfer.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_TRANSFERTEXT.html](https://curl.haxx.se/libcurl/c/CURLOPT_TRANSFERTEXT.html)
       */
      transferText: "TRANSFERTEXT",
      /**
       * Path to a Unix domain socket.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_UNIX_SOCKET_PATH.html](https://curl.haxx.se/libcurl/c/CURLOPT_UNIX_SOCKET_PATH.html)
       */
      unixSocketPath: "UNIX_SOCKET_PATH",
      /**
       * Do not restrict authentication to original host.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_UNRESTRICTED_AUTH.html](https://curl.haxx.se/libcurl/c/CURLOPT_UNRESTRICTED_AUTH.html)
       */
      unrestrictedAuth: "UNRESTRICTED_AUTH",
      /**
       * Sets the interval at which connection upkeep are performed.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_UPKEEP_INTERVAL_MS.html](https://curl.haxx.se/libcurl/c/CURLOPT_UPKEEP_INTERVAL_MS.html)
       */
      upkeepIntervalMs: "UPKEEP_INTERVAL_MS",
      /**
       * Upload data.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_UPLOAD.html](https://curl.haxx.se/libcurl/c/CURLOPT_UPLOAD.html)
       */
      upload: "UPLOAD",
      /**
       * Set upload buffer size.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_UPLOAD_BUFFERSIZE.html](https://curl.haxx.se/libcurl/c/CURLOPT_UPLOAD_BUFFERSIZE.html)
       */
      uploadBufferSize: "UPLOAD_BUFFERSIZE",
      /**
       * URL to work on.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_URL.html](https://curl.haxx.se/libcurl/c/CURLOPT_URL.html)
       */
      url: "URL",
      /**
       * Use TLS/SSL.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_USE_SSL.html](https://curl.haxx.se/libcurl/c/CURLOPT_USE_SSL.html)
       */
      useSsl: "USE_SSL",
      /**
       * User-Agent: header.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_USERAGENT.html](https://curl.haxx.se/libcurl/c/CURLOPT_USERAGENT.html)
       */
      userAgent: "USERAGENT",
      /**
       * User name.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_USERNAME.html](https://curl.haxx.se/libcurl/c/CURLOPT_USERNAME.html)
       */
      username: "USERNAME",
      /**
       * User name and password.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_USERPWD.html](https://curl.haxx.se/libcurl/c/CURLOPT_USERPWD.html)
       */
      userpwd: "USERPWD",
      /**
       * Display verbose information.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_VERBOSE.html](https://curl.haxx.se/libcurl/c/CURLOPT_VERBOSE.html)
       */
      verbose: "VERBOSE",
      /**
       * Transfer multiple files according to a file name pattern.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_WILDCARDMATCH.html](https://curl.haxx.se/libcurl/c/CURLOPT_WILDCARDMATCH.html)
       */
      wildcardMatch: "WILDCARDMATCH",
      /**
       * Callback for writing data.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_WRITEFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_WRITEFUNCTION.html)
       */
      writeFunction: "WRITEFUNCTION",
      /**
       * Callback for progress meter.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_XFERINFOFUNCTION.html](https://curl.haxx.se/libcurl/c/CURLOPT_XFERINFOFUNCTION.html)
       */
      xferInfoFunction: "XFERINFOFUNCTION",
      /**
       * OAuth2 bearer token.
       *
       * Official libcurl documentation: : [https://curl.haxx.se/libcurl/c/CURLOPT_XOAUTH2_BEARER.html](https://curl.haxx.se/libcurl/c/CURLOPT_XOAUTH2_BEARER.html)
       */
      xoauth2Bearer: "XOAUTH2_BEARER"
    };
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/curly.js
var require_curly = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/curly.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.curly = void 0;
    var CurlOption_1 = require_CurlOption();
    var Curl_1 = require_Curl();
    var CurlFeature_1 = require_CurlFeature();
    var methods = [
      "acl",
      "bind",
      "checkout",
      "connect",
      "copy",
      "delete",
      "get",
      "head",
      "link",
      "lock",
      "m-search",
      "merge",
      "mkactivity",
      "mkcalendar",
      "mkcol",
      "move",
      "notify",
      "options",
      "patch",
      "post",
      "propfind",
      "proppatch",
      "purge",
      "put",
      "rebind",
      "report",
      "search",
      "source",
      "subscribe",
      "trace",
      "unbind",
      "unlink",
      "unlock",
      "unsubscribe"
    ];
    var create2 = (defaultOptions = {}) => {
      function curly(url, options = {}) {
        const curlHandle = new Curl_1.Curl();
        curlHandle.enable(CurlFeature_1.CurlFeature.NoDataParsing);
        curlHandle.setOpt("URL", `${options.curlyBaseUrl || ""}${url}`);
        const finalOptions = {
          ...defaultOptions,
          ...options
        };
        for (const key of Object.keys(finalOptions)) {
          const keyTyped = key;
          const optionName = keyTyped in CurlOption_1.CurlOptionCamelCaseMap ? CurlOption_1.CurlOptionCamelCaseMap[keyTyped] : keyTyped;
          if (optionName.startsWith("curly"))
            continue;
          curlHandle.setOpt(optionName, finalOptions[key]);
        }
        const { curlyStreamResponse, curlyStreamResponseHighWaterMark, curlyStreamUpload } = finalOptions;
        const isUsingStream = !!(curlyStreamResponse || curlyStreamUpload);
        if (finalOptions.curlyProgressCallback) {
          if (typeof finalOptions.curlyProgressCallback !== "function") {
            throw new TypeError("curlyProgressCallback must be a function with signature (number, number, number, number) => number");
          }
          const fnToCall = isUsingStream ? "setStreamProgressCallback" : "setProgressCallback";
          curlHandle[fnToCall](finalOptions.curlyProgressCallback);
        }
        if (curlyStreamResponse) {
          curlHandle.enable(CurlFeature_1.CurlFeature.StreamResponse);
          if (curlyStreamResponseHighWaterMark) {
            curlHandle.setStreamResponseHighWaterMark(curlyStreamResponseHighWaterMark);
          }
        }
        if (curlyStreamUpload) {
          curlHandle.setUploadStream(curlyStreamUpload);
        }
        const lowerCaseHeadersIfNecessary = (headers) => {
          if (finalOptions.curlyLowerCaseHeaders) {
            for (const headersReq of headers) {
              const entries = Object.entries(headersReq);
              for (const [headerKey, headerValue] of entries) {
                if (typeof headerKey === "string" && typeof headerValue === "string") {
                  delete headersReq[headerKey];
                  headersReq[headerKey.toLowerCase()] = headerValue;
                }
              }
            }
          }
        };
        return new Promise((resolve, reject2) => {
          let stream;
          if (curlyStreamResponse) {
            curlHandle.on("stream", (_stream, statusCode, headers) => {
              lowerCaseHeadersIfNecessary(headers);
              stream = _stream;
              resolve({
                // @ts-ignore cannot be subtype yada yada
                data: stream,
                statusCode,
                headers
              });
            });
          }
          curlHandle.on("end", (statusCode, data, headers) => {
            curlHandle.close();
            if (curlyStreamResponse) {
              return;
            }
            const contentTypeEntry = Object.entries(headers[headers.length - 1]).find(([k2]) => k2.toLowerCase() === "content-type");
            const firstHeader = contentTypeEntry && contentTypeEntry[1];
            if (typeof firstHeader !== "string") {
              return resolve({
                statusCode,
                // @ts-ignore
                data,
                headers
              });
            }
            let contentType = firstHeader;
            contentType = contentType.split(";")[0];
            const responseBodyParsers = {
              ...curly.defaultResponseBodyParsers,
              ...finalOptions.curlyResponseBodyParsers
            };
            let foundParser = finalOptions.curlyResponseBodyParser;
            if (typeof foundParser === "undefined") {
              for (const [contentTypeFormat, parser] of Object.entries(responseBodyParsers)) {
                if (typeof parser !== "function") {
                  return reject2(new TypeError(`Response body parser for ${contentTypeFormat} must be a function`));
                }
                if (contentType === contentTypeFormat) {
                  foundParser = parser;
                  break;
                } else if (contentTypeFormat === "*") {
                  foundParser = parser;
                  break;
                } else {
                  const partsFormat = contentTypeFormat.split("/");
                  const partsContentType = contentType.split("/");
                  if (partsContentType.length === partsFormat.length && partsContentType.every((val, index) => partsFormat[index] === "*" || partsFormat[index] === val)) {
                    foundParser = parser;
                    break;
                  }
                }
              }
            }
            if (foundParser && typeof foundParser !== "function") {
              return reject2(new TypeError("`curlyResponseBodyParser` passed to curly must be false or a function."));
            }
            lowerCaseHeadersIfNecessary(headers);
            try {
              resolve({
                statusCode,
                data: foundParser ? foundParser(data, headers) : data,
                headers
              });
            } catch (error) {
              reject2(error);
            }
          });
          curlHandle.on("error", (error, errorCode) => {
            curlHandle.close();
            error.code = errorCode;
            error.isCurlError = true;
            if (stream) {
              stream.emit("error", error);
            } else {
              reject2(error);
            }
          });
          try {
            curlHandle.perform();
          } catch (error) {
            curlHandle.close();
            reject2(error);
          }
        });
      }
      curly.create = create2;
      curly.defaultResponseBodyParsers = {
        "application/json": (data, _headers) => {
          try {
            const string = data.toString("utf8");
            return JSON.parse(string);
          } catch (error) {
            throw new Error(`curly failed to parse "application/json" content as JSON. This is generally caused by receiving malformed JSON data from the server.
You can disable this automatic behavior by setting the option curlyResponseBodyParser to false, then a Buffer will be returned as the data.
You can also overwrite the "application/json" parser with your own by changing one of the following:
  - curly.defaultResponseBodyParsers['application/json']
  or
  - options.curlyResponseBodyParsers = { 'application/json': parser }

If you want just a single function to handle all content-types, you can use the option "curlyResponseBodyParser".
`);
          }
        },
        // We are in [INSERT CURRENT YEAR], let's assume everyone is using utf8 encoding for text/* content-type.
        "text/*": (data, _headers) => data.toString("utf8"),
        // otherwise let's just return the raw buffer
        "*": (data, _headers) => data
      };
      const httpMethodOptionsMap = {
        get: null,
        post: (_m, o2) => ({
          post: true,
          ...o2
        }),
        head: (_m, o2) => ({
          nobody: true,
          ...o2
        }),
        _: (m3, o2) => ({
          customRequest: m3.toUpperCase(),
          ...o2
        })
      };
      for (const httpMethod of methods) {
        const httpMethodOptionsKey = Object.prototype.hasOwnProperty.call(httpMethodOptionsMap, httpMethod) ? httpMethod : "_";
        const httpMethodOptions = httpMethodOptionsMap[httpMethodOptionsKey];
        curly[httpMethod] = httpMethodOptions === null ? curly : (url, options = {}) => curly(url, {
          ...httpMethodOptions(httpMethod, options)
        });
      }
      return curly;
    };
    exports2.curly = create2();
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlAuth.js
var require_CurlAuth = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlAuth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlFtpAuth = exports2.CurlAuth = void 0;
    var CurlAuth2;
    (function(CurlAuth3) {
      CurlAuth3[CurlAuth3["None"] = 0] = "None";
      CurlAuth3[CurlAuth3["Basic"] = 1] = "Basic";
      CurlAuth3[CurlAuth3["Digest"] = 2] = "Digest";
      CurlAuth3[CurlAuth3["Negotiate"] = 4] = "Negotiate";
      CurlAuth3[CurlAuth3["GssNegotiate"] = 4] = "GssNegotiate";
      CurlAuth3[CurlAuth3["GssApi"] = 4] = "GssApi";
      CurlAuth3[CurlAuth3["Ntlm"] = 8] = "Ntlm";
      CurlAuth3[CurlAuth3["DigestIe"] = 16] = "DigestIe";
      CurlAuth3[CurlAuth3["NtlmWb"] = 32] = "NtlmWb";
      CurlAuth3[CurlAuth3["Bearer"] = 64] = "Bearer";
      CurlAuth3[CurlAuth3["AwsSigV4"] = 128] = "AwsSigV4";
      CurlAuth3[CurlAuth3["Only"] = 2147483648] = "Only";
      CurlAuth3[CurlAuth3["Any"] = -17] = "Any";
      CurlAuth3[CurlAuth3["AnySafe"] = -18] = "AnySafe";
    })(CurlAuth2 = exports2.CurlAuth || (exports2.CurlAuth = {}));
    var CurlFtpAuth;
    (function(CurlFtpAuth2) {
      CurlFtpAuth2[CurlFtpAuth2["Default"] = 0] = "Default";
      CurlFtpAuth2[CurlFtpAuth2["Ssl"] = 1] = "Ssl";
      CurlFtpAuth2[CurlFtpAuth2["Tls"] = 2] = "Tls";
    })(CurlFtpAuth = exports2.CurlFtpAuth || (exports2.CurlFtpAuth = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlChunk.js
var require_CurlChunk = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlChunk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlChunk = void 0;
    var CurlChunk;
    (function(CurlChunk2) {
      CurlChunk2[CurlChunk2["BgnFuncOk"] = 0] = "BgnFuncOk";
      CurlChunk2[CurlChunk2["BgnFuncFail"] = 1] = "BgnFuncFail";
      CurlChunk2[CurlChunk2["BgnFuncSkip"] = 2] = "BgnFuncSkip";
      CurlChunk2[CurlChunk2["EndFuncOk"] = 0] = "EndFuncOk";
      CurlChunk2[CurlChunk2["EndFuncFail"] = 1] = "EndFuncFail";
    })(CurlChunk = exports2.CurlChunk || (exports2.CurlChunk = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFileType.js
var require_CurlFileType = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFileType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlFileType = void 0;
    var CurlFileType;
    (function(CurlFileType2) {
      CurlFileType2[CurlFileType2["File"] = 0] = "File";
      CurlFileType2[CurlFileType2["Directory"] = 1] = "Directory";
      CurlFileType2[CurlFileType2["Symlink"] = 2] = "Symlink";
      CurlFileType2[CurlFileType2["DeviceBlock"] = 3] = "DeviceBlock";
      CurlFileType2[CurlFileType2["DeviceChar"] = 4] = "DeviceChar";
      CurlFileType2[CurlFileType2["NamedPipe"] = 5] = "NamedPipe";
      CurlFileType2[CurlFileType2["Socket"] = 6] = "Socket";
      CurlFileType2[CurlFileType2["Door"] = 7] = "Door";
    })(CurlFileType = exports2.CurlFileType || (exports2.CurlFileType = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFnMatchFunc.js
var require_CurlFnMatchFunc = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFnMatchFunc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlFnMatchFunc = void 0;
    var CurlFnMatchFunc;
    (function(CurlFnMatchFunc2) {
      CurlFnMatchFunc2[CurlFnMatchFunc2["Match"] = 0] = "Match";
      CurlFnMatchFunc2[CurlFnMatchFunc2["NoMatch"] = 1] = "NoMatch";
      CurlFnMatchFunc2[CurlFnMatchFunc2["Fail"] = 2] = "Fail";
    })(CurlFnMatchFunc = exports2.CurlFnMatchFunc || (exports2.CurlFnMatchFunc = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFtpMethod.js
var require_CurlFtpMethod = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFtpMethod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlFtpMethod = void 0;
    var CurlFtpMethod;
    (function(CurlFtpMethod2) {
      CurlFtpMethod2[CurlFtpMethod2["DEFAULT"] = 0] = "DEFAULT";
      CurlFtpMethod2[CurlFtpMethod2["MULTICWD"] = 1] = "MULTICWD";
      CurlFtpMethod2[CurlFtpMethod2["NOCWD"] = 2] = "NOCWD";
      CurlFtpMethod2[CurlFtpMethod2["SINGLECWD"] = 3] = "SINGLECWD";
    })(CurlFtpMethod = exports2.CurlFtpMethod || (exports2.CurlFtpMethod = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFtpSsl.js
var require_CurlFtpSsl = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlFtpSsl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlFtpSsl = void 0;
    var CurlFtpSsl;
    (function(CurlFtpSsl2) {
      CurlFtpSsl2[CurlFtpSsl2["CccNone"] = 0] = "CccNone";
      CurlFtpSsl2[CurlFtpSsl2["CccPassive"] = 1] = "CccPassive";
      CurlFtpSsl2[CurlFtpSsl2["CccActive"] = 2] = "CccActive";
    })(CurlFtpSsl = exports2.CurlFtpSsl || (exports2.CurlFtpSsl = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlGlobalInit.js
var require_CurlGlobalInit = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlGlobalInit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlGssApi.js
var require_CurlGssApi = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlGssApi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlGssApi = void 0;
    var CurlGssApi;
    (function(CurlGssApi2) {
      CurlGssApi2[CurlGssApi2["None"] = 0] = "None";
      CurlGssApi2[CurlGssApi2["PolicyFlag"] = 1] = "PolicyFlag";
      CurlGssApi2[CurlGssApi2["DelegationFlag"] = 2] = "DelegationFlag";
    })(CurlGssApi = exports2.CurlGssApi || (exports2.CurlGssApi = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlHeader.js
var require_CurlHeader = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlHeader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlHeader = void 0;
    var CurlHeader;
    (function(CurlHeader2) {
      CurlHeader2[CurlHeader2["Unified"] = 0] = "Unified";
      CurlHeader2[CurlHeader2["Separate"] = 1] = "Separate";
    })(CurlHeader = exports2.CurlHeader || (exports2.CurlHeader = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlHsts.js
var require_CurlHsts = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlHsts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlHstsCallback = exports2.CurlHsts = void 0;
    var CurlHsts;
    (function(CurlHsts2) {
      CurlHsts2[CurlHsts2["Disabled"] = 0] = "Disabled";
      CurlHsts2[CurlHsts2["Enable"] = 1] = "Enable";
      CurlHsts2[CurlHsts2["ReadonlyFile"] = 2] = "ReadonlyFile";
    })(CurlHsts = exports2.CurlHsts || (exports2.CurlHsts = {}));
    var CurlHstsCallback;
    (function(CurlHstsCallback2) {
      CurlHstsCallback2[CurlHstsCallback2["Ok"] = 0] = "Ok";
      CurlHstsCallback2[CurlHstsCallback2["Done"] = 1] = "Done";
      CurlHstsCallback2[CurlHstsCallback2["Fail"] = 2] = "Fail";
    })(CurlHstsCallback = exports2.CurlHstsCallback || (exports2.CurlHstsCallback = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlHttpVersion.js
var require_CurlHttpVersion = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlHttpVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlHttpVersion = void 0;
    var CurlHttpVersion2;
    (function(CurlHttpVersion3) {
      CurlHttpVersion3[CurlHttpVersion3["None"] = 0] = "None";
      CurlHttpVersion3[CurlHttpVersion3["V1_0"] = 1] = "V1_0";
      CurlHttpVersion3[CurlHttpVersion3["V1_1"] = 2] = "V1_1";
      CurlHttpVersion3[CurlHttpVersion3["V2_0"] = 3] = "V2_0";
      CurlHttpVersion3[CurlHttpVersion3["V2Tls"] = 4] = "V2Tls";
      CurlHttpVersion3[CurlHttpVersion3["V2PriorKnowledge"] = 5] = "V2PriorKnowledge";
      CurlHttpVersion3[CurlHttpVersion3["v3"] = 6] = "v3";
    })(CurlHttpVersion2 = exports2.CurlHttpVersion || (exports2.CurlHttpVersion = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlInfoDebug.js
var require_CurlInfoDebug = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlInfoDebug.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlInfoDebug = void 0;
    var CurlInfoDebug2;
    (function(CurlInfoDebug3) {
      CurlInfoDebug3[CurlInfoDebug3["Text"] = 0] = "Text";
      CurlInfoDebug3[CurlInfoDebug3["HeaderIn"] = 1] = "HeaderIn";
      CurlInfoDebug3[CurlInfoDebug3["HeaderOut"] = 2] = "HeaderOut";
      CurlInfoDebug3[CurlInfoDebug3["DataIn"] = 3] = "DataIn";
      CurlInfoDebug3[CurlInfoDebug3["DataOut"] = 4] = "DataOut";
      CurlInfoDebug3[CurlInfoDebug3["SslDataIn"] = 5] = "SslDataIn";
      CurlInfoDebug3[CurlInfoDebug3["SslDataOut"] = 6] = "SslDataOut";
    })(CurlInfoDebug2 = exports2.CurlInfoDebug || (exports2.CurlInfoDebug = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlIpResolve.js
var require_CurlIpResolve = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlIpResolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlIpResolve = void 0;
    var CurlIpResolve;
    (function(CurlIpResolve2) {
      CurlIpResolve2[CurlIpResolve2["Whatever"] = 0] = "Whatever";
      CurlIpResolve2[CurlIpResolve2["V4"] = 1] = "V4";
      CurlIpResolve2[CurlIpResolve2["V6"] = 2] = "V6";
    })(CurlIpResolve = exports2.CurlIpResolve || (exports2.CurlIpResolve = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlNetrc.js
var require_CurlNetrc = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlNetrc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlNetrc = void 0;
    var CurlNetrc2;
    (function(CurlNetrc3) {
      CurlNetrc3[CurlNetrc3["Ignored"] = 0] = "Ignored";
      CurlNetrc3[CurlNetrc3["Optional"] = 1] = "Optional";
      CurlNetrc3[CurlNetrc3["Required"] = 2] = "Required";
    })(CurlNetrc2 = exports2.CurlNetrc || (exports2.CurlNetrc = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPipe.js
var require_CurlPipe = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlPipe = void 0;
    var CurlPipe;
    (function(CurlPipe2) {
      CurlPipe2[CurlPipe2["Nothing"] = 0] = "Nothing";
      CurlPipe2[CurlPipe2["Http1"] = 1] = "Http1";
      CurlPipe2[CurlPipe2["Multiplex"] = 2] = "Multiplex";
    })(CurlPipe = exports2.CurlPipe || (exports2.CurlPipe = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlProgressFunc.js
var require_CurlProgressFunc = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlProgressFunc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlProgressFunc = void 0;
    var CurlProgressFunc;
    (function(CurlProgressFunc2) {
      CurlProgressFunc2[CurlProgressFunc2["Continue"] = 268435457] = "Continue";
    })(CurlProgressFunc = exports2.CurlProgressFunc || (exports2.CurlProgressFunc = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlProtocol.js
var require_CurlProtocol = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlProtocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlProtocol = void 0;
    var CurlProtocol;
    (function(CurlProtocol2) {
      CurlProtocol2[CurlProtocol2["HTTP"] = 1] = "HTTP";
      CurlProtocol2[CurlProtocol2["HTTPS"] = 2] = "HTTPS";
      CurlProtocol2[CurlProtocol2["FTP"] = 4] = "FTP";
      CurlProtocol2[CurlProtocol2["FTPS"] = 8] = "FTPS";
      CurlProtocol2[CurlProtocol2["SCP"] = 16] = "SCP";
      CurlProtocol2[CurlProtocol2["SFTP"] = 32] = "SFTP";
      CurlProtocol2[CurlProtocol2["TELNET"] = 64] = "TELNET";
      CurlProtocol2[CurlProtocol2["LDAP"] = 128] = "LDAP";
      CurlProtocol2[CurlProtocol2["LDAPS"] = 256] = "LDAPS";
      CurlProtocol2[CurlProtocol2["DICT"] = 512] = "DICT";
      CurlProtocol2[CurlProtocol2["FILE"] = 1024] = "FILE";
      CurlProtocol2[CurlProtocol2["TFTP"] = 2048] = "TFTP";
      CurlProtocol2[CurlProtocol2["IMAP"] = 4096] = "IMAP";
      CurlProtocol2[CurlProtocol2["IMAPS"] = 8192] = "IMAPS";
      CurlProtocol2[CurlProtocol2["POP3"] = 16384] = "POP3";
      CurlProtocol2[CurlProtocol2["POP3S"] = 32768] = "POP3S";
      CurlProtocol2[CurlProtocol2["SMTP"] = 65536] = "SMTP";
      CurlProtocol2[CurlProtocol2["SMTPS"] = 131072] = "SMTPS";
      CurlProtocol2[CurlProtocol2["RTSP"] = 262144] = "RTSP";
      CurlProtocol2[CurlProtocol2["RTMP"] = 524288] = "RTMP";
      CurlProtocol2[CurlProtocol2["RTMPT"] = 1048576] = "RTMPT";
      CurlProtocol2[CurlProtocol2["RTMPE"] = 2097152] = "RTMPE";
      CurlProtocol2[CurlProtocol2["RTMPTE"] = 4194304] = "RTMPTE";
      CurlProtocol2[CurlProtocol2["RTMPS"] = 8388608] = "RTMPS";
      CurlProtocol2[CurlProtocol2["RTMPTS"] = 16777216] = "RTMPTS";
      CurlProtocol2[CurlProtocol2["GOPHER"] = 33554432] = "GOPHER";
      CurlProtocol2[CurlProtocol2["SMB"] = 67108864] = "SMB";
      CurlProtocol2[CurlProtocol2["SMBS"] = 134217728] = "SMBS";
      CurlProtocol2[CurlProtocol2["MQTT"] = 268435456] = "MQTT";
      CurlProtocol2[CurlProtocol2["GOPHERS"] = 536870912] = "GOPHERS";
      CurlProtocol2[CurlProtocol2["ALL"] = -1] = "ALL";
    })(CurlProtocol = exports2.CurlProtocol || (exports2.CurlProtocol = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlProxy.js
var require_CurlProxy = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlProxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlProxy = void 0;
    var CurlProxy;
    (function(CurlProxy2) {
      CurlProxy2[CurlProxy2["Http"] = 0] = "Http";
      CurlProxy2[CurlProxy2["Http_1_0"] = 1] = "Http_1_0";
      CurlProxy2[CurlProxy2["Https"] = 2] = "Https";
      CurlProxy2[CurlProxy2["Socks4"] = 4] = "Socks4";
      CurlProxy2[CurlProxy2["Socks5"] = 5] = "Socks5";
      CurlProxy2[CurlProxy2["Socks4A"] = 6] = "Socks4A";
      CurlProxy2[CurlProxy2["Socks5Hostname"] = 7] = "Socks5Hostname";
    })(CurlProxy = exports2.CurlProxy || (exports2.CurlProxy = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPush.js
var require_CurlPush = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPush.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlPush = void 0;
    var CurlPush;
    (function(CurlPush2) {
      CurlPush2[CurlPush2["Ok"] = 0] = "Ok";
      CurlPush2[CurlPush2["Deny"] = 1] = "Deny";
      CurlPush2[CurlPush2["ErrorOut"] = 2] = "ErrorOut";
    })(CurlPush = exports2.CurlPush || (exports2.CurlPush = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPx.js
var require_CurlPx = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlPx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlPx = void 0;
    var CurlPx;
    (function(CurlPx2) {
      CurlPx2[CurlPx2["Ok"] = 0] = "Ok";
      CurlPx2[CurlPx2["BadAddressType"] = 1] = "BadAddressType";
      CurlPx2[CurlPx2["BadVersion"] = 2] = "BadVersion";
      CurlPx2[CurlPx2["Closed"] = 3] = "Closed";
      CurlPx2[CurlPx2["Gssapi"] = 4] = "Gssapi";
      CurlPx2[CurlPx2["GssapiPermsg"] = 5] = "GssapiPermsg";
      CurlPx2[CurlPx2["GssapiProtection"] = 6] = "GssapiProtection";
      CurlPx2[CurlPx2["Identd"] = 7] = "Identd";
      CurlPx2[CurlPx2["IdentdDiffer"] = 8] = "IdentdDiffer";
      CurlPx2[CurlPx2["LongHostname"] = 9] = "LongHostname";
      CurlPx2[CurlPx2["LongPasswd"] = 10] = "LongPasswd";
      CurlPx2[CurlPx2["LongUser"] = 11] = "LongUser";
      CurlPx2[CurlPx2["NoAuth"] = 12] = "NoAuth";
      CurlPx2[CurlPx2["RecvAddress"] = 13] = "RecvAddress";
      CurlPx2[CurlPx2["RecvAuth"] = 14] = "RecvAuth";
      CurlPx2[CurlPx2["RecvConnect"] = 15] = "RecvConnect";
      CurlPx2[CurlPx2["RecvReqack"] = 16] = "RecvReqack";
      CurlPx2[CurlPx2["ReplyAddressTypeNotSupported"] = 17] = "ReplyAddressTypeNotSupported";
      CurlPx2[CurlPx2["ReplyCommandNotSupported"] = 18] = "ReplyCommandNotSupported";
      CurlPx2[CurlPx2["ReplyConnectionRefused"] = 19] = "ReplyConnectionRefused";
      CurlPx2[CurlPx2["ReplyGeneralServerFailure"] = 20] = "ReplyGeneralServerFailure";
      CurlPx2[CurlPx2["ReplyHostUnreachable"] = 21] = "ReplyHostUnreachable";
      CurlPx2[CurlPx2["ReplyNetworkUnreachable"] = 22] = "ReplyNetworkUnreachable";
      CurlPx2[CurlPx2["ReplyNotAllowed"] = 23] = "ReplyNotAllowed";
      CurlPx2[CurlPx2["ReplyTtlExpired"] = 24] = "ReplyTtlExpired";
      CurlPx2[CurlPx2["ReplyUnassigned"] = 25] = "ReplyUnassigned";
      CurlPx2[CurlPx2["RequestFailed"] = 26] = "RequestFailed";
      CurlPx2[CurlPx2["ResolveHost"] = 27] = "ResolveHost";
      CurlPx2[CurlPx2["SendAuth"] = 28] = "SendAuth";
      CurlPx2[CurlPx2["SendConnect"] = 29] = "SendConnect";
      CurlPx2[CurlPx2["SendRequest"] = 30] = "SendRequest";
      CurlPx2[CurlPx2["UnknownFail"] = 31] = "UnknownFail";
      CurlPx2[CurlPx2["UnknownMode"] = 32] = "UnknownMode";
      CurlPx2[CurlPx2["UserRejected"] = 33] = "UserRejected";
    })(CurlPx = exports2.CurlPx || (exports2.CurlPx = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlRtspRequest.js
var require_CurlRtspRequest = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlRtspRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlRtspRequest = void 0;
    var CurlRtspRequest;
    (function(CurlRtspRequest2) {
      CurlRtspRequest2[CurlRtspRequest2["None"] = 0] = "None";
      CurlRtspRequest2[CurlRtspRequest2["Options"] = 1] = "Options";
      CurlRtspRequest2[CurlRtspRequest2["Describe"] = 2] = "Describe";
      CurlRtspRequest2[CurlRtspRequest2["Announce"] = 3] = "Announce";
      CurlRtspRequest2[CurlRtspRequest2["Setup"] = 4] = "Setup";
      CurlRtspRequest2[CurlRtspRequest2["Play"] = 5] = "Play";
      CurlRtspRequest2[CurlRtspRequest2["Pause"] = 6] = "Pause";
      CurlRtspRequest2[CurlRtspRequest2["Teardown"] = 7] = "Teardown";
      CurlRtspRequest2[CurlRtspRequest2["GetParameter"] = 8] = "GetParameter";
      CurlRtspRequest2[CurlRtspRequest2["SetParameter"] = 9] = "SetParameter";
      CurlRtspRequest2[CurlRtspRequest2["Record"] = 10] = "Record";
      CurlRtspRequest2[CurlRtspRequest2["Receive"] = 11] = "Receive";
    })(CurlRtspRequest = exports2.CurlRtspRequest || (exports2.CurlRtspRequest = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlShareLock.js
var require_CurlShareLock = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlShareLock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlShareLock = void 0;
    var CurlShareLock;
    (function(CurlShareLock2) {
      CurlShareLock2[CurlShareLock2["DataNone"] = 0] = "DataNone";
      CurlShareLock2[CurlShareLock2["DataShare"] = 1] = "DataShare";
      CurlShareLock2[CurlShareLock2["DataCookie"] = 2] = "DataCookie";
      CurlShareLock2[CurlShareLock2["DataDns"] = 3] = "DataDns";
      CurlShareLock2[CurlShareLock2["DataSslSession"] = 4] = "DataSslSession";
      CurlShareLock2[CurlShareLock2["DataConnect"] = 5] = "DataConnect";
      CurlShareLock2[CurlShareLock2["DataPsl"] = 6] = "DataPsl";
    })(CurlShareLock = exports2.CurlShareLock || (exports2.CurlShareLock = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlSshAuth.js
var require_CurlSshAuth = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlSshAuth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlSshAuth = void 0;
    var CurlSshAuth;
    (function(CurlSshAuth2) {
      CurlSshAuth2[CurlSshAuth2["Any"] = -1] = "Any";
      CurlSshAuth2[CurlSshAuth2["None"] = 0] = "None";
      CurlSshAuth2[CurlSshAuth2["PublicKey"] = 1] = "PublicKey";
      CurlSshAuth2[CurlSshAuth2["Password"] = 2] = "Password";
      CurlSshAuth2[CurlSshAuth2["Host"] = 4] = "Host";
      CurlSshAuth2[CurlSshAuth2["Keyboard"] = 8] = "Keyboard";
      CurlSshAuth2[CurlSshAuth2["Agent"] = 16] = "Agent";
      CurlSshAuth2[CurlSshAuth2["GssApi"] = 32] = "GssApi";
      CurlSshAuth2[CurlSshAuth2["Default"] = -1] = "Default";
    })(CurlSshAuth = exports2.CurlSshAuth || (exports2.CurlSshAuth = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlSslOpt.js
var require_CurlSslOpt = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlSslOpt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlSslOpt = void 0;
    var CurlSslOpt2;
    (function(CurlSslOpt3) {
      CurlSslOpt3[CurlSslOpt3["AllowBeast"] = 1] = "AllowBeast";
      CurlSslOpt3[CurlSslOpt3["NoRevoke"] = 2] = "NoRevoke";
      CurlSslOpt3[CurlSslOpt3["NoPartialChain"] = 4] = "NoPartialChain";
      CurlSslOpt3[CurlSslOpt3["RevokeBestEffort"] = 8] = "RevokeBestEffort";
      CurlSslOpt3[CurlSslOpt3["NativeCa"] = 16] = "NativeCa";
      CurlSslOpt3[CurlSslOpt3["AutoClientCert"] = 32] = "AutoClientCert";
    })(CurlSslOpt2 = exports2.CurlSslOpt || (exports2.CurlSslOpt = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlSslVersion.js
var require_CurlSslVersion = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlSslVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlSslVersionMax = exports2.CurlSslVersion = void 0;
    var CurlSslVersion;
    (function(CurlSslVersion2) {
      CurlSslVersion2[CurlSslVersion2["Default"] = 0] = "Default";
      CurlSslVersion2[CurlSslVersion2["TlsV1"] = 1] = "TlsV1";
      CurlSslVersion2[CurlSslVersion2["SslV2"] = 2] = "SslV2";
      CurlSslVersion2[CurlSslVersion2["SslV3"] = 3] = "SslV3";
      CurlSslVersion2[CurlSslVersion2["TlsV1_0"] = 4] = "TlsV1_0";
      CurlSslVersion2[CurlSslVersion2["TlsV1_1"] = 5] = "TlsV1_1";
      CurlSslVersion2[CurlSslVersion2["TlsV1_2"] = 6] = "TlsV1_2";
      CurlSslVersion2[CurlSslVersion2["TlsV1_3"] = 7] = "TlsV1_3";
    })(CurlSslVersion = exports2.CurlSslVersion || (exports2.CurlSslVersion = {}));
    var CurlSslVersionMax;
    (function(CurlSslVersionMax2) {
      CurlSslVersionMax2[CurlSslVersionMax2["None"] = 0] = "None";
      CurlSslVersionMax2[CurlSslVersionMax2["Default"] = 65536] = "Default";
      CurlSslVersionMax2[CurlSslVersionMax2["TlsV1_0"] = 262144] = "TlsV1_0";
      CurlSslVersionMax2[CurlSslVersionMax2["TlsV1_1"] = 327680] = "TlsV1_1";
      CurlSslVersionMax2[CurlSslVersionMax2["TlsV1_2"] = 393216] = "TlsV1_2";
      CurlSslVersionMax2[CurlSslVersionMax2["TlsV1_3"] = 458752] = "TlsV1_3";
    })(CurlSslVersionMax = exports2.CurlSslVersionMax || (exports2.CurlSslVersionMax = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlTimeCond.js
var require_CurlTimeCond = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlTimeCond.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlTimeCond = void 0;
    var CurlTimeCond;
    (function(CurlTimeCond2) {
      CurlTimeCond2[CurlTimeCond2["None"] = 0] = "None";
      CurlTimeCond2[CurlTimeCond2["IfModSince"] = 1] = "IfModSince";
      CurlTimeCond2[CurlTimeCond2["IfUnmodSince"] = 2] = "IfUnmodSince";
      CurlTimeCond2[CurlTimeCond2["LastMod"] = 3] = "LastMod";
    })(CurlTimeCond = exports2.CurlTimeCond || (exports2.CurlTimeCond = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlUseSsl.js
var require_CurlUseSsl = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlUseSsl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlUseSsl = void 0;
    var CurlUseSsl;
    (function(CurlUseSsl2) {
      CurlUseSsl2[CurlUseSsl2["None"] = 0] = "None";
      CurlUseSsl2[CurlUseSsl2["Try"] = 1] = "Try";
      CurlUseSsl2[CurlUseSsl2["Control"] = 2] = "Control";
      CurlUseSsl2[CurlUseSsl2["All"] = 3] = "All";
    })(CurlUseSsl = exports2.CurlUseSsl || (exports2.CurlUseSsl = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlVersion.js
var require_CurlVersion = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/CurlVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CurlVersion = void 0;
    var CurlVersion;
    (function(CurlVersion2) {
      CurlVersion2[CurlVersion2["Ipv6"] = 1] = "Ipv6";
      CurlVersion2[CurlVersion2["Kerberos4"] = 2] = "Kerberos4";
      CurlVersion2[CurlVersion2["Ssl"] = 4] = "Ssl";
      CurlVersion2[CurlVersion2["Libz"] = 8] = "Libz";
      CurlVersion2[CurlVersion2["Ntlm"] = 16] = "Ntlm";
      CurlVersion2[CurlVersion2["GssNegotiate"] = 32] = "GssNegotiate";
      CurlVersion2[CurlVersion2["Debug"] = 64] = "Debug";
      CurlVersion2[CurlVersion2["AsynchDns"] = 128] = "AsynchDns";
      CurlVersion2[CurlVersion2["Spnego"] = 256] = "Spnego";
      CurlVersion2[CurlVersion2["LargeFile"] = 512] = "LargeFile";
      CurlVersion2[CurlVersion2["Idn"] = 1024] = "Idn";
      CurlVersion2[CurlVersion2["Sspi"] = 2048] = "Sspi";
      CurlVersion2[CurlVersion2["Conv"] = 4096] = "Conv";
      CurlVersion2[CurlVersion2["CurlDebug"] = 8192] = "CurlDebug";
      CurlVersion2[CurlVersion2["TlsAuthSrp"] = 16384] = "TlsAuthSrp";
      CurlVersion2[CurlVersion2["NtlmWb"] = 32768] = "NtlmWb";
      CurlVersion2[CurlVersion2["Http2"] = 65536] = "Http2";
      CurlVersion2[CurlVersion2["GssApi"] = 131072] = "GssApi";
      CurlVersion2[CurlVersion2["Kerberos5"] = 262144] = "Kerberos5";
      CurlVersion2[CurlVersion2["UnixSockets"] = 524288] = "UnixSockets";
      CurlVersion2[CurlVersion2["Psl"] = 1048576] = "Psl";
      CurlVersion2[CurlVersion2["HttpsProxy"] = 2097152] = "HttpsProxy";
      CurlVersion2[CurlVersion2["MultiSsl"] = 4194304] = "MultiSsl";
      CurlVersion2[CurlVersion2["Brotli"] = 8388608] = "Brotli";
      CurlVersion2[CurlVersion2["AltSvc"] = 16777216] = "AltSvc";
      CurlVersion2[CurlVersion2["Http3"] = 33554432] = "Http3";
      CurlVersion2[CurlVersion2["Zstd"] = 67108864] = "Zstd";
      CurlVersion2[CurlVersion2["Unicode"] = 134217728] = "Unicode";
      CurlVersion2[CurlVersion2["Gsasl"] = 536870912] = "Gsasl";
    })(CurlVersion = exports2.CurlVersion || (exports2.CurlVersion = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/enum/SocketState.js
var require_SocketState = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/enum/SocketState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocketState = void 0;
    var SocketState;
    (function(SocketState2) {
      SocketState2[SocketState2["Readable"] = 1] = "Readable";
      SocketState2[SocketState2["Writable"] = 2] = "Writable";
    })(SocketState = exports2.SocketState || (exports2.SocketState = {}));
  }
});

// ../../node_modules/@getinsomnia/node-libcurl/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@getinsomnia/node-libcurl/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.curly = exports2.Share = exports2.Multi = exports2.Easy = exports2.Curl = void 0;
    var tslib_1 = require_tslib();
    var Curl_1 = require_Curl();
    Object.defineProperty(exports2, "Curl", { enumerable: true, get: function() {
      return Curl_1.Curl;
    } });
    var Easy_1 = require_Easy();
    Object.defineProperty(exports2, "Easy", { enumerable: true, get: function() {
      return Easy_1.Easy;
    } });
    var Multi_1 = require_Multi();
    Object.defineProperty(exports2, "Multi", { enumerable: true, get: function() {
      return Multi_1.Multi;
    } });
    var Share_1 = require_Share();
    Object.defineProperty(exports2, "Share", { enumerable: true, get: function() {
      return Share_1.Share;
    } });
    var curly_1 = require_curly();
    Object.defineProperty(exports2, "curly", { enumerable: true, get: function() {
      return curly_1.curly;
    } });
    tslib_1.__exportStar(require_CurlAuth(), exports2);
    tslib_1.__exportStar(require_CurlChunk(), exports2);
    tslib_1.__exportStar(require_CurlCode(), exports2);
    tslib_1.__exportStar(require_CurlFeature(), exports2);
    tslib_1.__exportStar(require_CurlFileType(), exports2);
    tslib_1.__exportStar(require_CurlFnMatchFunc(), exports2);
    tslib_1.__exportStar(require_CurlFtpMethod(), exports2);
    tslib_1.__exportStar(require_CurlFtpSsl(), exports2);
    tslib_1.__exportStar(require_CurlGlobalInit(), exports2);
    tslib_1.__exportStar(require_CurlGssApi(), exports2);
    tslib_1.__exportStar(require_CurlHeader(), exports2);
    tslib_1.__exportStar(require_CurlHsts(), exports2);
    tslib_1.__exportStar(require_CurlHttpVersion(), exports2);
    tslib_1.__exportStar(require_CurlInfoDebug(), exports2);
    tslib_1.__exportStar(require_CurlIpResolve(), exports2);
    tslib_1.__exportStar(require_CurlNetrc(), exports2);
    tslib_1.__exportStar(require_CurlPause(), exports2);
    tslib_1.__exportStar(require_CurlPipe(), exports2);
    tslib_1.__exportStar(require_CurlProgressFunc(), exports2);
    tslib_1.__exportStar(require_CurlProtocol(), exports2);
    tslib_1.__exportStar(require_CurlProxy(), exports2);
    tslib_1.__exportStar(require_CurlPush(), exports2);
    tslib_1.__exportStar(require_CurlPx(), exports2);
    tslib_1.__exportStar(require_CurlReadFunc(), exports2);
    tslib_1.__exportStar(require_CurlRtspRequest(), exports2);
    tslib_1.__exportStar(require_CurlShareLock(), exports2);
    tslib_1.__exportStar(require_CurlShareOption(), exports2);
    tslib_1.__exportStar(require_CurlSshAuth(), exports2);
    tslib_1.__exportStar(require_CurlSslOpt(), exports2);
    tslib_1.__exportStar(require_CurlSslVersion(), exports2);
    tslib_1.__exportStar(require_CurlTimeCond(), exports2);
    tslib_1.__exportStar(require_CurlUseSsl(), exports2);
    tslib_1.__exportStar(require_CurlVersion(), exports2);
    tslib_1.__exportStar(require_CurlWriteFunc(), exports2);
    tslib_1.__exportStar(require_SocketState(), exports2);
  }
});

// ../../node_modules/date-fns/toDate.mjs
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
var init_toDate = __esm({
  "../../node_modules/date-fns/toDate.mjs"() {
  }
});

// ../../node_modules/date-fns/constructFrom.mjs
var init_constructFrom = __esm({
  "../../node_modules/date-fns/constructFrom.mjs"() {
  }
});

// ../../node_modules/date-fns/addDays.mjs
var init_addDays = __esm({
  "../../node_modules/date-fns/addDays.mjs"() {
  }
});

// ../../node_modules/date-fns/addMonths.mjs
var init_addMonths = __esm({
  "../../node_modules/date-fns/addMonths.mjs"() {
  }
});

// ../../node_modules/date-fns/add.mjs
var init_add = __esm({
  "../../node_modules/date-fns/add.mjs"() {
  }
});

// ../../node_modules/date-fns/isSaturday.mjs
var init_isSaturday = __esm({
  "../../node_modules/date-fns/isSaturday.mjs"() {
  }
});

// ../../node_modules/date-fns/isSunday.mjs
var init_isSunday = __esm({
  "../../node_modules/date-fns/isSunday.mjs"() {
  }
});

// ../../node_modules/date-fns/isWeekend.mjs
var init_isWeekend = __esm({
  "../../node_modules/date-fns/isWeekend.mjs"() {
  }
});

// ../../node_modules/date-fns/addBusinessDays.mjs
var init_addBusinessDays = __esm({
  "../../node_modules/date-fns/addBusinessDays.mjs"() {
  }
});

// ../../node_modules/date-fns/addMilliseconds.mjs
var init_addMilliseconds = __esm({
  "../../node_modules/date-fns/addMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/addHours.mjs
var init_addHours = __esm({
  "../../node_modules/date-fns/addHours.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfWeek.mjs
var init_startOfWeek = __esm({
  "../../node_modules/date-fns/startOfWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfISOWeek.mjs
var init_startOfISOWeek = __esm({
  "../../node_modules/date-fns/startOfISOWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/getISOWeekYear.mjs
var init_getISOWeekYear = __esm({
  "../../node_modules/date-fns/getISOWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfDay.mjs
var init_startOfDay = __esm({
  "../../node_modules/date-fns/startOfDay.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInCalendarDays.mjs
var init_differenceInCalendarDays = __esm({
  "../../node_modules/date-fns/differenceInCalendarDays.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfISOWeekYear.mjs
var init_startOfISOWeekYear = __esm({
  "../../node_modules/date-fns/startOfISOWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/setISOWeekYear.mjs
var init_setISOWeekYear = __esm({
  "../../node_modules/date-fns/setISOWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/addISOWeekYears.mjs
var init_addISOWeekYears = __esm({
  "../../node_modules/date-fns/addISOWeekYears.mjs"() {
  }
});

// ../../node_modules/date-fns/addMinutes.mjs
var init_addMinutes = __esm({
  "../../node_modules/date-fns/addMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/addQuarters.mjs
var init_addQuarters = __esm({
  "../../node_modules/date-fns/addQuarters.mjs"() {
  }
});

// ../../node_modules/date-fns/addSeconds.mjs
var init_addSeconds = __esm({
  "../../node_modules/date-fns/addSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/addWeeks.mjs
var init_addWeeks = __esm({
  "../../node_modules/date-fns/addWeeks.mjs"() {
  }
});

// ../../node_modules/date-fns/addYears.mjs
var init_addYears = __esm({
  "../../node_modules/date-fns/addYears.mjs"() {
  }
});

// ../../node_modules/date-fns/areIntervalsOverlapping.mjs
var init_areIntervalsOverlapping = __esm({
  "../../node_modules/date-fns/areIntervalsOverlapping.mjs"() {
  }
});

// ../../node_modules/date-fns/max.mjs
var init_max = __esm({
  "../../node_modules/date-fns/max.mjs"() {
  }
});

// ../../node_modules/date-fns/min.mjs
var init_min = __esm({
  "../../node_modules/date-fns/min.mjs"() {
  }
});

// ../../node_modules/date-fns/clamp.mjs
var init_clamp = __esm({
  "../../node_modules/date-fns/clamp.mjs"() {
  }
});

// ../../node_modules/date-fns/closestIndexTo.mjs
var init_closestIndexTo = __esm({
  "../../node_modules/date-fns/closestIndexTo.mjs"() {
  }
});

// ../../node_modules/date-fns/closestTo.mjs
var init_closestTo = __esm({
  "../../node_modules/date-fns/closestTo.mjs"() {
  }
});

// ../../node_modules/date-fns/compareAsc.mjs
var init_compareAsc = __esm({
  "../../node_modules/date-fns/compareAsc.mjs"() {
  }
});

// ../../node_modules/date-fns/compareDesc.mjs
var init_compareDesc = __esm({
  "../../node_modules/date-fns/compareDesc.mjs"() {
  }
});

// ../../node_modules/date-fns/constructNow.mjs
var init_constructNow = __esm({
  "../../node_modules/date-fns/constructNow.mjs"() {
  }
});

// ../../node_modules/date-fns/daysToWeeks.mjs
var init_daysToWeeks = __esm({
  "../../node_modules/date-fns/daysToWeeks.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameDay.mjs
var init_isSameDay = __esm({
  "../../node_modules/date-fns/isSameDay.mjs"() {
  }
});

// ../../node_modules/date-fns/isDate.mjs
function isDate3(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
var init_isDate = __esm({
  "../../node_modules/date-fns/isDate.mjs"() {
  }
});

// ../../node_modules/date-fns/isValid.mjs
function isValid(date) {
  if (!isDate3(date) && typeof date !== "number") {
    return false;
  }
  const _date = toDate(date);
  return !isNaN(Number(_date));
}
var init_isValid = __esm({
  "../../node_modules/date-fns/isValid.mjs"() {
    init_isDate();
    init_toDate();
  }
});

// ../../node_modules/date-fns/differenceInBusinessDays.mjs
var init_differenceInBusinessDays = __esm({
  "../../node_modules/date-fns/differenceInBusinessDays.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInCalendarISOWeekYears.mjs
var init_differenceInCalendarISOWeekYears = __esm({
  "../../node_modules/date-fns/differenceInCalendarISOWeekYears.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInCalendarISOWeeks.mjs
var init_differenceInCalendarISOWeeks = __esm({
  "../../node_modules/date-fns/differenceInCalendarISOWeeks.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInCalendarMonths.mjs
var init_differenceInCalendarMonths = __esm({
  "../../node_modules/date-fns/differenceInCalendarMonths.mjs"() {
  }
});

// ../../node_modules/date-fns/getQuarter.mjs
var init_getQuarter = __esm({
  "../../node_modules/date-fns/getQuarter.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInCalendarQuarters.mjs
var init_differenceInCalendarQuarters = __esm({
  "../../node_modules/date-fns/differenceInCalendarQuarters.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInCalendarWeeks.mjs
var init_differenceInCalendarWeeks = __esm({
  "../../node_modules/date-fns/differenceInCalendarWeeks.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInCalendarYears.mjs
var init_differenceInCalendarYears = __esm({
  "../../node_modules/date-fns/differenceInCalendarYears.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInDays.mjs
var init_differenceInDays = __esm({
  "../../node_modules/date-fns/differenceInDays.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInMilliseconds.mjs
var init_differenceInMilliseconds = __esm({
  "../../node_modules/date-fns/differenceInMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInHours.mjs
var init_differenceInHours = __esm({
  "../../node_modules/date-fns/differenceInHours.mjs"() {
  }
});

// ../../node_modules/date-fns/subISOWeekYears.mjs
var init_subISOWeekYears = __esm({
  "../../node_modules/date-fns/subISOWeekYears.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInISOWeekYears.mjs
var init_differenceInISOWeekYears = __esm({
  "../../node_modules/date-fns/differenceInISOWeekYears.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInMinutes.mjs
var init_differenceInMinutes = __esm({
  "../../node_modules/date-fns/differenceInMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfDay.mjs
var init_endOfDay = __esm({
  "../../node_modules/date-fns/endOfDay.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfMonth.mjs
var init_endOfMonth = __esm({
  "../../node_modules/date-fns/endOfMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/isLastDayOfMonth.mjs
var init_isLastDayOfMonth = __esm({
  "../../node_modules/date-fns/isLastDayOfMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInMonths.mjs
var init_differenceInMonths = __esm({
  "../../node_modules/date-fns/differenceInMonths.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInQuarters.mjs
var init_differenceInQuarters = __esm({
  "../../node_modules/date-fns/differenceInQuarters.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInSeconds.mjs
var init_differenceInSeconds = __esm({
  "../../node_modules/date-fns/differenceInSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInWeeks.mjs
var init_differenceInWeeks = __esm({
  "../../node_modules/date-fns/differenceInWeeks.mjs"() {
  }
});

// ../../node_modules/date-fns/differenceInYears.mjs
var init_differenceInYears = __esm({
  "../../node_modules/date-fns/differenceInYears.mjs"() {
  }
});

// ../../node_modules/date-fns/eachDayOfInterval.mjs
var init_eachDayOfInterval = __esm({
  "../../node_modules/date-fns/eachDayOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/eachHourOfInterval.mjs
var init_eachHourOfInterval = __esm({
  "../../node_modules/date-fns/eachHourOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfMinute.mjs
var init_startOfMinute = __esm({
  "../../node_modules/date-fns/startOfMinute.mjs"() {
  }
});

// ../../node_modules/date-fns/eachMinuteOfInterval.mjs
var init_eachMinuteOfInterval = __esm({
  "../../node_modules/date-fns/eachMinuteOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/eachMonthOfInterval.mjs
var init_eachMonthOfInterval = __esm({
  "../../node_modules/date-fns/eachMonthOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfQuarter.mjs
var init_startOfQuarter = __esm({
  "../../node_modules/date-fns/startOfQuarter.mjs"() {
  }
});

// ../../node_modules/date-fns/eachQuarterOfInterval.mjs
var init_eachQuarterOfInterval = __esm({
  "../../node_modules/date-fns/eachQuarterOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/eachWeekOfInterval.mjs
var init_eachWeekOfInterval = __esm({
  "../../node_modules/date-fns/eachWeekOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/eachWeekendOfInterval.mjs
var init_eachWeekendOfInterval = __esm({
  "../../node_modules/date-fns/eachWeekendOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfMonth.mjs
var init_startOfMonth = __esm({
  "../../node_modules/date-fns/startOfMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/eachWeekendOfMonth.mjs
var init_eachWeekendOfMonth = __esm({
  "../../node_modules/date-fns/eachWeekendOfMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfYear.mjs
var init_endOfYear = __esm({
  "../../node_modules/date-fns/endOfYear.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfYear.mjs
var init_startOfYear = __esm({
  "../../node_modules/date-fns/startOfYear.mjs"() {
  }
});

// ../../node_modules/date-fns/eachWeekendOfYear.mjs
var init_eachWeekendOfYear = __esm({
  "../../node_modules/date-fns/eachWeekendOfYear.mjs"() {
  }
});

// ../../node_modules/date-fns/eachYearOfInterval.mjs
var init_eachYearOfInterval = __esm({
  "../../node_modules/date-fns/eachYearOfInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfDecade.mjs
var init_endOfDecade = __esm({
  "../../node_modules/date-fns/endOfDecade.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfHour.mjs
var init_endOfHour = __esm({
  "../../node_modules/date-fns/endOfHour.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfWeek.mjs
var init_endOfWeek = __esm({
  "../../node_modules/date-fns/endOfWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfISOWeek.mjs
var init_endOfISOWeek = __esm({
  "../../node_modules/date-fns/endOfISOWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfISOWeekYear.mjs
var init_endOfISOWeekYear = __esm({
  "../../node_modules/date-fns/endOfISOWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfMinute.mjs
var init_endOfMinute = __esm({
  "../../node_modules/date-fns/endOfMinute.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfQuarter.mjs
var init_endOfQuarter = __esm({
  "../../node_modules/date-fns/endOfQuarter.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfSecond.mjs
var init_endOfSecond = __esm({
  "../../node_modules/date-fns/endOfSecond.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfToday.mjs
var init_endOfToday = __esm({
  "../../node_modules/date-fns/endOfToday.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfTomorrow.mjs
var init_endOfTomorrow = __esm({
  "../../node_modules/date-fns/endOfTomorrow.mjs"() {
  }
});

// ../../node_modules/date-fns/endOfYesterday.mjs
var init_endOfYesterday = __esm({
  "../../node_modules/date-fns/endOfYesterday.mjs"() {
  }
});

// ../../node_modules/date-fns/getDayOfYear.mjs
var init_getDayOfYear = __esm({
  "../../node_modules/date-fns/getDayOfYear.mjs"() {
  }
});

// ../../node_modules/date-fns/getISOWeek.mjs
var init_getISOWeek = __esm({
  "../../node_modules/date-fns/getISOWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/getWeekYear.mjs
var init_getWeekYear = __esm({
  "../../node_modules/date-fns/getWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfWeekYear.mjs
var init_startOfWeekYear = __esm({
  "../../node_modules/date-fns/startOfWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/getWeek.mjs
var init_getWeek = __esm({
  "../../node_modules/date-fns/getWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/format.mjs
var init_format = __esm({
  "../../node_modules/date-fns/format.mjs"() {
  }
});

// ../../node_modules/date-fns/formatDistance.mjs
var init_formatDistance = __esm({
  "../../node_modules/date-fns/formatDistance.mjs"() {
  }
});

// ../../node_modules/date-fns/formatDistanceStrict.mjs
var init_formatDistanceStrict = __esm({
  "../../node_modules/date-fns/formatDistanceStrict.mjs"() {
  }
});

// ../../node_modules/date-fns/formatDistanceToNow.mjs
var init_formatDistanceToNow = __esm({
  "../../node_modules/date-fns/formatDistanceToNow.mjs"() {
  }
});

// ../../node_modules/date-fns/formatDistanceToNowStrict.mjs
var init_formatDistanceToNowStrict = __esm({
  "../../node_modules/date-fns/formatDistanceToNowStrict.mjs"() {
  }
});

// ../../node_modules/date-fns/formatDuration.mjs
var init_formatDuration = __esm({
  "../../node_modules/date-fns/formatDuration.mjs"() {
  }
});

// ../../node_modules/date-fns/formatISO.mjs
var init_formatISO = __esm({
  "../../node_modules/date-fns/formatISO.mjs"() {
  }
});

// ../../node_modules/date-fns/formatISO9075.mjs
var init_formatISO9075 = __esm({
  "../../node_modules/date-fns/formatISO9075.mjs"() {
  }
});

// ../../node_modules/date-fns/formatISODuration.mjs
var init_formatISODuration = __esm({
  "../../node_modules/date-fns/formatISODuration.mjs"() {
  }
});

// ../../node_modules/date-fns/formatRFC3339.mjs
var init_formatRFC3339 = __esm({
  "../../node_modules/date-fns/formatRFC3339.mjs"() {
  }
});

// ../../node_modules/date-fns/formatRFC7231.mjs
var init_formatRFC7231 = __esm({
  "../../node_modules/date-fns/formatRFC7231.mjs"() {
  }
});

// ../../node_modules/date-fns/formatRelative.mjs
var init_formatRelative = __esm({
  "../../node_modules/date-fns/formatRelative.mjs"() {
  }
});

// ../../node_modules/date-fns/fromUnixTime.mjs
var init_fromUnixTime = __esm({
  "../../node_modules/date-fns/fromUnixTime.mjs"() {
  }
});

// ../../node_modules/date-fns/getDate.mjs
var init_getDate = __esm({
  "../../node_modules/date-fns/getDate.mjs"() {
  }
});

// ../../node_modules/date-fns/getDay.mjs
var init_getDay = __esm({
  "../../node_modules/date-fns/getDay.mjs"() {
  }
});

// ../../node_modules/date-fns/getDaysInMonth.mjs
var init_getDaysInMonth = __esm({
  "../../node_modules/date-fns/getDaysInMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/isLeapYear.mjs
var init_isLeapYear = __esm({
  "../../node_modules/date-fns/isLeapYear.mjs"() {
  }
});

// ../../node_modules/date-fns/getDaysInYear.mjs
var init_getDaysInYear = __esm({
  "../../node_modules/date-fns/getDaysInYear.mjs"() {
  }
});

// ../../node_modules/date-fns/getDecade.mjs
var init_getDecade = __esm({
  "../../node_modules/date-fns/getDecade.mjs"() {
  }
});

// ../../node_modules/date-fns/getDefaultOptions.mjs
var init_getDefaultOptions = __esm({
  "../../node_modules/date-fns/getDefaultOptions.mjs"() {
  }
});

// ../../node_modules/date-fns/getHours.mjs
var init_getHours = __esm({
  "../../node_modules/date-fns/getHours.mjs"() {
  }
});

// ../../node_modules/date-fns/getISODay.mjs
var init_getISODay = __esm({
  "../../node_modules/date-fns/getISODay.mjs"() {
  }
});

// ../../node_modules/date-fns/getISOWeeksInYear.mjs
var init_getISOWeeksInYear = __esm({
  "../../node_modules/date-fns/getISOWeeksInYear.mjs"() {
  }
});

// ../../node_modules/date-fns/getMilliseconds.mjs
var init_getMilliseconds = __esm({
  "../../node_modules/date-fns/getMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/getMinutes.mjs
var init_getMinutes = __esm({
  "../../node_modules/date-fns/getMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/getMonth.mjs
var init_getMonth = __esm({
  "../../node_modules/date-fns/getMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/getOverlappingDaysInIntervals.mjs
var init_getOverlappingDaysInIntervals = __esm({
  "../../node_modules/date-fns/getOverlappingDaysInIntervals.mjs"() {
  }
});

// ../../node_modules/date-fns/getSeconds.mjs
var init_getSeconds = __esm({
  "../../node_modules/date-fns/getSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/getTime.mjs
var init_getTime = __esm({
  "../../node_modules/date-fns/getTime.mjs"() {
  }
});

// ../../node_modules/date-fns/getUnixTime.mjs
var init_getUnixTime = __esm({
  "../../node_modules/date-fns/getUnixTime.mjs"() {
  }
});

// ../../node_modules/date-fns/getWeekOfMonth.mjs
var init_getWeekOfMonth = __esm({
  "../../node_modules/date-fns/getWeekOfMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/lastDayOfMonth.mjs
var init_lastDayOfMonth = __esm({
  "../../node_modules/date-fns/lastDayOfMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/getWeeksInMonth.mjs
var init_getWeeksInMonth = __esm({
  "../../node_modules/date-fns/getWeeksInMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/getYear.mjs
var init_getYear = __esm({
  "../../node_modules/date-fns/getYear.mjs"() {
  }
});

// ../../node_modules/date-fns/hoursToMilliseconds.mjs
var init_hoursToMilliseconds = __esm({
  "../../node_modules/date-fns/hoursToMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/hoursToMinutes.mjs
var init_hoursToMinutes = __esm({
  "../../node_modules/date-fns/hoursToMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/hoursToSeconds.mjs
var init_hoursToSeconds = __esm({
  "../../node_modules/date-fns/hoursToSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/interval.mjs
var init_interval = __esm({
  "../../node_modules/date-fns/interval.mjs"() {
  }
});

// ../../node_modules/date-fns/intervalToDuration.mjs
var init_intervalToDuration = __esm({
  "../../node_modules/date-fns/intervalToDuration.mjs"() {
  }
});

// ../../node_modules/date-fns/intlFormat.mjs
var init_intlFormat = __esm({
  "../../node_modules/date-fns/intlFormat.mjs"() {
  }
});

// ../../node_modules/date-fns/intlFormatDistance.mjs
var init_intlFormatDistance = __esm({
  "../../node_modules/date-fns/intlFormatDistance.mjs"() {
  }
});

// ../../node_modules/date-fns/isAfter.mjs
var init_isAfter = __esm({
  "../../node_modules/date-fns/isAfter.mjs"() {
  }
});

// ../../node_modules/date-fns/isBefore.mjs
var init_isBefore = __esm({
  "../../node_modules/date-fns/isBefore.mjs"() {
  }
});

// ../../node_modules/date-fns/isEqual.mjs
var init_isEqual = __esm({
  "../../node_modules/date-fns/isEqual.mjs"() {
  }
});

// ../../node_modules/date-fns/isExists.mjs
var init_isExists = __esm({
  "../../node_modules/date-fns/isExists.mjs"() {
  }
});

// ../../node_modules/date-fns/isFirstDayOfMonth.mjs
var init_isFirstDayOfMonth = __esm({
  "../../node_modules/date-fns/isFirstDayOfMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/isFriday.mjs
var init_isFriday = __esm({
  "../../node_modules/date-fns/isFriday.mjs"() {
  }
});

// ../../node_modules/date-fns/isFuture.mjs
var init_isFuture = __esm({
  "../../node_modules/date-fns/isFuture.mjs"() {
  }
});

// ../../node_modules/date-fns/transpose.mjs
var init_transpose = __esm({
  "../../node_modules/date-fns/transpose.mjs"() {
  }
});

// ../../node_modules/date-fns/setWeek.mjs
var init_setWeek = __esm({
  "../../node_modules/date-fns/setWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/setISOWeek.mjs
var init_setISOWeek = __esm({
  "../../node_modules/date-fns/setISOWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/setDay.mjs
var init_setDay = __esm({
  "../../node_modules/date-fns/setDay.mjs"() {
  }
});

// ../../node_modules/date-fns/setISODay.mjs
var init_setISODay = __esm({
  "../../node_modules/date-fns/setISODay.mjs"() {
  }
});

// ../../node_modules/date-fns/parse.mjs
var init_parse = __esm({
  "../../node_modules/date-fns/parse.mjs"() {
  }
});

// ../../node_modules/date-fns/isMatch.mjs
var init_isMatch = __esm({
  "../../node_modules/date-fns/isMatch.mjs"() {
  }
});

// ../../node_modules/date-fns/isMonday.mjs
var init_isMonday = __esm({
  "../../node_modules/date-fns/isMonday.mjs"() {
  }
});

// ../../node_modules/date-fns/isPast.mjs
var init_isPast = __esm({
  "../../node_modules/date-fns/isPast.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfHour.mjs
var init_startOfHour = __esm({
  "../../node_modules/date-fns/startOfHour.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameHour.mjs
var init_isSameHour = __esm({
  "../../node_modules/date-fns/isSameHour.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameWeek.mjs
var init_isSameWeek = __esm({
  "../../node_modules/date-fns/isSameWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameISOWeek.mjs
var init_isSameISOWeek = __esm({
  "../../node_modules/date-fns/isSameISOWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameISOWeekYear.mjs
var init_isSameISOWeekYear = __esm({
  "../../node_modules/date-fns/isSameISOWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameMinute.mjs
var init_isSameMinute = __esm({
  "../../node_modules/date-fns/isSameMinute.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameMonth.mjs
var init_isSameMonth = __esm({
  "../../node_modules/date-fns/isSameMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameQuarter.mjs
var init_isSameQuarter = __esm({
  "../../node_modules/date-fns/isSameQuarter.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfSecond.mjs
var init_startOfSecond = __esm({
  "../../node_modules/date-fns/startOfSecond.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameSecond.mjs
var init_isSameSecond = __esm({
  "../../node_modules/date-fns/isSameSecond.mjs"() {
  }
});

// ../../node_modules/date-fns/isSameYear.mjs
var init_isSameYear = __esm({
  "../../node_modules/date-fns/isSameYear.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisHour.mjs
var init_isThisHour = __esm({
  "../../node_modules/date-fns/isThisHour.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisISOWeek.mjs
var init_isThisISOWeek = __esm({
  "../../node_modules/date-fns/isThisISOWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisMinute.mjs
var init_isThisMinute = __esm({
  "../../node_modules/date-fns/isThisMinute.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisMonth.mjs
var init_isThisMonth = __esm({
  "../../node_modules/date-fns/isThisMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisQuarter.mjs
var init_isThisQuarter = __esm({
  "../../node_modules/date-fns/isThisQuarter.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisSecond.mjs
var init_isThisSecond = __esm({
  "../../node_modules/date-fns/isThisSecond.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisWeek.mjs
var init_isThisWeek = __esm({
  "../../node_modules/date-fns/isThisWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/isThisYear.mjs
var init_isThisYear = __esm({
  "../../node_modules/date-fns/isThisYear.mjs"() {
  }
});

// ../../node_modules/date-fns/isThursday.mjs
var init_isThursday = __esm({
  "../../node_modules/date-fns/isThursday.mjs"() {
  }
});

// ../../node_modules/date-fns/isToday.mjs
var init_isToday = __esm({
  "../../node_modules/date-fns/isToday.mjs"() {
  }
});

// ../../node_modules/date-fns/isTomorrow.mjs
var init_isTomorrow = __esm({
  "../../node_modules/date-fns/isTomorrow.mjs"() {
  }
});

// ../../node_modules/date-fns/isTuesday.mjs
var init_isTuesday = __esm({
  "../../node_modules/date-fns/isTuesday.mjs"() {
  }
});

// ../../node_modules/date-fns/isWednesday.mjs
var init_isWednesday = __esm({
  "../../node_modules/date-fns/isWednesday.mjs"() {
  }
});

// ../../node_modules/date-fns/isWithinInterval.mjs
var init_isWithinInterval = __esm({
  "../../node_modules/date-fns/isWithinInterval.mjs"() {
  }
});

// ../../node_modules/date-fns/subDays.mjs
var init_subDays = __esm({
  "../../node_modules/date-fns/subDays.mjs"() {
  }
});

// ../../node_modules/date-fns/isYesterday.mjs
var init_isYesterday = __esm({
  "../../node_modules/date-fns/isYesterday.mjs"() {
  }
});

// ../../node_modules/date-fns/lastDayOfDecade.mjs
var init_lastDayOfDecade = __esm({
  "../../node_modules/date-fns/lastDayOfDecade.mjs"() {
  }
});

// ../../node_modules/date-fns/lastDayOfWeek.mjs
var init_lastDayOfWeek = __esm({
  "../../node_modules/date-fns/lastDayOfWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/lastDayOfISOWeek.mjs
var init_lastDayOfISOWeek = __esm({
  "../../node_modules/date-fns/lastDayOfISOWeek.mjs"() {
  }
});

// ../../node_modules/date-fns/lastDayOfISOWeekYear.mjs
var init_lastDayOfISOWeekYear = __esm({
  "../../node_modules/date-fns/lastDayOfISOWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/lastDayOfQuarter.mjs
var init_lastDayOfQuarter = __esm({
  "../../node_modules/date-fns/lastDayOfQuarter.mjs"() {
  }
});

// ../../node_modules/date-fns/lastDayOfYear.mjs
var init_lastDayOfYear = __esm({
  "../../node_modules/date-fns/lastDayOfYear.mjs"() {
  }
});

// ../../node_modules/date-fns/lightFormat.mjs
var init_lightFormat = __esm({
  "../../node_modules/date-fns/lightFormat.mjs"() {
  }
});

// ../../node_modules/date-fns/milliseconds.mjs
var init_milliseconds = __esm({
  "../../node_modules/date-fns/milliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/millisecondsToHours.mjs
var init_millisecondsToHours = __esm({
  "../../node_modules/date-fns/millisecondsToHours.mjs"() {
  }
});

// ../../node_modules/date-fns/millisecondsToMinutes.mjs
var init_millisecondsToMinutes = __esm({
  "../../node_modules/date-fns/millisecondsToMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/millisecondsToSeconds.mjs
var init_millisecondsToSeconds = __esm({
  "../../node_modules/date-fns/millisecondsToSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/minutesToHours.mjs
var init_minutesToHours = __esm({
  "../../node_modules/date-fns/minutesToHours.mjs"() {
  }
});

// ../../node_modules/date-fns/minutesToMilliseconds.mjs
var init_minutesToMilliseconds = __esm({
  "../../node_modules/date-fns/minutesToMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/minutesToSeconds.mjs
var init_minutesToSeconds = __esm({
  "../../node_modules/date-fns/minutesToSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/monthsToQuarters.mjs
var init_monthsToQuarters = __esm({
  "../../node_modules/date-fns/monthsToQuarters.mjs"() {
  }
});

// ../../node_modules/date-fns/monthsToYears.mjs
var init_monthsToYears = __esm({
  "../../node_modules/date-fns/monthsToYears.mjs"() {
  }
});

// ../../node_modules/date-fns/nextDay.mjs
var init_nextDay = __esm({
  "../../node_modules/date-fns/nextDay.mjs"() {
  }
});

// ../../node_modules/date-fns/nextFriday.mjs
var init_nextFriday = __esm({
  "../../node_modules/date-fns/nextFriday.mjs"() {
  }
});

// ../../node_modules/date-fns/nextMonday.mjs
var init_nextMonday = __esm({
  "../../node_modules/date-fns/nextMonday.mjs"() {
  }
});

// ../../node_modules/date-fns/nextSaturday.mjs
var init_nextSaturday = __esm({
  "../../node_modules/date-fns/nextSaturday.mjs"() {
  }
});

// ../../node_modules/date-fns/nextSunday.mjs
var init_nextSunday = __esm({
  "../../node_modules/date-fns/nextSunday.mjs"() {
  }
});

// ../../node_modules/date-fns/nextThursday.mjs
var init_nextThursday = __esm({
  "../../node_modules/date-fns/nextThursday.mjs"() {
  }
});

// ../../node_modules/date-fns/nextTuesday.mjs
var init_nextTuesday = __esm({
  "../../node_modules/date-fns/nextTuesday.mjs"() {
  }
});

// ../../node_modules/date-fns/nextWednesday.mjs
var init_nextWednesday = __esm({
  "../../node_modules/date-fns/nextWednesday.mjs"() {
  }
});

// ../../node_modules/date-fns/parseISO.mjs
var init_parseISO = __esm({
  "../../node_modules/date-fns/parseISO.mjs"() {
  }
});

// ../../node_modules/date-fns/parseJSON.mjs
var init_parseJSON = __esm({
  "../../node_modules/date-fns/parseJSON.mjs"() {
  }
});

// ../../node_modules/date-fns/previousDay.mjs
var init_previousDay = __esm({
  "../../node_modules/date-fns/previousDay.mjs"() {
  }
});

// ../../node_modules/date-fns/previousFriday.mjs
var init_previousFriday = __esm({
  "../../node_modules/date-fns/previousFriday.mjs"() {
  }
});

// ../../node_modules/date-fns/previousMonday.mjs
var init_previousMonday = __esm({
  "../../node_modules/date-fns/previousMonday.mjs"() {
  }
});

// ../../node_modules/date-fns/previousSaturday.mjs
var init_previousSaturday = __esm({
  "../../node_modules/date-fns/previousSaturday.mjs"() {
  }
});

// ../../node_modules/date-fns/previousSunday.mjs
var init_previousSunday = __esm({
  "../../node_modules/date-fns/previousSunday.mjs"() {
  }
});

// ../../node_modules/date-fns/previousThursday.mjs
var init_previousThursday = __esm({
  "../../node_modules/date-fns/previousThursday.mjs"() {
  }
});

// ../../node_modules/date-fns/previousTuesday.mjs
var init_previousTuesday = __esm({
  "../../node_modules/date-fns/previousTuesday.mjs"() {
  }
});

// ../../node_modules/date-fns/previousWednesday.mjs
var init_previousWednesday = __esm({
  "../../node_modules/date-fns/previousWednesday.mjs"() {
  }
});

// ../../node_modules/date-fns/quartersToMonths.mjs
var init_quartersToMonths = __esm({
  "../../node_modules/date-fns/quartersToMonths.mjs"() {
  }
});

// ../../node_modules/date-fns/quartersToYears.mjs
var init_quartersToYears = __esm({
  "../../node_modules/date-fns/quartersToYears.mjs"() {
  }
});

// ../../node_modules/date-fns/roundToNearestHours.mjs
var init_roundToNearestHours = __esm({
  "../../node_modules/date-fns/roundToNearestHours.mjs"() {
  }
});

// ../../node_modules/date-fns/roundToNearestMinutes.mjs
var init_roundToNearestMinutes = __esm({
  "../../node_modules/date-fns/roundToNearestMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/secondsToHours.mjs
var init_secondsToHours = __esm({
  "../../node_modules/date-fns/secondsToHours.mjs"() {
  }
});

// ../../node_modules/date-fns/secondsToMilliseconds.mjs
var init_secondsToMilliseconds = __esm({
  "../../node_modules/date-fns/secondsToMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/secondsToMinutes.mjs
var init_secondsToMinutes = __esm({
  "../../node_modules/date-fns/secondsToMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/setMonth.mjs
var init_setMonth = __esm({
  "../../node_modules/date-fns/setMonth.mjs"() {
  }
});

// ../../node_modules/date-fns/set.mjs
var init_set = __esm({
  "../../node_modules/date-fns/set.mjs"() {
  }
});

// ../../node_modules/date-fns/setDate.mjs
var init_setDate = __esm({
  "../../node_modules/date-fns/setDate.mjs"() {
  }
});

// ../../node_modules/date-fns/setDayOfYear.mjs
var init_setDayOfYear = __esm({
  "../../node_modules/date-fns/setDayOfYear.mjs"() {
  }
});

// ../../node_modules/date-fns/setDefaultOptions.mjs
var init_setDefaultOptions = __esm({
  "../../node_modules/date-fns/setDefaultOptions.mjs"() {
  }
});

// ../../node_modules/date-fns/setHours.mjs
var init_setHours = __esm({
  "../../node_modules/date-fns/setHours.mjs"() {
  }
});

// ../../node_modules/date-fns/setMilliseconds.mjs
var init_setMilliseconds = __esm({
  "../../node_modules/date-fns/setMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/setMinutes.mjs
var init_setMinutes = __esm({
  "../../node_modules/date-fns/setMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/setQuarter.mjs
var init_setQuarter = __esm({
  "../../node_modules/date-fns/setQuarter.mjs"() {
  }
});

// ../../node_modules/date-fns/setSeconds.mjs
var init_setSeconds = __esm({
  "../../node_modules/date-fns/setSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/setWeekYear.mjs
var init_setWeekYear = __esm({
  "../../node_modules/date-fns/setWeekYear.mjs"() {
  }
});

// ../../node_modules/date-fns/setYear.mjs
var init_setYear = __esm({
  "../../node_modules/date-fns/setYear.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfDecade.mjs
var init_startOfDecade = __esm({
  "../../node_modules/date-fns/startOfDecade.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfToday.mjs
var init_startOfToday = __esm({
  "../../node_modules/date-fns/startOfToday.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfTomorrow.mjs
var init_startOfTomorrow = __esm({
  "../../node_modules/date-fns/startOfTomorrow.mjs"() {
  }
});

// ../../node_modules/date-fns/startOfYesterday.mjs
var init_startOfYesterday = __esm({
  "../../node_modules/date-fns/startOfYesterday.mjs"() {
  }
});

// ../../node_modules/date-fns/subMonths.mjs
var init_subMonths = __esm({
  "../../node_modules/date-fns/subMonths.mjs"() {
  }
});

// ../../node_modules/date-fns/sub.mjs
var init_sub = __esm({
  "../../node_modules/date-fns/sub.mjs"() {
  }
});

// ../../node_modules/date-fns/subBusinessDays.mjs
var init_subBusinessDays = __esm({
  "../../node_modules/date-fns/subBusinessDays.mjs"() {
  }
});

// ../../node_modules/date-fns/subHours.mjs
var init_subHours = __esm({
  "../../node_modules/date-fns/subHours.mjs"() {
  }
});

// ../../node_modules/date-fns/subMilliseconds.mjs
var init_subMilliseconds = __esm({
  "../../node_modules/date-fns/subMilliseconds.mjs"() {
  }
});

// ../../node_modules/date-fns/subMinutes.mjs
var init_subMinutes = __esm({
  "../../node_modules/date-fns/subMinutes.mjs"() {
  }
});

// ../../node_modules/date-fns/subQuarters.mjs
var init_subQuarters = __esm({
  "../../node_modules/date-fns/subQuarters.mjs"() {
  }
});

// ../../node_modules/date-fns/subSeconds.mjs
var init_subSeconds = __esm({
  "../../node_modules/date-fns/subSeconds.mjs"() {
  }
});

// ../../node_modules/date-fns/subWeeks.mjs
var init_subWeeks = __esm({
  "../../node_modules/date-fns/subWeeks.mjs"() {
  }
});

// ../../node_modules/date-fns/subYears.mjs
var init_subYears = __esm({
  "../../node_modules/date-fns/subYears.mjs"() {
  }
});

// ../../node_modules/date-fns/weeksToDays.mjs
var init_weeksToDays = __esm({
  "../../node_modules/date-fns/weeksToDays.mjs"() {
  }
});

// ../../node_modules/date-fns/yearsToDays.mjs
var init_yearsToDays = __esm({
  "../../node_modules/date-fns/yearsToDays.mjs"() {
  }
});

// ../../node_modules/date-fns/yearsToMonths.mjs
var init_yearsToMonths = __esm({
  "../../node_modules/date-fns/yearsToMonths.mjs"() {
  }
});

// ../../node_modules/date-fns/yearsToQuarters.mjs
var init_yearsToQuarters = __esm({
  "../../node_modules/date-fns/yearsToQuarters.mjs"() {
  }
});

// ../../node_modules/date-fns/index.mjs
var init_date_fns = __esm({
  "../../node_modules/date-fns/index.mjs"() {
    init_add();
    init_addBusinessDays();
    init_addDays();
    init_addHours();
    init_addISOWeekYears();
    init_addMilliseconds();
    init_addMinutes();
    init_addMonths();
    init_addQuarters();
    init_addSeconds();
    init_addWeeks();
    init_addYears();
    init_areIntervalsOverlapping();
    init_clamp();
    init_closestIndexTo();
    init_closestTo();
    init_compareAsc();
    init_compareDesc();
    init_constructFrom();
    init_constructNow();
    init_daysToWeeks();
    init_differenceInBusinessDays();
    init_differenceInCalendarDays();
    init_differenceInCalendarISOWeekYears();
    init_differenceInCalendarISOWeeks();
    init_differenceInCalendarMonths();
    init_differenceInCalendarQuarters();
    init_differenceInCalendarWeeks();
    init_differenceInCalendarYears();
    init_differenceInDays();
    init_differenceInHours();
    init_differenceInISOWeekYears();
    init_differenceInMilliseconds();
    init_differenceInMinutes();
    init_differenceInMonths();
    init_differenceInQuarters();
    init_differenceInSeconds();
    init_differenceInWeeks();
    init_differenceInYears();
    init_eachDayOfInterval();
    init_eachHourOfInterval();
    init_eachMinuteOfInterval();
    init_eachMonthOfInterval();
    init_eachQuarterOfInterval();
    init_eachWeekOfInterval();
    init_eachWeekendOfInterval();
    init_eachWeekendOfMonth();
    init_eachWeekendOfYear();
    init_eachYearOfInterval();
    init_endOfDay();
    init_endOfDecade();
    init_endOfHour();
    init_endOfISOWeek();
    init_endOfISOWeekYear();
    init_endOfMinute();
    init_endOfMonth();
    init_endOfQuarter();
    init_endOfSecond();
    init_endOfToday();
    init_endOfTomorrow();
    init_endOfWeek();
    init_endOfYear();
    init_endOfYesterday();
    init_format();
    init_formatDistance();
    init_formatDistanceStrict();
    init_formatDistanceToNow();
    init_formatDistanceToNowStrict();
    init_formatDuration();
    init_formatISO();
    init_formatISO9075();
    init_formatISODuration();
    init_formatRFC3339();
    init_formatRFC7231();
    init_formatRelative();
    init_fromUnixTime();
    init_getDate();
    init_getDay();
    init_getDayOfYear();
    init_getDaysInMonth();
    init_getDaysInYear();
    init_getDecade();
    init_getDefaultOptions();
    init_getHours();
    init_getISODay();
    init_getISOWeek();
    init_getISOWeekYear();
    init_getISOWeeksInYear();
    init_getMilliseconds();
    init_getMinutes();
    init_getMonth();
    init_getOverlappingDaysInIntervals();
    init_getQuarter();
    init_getSeconds();
    init_getTime();
    init_getUnixTime();
    init_getWeek();
    init_getWeekOfMonth();
    init_getWeekYear();
    init_getWeeksInMonth();
    init_getYear();
    init_hoursToMilliseconds();
    init_hoursToMinutes();
    init_hoursToSeconds();
    init_interval();
    init_intervalToDuration();
    init_intlFormat();
    init_intlFormatDistance();
    init_isAfter();
    init_isBefore();
    init_isDate();
    init_isEqual();
    init_isExists();
    init_isFirstDayOfMonth();
    init_isFriday();
    init_isFuture();
    init_isLastDayOfMonth();
    init_isLeapYear();
    init_isMatch();
    init_isMonday();
    init_isPast();
    init_isSameDay();
    init_isSameHour();
    init_isSameISOWeek();
    init_isSameISOWeekYear();
    init_isSameMinute();
    init_isSameMonth();
    init_isSameQuarter();
    init_isSameSecond();
    init_isSameWeek();
    init_isSameYear();
    init_isSaturday();
    init_isSunday();
    init_isThisHour();
    init_isThisISOWeek();
    init_isThisMinute();
    init_isThisMonth();
    init_isThisQuarter();
    init_isThisSecond();
    init_isThisWeek();
    init_isThisYear();
    init_isThursday();
    init_isToday();
    init_isTomorrow();
    init_isTuesday();
    init_isValid();
    init_isWednesday();
    init_isWeekend();
    init_isWithinInterval();
    init_isYesterday();
    init_lastDayOfDecade();
    init_lastDayOfISOWeek();
    init_lastDayOfISOWeekYear();
    init_lastDayOfMonth();
    init_lastDayOfQuarter();
    init_lastDayOfWeek();
    init_lastDayOfYear();
    init_lightFormat();
    init_max();
    init_milliseconds();
    init_millisecondsToHours();
    init_millisecondsToMinutes();
    init_millisecondsToSeconds();
    init_min();
    init_minutesToHours();
    init_minutesToMilliseconds();
    init_minutesToSeconds();
    init_monthsToQuarters();
    init_monthsToYears();
    init_nextDay();
    init_nextFriday();
    init_nextMonday();
    init_nextSaturday();
    init_nextSunday();
    init_nextThursday();
    init_nextTuesday();
    init_nextWednesday();
    init_parse();
    init_parseISO();
    init_parseJSON();
    init_previousDay();
    init_previousFriday();
    init_previousMonday();
    init_previousSaturday();
    init_previousSunday();
    init_previousThursday();
    init_previousTuesday();
    init_previousWednesday();
    init_quartersToMonths();
    init_quartersToYears();
    init_roundToNearestHours();
    init_roundToNearestMinutes();
    init_secondsToHours();
    init_secondsToMilliseconds();
    init_secondsToMinutes();
    init_set();
    init_setDate();
    init_setDay();
    init_setDayOfYear();
    init_setDefaultOptions();
    init_setHours();
    init_setISODay();
    init_setISOWeek();
    init_setISOWeekYear();
    init_setMilliseconds();
    init_setMinutes();
    init_setMonth();
    init_setQuarter();
    init_setSeconds();
    init_setWeek();
    init_setWeekYear();
    init_setYear();
    init_startOfDay();
    init_startOfDecade();
    init_startOfHour();
    init_startOfISOWeek();
    init_startOfISOWeekYear();
    init_startOfMinute();
    init_startOfMonth();
    init_startOfQuarter();
    init_startOfSecond();
    init_startOfToday();
    init_startOfTomorrow();
    init_startOfWeek();
    init_startOfWeekYear();
    init_startOfYear();
    init_startOfYesterday();
    init_sub();
    init_subBusinessDays();
    init_subDays();
    init_subHours();
    init_subISOWeekYears();
    init_subMilliseconds();
    init_subMinutes();
    init_subMonths();
    init_subQuarters();
    init_subSeconds();
    init_subWeeks();
    init_subYears();
    init_toDate();
    init_transpose();
    init_weeksToDays();
    init_yearsToDays();
    init_yearsToMonths();
    init_yearsToQuarters();
  }
});

// src/main/secure-read-file.ts
var import_node_fs2, import_node_os, import_node_path, import_electron2, isPathAllowed, securePath, getSecuredFolderAllowList, insecureReadFile;
var init_secure_read_file = __esm({
  "src/main/secure-read-file.ts"() {
    "use strict";
    import_node_fs2 = __toESM(require("node:fs"));
    import_node_os = __toESM(require("node:os"));
    import_node_path = __toESM(require("node:path"));
    import_electron2 = __toESM(require("electron"));
    init_invariant();
    init_models();
    isPathAllowed = (filePath, userAllowList) => {
      const allowList = getSecuredFolderAllowList(userAllowList);
      const securedPath = securePath(filePath);
      const isAllowed = allowList.some((f3) => import_node_path.default.resolve(f3) !== "" && securedPath.startsWith(import_node_path.default.resolve(f3)));
      return { isAllowed, securedPath };
    };
    securePath = (filePath) => import_node_path.default.resolve(decodeURIComponent(filePath));
    getSecuredFolderAllowList = (userAllowList) => {
      const userDataPath = process.type === "renderer" ? window.app.getPath("userData") : import_electron2.default.app.getPath("userData");
      const userdataDirectory = process.env.INSOMNIA_DATA_PATH || userDataPath;
      return [import_node_os.default.tmpdir(), userdataDirectory, ...userAllowList];
    };
    insecureReadFile = async (filePath) => {
      return import_node_fs2.default.promises.readFile(securePath(filePath), { encoding: "utf8" });
    };
  }
});

// ../../node_modules/mime-types/node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/mime-types/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/mime-types/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/mime-types/node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup2;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup2(path4) {
      if (!path4 || typeof path4 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path4).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i2 = 0; i2 < exts.length; i2++) {
          var extension2 = exts[i2];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// src/main/network/multipart.ts
async function buildMultipart(params) {
  return new Promise(async (resolve, reject2) => {
    const filePath = import_node_path2.default.join(import_node_os2.default.tmpdir(), Math.random() + ".body");
    const writeStream = import_node_fs3.default.createWriteStream(filePath);
    const lineBreak = "\r\n";
    let totalSize = 0;
    function addFile(path4) {
      return new Promise((resolve2, reject3) => {
        let size2;
        try {
          size2 = import_node_fs3.default.statSync(path4).size;
        } catch (err) {
          reject3(err);
        }
        const stream = import_node_fs3.default.createReadStream(path4);
        stream.once("end", () => {
          resolve2();
        });
        stream.once("error", (err) => {
          reject3(err);
        });
        stream.pipe(writeStream, {
          end: false
        });
        totalSize += size2;
      });
    }
    const addString = (v3) => {
      const buffer = Buffer.from(v3);
      writeStream.write(buffer);
      totalSize += buffer.length;
    };
    for (const param of params) {
      const noName = !param.name;
      const noValue = !(param.value || param.fileName);
      if (noName && noValue) {
        continue;
      }
      addString(`--${DEFAULT_BOUNDARY}`);
      addString(lineBreak);
      if (param.type === "file" && param.fileName) {
        const name = param.name || "";
        const fileName = param.fileName;
        const contentType = (0, import_mime_types.lookup)(fileName) || "application/octet-stream";
        addString(
          `Content-Disposition: form-data; name="${name.replace(/"/g, '\\"')}"; filename="${import_node_path2.default.basename(fileName).replace(/"/g, '\\"')}"`
        );
        addString(lineBreak);
        addString(`Content-Type: ${contentType}`);
        addString(lineBreak);
        addString(lineBreak);
        try {
          await addFile(fileName);
        } catch (err) {
          return reject2(err);
        }
      } else {
        const name = param.name || "";
        const value = param.value || "";
        const contentType = param.multiline;
        addString(`Content-Disposition: form-data; name="${name}"`);
        addString(lineBreak);
        if (typeof contentType === "string") {
          addString(`Content-Type: ${contentType}`);
          addString(lineBreak);
        }
        addString(lineBreak);
        addString(value);
      }
      addString(lineBreak);
    }
    addString(`--${DEFAULT_BOUNDARY}--`);
    addString(lineBreak);
    writeStream.once("error", (err) => {
      reject2(err);
    });
    writeStream.once("close", () => {
      resolve({
        boundary: DEFAULT_BOUNDARY,
        filePath,
        contentLength: totalSize
      });
    });
    writeStream.end();
  });
}
var import_node_fs3, import_node_os2, import_node_path2, import_mime_types, DEFAULT_BOUNDARY;
var init_multipart = __esm({
  "src/main/network/multipart.ts"() {
    "use strict";
    import_node_fs3 = __toESM(require("node:fs"));
    import_node_os2 = __toESM(require("node:os"));
    import_node_path2 = __toESM(require("node:path"));
    import_mime_types = __toESM(require_mime_types());
    if (process.type === "renderer") {
      throw new Error("multipart.ts unavailable in renderer");
    }
    DEFAULT_BOUNDARY = "X-INSOMNIA-BOUNDARY";
  }
});

// ../../node_modules/aws4/lru.js
var require_lru = __commonJS({
  "../../node_modules/aws4/lru.js"(exports2, module2) {
    module2.exports = function(size2) {
      return new LruCache(size2);
    };
    function LruCache(size2) {
      this.capacity = size2 | 0;
      this.map = /* @__PURE__ */ Object.create(null);
      this.list = new DoublyLinkedList();
    }
    LruCache.prototype.get = function(key) {
      var node3 = this.map[key];
      if (node3 == null) return void 0;
      this.used(node3);
      return node3.val;
    };
    LruCache.prototype.set = function(key, val) {
      var node3 = this.map[key];
      if (node3 != null) {
        node3.val = val;
      } else {
        if (!this.capacity) this.prune();
        if (!this.capacity) return false;
        node3 = new DoublyLinkedNode(key, val);
        this.map[key] = node3;
        this.capacity--;
      }
      this.used(node3);
      return true;
    };
    LruCache.prototype.used = function(node3) {
      this.list.moveToFront(node3);
    };
    LruCache.prototype.prune = function() {
      var node3 = this.list.pop();
      if (node3 != null) {
        delete this.map[node3.key];
        this.capacity++;
      }
    };
    function DoublyLinkedList() {
      this.firstNode = null;
      this.lastNode = null;
    }
    DoublyLinkedList.prototype.moveToFront = function(node3) {
      if (this.firstNode == node3) return;
      this.remove(node3);
      if (this.firstNode == null) {
        this.firstNode = node3;
        this.lastNode = node3;
        node3.prev = null;
        node3.next = null;
      } else {
        node3.prev = null;
        node3.next = this.firstNode;
        node3.next.prev = node3;
        this.firstNode = node3;
      }
    };
    DoublyLinkedList.prototype.pop = function() {
      var lastNode = this.lastNode;
      if (lastNode != null) {
        this.remove(lastNode);
      }
      return lastNode;
    };
    DoublyLinkedList.prototype.remove = function(node3) {
      if (this.firstNode == node3) {
        this.firstNode = node3.next;
      } else if (node3.prev != null) {
        node3.prev.next = node3.next;
      }
      if (this.lastNode == node3) {
        this.lastNode = node3.prev;
      } else if (node3.next != null) {
        node3.next.prev = node3.prev;
      }
    };
    function DoublyLinkedNode(key, val) {
      this.key = key;
      this.val = val;
      this.prev = null;
      this.next = null;
    }
  }
});

// ../../node_modules/aws4/aws4.js
var require_aws4 = __commonJS({
  "../../node_modules/aws4/aws4.js"(exports2) {
    var aws42 = exports2;
    var url = require("url");
    var querystring = require("querystring");
    var crypto3 = require("crypto");
    var lru = require_lru();
    var credentialsCache = lru(1e3);
    function hmac(key, string, encoding) {
      return crypto3.createHmac("sha256", key).update(string, "utf8").digest(encoding);
    }
    function hash(string, encoding) {
      return crypto3.createHash("sha256").update(string, "utf8").digest(encoding);
    }
    function encodeRfc3986(urlEncodedString) {
      return urlEncodedString.replace(/[!'()*]/g, function(c2) {
        return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeRfc3986Full(str) {
      return encodeRfc3986(encodeURIComponent(str));
    }
    var HEADERS_TO_IGNORE = {
      "authorization": true,
      "connection": true,
      "x-amzn-trace-id": true,
      "user-agent": true,
      "expect": true,
      "presigned-expires": true,
      "range": true
    };
    function RequestSigner(request2, credentials) {
      if (typeof request2 === "string") request2 = url.parse(request2);
      var headers = request2.headers = Object.assign({}, request2.headers || {}), hostParts = (!this.service || !this.region) && this.matchHost(request2.hostname || request2.host || headers.Host || headers.host);
      this.request = request2;
      this.credentials = credentials || this.defaultCredentials();
      this.service = request2.service || hostParts[0] || "";
      this.region = request2.region || hostParts[1] || "us-east-1";
      if (this.service === "email") this.service = "ses";
      if (!request2.method && request2.body)
        request2.method = "POST";
      if (!headers.Host && !headers.host) {
        headers.Host = request2.hostname || request2.host || this.createHost();
        if (request2.port)
          headers.Host += ":" + request2.port;
      }
      if (!request2.hostname && !request2.host)
        request2.hostname = headers.Host || headers.host;
      this.isCodeCommitGit = this.service === "codecommit" && request2.method === "GIT";
      this.extraHeadersToIgnore = request2.extraHeadersToIgnore || /* @__PURE__ */ Object.create(null);
      this.extraHeadersToInclude = request2.extraHeadersToInclude || /* @__PURE__ */ Object.create(null);
    }
    RequestSigner.prototype.matchHost = function(host) {
      var match = (host || "").match(/([^\.]{1,63})\.(?:([^\.]{0,63})\.)?amazonaws\.com(\.cn)?$/);
      var hostParts = (match || []).slice(1, 3);
      if (hostParts[1] === "es" || hostParts[1] === "aoss")
        hostParts = hostParts.reverse();
      if (hostParts[1] == "s3") {
        hostParts[0] = "s3";
        hostParts[1] = "us-east-1";
      } else {
        for (var i2 = 0; i2 < 2; i2++) {
          if (/^s3-/.test(hostParts[i2])) {
            hostParts[1] = hostParts[i2].slice(3);
            hostParts[0] = "s3";
            break;
          }
        }
      }
      return hostParts;
    };
    RequestSigner.prototype.isSingleRegion = function() {
      if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1") return true;
      return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
    };
    RequestSigner.prototype.createHost = function() {
      var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
      return subdomain + region + ".amazonaws.com";
    };
    RequestSigner.prototype.prepareRequest = function() {
      this.parsePath();
      var request2 = this.request, headers = request2.headers, query;
      if (request2.signQuery) {
        this.parsedPath.query = query = this.parsedPath.query || {};
        if (this.credentials.sessionToken)
          query["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !query["X-Amz-Expires"])
          query["X-Amz-Expires"] = 86400;
        if (query["X-Amz-Date"])
          this.datetime = query["X-Amz-Date"];
        else
          query["X-Amz-Date"] = this.getDateTime();
        query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
        query["X-Amz-SignedHeaders"] = this.signedHeaders();
      } else {
        if (!request2.doNotModifyHeaders && !this.isCodeCommitGit) {
          if (request2.body && !headers["Content-Type"] && !headers["content-type"])
            headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
          if (request2.body && !headers["Content-Length"] && !headers["content-length"])
            headers["Content-Length"] = Buffer.byteLength(request2.body);
          if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
            headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
          if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
            headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
          if (headers["X-Amz-Date"] || headers["x-amz-date"])
            this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
          else
            headers["X-Amz-Date"] = this.getDateTime();
        }
        delete headers.Authorization;
        delete headers.authorization;
      }
    };
    RequestSigner.prototype.sign = function() {
      if (!this.parsedPath) this.prepareRequest();
      if (this.request.signQuery) {
        this.parsedPath.query["X-Amz-Signature"] = this.signature();
      } else {
        this.request.headers.Authorization = this.authHeader();
      }
      this.request.path = this.formatPath();
      return this.request;
    };
    RequestSigner.prototype.getDateTime = function() {
      if (!this.datetime) {
        var headers = this.request.headers, date = new Date(headers.Date || headers.date || /* @__PURE__ */ new Date());
        this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
        if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1);
      }
      return this.datetime;
    };
    RequestSigner.prototype.getDate = function() {
      return this.getDateTime().substr(0, 8);
    };
    RequestSigner.prototype.authHeader = function() {
      return [
        "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
        "SignedHeaders=" + this.signedHeaders(),
        "Signature=" + this.signature()
      ].join(", ");
    };
    RequestSigner.prototype.signature = function() {
      var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
      if (!kCredentials) {
        kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
        kRegion = hmac(kDate, this.region);
        kService = hmac(kRegion, this.service);
        kCredentials = hmac(kService, "aws4_request");
        credentialsCache.set(cacheKey, kCredentials);
      }
      return hmac(kCredentials, this.stringToSign(), "hex");
    };
    RequestSigner.prototype.stringToSign = function() {
      return [
        "AWS4-HMAC-SHA256",
        this.getDateTime(),
        this.credentialString(),
        hash(this.canonicalString(), "hex")
      ].join("\n");
    };
    RequestSigner.prototype.canonicalString = function() {
      if (!this.parsedPath) this.prepareRequest();
      var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
      if (this.service === "s3" && this.request.signQuery) {
        bodyHash = "UNSIGNED-PAYLOAD";
      } else if (this.isCodeCommitGit) {
        bodyHash = "";
      } else {
        bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
      }
      if (query) {
        var reducedQuery = Object.keys(query).reduce(function(obj, key) {
          if (!key) return obj;
          obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key];
          return obj;
        }, {});
        var encodedQueryPieces = [];
        Object.keys(reducedQuery).sort().forEach(function(key) {
          if (!Array.isArray(reducedQuery[key])) {
            encodedQueryPieces.push(key + "=" + encodeRfc3986Full(reducedQuery[key]));
          } else {
            reducedQuery[key].map(encodeRfc3986Full).sort().forEach(function(val) {
              encodedQueryPieces.push(key + "=" + val);
            });
          }
        });
        queryStr = encodedQueryPieces.join("&");
      }
      if (pathStr !== "/") {
        if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, "/");
        pathStr = pathStr.split("/").reduce(function(path4, piece) {
          if (normalizePath && piece === "..") {
            path4.pop();
          } else if (!normalizePath || piece !== ".") {
            if (decodePath) piece = decodeURIComponent(piece.replace(/\+/g, " "));
            path4.push(encodeRfc3986Full(piece));
          }
          return path4;
        }, []).join("/");
        if (pathStr[0] !== "/") pathStr = "/" + pathStr;
        if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, "/");
      }
      return [
        this.request.method || "GET",
        pathStr,
        queryStr,
        this.canonicalHeaders() + "\n",
        this.signedHeaders(),
        bodyHash
      ].join("\n");
    };
    RequestSigner.prototype.filterHeaders = function() {
      var headers = this.request.headers, extraHeadersToInclude = this.extraHeadersToInclude, extraHeadersToIgnore = this.extraHeadersToIgnore;
      this.filteredHeaders = Object.keys(headers).map(function(key) {
        return [key.toLowerCase(), headers[key]];
      }).filter(function(entry) {
        return extraHeadersToInclude[entry[0]] || HEADERS_TO_IGNORE[entry[0]] == null && !extraHeadersToIgnore[entry[0]];
      }).sort(function(a2, b2) {
        return a2[0] < b2[0] ? -1 : 1;
      });
    };
    RequestSigner.prototype.canonicalHeaders = function() {
      if (!this.filteredHeaders) this.filterHeaders();
      return this.filteredHeaders.map(function(entry) {
        return entry[0] + ":" + entry[1].toString().trim().replace(/\s+/g, " ");
      }).join("\n");
    };
    RequestSigner.prototype.signedHeaders = function() {
      if (!this.filteredHeaders) this.filterHeaders();
      return this.filteredHeaders.map(function(entry) {
        return entry[0];
      }).join(";");
    };
    RequestSigner.prototype.credentialString = function() {
      return [
        this.getDate(),
        this.region,
        this.service,
        "aws4_request"
      ].join("/");
    };
    RequestSigner.prototype.defaultCredentials = function() {
      var env2 = process.env;
      return {
        accessKeyId: env2.AWS_ACCESS_KEY_ID || env2.AWS_ACCESS_KEY,
        secretAccessKey: env2.AWS_SECRET_ACCESS_KEY || env2.AWS_SECRET_KEY,
        sessionToken: env2.AWS_SESSION_TOKEN
      };
    };
    RequestSigner.prototype.parsePath = function() {
      var path4 = this.request.path || "/";
      if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path4)) {
        path4 = encodeURI(decodeURI(path4));
      }
      var queryIx = path4.indexOf("?"), query = null;
      if (queryIx >= 0) {
        query = querystring.parse(path4.slice(queryIx + 1));
        path4 = path4.slice(0, queryIx);
      }
      this.parsedPath = {
        path: path4,
        query
      };
    };
    RequestSigner.prototype.formatPath = function() {
      var path4 = this.parsedPath.path, query = this.parsedPath.query;
      if (!query) return path4;
      if (query[""] != null) delete query[""];
      return path4 + "?" + encodeRfc3986(querystring.stringify(query));
    };
    aws42.RequestSigner = RequestSigner;
    aws42.sign = function(request2, credentials) {
      return new RequestSigner(request2, credentials).sign();
    };
  }
});

// src/main/network/parse-header-strings.ts
function _getAwsAuthHeaders({
  authentication,
  url,
  method: method2,
  hostHeader,
  contentTypeHeader,
  body
}) {
  const { path: path4, host } = (0, import_node_url2.parse)(url);
  const onlyContentTypeHeader = contentTypeHeader ? { "content-type": contentTypeHeader } : {};
  const { service, region, accessKeyId, secretAccessKey, sessionToken } = authentication;
  const signature = import_aws4.default.sign(
    {
      service,
      region,
      body,
      method: method2,
      headers: onlyContentTypeHeader,
      path: path4 || void 0,
      // AWS uses host header for signing so prioritize that if the user set it manually
      host: hostHeader || host || void 0
    },
    { accessKeyId, secretAccessKey, sessionToken }
  );
  if (!signature.headers) {
    return [];
  }
  return Object.entries(signature.headers).filter(([name]) => name !== "content-type").map(([name, value]) => ({ name, value }));
}
var import_node_url2, import_aws4, import_clone6, DISABLE_HEADER_VALUE, parseHeaderStrings;
var init_parse_header_strings = __esm({
  "src/main/network/parse-header-strings.ts"() {
    "use strict";
    import_node_url2 = require("node:url");
    import_aws4 = __toESM(require_aws4());
    import_clone6 = __toESM(require_clone());
    init_constants();
    init_misc();
    init_multipart();
    DISABLE_HEADER_VALUE = "__Di$aB13d__";
    parseHeaderStrings = ({ req, finalUrl, requestBody, requestBodyPath, authHeader }) => {
      const headers = (0, import_clone6.default)(req.headers);
      const hasRequestBodyOrFilePath = requestBody !== void 0 || requestBodyPath;
      if (hasRequestBodyOrFilePath) {
        headers.push({ name: "Expect", value: DISABLE_HEADER_VALUE });
        headers.push({ name: "Transfer-Encoding", value: DISABLE_HEADER_VALUE });
      }
      const { authentication, method: method2 } = req;
      if (authentication && "type" in authentication) {
        const isDigest = authentication.type === "digest";
        const isNTLM = authentication.type === "ntlm";
        const isAWSIAM = authentication.type === "iam";
        const hasNoAuthorisationAndNotDisabledAWSBasicOrDigest = !hasAuthHeader(headers) && !authentication.disabled && !isAWSIAM && !isDigest && !isNTLM;
        if (hasNoAuthorisationAndNotDisabledAWSBasicOrDigest && authHeader) {
          headers.push(authHeader);
        }
        if (isAWSIAM) {
          const hostHeader = getHostHeader(headers)?.value;
          const contentTypeHeader = getContentTypeHeader(headers)?.value;
          _getAwsAuthHeaders({
            authentication,
            url: finalUrl,
            hostHeader,
            contentTypeHeader,
            body: requestBody,
            method: method2
          }).forEach((header) => headers.push(header));
        }
      }
      const isMultipartForm = req.body.mimeType === CONTENT_TYPE_FORM_DATA;
      if (isMultipartForm && requestBodyPath) {
        const contentTypeHeader = getContentTypeHeader(headers);
        if (contentTypeHeader) {
          contentTypeHeader.value = `multipart/form-data; boundary=${DEFAULT_BOUNDARY}`;
        } else {
          headers.push({ name: "Content-Type", value: `multipart/form-data; boundary=${DEFAULT_BOUNDARY}` });
        }
      }
      if (!hasAcceptHeader(headers)) {
        headers.push({ name: "Accept", value: "*/*" });
      }
      if (!hasAcceptEncodingHeader(headers)) {
        headers.push({ name: "Accept-Encoding", value: DISABLE_HEADER_VALUE });
      }
      if (!hasContentTypeHeader(headers)) {
        headers.push({ name: "content-type", value: DISABLE_HEADER_VALUE });
      }
      return headers.filter((h2) => h2.name).map(
        ({ name, value }) => value === "" ? `${name};` : value === DISABLE_HEADER_VALUE ? `${name}:` : `${name}: ${value}`
      );
    };
  }
});

// src/main/network/libcurl-promise.ts
var libcurl_promise_exports = {};
__export(libcurl_promise_exports, {
  _parseHeaders: () => _parseHeaders,
  cancelCurlRequest: () => cancelCurlRequest,
  createConfiguredCurlInstance: () => createConfiguredCurlInstance,
  curlRequest: () => curlRequest,
  getHttpVersion: () => getHttpVersion,
  setDefaultProtocol: () => setDefaultProtocol2
});
function _parseHeaders(buffer) {
  const redirects = buffer.toString("utf8").split(/\r?\n\r?\n|\r\r/g);
  return redirects.filter((r2) => !!r2.trim()).map((redirect) => {
    const [first, ...rest3] = redirect.split(/\r?\n|\r/g);
    const headers = rest3.map((l2) => l2.split(/:\s(.+)/)).filter(([n2]) => !!n2).map(([name, value = ""]) => ({ name, value }));
    const [version3, code, ...other] = first.split(/ +/g);
    return {
      version: version3,
      code: parseInt(code, 10),
      reason: other.join(" "),
      headers
    };
  });
}
async function waitForStreamToFinish(stream) {
  return new Promise((resolve) => {
    if (stream._readableState?.finished) {
      return resolve();
    }
    if (stream._writableState?.finished) {
      return resolve();
    }
    stream.on("close", () => {
      resolve();
    });
    stream.on("error", () => {
      resolve();
    });
  });
}
var import_node_fs4, import_node_path3, import_node_url3, import_node_libcurl, import_electron3, cancelCurlRequestHandlers, cancelCurlRequest, curlRequest, createConfiguredCurlInstance, closeReadFunction, parseRequestBody, parseRequestBodyPath, getHttpVersion, setDefaultProtocol2;
var init_libcurl_promise = __esm({
  "src/main/network/libcurl-promise.ts"() {
    "use strict";
    init_invariant();
    import_node_fs4 = __toESM(require("node:fs"));
    import_node_path3 = __toESM(require("node:path"));
    import_node_url3 = require("node:url");
    import_node_libcurl = __toESM(require_dist2());
    init_date_fns();
    import_electron3 = __toESM(require("electron"));
    init_esm_node();
    init_package();
    init_constants();
    init_misc();
    init_secure_read_file();
    init_multipart();
    init_parse_header_strings();
    invariant(process.type !== "renderer", "Native abstractions for Nodejs module unavailable in renderer");
    cancelCurlRequestHandlers = {};
    cancelCurlRequest = (id) => cancelCurlRequestHandlers[id]();
    curlRequest = (options) => new Promise(async (resolve) => {
      try {
        const userdataDirectory = process.env.INSOMNIA_DATA_PATH || import_electron3.default.app.getPath("userData");
        const responsesDir = import_node_path3.default.join(userdataDirectory, "responses");
        await import_node_fs4.default.promises.mkdir(responsesDir, { recursive: true });
        const responseBodyPath = import_node_path3.default.join(responsesDir, v4_default() + ".response");
        const {
          requestId,
          req,
          finalUrl,
          settings: settings2,
          certificates,
          caCertficatePath,
          socketPath,
          authHeader,
          noDecompress = false
        } = options;
        const caCert = caCertficatePath && await insecureReadFile(caCertficatePath);
        const { curl, debugTimeline } = createConfiguredCurlInstance({
          req,
          finalUrl,
          settings: settings2,
          caCert,
          certificates,
          socketPath,
          noDecompress
        });
        const { method: method2, body } = req;
        if (method2.toUpperCase() === "HEAD") {
          curl.setOpt(import_node_libcurl.Curl.option.NOBODY, 1);
        } else if (method2.toUpperCase() === "POST") {
          curl.setOpt(import_node_libcurl.Curl.option.POST, 1);
        } else {
          curl.setOpt(import_node_libcurl.Curl.option.CUSTOMREQUEST, method2);
        }
        const requestBodyPath = await parseRequestBodyPath(body);
        const requestBody = parseRequestBody({ body, method: method2 });
        const isMultipart = body.mimeType === CONTENT_TYPE_FORM_DATA && requestBodyPath;
        let requestFileDescriptor;
        const { authentication } = req;
        if (requestBodyPath) {
          const { isAllowed, securedPath } = isPathAllowed(requestBodyPath, settings2.dataFolders);
          invariant(isAllowed, cannotAccessPathError(securedPath));
          const isAWSIAM = "type" in authentication && authentication.type === "iam";
          invariant(!isAWSIAM, "AWS authentication not supported for provided body type");
          const { size: contentLength } = import_node_fs4.default.statSync(securedPath);
          curl.setOpt(import_node_libcurl.Curl.option.INFILESIZE_LARGE, contentLength);
          curl.setOpt(import_node_libcurl.Curl.option.UPLOAD, 1);
          curl.setOpt(import_node_libcurl.Curl.option.CUSTOMREQUEST, method2);
          requestFileDescriptor = import_node_fs4.default.openSync(securedPath, "r");
          curl.setOpt(import_node_libcurl.Curl.option.READDATA, requestFileDescriptor);
          curl.on("end", () => closeReadFunction(isMultipart, requestFileDescriptor, requestBodyPath));
          curl.on("error", () => closeReadFunction(isMultipart, requestFileDescriptor, requestBodyPath));
        } else if (requestBody !== void 0) {
          curl.setOpt(import_node_libcurl.Curl.option.POSTFIELDS, requestBody);
        }
        if (process.env.PLAYWRIGHT) {
          req.headers = [...req.headers, { name: "X-Mockbin-Test", value: "true" }];
        }
        const headerStrings = parseHeaderStrings({ req, requestBody, requestBodyPath, finalUrl, authHeader });
        curl.setOpt(import_node_libcurl.Curl.option.HTTPHEADER, headerStrings);
        const responseBodyWriteStream = import_node_fs4.default.createWriteStream(responseBodyPath);
        cancelCurlRequestHandlers[requestId] = () => {
          if (requestFileDescriptor && responseBodyPath) {
            closeReadFunction(isMultipart, requestFileDescriptor, requestBodyPath);
          }
          curl.isOpen && curl.close();
        };
        let responseBodyBytes = 0;
        curl.setOpt(import_node_libcurl.Curl.option.WRITEFUNCTION, (buffer) => {
          responseBodyBytes += buffer.length;
          responseBodyWriteStream.write(buffer);
          return buffer.length;
        });
        curl.setOpt(import_node_libcurl.Curl.option.DEBUGFUNCTION, (infoType, buffer) => {
          const isSSLData = infoType === import_node_libcurl.CurlInfoDebug.SslDataIn || infoType === import_node_libcurl.CurlInfoDebug.SslDataOut;
          const isEmpty2 = buffer.length === 0;
          const isAddCookie = infoType === import_node_libcurl.CurlInfoDebug.Text && buffer.toString("utf8").indexOf("Added cookie") === 0;
          if (isSSLData || isEmpty2 || isAddCookie) {
            return 0;
          }
          let name = import_node_libcurl.CurlInfoDebug[infoType];
          let timelineMessage;
          const isRequestData = infoType === import_node_libcurl.CurlInfoDebug.DataOut;
          if (isRequestData) {
            const isLessThan10KB = buffer.length / 1024 < (settings2.maxTimelineDataSizeKB || 1);
            timelineMessage = isLessThan10KB ? buffer.toString("utf8") : `(${describeByteSize(buffer.length)} hidden)`;
          }
          const isResponseData = infoType === import_node_libcurl.CurlInfoDebug.DataIn;
          if (isResponseData) {
            timelineMessage = `Received ${describeByteSize(buffer.length)} chunk`;
            name = "Text";
          }
          const value = timelineMessage || buffer.toString("utf8");
          debugTimeline.push({ name, value, timestamp: Date.now() });
          return 0;
        });
        curl.enable(import_node_libcurl.CurlFeature.Raw);
        curl.on("end", () => responseBodyWriteStream.end());
        curl.on("end", async (_1, _2, rawHeaders) => {
          const patch = {
            bytesContent: responseBodyBytes,
            bytesRead: curl.getInfo(import_node_libcurl.Curl.info.SIZE_DOWNLOAD),
            elapsedTime: curl.getInfo(import_node_libcurl.Curl.info.TOTAL_TIME) * 1e3,
            url: curl.getInfo(import_node_libcurl.Curl.info.EFFECTIVE_URL)
          };
          curl.isOpen && curl.close();
          await waitForStreamToFinish(responseBodyWriteStream);
          const headerResults = _parseHeaders(rawHeaders);
          resolve({ patch, debugTimeline, headerResults, responseBodyPath });
        });
        curl.on("error", () => responseBodyWriteStream.end());
        curl.on("error", async (err, code) => {
          const elapsedTime = curl.getInfo(import_node_libcurl.Curl.info.TOTAL_TIME) * 1e3;
          curl.isOpen && curl.close();
          await waitForStreamToFinish(responseBodyWriteStream);
          if (code === import_node_libcurl.CurlCode.CURLE_BAD_CONTENT_ENCODING && !noDecompress) {
            resolve(curlRequest({ ...options, noDecompress: true }));
            return;
          }
          let error = err + "";
          let statusMessage = "Error";
          if (code === import_node_libcurl.CurlCode.CURLE_ABORTED_BY_CALLBACK) {
            error = "Request aborted";
            statusMessage = "Abort";
          }
          const patch = {
            statusMessage,
            error: error || "Something went wrong inside libcurl",
            elapsedTime
          };
          resolve({ patch, debugTimeline, headerResults: [{ version: "", code: 0, reason: "", headers: [] }] });
        });
        curl.perform();
      } catch (error) {
        console.error(error);
        const patch = {
          statusMessage: "Error",
          error: error.toString() || "Something went wrong performing curl",
          elapsedTime: 0
        };
        resolve({ patch, debugTimeline: [], headerResults: [{ version: "", code: 0, reason: "", headers: [] }] });
      }
    });
    createConfiguredCurlInstance = ({
      req,
      finalUrl,
      settings: settings2,
      caCert,
      certificates,
      socketPath,
      noDecompress = false
    }) => {
      const debugTimeline = [];
      const curl = new import_node_libcurl.Curl();
      curl.setOpt(import_node_libcurl.Curl.option.URL, finalUrl);
      socketPath && curl.setOpt(import_node_libcurl.Curl.option.UNIX_SOCKET_PATH, socketPath);
      curl.setOpt(import_node_libcurl.Curl.option.VERBOSE, true);
      curl.setOpt(import_node_libcurl.Curl.option.NOPROGRESS, true);
      curl.setOpt(import_node_libcurl.Curl.option.ACCEPT_ENCODING, noDecompress ? null : "");
      if (caCert) {
        curl.setOpt(import_node_libcurl.Curl.option.CAINFO_BLOB, caCert);
      }
      curl.setOpt(import_node_libcurl.Curl.option.SSL_OPTIONS, import_node_libcurl.CurlSslOpt.NativeCa);
      certificates.forEach((validCert) => {
        const { passphrase, cert, key, pfx } = validCert;
        if (cert) {
          const { isAllowed, securedPath } = isPathAllowed(cert, settings2.dataFolders);
          invariant(isAllowed, cannotAccessPathError(securedPath));
          curl.setOpt(import_node_libcurl.Curl.option.SSLCERT, cert);
          curl.setOpt(import_node_libcurl.Curl.option.SSLCERTTYPE, "PEM");
          debugTimeline.push({ value: "Adding SSL PEM certificate", name: "Text", timestamp: Date.now() });
        }
        if (pfx) {
          const { isAllowed, securedPath } = isPathAllowed(pfx, settings2.dataFolders);
          invariant(isAllowed, cannotAccessPathError(securedPath));
          curl.setOpt(import_node_libcurl.Curl.option.SSLCERT, pfx);
          curl.setOpt(import_node_libcurl.Curl.option.SSLCERTTYPE, "P12");
          debugTimeline.push({ value: "Adding SSL P12 certificate", name: "Text", timestamp: Date.now() });
        }
        if (key) {
          const { isAllowed, securedPath } = isPathAllowed(key, settings2.dataFolders);
          invariant(isAllowed, cannotAccessPathError(securedPath));
          curl.setOpt(import_node_libcurl.Curl.option.SSLKEY, key);
          debugTimeline.push({ value: "Adding SSL KEY certificate", name: "Text", timestamp: Date.now() });
        }
        if (passphrase) {
          curl.setOpt(import_node_libcurl.Curl.option.KEYPASSWD, passphrase);
        }
      });
      const httpVersion = getHttpVersion(settings2.preferredHttpVersion);
      debugTimeline.push({ value: httpVersion.log, name: "Text", timestamp: Date.now() });
      if (httpVersion.curlHttpVersion) {
        curl.setOpt(import_node_libcurl.Curl.option.HTTP_VERSION, httpVersion.curlHttpVersion);
      }
      if (settings2.maxRedirects > 0) {
        curl.setOpt(import_node_libcurl.Curl.option.MAXREDIRS, settings2.maxRedirects);
      }
      if (!settings2.proxyEnabled) {
        curl.setOpt(import_node_libcurl.Curl.option.PROXY, "");
      } else {
        const { protocol } = (0, import_node_url3.parse)(req.url);
        const { httpProxy, httpsProxy, noProxy } = settings2;
        const proxyHost = protocol === "https:" ? httpsProxy : httpProxy;
        const proxy = proxyHost ? setDefaultProtocol2(proxyHost) : null;
        debugTimeline.push({ value: `Enable network proxy for ${protocol || ""}`, name: "Text", timestamp: Date.now() });
        if (proxy) {
          curl.setOpt(import_node_libcurl.Curl.option.PROXY, proxy);
          curl.setOpt(import_node_libcurl.Curl.option.PROXYAUTH, import_node_libcurl.CurlAuth.Any);
        }
        if (noProxy) {
          curl.setOpt(import_node_libcurl.Curl.option.NOPROXY, noProxy);
        }
      }
      const { timeout } = settings2;
      if (timeout <= 0) {
        curl.setOpt(import_node_libcurl.Curl.option.TIMEOUT_MS, 0);
      } else {
        curl.setOpt(import_node_libcurl.Curl.option.TIMEOUT_MS, timeout);
        debugTimeline.push({ value: `Enable timeout of ${timeout}ms`, name: "Text", timestamp: Date.now() });
      }
      const { validateSSL } = settings2;
      if (!validateSSL) {
        curl.setOpt(import_node_libcurl.Curl.option.SSL_VERIFYHOST, 0);
        curl.setOpt(import_node_libcurl.Curl.option.SSL_VERIFYPEER, 0);
      }
      debugTimeline.push({
        value: `${validateSSL ? "Enable" : "Disable"} SSL validation`,
        name: "Text",
        timestamp: Date.now()
      });
      const followRedirects = {
        off: false,
        on: true,
        global: settings2.followRedirects
      }[req.settingFollowRedirects] ?? true;
      curl.setOpt(import_node_libcurl.Curl.option.FOLLOWLOCATION, followRedirects);
      if (!req.settingRebuildPath) {
        curl.setOpt(import_node_libcurl.Curl.option.PATH_AS_IS, true);
      }
      if (req.settingSendCookies) {
        const { cookieJar: cookieJar2, cookies } = req;
        curl.setOpt(import_node_libcurl.Curl.option.COOKIEFILE, "");
        for (const { name, value } of cookies) {
          curl.setOpt(import_node_libcurl.Curl.option.COOKIE, `${name}=${value}`);
        }
        if (cookieJar2.cookies.length) {
          debugTimeline.push({
            value: `Enable cookie sending with jar of ${cookieJar2.cookies.length} cookie${cookieJar2.cookies.length !== 1 ? "s" : ""}`,
            name: "Text",
            timestamp: Date.now()
          });
          for (const cookie of cookieJar2.cookies) {
            const setCookie = [
              cookie.httpOnly ? `#HttpOnly_${cookie.domain}` : cookie.domain,
              cookie.hostOnly ? "FALSE" : "TRUE",
              cookie.path,
              cookie.secure ? "TRUE" : "FALSE",
              cookie.expires && isValid(new Date(cookie.expires)) ? Math.round(new Date(cookie.expires).getTime() / 1e3) : 0,
              cookie.key,
              cookie.value
            ].join("	");
            curl.setOpt(import_node_libcurl.Curl.option.COOKIELIST, setCookie);
          }
        }
      }
      const { headers, authentication } = req;
      const userAgent = headers.find((h2) => h2.name.toLowerCase() === "user-agent") || null;
      const userAgentOrFallback = typeof userAgent?.value === "string" ? userAgent?.value : "insomnia/" + version;
      curl.setOpt(import_node_libcurl.Curl.option.USERAGENT, userAgentOrFallback);
      if (req.suppressUserAgent) {
        curl.setOpt(import_node_libcurl.Curl.option.USERAGENT, "");
      }
      if (authentication && "type" in authentication) {
        const { username, password, disabled } = authentication;
        const isDigest = authentication.type === "digest";
        const isNLTM = authentication.type === "ntlm";
        const isDigestOrNLTM = isDigest || isNLTM;
        if (!hasAuthHeader(headers) && !disabled && isDigestOrNLTM) {
          isDigest && curl.setOpt(import_node_libcurl.Curl.option.HTTPAUTH, import_node_libcurl.CurlAuth.Digest);
          isNLTM && curl.setOpt(import_node_libcurl.Curl.option.HTTPAUTH, import_node_libcurl.CurlAuth.Ntlm);
          curl.setOpt(import_node_libcurl.Curl.option.USERNAME, username || "");
          curl.setOpt(import_node_libcurl.Curl.option.PASSWORD, password || "");
        }
        if (authentication.type === "netrc") {
          curl.setOpt(import_node_libcurl.Curl.option.NETRC, import_node_libcurl.CurlNetrc.Required);
        }
      }
      return { curl, debugTimeline };
    };
    closeReadFunction = (isMultipart, fd, path4) => {
      if (fd) {
        import_node_fs4.default.closeSync(fd);
      }
      if (isMultipart && path4) {
        import_node_fs4.default.unlink(path4, () => {
        });
      }
    };
    parseRequestBody = ({ body, method: method2 }) => {
      const isUrlEncodedForm = body.mimeType === CONTENT_TYPE_FORM_URLENCODED;
      const expectsBody = ["POST", "PUT", "PATCH"].includes(method2.toUpperCase());
      const hasMimetypeAndUpdateMethod = typeof body.mimeType === "string" || expectsBody;
      if (isUrlEncodedForm) {
        const urlSearchParams = new URLSearchParams();
        (body.params || []).map((p3) => urlSearchParams.append(p3.name, p3?.value || ""));
        return urlSearchParams.toString();
      }
      if (hasMimetypeAndUpdateMethod) {
        return body.text || "";
      }
      return void 0;
    };
    parseRequestBodyPath = async (body) => {
      const isMultipartForm = body.mimeType === CONTENT_TYPE_FORM_DATA;
      if (!isMultipartForm) {
        return body.fileName;
      }
      const { filePath } = await buildMultipart(body.params || []);
      return filePath;
    };
    getHttpVersion = (preferredHttpVersion) => {
      switch (preferredHttpVersion) {
        case "V1_0": {
          return { log: "Using HTTP 1.0", curlHttpVersion: import_node_libcurl.CurlHttpVersion.V1_0 };
        }
        case "V1_1": {
          return { log: "Using HTTP 1.1", curlHttpVersion: import_node_libcurl.CurlHttpVersion.V1_1 };
        }
        case "V2PriorKnowledge": {
          return { log: "Using HTTP/2 PriorKnowledge", curlHttpVersion: import_node_libcurl.CurlHttpVersion.V2PriorKnowledge };
        }
        case "V2_0": {
          return { log: "Using HTTP/2", curlHttpVersion: import_node_libcurl.CurlHttpVersion.V2_0 };
        }
        case "v3": {
          return { log: "Using HTTP/3", curlHttpVersion: import_node_libcurl.CurlHttpVersion.v3 };
        }
        case "default": {
          return { log: "Using default HTTP version" };
        }
        default: {
          return { log: `Unknown HTTP version specified ${preferredHttpVersion}` };
        }
      }
    };
    setDefaultProtocol2 = (url, defaultProto) => {
      const trimmedUrl = url.trim();
      defaultProto = defaultProto || "http:";
      if (!trimmedUrl) {
        return "";
      }
      if (!trimmedUrl.includes("://")) {
        return `${defaultProto}//${trimmedUrl}`;
      }
      return trimmedUrl;
    };
  }
});

// src/entry.hidden-window.ts
var entry_hidden_window_exports = {};
module.exports = __toCommonJS(entry_hidden_window_exports);

// ../../node_modules/@sentry/core/build/esm/debug-build.js
var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js
var GLOBAL_OBJ = globalThis;

// ../../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js
var DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry/core/build/esm/utils-hoist/version.js
var SDK_VERSION = "9.11.0";

// ../../node_modules/@sentry/core/build/esm/carrier.js
function getMainCarrier() {
  getSentryCarrier(GLOBAL_OBJ);
  return GLOBAL_OBJ;
}
function getSentryCarrier(carrier) {
  const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
  return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
}
function getGlobalSingleton(name, creator, obj = GLOBAL_OBJ) {
  const __SENTRY__ = obj.__SENTRY__ = obj.__SENTRY__ || {};
  const carrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
  return carrier[name] || (carrier[name] = creator());
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/logger.js
var PREFIX = "Sentry Logger ";
var CONSOLE_LEVELS = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
];
var originalConsoleMethods = {};
function consoleSandbox(callback) {
  if (!("console" in GLOBAL_OBJ)) {
    return callback();
  }
  const console2 = GLOBAL_OBJ.console;
  const wrappedFuncs = {};
  const wrappedLevels = Object.keys(originalConsoleMethods);
  wrappedLevels.forEach((level) => {
    const originalConsoleMethod = originalConsoleMethods[level];
    wrappedFuncs[level] = console2[level];
    console2[level] = originalConsoleMethod;
  });
  try {
    return callback();
  } finally {
    wrappedLevels.forEach((level) => {
      console2[level] = wrappedFuncs[level];
    });
  }
}
function makeLogger() {
  let enabled = false;
  const logger2 = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
    isEnabled: () => enabled
  };
  if (DEBUG_BUILD2) {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = () => void 0;
    });
  }
  return logger2;
}
var logger = getGlobalSingleton("logger", makeLogger);

// ../../node_modules/@sentry/core/build/esm/utils-hoist/stacktrace.js
var STACKTRACE_FRAME_LIMIT = 50;
var UNKNOWN_FUNCTION = "?";
var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
var STRIP_FRAME_REGEXP = /captureMessage|captureException/;
function createStackParser(...parsers) {
  const sortedParsers = parsers.sort((a2, b2) => a2[0] - b2[0]).map((p3) => p3[1]);
  return (stack, skipFirstLines = 0, framesToPop = 0) => {
    const frames = [];
    const lines = stack.split("\n");
    for (let i2 = skipFirstLines; i2 < lines.length; i2++) {
      const line = lines[i2];
      if (line.length > 1024) {
        continue;
      }
      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
      if (cleanedLine.match(/\S*Error: /)) {
        continue;
      }
      for (const parser of sortedParsers) {
        const frame = parser(cleanedLine);
        if (frame) {
          frames.push(frame);
          break;
        }
      }
      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {
        break;
      }
    }
    return stripSentryFramesAndReverse(frames.slice(framesToPop));
  };
}
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }
  const localStack = Array.from(stack);
  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
  }
  localStack.reverse();
  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
      localStack.pop();
    }
  }
  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
    ...frame,
    filename: frame.filename || getLastStackFrame(localStack).filename,
    function: frame.function || UNKNOWN_FUNCTION
  }));
}
function getLastStackFrame(arr) {
  return arr[arr.length - 1] || {};
}
var defaultFunctionName = "<anonymous>";
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== "function") {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e2) {
    return defaultFunctionName;
  }
}
function getFramesFromEvent(event) {
  const exception = event.exception;
  if (exception) {
    const frames = [];
    try {
      exception.values.forEach((value) => {
        if (value.stacktrace.frames) {
          frames.push(...value.stacktrace.frames);
        }
      });
      return frames;
    } catch (_oO) {
      return void 0;
    }
  }
  return void 0;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/instrument/handlers.js
var handlers = {};
var instrumented = {};
function addHandler(type, handler) {
  handlers[type] = handlers[type] || [];
  handlers[type].push(handler);
}
function maybeInstrument(type, instrumentFn) {
  if (!instrumented[type]) {
    instrumented[type] = true;
    try {
      instrumentFn();
    } catch (e2) {
      DEBUG_BUILD2 && logger.error(`Error while instrumenting ${type}`, e2);
    }
  }
}
function triggerHandlers(type, data) {
  const typeHandlers = type && handlers[type];
  if (!typeHandlers) {
    return;
  }
  for (const handler of typeHandlers) {
    try {
      handler(data);
    } catch (e2) {
      DEBUG_BUILD2 && logger.error(
        `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
        e2
      );
    }
  }
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/instrument/globalError.js
var _oldOnErrorHandler = null;
function addGlobalErrorInstrumentationHandler(handler) {
  const type = "error";
  addHandler(type, handler);
  maybeInstrument(type, instrumentError);
}
function instrumentError() {
  _oldOnErrorHandler = GLOBAL_OBJ.onerror;
  GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {
    const handlerData = {
      column,
      error,
      line,
      msg,
      url
    };
    triggerHandlers("error", handlerData);
    if (_oldOnErrorHandler) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/instrument/globalUnhandledRejection.js
var _oldOnUnhandledRejectionHandler = null;
function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
  const type = "unhandledrejection";
  addHandler(type, handler);
  maybeInstrument(type, instrumentUnhandledRejection);
}
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
  GLOBAL_OBJ.onunhandledrejection = function(e2) {
    const handlerData = e2;
    triggerHandlers("unhandledrejection", handlerData);
    if (_oldOnUnhandledRejectionHandler) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
  GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/time.js
var ONE_SECOND_IN_MS = 1e3;
function dateTimestampInSeconds() {
  return Date.now() / ONE_SECOND_IN_MS;
}
function createUnixTimestampInSecondsFunc() {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2?.now) {
    return dateTimestampInSeconds;
  }
  const approxStartingTimeOrigin = Date.now() - performance2.now();
  const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
  return () => {
    return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
  };
}
var timestampInSeconds = createUnixTimestampInSecondsFunc();

// ../../node_modules/@sentry/core/build/esm/utils-hoist/is.js
var objectToString = Object.prototype.toString;
function isError(wat) {
  switch (objectToString.call(wat)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isBuiltin(wat, className) {
  return objectToString.call(wat) === `[object ${className}]`;
}
function isErrorEvent(wat) {
  return isBuiltin(wat, "ErrorEvent");
}
function isDOMError(wat) {
  return isBuiltin(wat, "DOMError");
}
function isDOMException(wat) {
  return isBuiltin(wat, "DOMException");
}
function isString(wat) {
  return isBuiltin(wat, "String");
}
function isParameterizedString(wat) {
  return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
}
function isPrimitive(wat) {
  return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return isBuiltin(wat, "RegExp");
}
function isThenable(wat) {
  return Boolean(wat?.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e3) {
    return false;
  }
}
function isVueViewModel(wat) {
  return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/browser.js
var WINDOW = GLOBAL_OBJ;
var DEFAULT_MAX_STRING_LENGTH = 80;
function htmlTreeAsString(elem, options = {}) {
  if (!elem) {
    return "<unknown>";
  }
  try {
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    const out = [];
    let height = 0;
    let len = 0;
    const separator = " > ";
    const sepLength = separator.length;
    let nextStr;
    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
    const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch (_oO) {
    return "<unknown>";
  }
}
function _htmlElementAsString(el, keyAttrs) {
  const elem = el;
  const out = [];
  if (!elem?.tagName) {
    return "";
  }
  if (WINDOW.HTMLElement) {
    if (elem instanceof HTMLElement && elem.dataset) {
      if (elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
      if (elem.dataset["sentryElement"]) {
        return elem.dataset["sentryElement"];
      }
    }
  }
  out.push(elem.tagName.toLowerCase());
  const keyAttrPairs = keyAttrs?.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
  if (keyAttrPairs?.length) {
    keyAttrPairs.forEach((keyAttrPair) => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }
    const className = elem.className;
    if (className && isString(className)) {
      const classes = className.split(/\s+/);
      for (const c2 of classes) {
        out.push(`.${c2}`);
      }
    }
  }
  const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
  for (const k2 of allowedAttrs) {
    const attr = elem.getAttribute(k2);
    if (attr) {
      out.push(`[${k2}="${attr}"]`);
    }
  }
  return out.join("");
}
function getLocationHref() {
  try {
    return WINDOW.document.location.href;
  } catch (oO) {
    return "";
  }
}
function getComponentName(elem) {
  if (!WINDOW.HTMLElement) {
    return null;
  }
  let currentElem = elem;
  const MAX_TRAVERSE_HEIGHT = 5;
  for (let i2 = 0; i2 < MAX_TRAVERSE_HEIGHT; i2++) {
    if (!currentElem) {
      return null;
    }
    if (currentElem instanceof HTMLElement) {
      if (currentElem.dataset["sentryComponent"]) {
        return currentElem.dataset["sentryComponent"];
      }
      if (currentElem.dataset["sentryElement"]) {
        return currentElem.dataset["sentryElement"];
      }
    }
    currentElem = currentElem.parentNode;
  }
  return null;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/string.js
function truncate(str, max2 = 0) {
  if (typeof str !== "string" || max2 === 0) {
    return str;
  }
  return str.length <= max2 ? str : `${str.slice(0, max2)}...`;
}
function safeJoin(input, delimiter) {
  if (!Array.isArray(input)) {
    return "";
  }
  const output = [];
  for (let i2 = 0; i2 < input.length; i2++) {
    const value = input[i2];
    try {
      if (isVueViewModel(value)) {
        output.push("[VueViewModel]");
      } else {
        output.push(String(value));
      }
    } catch (e2) {
      output.push("[value cannot be serialized]");
    }
  }
  return output.join(delimiter);
}
function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
  if (!isString(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (isString(pattern)) {
    return requireExactStringMatch ? value === pattern : value.includes(pattern);
  }
  return false;
}
function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
  return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/object.js
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  const original = source[name];
  if (typeof original !== "function") {
    return;
  }
  const wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    markFunctionWrapped(wrapped, original);
  }
  try {
    source[name] = wrapped;
  } catch {
    DEBUG_BUILD2 && logger.log(`Failed to replace method "${name}" in object`, source);
  }
}
function addNonEnumerableProperty(obj, name, value) {
  try {
    Object.defineProperty(obj, name, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value,
      writable: true,
      configurable: true
    });
  } catch (o_O) {
    DEBUG_BUILD2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
  }
}
function markFunctionWrapped(wrapped, original) {
  try {
    const proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  } catch (o_O) {
  }
}
function getOriginalFunction(func) {
  return func.__sentry_original__;
}
function convertToPlainObject(value) {
  if (isError(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value)
    };
  } else if (isEvent(value)) {
    const newObj = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value)
    };
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      newObj.detail = value.detail;
    }
    return newObj;
  } else {
    return value;
  }
}
function serializeEventTarget(target) {
  try {
    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return "<unknown>";
  }
}
function getOwnProperties(obj) {
  if (typeof obj === "object" && obj !== null) {
    const extractedProps = {};
    for (const property2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property2)) {
        extractedProps[property2] = obj[property2];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  const keys2 = Object.keys(convertToPlainObject(exception));
  keys2.sort();
  const firstKey = keys2[0];
  if (!firstKey) {
    return "[object has no keys]";
  }
  if (firstKey.length >= maxLength) {
    return truncate(firstKey, maxLength);
  }
  for (let includedKeys = keys2.length; includedKeys > 0; includedKeys--) {
    const serialized = keys2.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys2.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/misc.js
function getCrypto() {
  const gbl = GLOBAL_OBJ;
  return gbl.crypto || gbl.msCrypto;
}
function uuid4(crypto3 = getCrypto()) {
  let getRandomByte = () => Math.random() * 16;
  try {
    if (crypto3?.randomUUID) {
      return crypto3.randomUUID().replace(/-/g, "");
    }
    if (crypto3?.getRandomValues) {
      getRandomByte = () => {
        const typedArray = new Uint8Array(1);
        crypto3.getRandomValues(typedArray);
        return typedArray[0];
      };
    }
  } catch (_2) {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (c2) => (
      // eslint-disable-next-line no-bitwise
      (c2 ^ (getRandomByte() & 15) >> c2 / 4).toString(16)
    )
  );
}
function getFirstException(event) {
  return event.exception?.values?.[0];
}
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }
  const firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || "<unknown>";
  }
  return eventId || "<unknown>";
}
function addExceptionTypeValue(event, value, type) {
  const exception = event.exception = event.exception || {};
  const values2 = exception.values = exception.values || [];
  const firstException = values2[0] = values2[0] || {};
  if (!firstException.value) {
    firstException.value = value || "";
  }
  if (!firstException.type) {
    firstException.type = type || "Error";
  }
}
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  const defaultMechanism = { type: "generic", handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
  if (newMechanism && "data" in newMechanism) {
    const mergedData = { ...currentMechanism?.data, ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}
function checkOrSetAlreadyCaught(exception) {
  if (isAlreadyCaptured(exception)) {
    return true;
  }
  try {
    addNonEnumerableProperty(exception, "__sentry_captured__", true);
  } catch (err) {
  }
  return false;
}
function isAlreadyCaptured(exception) {
  try {
    return exception.__sentry_captured__;
  } catch {
  }
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js
var States;
(function(States2) {
  const PENDING = 0;
  States2[States2["PENDING"] = PENDING] = "PENDING";
  const RESOLVED = 1;
  States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
  const REJECTED = 2;
  States2[States2["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));
function resolvedSyncPromise(value) {
  return new SyncPromise((resolve) => {
    resolve(value);
  });
}
function rejectedSyncPromise(reason) {
  return new SyncPromise((_2, reject2) => {
    reject2(reason);
  });
}
var SyncPromise = class _SyncPromise {
  constructor(executor) {
    this._state = States.PENDING;
    this._handlers = [];
    this._runExecutor(executor);
  }
  /** @inheritdoc */
  then(onfulfilled, onrejected) {
    return new _SyncPromise((resolve, reject2) => {
      this._handlers.push([
        false,
        (result2) => {
          if (!onfulfilled) {
            resolve(result2);
          } else {
            try {
              resolve(onfulfilled(result2));
            } catch (e2) {
              reject2(e2);
            }
          }
        },
        (reason) => {
          if (!onrejected) {
            reject2(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e2) {
              reject2(e2);
            }
          }
        }
      ]);
      this._executeHandlers();
    });
  }
  /** @inheritdoc */
  catch(onrejected) {
    return this.then((val) => val, onrejected);
  }
  /** @inheritdoc */
  finally(onfinally) {
    return new _SyncPromise((resolve, reject2) => {
      let val;
      let isRejected;
      return this.then(
        (value) => {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        },
        (reason) => {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }
      ).then(() => {
        if (isRejected) {
          reject2(val);
          return;
        }
        resolve(val);
      });
    });
  }
  /** Excute the resolve/reject handlers. */
  _executeHandlers() {
    if (this._state === States.PENDING) {
      return;
    }
    const cachedHandlers = this._handlers.slice();
    this._handlers = [];
    cachedHandlers.forEach((handler) => {
      if (handler[0]) {
        return;
      }
      if (this._state === States.RESOLVED) {
        handler[1](this._value);
      }
      if (this._state === States.REJECTED) {
        handler[2](this._value);
      }
      handler[0] = true;
    });
  }
  /** Run the executor for the SyncPromise. */
  _runExecutor(executor) {
    const setResult = (state, value) => {
      if (this._state !== States.PENDING) {
        return;
      }
      if (isThenable(value)) {
        void value.then(resolve, reject2);
        return;
      }
      this._state = state;
      this._value = value;
      this._executeHandlers();
    };
    const resolve = (value) => {
      setResult(States.RESOLVED, value);
    };
    const reject2 = (reason) => {
      setResult(States.REJECTED, reason);
    };
    try {
      executor(resolve, reject2);
    } catch (e2) {
      reject2(e2);
    }
  }
};

// ../../node_modules/@sentry/core/build/esm/session.js
function makeSession(context) {
  const startingTime = timestampInSeconds();
  const session = {
    sid: uuid4(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session)
  };
  if (context) {
    updateSession(session, context);
  }
  return session;
}
function updateSession(session, context = {}) {
  if (context.user) {
    if (!session.ipAddress && context.user.ip_address) {
      session.ipAddress = context.user.ip_address;
    }
    if (!session.did && !context.did) {
      session.did = context.user.id || context.user.email || context.user.username;
    }
  }
  session.timestamp = context.timestamp || timestampInSeconds();
  if (context.abnormal_mechanism) {
    session.abnormal_mechanism = context.abnormal_mechanism;
  }
  if (context.ignoreDuration) {
    session.ignoreDuration = context.ignoreDuration;
  }
  if (context.sid) {
    session.sid = context.sid.length === 32 ? context.sid : uuid4();
  }
  if (context.init !== void 0) {
    session.init = context.init;
  }
  if (!session.did && context.did) {
    session.did = `${context.did}`;
  }
  if (typeof context.started === "number") {
    session.started = context.started;
  }
  if (session.ignoreDuration) {
    session.duration = void 0;
  } else if (typeof context.duration === "number") {
    session.duration = context.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context.release) {
    session.release = context.release;
  }
  if (context.environment) {
    session.environment = context.environment;
  }
  if (!session.ipAddress && context.ipAddress) {
    session.ipAddress = context.ipAddress;
  }
  if (!session.userAgent && context.userAgent) {
    session.userAgent = context.userAgent;
  }
  if (typeof context.errors === "number") {
    session.errors = context.errors;
  }
  if (context.status) {
    session.status = context.status;
  }
}
function closeSession(session, status) {
  let context = {};
  if (status) {
    context = { status };
  } else if (session.status === "ok") {
    context = { status: "exited" };
  }
  updateSession(session, context);
}
function sessionToJSON(session) {
  return {
    sid: `${session.sid}`,
    init: session.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(session.started * 1e3).toISOString(),
    timestamp: new Date(session.timestamp * 1e3).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
    duration: session.duration,
    abnormal_mechanism: session.abnormal_mechanism,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent
    }
  };
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js
function generateTraceId() {
  return uuid4();
}
function generateSpanId() {
  return uuid4().substring(16);
}

// ../../node_modules/@sentry/core/build/esm/utils/merge.js
function merge(initialObj, mergeObj, levels = 2) {
  if (!mergeObj || typeof mergeObj !== "object" || levels <= 0) {
    return mergeObj;
  }
  if (initialObj && Object.keys(mergeObj).length === 0) {
    return initialObj;
  }
  const output = { ...initialObj };
  for (const key in mergeObj) {
    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {
      output[key] = merge(output[key], mergeObj[key], levels - 1);
    }
  }
  return output;
}

// ../../node_modules/@sentry/core/build/esm/utils/spanOnScope.js
var SCOPE_SPAN_FIELD = "_sentrySpan";
function _setSpanForScope(scope, span) {
  if (span) {
    addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);
  } else {
    delete scope[SCOPE_SPAN_FIELD];
  }
}
function _getSpanForScope(scope) {
  return scope[SCOPE_SPAN_FIELD];
}

// ../../node_modules/@sentry/core/build/esm/scope.js
var DEFAULT_MAX_BREADCRUMBS = 100;
var Scope = class _Scope {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
    this._propagationContext = {
      traceId: generateTraceId(),
      sampleRand: Math.random()
    };
  }
  /**
   * Clone all data from this scope into a new scope.
   */
  clone() {
    const newScope = new _Scope();
    newScope._breadcrumbs = [...this._breadcrumbs];
    newScope._tags = { ...this._tags };
    newScope._extra = { ...this._extra };
    newScope._contexts = { ...this._contexts };
    if (this._contexts.flags) {
      newScope._contexts.flags = {
        values: [...this._contexts.flags.values]
      };
    }
    newScope._user = this._user;
    newScope._level = this._level;
    newScope._session = this._session;
    newScope._transactionName = this._transactionName;
    newScope._fingerprint = this._fingerprint;
    newScope._eventProcessors = [...this._eventProcessors];
    newScope._attachments = [...this._attachments];
    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
    newScope._propagationContext = { ...this._propagationContext };
    newScope._client = this._client;
    newScope._lastEventId = this._lastEventId;
    _setSpanForScope(newScope, _getSpanForScope(this));
    return newScope;
  }
  /**
   * Update the client assigned to this scope.
   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,
   * as well as manually created scopes.
   */
  setClient(client) {
    this._client = client;
  }
  /**
   * Set the ID of the last captured error event.
   * This is generally only captured on the isolation scope.
   */
  setLastEventId(lastEventId2) {
    this._lastEventId = lastEventId2;
  }
  /**
   * Get the client assigned to this scope.
   */
  getClient() {
    return this._client;
  }
  /**
   * Get the ID of the last captured error event.
   * This is generally only available on the isolation scope.
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }
  /**
   * Add an event processor that will be called before an event is sent.
   */
  addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }
  /**
   * Set the user for this scope.
   * Set to `null` to unset the user.
   */
  setUser(user) {
    this._user = user || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    };
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Get the user from this scope.
   */
  getUser() {
    return this._user;
  }
  /**
   * Set an object that will be merged into existing tags on the scope,
   * and will be sent as tags data with the event.
   */
  setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set a single tag that will be sent as tags data with the event.
   */
  setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set an object that will be merged into existing extra on the scope,
   * and will be sent as extra data with the event.
   */
  setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set a single key:value extra entry that will be sent as extra data with the event.
   */
  setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the fingerprint on the scope to send with the events.
   * @param {string[]} fingerprint Fingerprint to group events in Sentry.
   */
  setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the level on the scope for future events.
   */
  setLevel(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the transaction name on the scope so that the name of e.g. taken server route or
   * the page location is attached to future events.
   *
   * IMPORTANT: Calling this function does NOT change the name of the currently active
   * root span. If you want to change the name of the active root span, use
   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.
   *
   * By default, the SDK updates the scope's transaction name automatically on sensible
   * occasions, such as a page navigation or when handling a new request on the server.
   */
  setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets context data with the given name.
   * Data passed as context will be normalized. You can also pass `null` to unset the context.
   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.
   */
  setContext(key, context) {
    if (context === null) {
      delete this._contexts[key];
    } else {
      this._contexts[key] = context;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set the session for the scope.
   */
  setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Get the session from the scope.
   */
  getSession() {
    return this._session;
  }
  /**
   * Updates the scope with provided data. Can work in three variations:
   * - plain object containing updatable attributes
   * - Scope instance that'll extract the attributes from
   * - callback function that'll receive the current scope as an argument and allow for modifications
   */
  update(captureContext) {
    if (!captureContext) {
      return this;
    }
    const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
    const scopeInstance = scopeToMerge instanceof _Scope ? scopeToMerge.getScopeData() : isPlainObject(scopeToMerge) ? captureContext : void 0;
    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
    this._tags = { ...this._tags, ...tags };
    this._extra = { ...this._extra, ...extra };
    this._contexts = { ...this._contexts, ...contexts };
    if (user && Object.keys(user).length) {
      this._user = user;
    }
    if (level) {
      this._level = level;
    }
    if (fingerprint.length) {
      this._fingerprint = fingerprint;
    }
    if (propagationContext) {
      this._propagationContext = propagationContext;
    }
    return this;
  }
  /**
   * Clears the current scope and resets its properties.
   * Note: The client will not be cleared.
   */
  clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = void 0;
    this._transactionName = void 0;
    this._fingerprint = void 0;
    this._session = void 0;
    _setSpanForScope(this, void 0);
    this._attachments = [];
    this.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Adds a breadcrumb to the scope.
   * By default, the last 100 breadcrumbs are kept.
   */
  addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb,
      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory
      message: breadcrumb.message ? truncate(breadcrumb.message, 2048) : breadcrumb.message
    };
    this._breadcrumbs.push(mergedBreadcrumb);
    if (this._breadcrumbs.length > maxCrumbs) {
      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);
      this._client?.recordDroppedEvent("buffer_overflow", "log_item");
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Get the last breadcrumb of the scope.
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * Clear all breadcrumbs from the scope.
   */
  clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Add an attachment to the scope.
   */
  addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }
  /**
   * Clear all attachments from the scope.
   */
  clearAttachments() {
    this._attachments = [];
    return this;
  }
  /**
   * Get the data of this scope, which should be applied to an event during processing.
   */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: _getSpanForScope(this)
    };
  }
  /**
   * Add data which will be accessible during event processing but won't get sent to Sentry.
   */
  setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);
    return this;
  }
  /**
   * Add propagation context to the scope, used for distributed tracing
   */
  setPropagationContext(context) {
    this._propagationContext = context;
    return this;
  }
  /**
   * Get propagation context from the scope, used for distributed tracing
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * Capture an exception for this scope.
   *
   * @returns {string} The id of the captured Sentry event.
   */
  captureException(exception, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture exception!");
      return eventId;
    }
    const syntheticException = new Error("Sentry syntheticException");
    this._client.captureException(
      exception,
      {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * Capture a message for this scope.
   *
   * @returns {string} The id of the captured message.
   */
  captureMessage(message, level, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture message!");
      return eventId;
    }
    const syntheticException = new Error(message);
    this._client.captureMessage(
      message,
      level,
      {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * Capture a Sentry event for this scope.
   *
   * @returns {string} The id of the captured event.
   */
  captureEvent(event, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture event!");
      return eventId;
    }
    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
    return eventId;
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach((callback) => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }
};

// ../../node_modules/@sentry/core/build/esm/defaultScopes.js
function getDefaultCurrentScope() {
  return getGlobalSingleton("defaultCurrentScope", () => new Scope());
}
function getDefaultIsolationScope() {
  return getGlobalSingleton("defaultIsolationScope", () => new Scope());
}

// ../../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js
var AsyncContextStack = class {
  constructor(scope, isolationScope) {
    let assignedScope;
    if (!scope) {
      assignedScope = new Scope();
    } else {
      assignedScope = scope;
    }
    let assignedIsolationScope;
    if (!isolationScope) {
      assignedIsolationScope = new Scope();
    } else {
      assignedIsolationScope = isolationScope;
    }
    this._stack = [{ scope: assignedScope }];
    this._isolationScope = assignedIsolationScope;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(callback) {
    const scope = this._pushScope();
    let maybePromiseResult;
    try {
      maybePromiseResult = callback(scope);
    } catch (e2) {
      this._popScope();
      throw e2;
    }
    if (isThenable(maybePromiseResult)) {
      return maybePromiseResult.then(
        (res) => {
          this._popScope();
          return res;
        },
        (e2) => {
          this._popScope();
          throw e2;
        }
      );
    }
    this._popScope();
    return maybePromiseResult;
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const scope = this.getScope().clone();
    this._stack.push({
      client: this.getClient(),
      scope
    });
    return scope;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    if (this._stack.length <= 1) return false;
    return !!this._stack.pop();
  }
};
function getAsyncContextStack() {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
}
function withScope(callback) {
  return getAsyncContextStack().withScope(callback);
}
function withSetScope(scope, callback) {
  const stack = getAsyncContextStack();
  return stack.withScope(() => {
    stack.getStackTop().scope = scope;
    return callback(scope);
  });
}
function withIsolationScope(callback) {
  return getAsyncContextStack().withScope(() => {
    return callback(getAsyncContextStack().getIsolationScope());
  });
}
function getStackAsyncContextStrategy() {
  return {
    withIsolationScope,
    withScope,
    withSetScope,
    withSetIsolationScope: (_isolationScope, callback) => {
      return withIsolationScope(callback);
    },
    getCurrentScope: () => getAsyncContextStack().getScope(),
    getIsolationScope: () => getAsyncContextStack().getIsolationScope()
  };
}

// ../../node_modules/@sentry/core/build/esm/asyncContext/index.js
function getAsyncContextStrategy(carrier) {
  const sentry = getSentryCarrier(carrier);
  if (sentry.acs) {
    return sentry.acs;
  }
  return getStackAsyncContextStrategy();
}

// ../../node_modules/@sentry/core/build/esm/currentScopes.js
function getCurrentScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getCurrentScope();
}
function getIsolationScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getIsolationScope();
}
function getGlobalScope() {
  return getGlobalSingleton("globalScope", () => new Scope());
}
function withScope2(...rest3) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest3.length === 2) {
    const [scope, callback] = rest3;
    if (!scope) {
      return acs.withScope(callback);
    }
    return acs.withSetScope(scope, callback);
  }
  return acs.withScope(rest3[0]);
}
function getClient() {
  return getCurrentScope().getClient();
}
function getTraceContextFromScope(scope) {
  const propagationContext = scope.getPropagationContext();
  const { traceId, parentSpanId, propagationSpanId } = propagationContext;
  const traceContext = {
    trace_id: traceId,
    span_id: propagationSpanId || generateSpanId()
  };
  if (parentSpanId) {
    traceContext.parent_span_id = parentSpanId;
  }
  return traceContext;
}

// ../../node_modules/@sentry/core/build/esm/semanticAttributes.js
var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
var SEMANTIC_ATTRIBUTE_PROFILE_ID = "sentry.profile_id";
var SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = "sentry.exclusive_time";

// ../../node_modules/@sentry/core/build/esm/tracing/spanstatus.js
var SPAN_STATUS_UNSET = 0;
var SPAN_STATUS_OK = 1;

// ../../node_modules/@sentry/core/build/esm/tracing/utils.js
var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
function getCapturedScopesOnSpan(span) {
  return {
    scope: span[SCOPE_ON_START_SPAN_FIELD],
    isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
  };
}

// ../../node_modules/@sentry/core/build/esm/utils/parseSampleRate.js
function parseSampleRate(sampleRate) {
  if (typeof sampleRate === "boolean") {
    return Number(sampleRate);
  }
  const rate = typeof sampleRate === "string" ? parseFloat(sampleRate) : sampleRate;
  if (typeof rate !== "number" || isNaN(rate) || rate < 0 || rate > 1) {
    return void 0;
  }
  return rate;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/baggage.js
var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
function baggageHeaderToDynamicSamplingContext(baggageHeader) {
  const baggageObject = parseBaggageHeader(baggageHeader);
  if (!baggageObject) {
    return void 0;
  }
  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
      acc[nonPrefixedKey] = value;
    }
    return acc;
  }, {});
  if (Object.keys(dynamicSamplingContext).length > 0) {
    return dynamicSamplingContext;
  } else {
    return void 0;
  }
}
function parseBaggageHeader(baggageHeader) {
  if (!baggageHeader || !isString(baggageHeader) && !Array.isArray(baggageHeader)) {
    return void 0;
  }
  if (Array.isArray(baggageHeader)) {
    return baggageHeader.reduce((acc, curr) => {
      const currBaggageObject = baggageHeaderToObject(curr);
      Object.entries(currBaggageObject).forEach(([key, value]) => {
        acc[key] = value;
      });
      return acc;
    }, {});
  }
  return baggageHeaderToObject(baggageHeader);
}
function baggageHeaderToObject(baggageHeader) {
  return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {});
}

// ../../node_modules/@sentry/core/build/esm/utils/spanUtils.js
var TRACE_FLAG_SAMPLED = 1;
var hasShownSpanDropWarning = false;
function spanToTraceContext(span) {
  const { spanId, traceId: trace_id, isRemote } = span.spanContext();
  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;
  const scope = getCapturedScopesOnSpan(span).scope;
  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;
  return {
    parent_span_id,
    span_id,
    trace_id
  };
}
function convertSpanLinksForEnvelope(links) {
  if (links && links.length > 0) {
    return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({
      span_id: spanId,
      trace_id: traceId,
      sampled: traceFlags === TRACE_FLAG_SAMPLED,
      attributes,
      ...restContext
    }));
  } else {
    return void 0;
  }
}
function spanTimeInputToSeconds(input) {
  if (typeof input === "number") {
    return ensureTimestampInSeconds(input);
  }
  if (Array.isArray(input)) {
    return input[0] + input[1] / 1e9;
  }
  if (input instanceof Date) {
    return ensureTimestampInSeconds(input.getTime());
  }
  return timestampInSeconds();
}
function ensureTimestampInSeconds(timestamp) {
  const isMs = timestamp > 9999999999;
  return isMs ? timestamp / 1e3 : timestamp;
}
function spanToJSON(span) {
  if (spanIsSentrySpan(span)) {
    return span.getSpanJSON();
  }
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
    const { attributes, startTime, name, endTime, parentSpanId, status, links } = span;
    return {
      span_id,
      trace_id,
      data: attributes,
      description: name,
      parent_span_id: parentSpanId,
      start_timestamp: spanTimeInputToSeconds(startTime),
      // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
      timestamp: spanTimeInputToSeconds(endTime) || void 0,
      status: getStatusMessage(status),
      op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
      origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
      links: convertSpanLinksForEnvelope(links)
    };
  }
  return {
    span_id,
    trace_id,
    start_timestamp: 0,
    data: {}
  };
}
function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
  const castSpan = span;
  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
}
function spanIsSentrySpan(span) {
  return typeof span.getSpanJSON === "function";
}
function spanIsSampled(span) {
  const { traceFlags } = span.spanContext();
  return traceFlags === TRACE_FLAG_SAMPLED;
}
function getStatusMessage(status) {
  if (!status || status.code === SPAN_STATUS_UNSET) {
    return void 0;
  }
  if (status.code === SPAN_STATUS_OK) {
    return "ok";
  }
  return status.message || "unknown_error";
}
var ROOT_SPAN_FIELD = "_sentryRootSpan";
function getRootSpan(span) {
  return span[ROOT_SPAN_FIELD] || span;
}
function showSpanDropWarning() {
  if (!hasShownSpanDropWarning) {
    consoleSandbox(() => {
      console.warn(
        "[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly."
      );
    });
    hasShownSpanDropWarning = true;
  }
}

// ../../node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js
function hasSpansEnabled(maybeOptions) {
  if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
    return false;
  }
  const options = maybeOptions || getClient()?.getOptions();
  return !!options && // Note: This check is `!= null`, meaning "nullish". `0` is not "nullish", `undefined` and `null` are. (This comment was brought to you by 15 minutes of questioning life)
  (options.tracesSampleRate != null || !!options.tracesSampler);
}

// ../../node_modules/@sentry/core/build/esm/constants.js
var DEFAULT_ENVIRONMENT = "production";

// ../../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js
var FROZEN_DSC_FIELD = "_frozenDsc";
function getDynamicSamplingContextFromClient(trace_id, client) {
  const options = client.getOptions();
  const { publicKey: public_key } = client.getDsn() || {};
  const dsc = {
    environment: options.environment || DEFAULT_ENVIRONMENT,
    release: options.release,
    public_key,
    trace_id
  };
  client.emit("createDsc", dsc);
  return dsc;
}
function getDynamicSamplingContextFromScope(client, scope) {
  const propagationContext = scope.getPropagationContext();
  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);
}
function getDynamicSamplingContextFromSpan(span) {
  const client = getClient();
  if (!client) {
    return {};
  }
  const rootSpan = getRootSpan(span);
  const rootSpanJson = spanToJSON(rootSpan);
  const rootSpanAttributes = rootSpanJson.data;
  const traceState = rootSpan.spanContext().traceState;
  const rootSpanSampleRate = traceState?.get("sentry.sample_rate") ?? rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  function applyLocalSampleRateToDsc(dsc2) {
    if (typeof rootSpanSampleRate === "number" || typeof rootSpanSampleRate === "string") {
      dsc2.sample_rate = `${rootSpanSampleRate}`;
    }
    return dsc2;
  }
  const frozenDsc = rootSpan[FROZEN_DSC_FIELD];
  if (frozenDsc) {
    return applyLocalSampleRateToDsc(frozenDsc);
  }
  const traceStateDsc = traceState?.get("sentry.dsc");
  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);
  if (dscOnTraceState) {
    return applyLocalSampleRateToDsc(dscOnTraceState);
  }
  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);
  const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  const name = rootSpanJson.description;
  if (source !== "url" && name) {
    dsc.transaction = name;
  }
  if (hasSpansEnabled()) {
    dsc.sampled = String(spanIsSampled(rootSpan));
    dsc.sample_rand = // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans
    // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span
    traceState?.get("sentry.sample_rand") ?? // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)
    getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();
  }
  applyLocalSampleRateToDsc(dsc);
  client.emit("createDsc", dsc, rootSpan);
  return dsc;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/dsn.js
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
  return protocol === "http" || protocol === "https";
}
function dsnToString(dsn, withPassword = false) {
  const { host, path: path4, pass, port, projectId, protocol, publicKey } = dsn;
  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path4 ? `${path4}/` : path4}${projectId}`;
}
function dsnFromString(str) {
  const match = DSN_REGEX.exec(str);
  if (!match) {
    consoleSandbox(() => {
      console.error(`Invalid Sentry Dsn: ${str}`);
    });
    return void 0;
  }
  const [protocol, publicKey, pass = "", host = "", port = "", lastPath = ""] = match.slice(1);
  let path4 = "";
  let projectId = lastPath;
  const split2 = projectId.split("/");
  if (split2.length > 1) {
    path4 = split2.slice(0, -1).join("/");
    projectId = split2.pop();
  }
  if (projectId) {
    const projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }
  return dsnFromComponents({ host, pass, path: path4, projectId, port, protocol, publicKey });
}
function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || "",
    pass: components.pass || "",
    host: components.host,
    port: components.port || "",
    path: components.path || "",
    projectId: components.projectId
  };
}
function validateDsn(dsn) {
  if (!DEBUG_BUILD2) {
    return true;
  }
  const { port, projectId, protocol } = dsn;
  const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
  const hasMissingRequiredComponent = requiredComponents.find((component) => {
    if (!dsn[component]) {
      logger.error(`Invalid Sentry Dsn: ${component} missing`);
      return true;
    }
    return false;
  });
  if (hasMissingRequiredComponent) {
    return false;
  }
  if (!projectId.match(/^\d+$/)) {
    logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
    return false;
  }
  if (!isValidProtocol(protocol)) {
    logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
    return false;
  }
  if (port && isNaN(parseInt(port, 10))) {
    logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
    return false;
  }
  return true;
}
function makeDsn(from) {
  const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
  if (!components || !validateDsn(components)) {
    return void 0;
  }
  return components;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/normalize.js
function normalize(input, depth = 100, maxProperties = Infinity) {
  try {
    return visit("", input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}
function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
  const normalized = normalize(object, depth);
  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return normalized;
}
function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
  const [memoize2, unmemoize] = memo;
  if (value == null || // this matches null and undefined -> eqeq not eqeqeq
  ["boolean", "string"].includes(typeof value) || typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  const stringified = stringifyValue(key, value);
  if (!stringified.startsWith("[object ")) {
    return stringified;
  }
  if (value["__sentry_skip_normalization__"]) {
    return value;
  }
  const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
  if (remainingDepth === 0) {
    return stringified.replace("object ", "");
  }
  if (memoize2(value)) {
    return "[Circular ~]";
  }
  const valueWithToJSON = value;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
    try {
      const jsonValue = valueWithToJSON.toJSON();
      return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
    } catch (err) {
    }
  }
  const normalized = Array.isArray(value) ? [] : {};
  let numAdded = 0;
  const visitable = convertToPlainObject(value);
  for (const visitKey in visitable) {
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }
    if (numAdded >= maxProperties) {
      normalized[visitKey] = "[MaxProperties ~]";
      break;
    }
    const visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
    numAdded++;
  }
  unmemoize(value);
  return normalized;
}
function stringifyValue(key, value) {
  try {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (isVueViewModel(value)) {
      return "[VueViewModel]";
    }
    if (isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && !Number.isFinite(value)) {
      return `[${value}]`;
    }
    if (typeof value === "function") {
      return `[Function: ${getFunctionName(value)}]`;
    }
    if (typeof value === "symbol") {
      return `[${String(value)}]`;
    }
    if (typeof value === "bigint") {
      return `[BigInt: ${String(value)}]`;
    }
    const objName = getConstructorName(value);
    if (/^HTML(\w*)Element$/.test(objName)) {
      return `[HTMLElement: ${objName}]`;
    }
    return `[object ${objName}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}
function getConstructorName(value) {
  const prototype = Object.getPrototypeOf(value);
  return prototype?.constructor ? prototype.constructor.name : "null prototype";
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}
function memoBuilder() {
  const inner = /* @__PURE__ */ new WeakSet();
  function memoize2(obj) {
    if (inner.has(obj)) {
      return true;
    }
    inner.add(obj);
    return false;
  }
  function unmemoize(obj) {
    inner.delete(obj);
  }
  return [memoize2, unmemoize];
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/envelope.js
function createEnvelope(headers, items = []) {
  return [headers, items];
}
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]];
}
function forEachEnvelopeItem(envelope, callback) {
  const envelopeItems = envelope[1];
  for (const envelopeItem of envelopeItems) {
    const envelopeItemType = envelopeItem[0].type;
    const result2 = callback(envelopeItem, envelopeItemType);
    if (result2) {
      return true;
    }
  }
  return false;
}
function encodeUTF8(input) {
  const carrier = getSentryCarrier(GLOBAL_OBJ);
  return carrier.encodePolyfill ? carrier.encodePolyfill(input) : new TextEncoder().encode(input);
}
function serializeEnvelope(envelope) {
  const [envHeaders, items] = envelope;
  let parts = JSON.stringify(envHeaders);
  function append(next) {
    if (typeof parts === "string") {
      parts = typeof next === "string" ? parts + next : [encodeUTF8(parts), next];
    } else {
      parts.push(typeof next === "string" ? encodeUTF8(next) : next);
    }
  }
  for (const item of items) {
    const [itemHeaders, payload] = item;
    append(`
${JSON.stringify(itemHeaders)}
`);
    if (typeof payload === "string" || payload instanceof Uint8Array) {
      append(payload);
    } else {
      let stringifiedPayload;
      try {
        stringifiedPayload = JSON.stringify(payload);
      } catch (e2) {
        stringifiedPayload = JSON.stringify(normalize(payload));
      }
      append(stringifiedPayload);
    }
  }
  return typeof parts === "string" ? parts : concatBuffers(parts);
}
function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
  const merged = new Uint8Array(totalLength);
  let offset = 0;
  for (const buffer of buffers) {
    merged.set(buffer, offset);
    offset += buffer.length;
  }
  return merged;
}
function createAttachmentEnvelopeItem(attachment) {
  const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data) : attachment.data;
  return [
    {
      type: "attachment",
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType
    },
    buffer
  ];
}
var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  otel_log: "log_item"
};
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}
function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
  if (!metadataOrEvent?.sdk) {
    return;
  }
  const { name, version: version3 } = metadataOrEvent.sdk;
  return { name, version: version3 };
}
function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
  const dynamicSamplingContext = event.sdkProcessingMetadata?.dynamicSamplingContext;
  return {
    event_id: event.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
    ...dynamicSamplingContext && {
      trace: dynamicSamplingContext
    }
  };
}

// ../../node_modules/@sentry/core/build/esm/envelope.js
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
  event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
  return event;
}
function createSessionEnvelope(session, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const envelopeHeaders = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
  return createEnvelope(envelopeHeaders, [envelopeItem]);
}
function createEventEnvelope(event, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
  enhanceEventWithSdkInfo(event, metadata?.sdk);
  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
  delete event.sdkProcessingMetadata;
  const eventItem = [{ type: eventType }, event];
  return createEnvelope(envelopeHeaders, [eventItem]);
}

// ../../node_modules/@sentry/core/build/esm/eventProcessors.js
function notifyEventProcessors(processors, event, hint, index = 0) {
  return new SyncPromise((resolve, reject2) => {
    const processor = processors[index];
    if (event === null || typeof processor !== "function") {
      resolve(event);
    } else {
      const result2 = processor({ ...event }, hint);
      DEBUG_BUILD && processor.id && result2 === null && logger.log(`Event processor "${processor.id}" dropped event`);
      if (isThenable(result2)) {
        void result2.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve)).then(null, reject2);
      } else {
        void notifyEventProcessors(processors, result2, hint, index + 1).then(resolve).then(null, reject2);
      }
    }
  });
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/debug-ids.js
var parsedStackResults;
var lastKeysCount;
var cachedFilenameDebugIds;
function getFilenameToDebugIdMap(stackParser) {
  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
  if (!debugIdMap) {
    return {};
  }
  const debugIdKeys = Object.keys(debugIdMap);
  if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {
    return cachedFilenameDebugIds;
  }
  lastKeysCount = debugIdKeys.length;
  cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {
    if (!parsedStackResults) {
      parsedStackResults = {};
    }
    const result2 = parsedStackResults[stackKey];
    if (result2) {
      acc[result2[0]] = result2[1];
    } else {
      const parsedStack = stackParser(stackKey);
      for (let i2 = parsedStack.length - 1; i2 >= 0; i2--) {
        const stackFrame = parsedStack[i2];
        const filename = stackFrame?.filename;
        const debugId = debugIdMap[stackKey];
        if (filename && debugId) {
          acc[filename] = debugId;
          parsedStackResults[stackKey] = [filename, debugId];
          break;
        }
      }
    }
    return acc;
  }, {});
  return cachedFilenameDebugIds;
}

// ../../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js
function applyScopeDataToEvent(event, data) {
  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
  applyDataToEvent(event, data);
  if (span) {
    applySpanToEvent(event, span);
  }
  applyFingerprintToEvent(event, fingerprint);
  applyBreadcrumbsToEvent(event, breadcrumbs);
  applySdkMetadataToEvent(event, sdkProcessingMetadata);
}
function mergeScopeData(data, mergeData) {
  const {
    extra,
    tags,
    user,
    contexts,
    level,
    sdkProcessingMetadata,
    breadcrumbs,
    fingerprint,
    eventProcessors,
    attachments,
    propagationContext,
    transactionName,
    span
  } = mergeData;
  mergeAndOverwriteScopeData(data, "extra", extra);
  mergeAndOverwriteScopeData(data, "tags", tags);
  mergeAndOverwriteScopeData(data, "user", user);
  mergeAndOverwriteScopeData(data, "contexts", contexts);
  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);
  if (level) {
    data.level = level;
  }
  if (transactionName) {
    data.transactionName = transactionName;
  }
  if (span) {
    data.span = span;
  }
  if (breadcrumbs.length) {
    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
  }
  if (fingerprint.length) {
    data.fingerprint = [...data.fingerprint, ...fingerprint];
  }
  if (eventProcessors.length) {
    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
  }
  if (attachments.length) {
    data.attachments = [...data.attachments, ...attachments];
  }
  data.propagationContext = { ...data.propagationContext, ...propagationContext };
}
function mergeAndOverwriteScopeData(data, prop, mergeVal) {
  data[prop] = merge(data[prop], mergeVal, 1);
}
function applyDataToEvent(event, data) {
  const { extra, tags, user, contexts, level, transactionName } = data;
  if (Object.keys(extra).length) {
    event.extra = { ...extra, ...event.extra };
  }
  if (Object.keys(tags).length) {
    event.tags = { ...tags, ...event.tags };
  }
  if (Object.keys(user).length) {
    event.user = { ...user, ...event.user };
  }
  if (Object.keys(contexts).length) {
    event.contexts = { ...contexts, ...event.contexts };
  }
  if (level) {
    event.level = level;
  }
  if (transactionName && event.type !== "transaction") {
    event.transaction = transactionName;
  }
}
function applyBreadcrumbsToEvent(event, breadcrumbs) {
  const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
}
function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
  event.sdkProcessingMetadata = {
    ...event.sdkProcessingMetadata,
    ...sdkProcessingMetadata
  };
}
function applySpanToEvent(event, span) {
  event.contexts = {
    trace: spanToTraceContext(span),
    ...event.contexts
  };
  event.sdkProcessingMetadata = {
    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
    ...event.sdkProcessingMetadata
  };
  const rootSpan = getRootSpan(span);
  const transactionName = spanToJSON(rootSpan).description;
  if (transactionName && !event.transaction && event.type === "transaction") {
    event.transaction = transactionName;
  }
}
function applyFingerprintToEvent(event, fingerprint) {
  event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
  if (fingerprint) {
    event.fingerprint = event.fingerprint.concat(fingerprint);
  }
  if (!event.fingerprint.length) {
    delete event.fingerprint;
  }
}

// ../../node_modules/@sentry/core/build/esm/utils/prepareEvent.js
function prepareEvent(options, event, hint, scope, client, isolationScope) {
  const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
  const prepared = {
    ...event,
    event_id: event.event_id || hint.event_id || uuid4(),
    timestamp: event.timestamp || dateTimestampInSeconds()
  };
  const integrations = hint.integrations || options.integrations.map((i2) => i2.name);
  applyClientOptions(prepared, options);
  applyIntegrationsMetadata(prepared, integrations);
  if (client) {
    client.emit("applyFrameMetadata", event);
  }
  if (event.type === void 0) {
    applyDebugIds(prepared, options.stackParser);
  }
  const finalScope = getFinalScope(scope, hint.captureContext);
  if (hint.mechanism) {
    addExceptionMechanism(prepared, hint.mechanism);
  }
  const clientEventProcessors = client ? client.getEventProcessors() : [];
  const data = getGlobalScope().getScopeData();
  if (isolationScope) {
    const isolationData = isolationScope.getScopeData();
    mergeScopeData(data, isolationData);
  }
  if (finalScope) {
    const finalScopeData = finalScope.getScopeData();
    mergeScopeData(data, finalScopeData);
  }
  const attachments = [...hint.attachments || [], ...data.attachments];
  if (attachments.length) {
    hint.attachments = attachments;
  }
  applyScopeDataToEvent(prepared, data);
  const eventProcessors = [
    ...clientEventProcessors,
    // Run scope event processors _after_ all other processors
    ...data.eventProcessors
  ];
  const result2 = notifyEventProcessors(eventProcessors, prepared, hint);
  return result2.then((evt) => {
    if (evt) {
      applyDebugMeta(evt);
    }
    if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
    }
    return evt;
  });
}
function applyClientOptions(event, options) {
  const { environment: environment2, release, dist, maxValueLength = 250 } = options;
  event.environment = event.environment || environment2 || DEFAULT_ENVIRONMENT;
  if (!event.release && release) {
    event.release = release;
  }
  if (!event.dist && dist) {
    event.dist = dist;
  }
  const request2 = event.request;
  if (request2?.url) {
    request2.url = truncate(request2.url, maxValueLength);
  }
}
function applyDebugIds(event, stackParser) {
  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);
  event.exception?.values?.forEach((exception) => {
    exception.stacktrace?.frames?.forEach((frame) => {
      if (frame.filename) {
        frame.debug_id = filenameDebugIdMap[frame.filename];
      }
    });
  });
}
function applyDebugMeta(event) {
  const filenameDebugIdMap = {};
  event.exception?.values?.forEach((exception) => {
    exception.stacktrace?.frames?.forEach((frame) => {
      if (frame.debug_id) {
        if (frame.abs_path) {
          filenameDebugIdMap[frame.abs_path] = frame.debug_id;
        } else if (frame.filename) {
          filenameDebugIdMap[frame.filename] = frame.debug_id;
        }
        delete frame.debug_id;
      }
    });
  });
  if (Object.keys(filenameDebugIdMap).length === 0) {
    return;
  }
  event.debug_meta = event.debug_meta || {};
  event.debug_meta.images = event.debug_meta.images || [];
  const images = event.debug_meta.images;
  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {
    images.push({
      type: "sourcemap",
      code_file: filename,
      debug_id
    });
  });
}
function applyIntegrationsMetadata(event, integrationNames) {
  if (integrationNames.length > 0) {
    event.sdk = event.sdk || {};
    event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
  }
}
function normalizeEvent(event, depth, maxBreadth) {
  if (!event) {
    return null;
  }
  const normalized = {
    ...event,
    ...event.breadcrumbs && {
      breadcrumbs: event.breadcrumbs.map((b2) => ({
        ...b2,
        ...b2.data && {
          data: normalize(b2.data, depth, maxBreadth)
        }
      }))
    },
    ...event.user && {
      user: normalize(event.user, depth, maxBreadth)
    },
    ...event.contexts && {
      contexts: normalize(event.contexts, depth, maxBreadth)
    },
    ...event.extra && {
      extra: normalize(event.extra, depth, maxBreadth)
    }
  };
  if (event.contexts?.trace && normalized.contexts) {
    normalized.contexts.trace = event.contexts.trace;
    if (event.contexts.trace.data) {
      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
    }
  }
  if (event.spans) {
    normalized.spans = event.spans.map((span) => {
      return {
        ...span,
        ...span.data && {
          data: normalize(span.data, depth, maxBreadth)
        }
      };
    });
  }
  if (event.contexts?.flags && normalized.contexts) {
    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);
  }
  return normalized;
}
function getFinalScope(scope, captureContext) {
  if (!captureContext) {
    return scope;
  }
  const finalScope = scope ? scope.clone() : new Scope();
  finalScope.update(captureContext);
  return finalScope;
}
function parseEventHintOrCaptureContext(hint) {
  if (!hint) {
    return void 0;
  }
  if (hintIsScopeOrFunction(hint)) {
    return { captureContext: hint };
  }
  if (hintIsScopeContext(hint)) {
    return {
      captureContext: hint
    };
  }
  return hint;
}
function hintIsScopeOrFunction(hint) {
  return hint instanceof Scope || typeof hint === "function";
}
var captureContextKeys = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "propagationContext"
];
function hintIsScopeContext(hint) {
  return Object.keys(hint).some((key) => captureContextKeys.includes(key));
}

// ../../node_modules/@sentry/core/build/esm/exports.js
function captureException(exception, hint) {
  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));
}
function captureEvent(event, hint) {
  return getCurrentScope().captureEvent(event, hint);
}
function startSession(context) {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const { userAgent } = GLOBAL_OBJ.navigator || {};
  const session = makeSession({
    user: currentScope.getUser() || isolationScope.getUser(),
    ...userAgent && { userAgent },
    ...context
  });
  const currentSession = isolationScope.getSession();
  if (currentSession?.status === "ok") {
    updateSession(currentSession, { status: "exited" });
  }
  endSession();
  isolationScope.setSession(session);
  return session;
}
function endSession() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session) {
    closeSession(session);
  }
  _sendSessionUpdate();
  isolationScope.setSession();
}
function _sendSessionUpdate() {
  const isolationScope = getIsolationScope();
  const client = getClient();
  const session = isolationScope.getSession();
  if (session && client) {
    client.captureSession(session);
  }
}
function captureSession(end = false) {
  if (end) {
    endSession();
    return;
  }
  _sendSessionUpdate();
}

// ../../node_modules/@sentry/core/build/esm/api.js
var SENTRY_API_VERSION = "7";
function getBaseApiEndpoint(dsn) {
  const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
  const port = dsn.port ? `:${dsn.port}` : "";
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
}
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}
function _encodedAuth(dsn, sdkInfo) {
  const params = {
    sentry_version: SENTRY_API_VERSION
  };
  if (dsn.publicKey) {
    params.sentry_key = dsn.publicKey;
  }
  if (sdkInfo) {
    params.sentry_client = `${sdkInfo.name}/${sdkInfo.version}`;
  }
  return new URLSearchParams(params).toString();
}
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {
  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
}

// ../../node_modules/@sentry/core/build/esm/integration.js
var installedIntegrations = [];
function filterDuplicates(integrations) {
  const integrationsByName = {};
  integrations.forEach((currentInstance) => {
    const { name } = currentInstance;
    const existingInstance = integrationsByName[name];
    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
      return;
    }
    integrationsByName[name] = currentInstance;
  });
  return Object.values(integrationsByName);
}
function getIntegrationsToSetup(options) {
  const defaultIntegrations = options.defaultIntegrations || [];
  const userIntegrations = options.integrations;
  defaultIntegrations.forEach((integration) => {
    integration.isDefaultInstance = true;
  });
  let integrations;
  if (Array.isArray(userIntegrations)) {
    integrations = [...defaultIntegrations, ...userIntegrations];
  } else if (typeof userIntegrations === "function") {
    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);
    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];
  } else {
    integrations = defaultIntegrations;
  }
  return filterDuplicates(integrations);
}
function setupIntegrations(client, integrations) {
  const integrationIndex = {};
  integrations.forEach((integration) => {
    if (integration) {
      setupIntegration(client, integration, integrationIndex);
    }
  });
  return integrationIndex;
}
function afterSetupIntegrations(client, integrations) {
  for (const integration of integrations) {
    if (integration?.afterAllSetup) {
      integration.afterAllSetup(client);
    }
  }
}
function setupIntegration(client, integration, integrationIndex) {
  if (integrationIndex[integration.name]) {
    DEBUG_BUILD && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
    return;
  }
  integrationIndex[integration.name] = integration;
  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === "function") {
    integration.setupOnce();
    installedIntegrations.push(integration.name);
  }
  if (integration.setup && typeof integration.setup === "function") {
    integration.setup(client);
  }
  if (typeof integration.preprocessEvent === "function") {
    const callback = integration.preprocessEvent.bind(integration);
    client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
  }
  if (typeof integration.processEvent === "function") {
    const callback = integration.processEvent.bind(integration);
    const processor = Object.assign((event, hint) => callback(event, hint, client), {
      id: integration.name
    });
    client.addEventProcessor(processor);
  }
  DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);
}
function defineIntegration(fn) {
  return fn;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/clientreport.js
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
  const clientReportItem = [
    { type: "client_report" },
    {
      timestamp: timestamp || dateTimestampInSeconds(),
      discarded_events
    }
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}

// ../../node_modules/@sentry/core/build/esm/utils/eventUtils.js
function getPossibleEventMessages(event) {
  const possibleMessages = [];
  if (event.message) {
    possibleMessages.push(event.message);
  }
  try {
    const lastException = event.exception.values[event.exception.values.length - 1];
    if (lastException?.value) {
      possibleMessages.push(lastException.value);
      if (lastException.type) {
        possibleMessages.push(`${lastException.type}: ${lastException.value}`);
      }
    }
  } catch (e2) {
  }
  return possibleMessages;
}

// ../../node_modules/@sentry/core/build/esm/utils/transactionEvent.js
function convertTransactionEventToSpanJson(event) {
  const { trace_id, parent_span_id, span_id, status, origin, data, op } = event.contexts?.trace ?? {};
  return {
    data: data ?? {},
    description: event.transaction,
    op,
    parent_span_id,
    span_id: span_id ?? "",
    start_timestamp: event.start_timestamp ?? 0,
    status,
    timestamp: event.timestamp,
    trace_id: trace_id ?? "",
    origin,
    profile_id: data?.[SEMANTIC_ATTRIBUTE_PROFILE_ID],
    exclusive_time: data?.[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
    measurements: event.measurements,
    is_segment: true
  };
}
function convertSpanJsonToTransactionEvent(span) {
  return {
    type: "transaction",
    timestamp: span.timestamp,
    start_timestamp: span.start_timestamp,
    transaction: span.description,
    contexts: {
      trace: {
        trace_id: span.trace_id,
        span_id: span.span_id,
        parent_span_id: span.parent_span_id,
        op: span.op,
        status: span.status,
        origin: span.origin,
        data: {
          ...span.data,
          ...span.profile_id && { [SEMANTIC_ATTRIBUTE_PROFILE_ID]: span.profile_id },
          ...span.exclusive_time && { [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: span.exclusive_time }
        }
      }
    },
    measurements: span.measurements
  };
}

// ../../node_modules/@sentry/core/build/esm/client.js
var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
var MISSING_RELEASE_FOR_SESSION_ERROR = "Discarded session because of missing or non-string release";
var INTERNAL_ERROR_SYMBOL = Symbol.for("SentryInternalError");
var DO_NOT_SEND_EVENT_SYMBOL = Symbol.for("SentryDoNotSendEventError");
function _makeInternalError(message) {
  return {
    message,
    [INTERNAL_ERROR_SYMBOL]: true
  };
}
function _makeDoNotSendEventError(message) {
  return {
    message,
    [DO_NOT_SEND_EVENT_SYMBOL]: true
  };
}
function _isInternalError(error) {
  return !!error && typeof error === "object" && INTERNAL_ERROR_SYMBOL in error;
}
function _isDoNotSendEventError(error) {
  return !!error && typeof error === "object" && DO_NOT_SEND_EVENT_SYMBOL in error;
}
var Client = class {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(options) {
    this._options = options;
    this._integrations = {};
    this._numProcessing = 0;
    this._outcomes = {};
    this._hooks = {};
    this._eventProcessors = [];
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
    } else {
      DEBUG_BUILD && logger.warn("No DSN provided, client will not send events.");
    }
    if (this._dsn) {
      const url = getEnvelopeEndpointWithUrlEncodedAuth(
        this._dsn,
        options.tunnel,
        options._metadata ? options._metadata.sdk : void 0
      );
      this._transport = options.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options.transportOptions,
        url
      });
    }
  }
  /**
   * Captures an exception event and sends it to Sentry.
   *
   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureException(exception, hint, scope) {
    const eventId = uuid4();
    if (checkOrSetAlreadyCaught(exception)) {
      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    this._process(
      this.eventFromException(exception, hintWithEventId).then(
        (event) => this._captureEvent(event, hintWithEventId, scope)
      )
    );
    return hintWithEventId.event_id;
  }
  /**
   * Captures a message event and sends it to Sentry.
   *
   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureMessage(message, level, hint, currentScope) {
    const hintWithEventId = {
      event_id: uuid4(),
      ...hint
    };
    const eventMessage = isParameterizedString(message) ? message : String(message);
    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message, hintWithEventId);
    this._process(promisedEvent.then((event) => this._captureEvent(event, hintWithEventId, currentScope)));
    return hintWithEventId.event_id;
  }
  /**
   * Captures a manually created event and sends it to Sentry.
   *
   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureEvent(event, hint, currentScope) {
    const eventId = uuid4();
    if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
    this._process(
      this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope)
    );
    return hintWithEventId.event_id;
  }
  /**
   * Captures a session.
   */
  captureSession(session) {
    this.sendSession(session);
    updateSession(session, { init: false });
  }
  /**
   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.
   *
   * @param checkIn An object that describes a check in.
   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want
   * to create a monitor automatically when sending a check in.
   * @param scope An optional scope containing event metadata.
   * @returns A string representing the id of the check in.
   */
  /**
   * Get the current Dsn.
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * Get the current options.
   */
  getOptions() {
    return this._options;
  }
  /**
   * Get the SDK metadata.
   * @see SdkMetadata
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * Returns the transport that is used by the client.
   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.
   */
  getTransport() {
    return this._transport;
  }
  /**
   * Wait for all events to be sent or the timeout to expire, whichever comes first.
   *
   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will
   *   cause the client to wait until all events are sent before resolving the promise.
   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
   * still events in the queue when the timeout is reached.
   */
  flush(timeout) {
    const transport = this._transport;
    if (transport) {
      this.emit("flush");
      return this._isClientDoneProcessing(timeout).then((clientFinished) => {
        return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
      });
    } else {
      return resolvedSyncPromise(true);
    }
  }
  /**
   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.
   *
   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause
   *   the client to wait until all events are sent before disabling itself.
   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if
   * it doesn't.
   */
  close(timeout) {
    return this.flush(timeout).then((result2) => {
      this.getOptions().enabled = false;
      this.emit("close");
      return result2;
    });
  }
  /**
   * Get all installed event processors.
   */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /**
   * Adds an event processor that applies to any event processed by this client.
   */
  addEventProcessor(eventProcessor) {
    this._eventProcessors.push(eventProcessor);
  }
  /**
   * Initialize this client.
   * Call this after the client was set on a scope.
   */
  init() {
    if (this._isEnabled() || // Force integrations to be setup even if no DSN was set when we have
    // Spotlight enabled. This is particularly important for browser as we
    // don't support the `spotlight` option there and rely on the users
    // adding the `spotlightBrowserIntegration()` to their integrations which
    // wouldn't get initialized with the check below when there's no DSN set.
    this._options.integrations.some(({ name }) => name.startsWith("Spotlight"))) {
      this._setupIntegrations();
    }
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(integrationName) {
    return this._integrations[integrationName];
  }
  /**
   * Add an integration to the client.
   * This can be used to e.g. lazy load integrations.
   * In most cases, this should not be necessary,
   * and you're better off just passing the integrations via `integrations: []` at initialization time.
   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.
   */
  addIntegration(integration) {
    const isAlreadyInstalled = this._integrations[integration.name];
    setupIntegration(this, integration, this._integrations);
    if (!isAlreadyInstalled) {
      afterSetupIntegrations(this, [integration]);
    }
  }
  /**
   * Send a fully prepared event to Sentry.
   */
  sendEvent(event, hint = {}) {
    this.emit("beforeSendEvent", event, hint);
    let env2 = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
    for (const attachment of hint.attachments || []) {
      env2 = addItemToEnvelope(env2, createAttachmentEnvelopeItem(attachment));
    }
    const promise = this.sendEnvelope(env2);
    if (promise) {
      promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
    }
  }
  /**
   * Send a session or session aggregrates to Sentry.
   */
  sendSession(session) {
    const { release: clientReleaseOption, environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT } = this._options;
    if ("aggregates" in session) {
      const sessionAttrs = session.attrs || {};
      if (!sessionAttrs.release && !clientReleaseOption) {
        DEBUG_BUILD && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
        return;
      }
      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;
      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;
      session.attrs = sessionAttrs;
    } else {
      if (!session.release && !clientReleaseOption) {
        DEBUG_BUILD && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
        return;
      }
      session.release = session.release || clientReleaseOption;
      session.environment = session.environment || clientEnvironmentOption;
    }
    this.emit("beforeSendSession", session);
    const env2 = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(env2);
  }
  /**
   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).
   */
  recordDroppedEvent(reason, category, count = 1) {
    if (this._options.sendClientReports) {
      const key = `${reason}:${category}`;
      DEBUG_BUILD && logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
      this._outcomes[key] = (this._outcomes[key] || 0) + count;
    }
  }
  /* eslint-disable @typescript-eslint/unified-signatures */
  /**
   * Register a callback for whenever a span is started.
   * Receives the span as argument.
   * @returns {() => void} A function that, when executed, removes the registered callback.
   */
  /**
   * Register a hook on this client.
   */
  on(hook, callback) {
    const hooks = this._hooks[hook] = this._hooks[hook] || [];
    hooks.push(callback);
    return () => {
      const cbIndex = hooks.indexOf(callback);
      if (cbIndex > -1) {
        hooks.splice(cbIndex, 1);
      }
    };
  }
  /** Fire a hook whenever a span starts. */
  /**
   * Emit a hook that was previously registered via `on()`.
   */
  emit(hook, ...rest3) {
    const callbacks = this._hooks[hook];
    if (callbacks) {
      callbacks.forEach((callback) => callback(...rest3));
    }
  }
  /**
   * Send an envelope to Sentry.
   */
  sendEnvelope(envelope) {
    this.emit("beforeEnvelope", envelope);
    if (this._isEnabled() && this._transport) {
      return this._transport.send(envelope).then(null, (reason) => {
        DEBUG_BUILD && logger.error("Error while sending envelope:", reason);
        return reason;
      });
    }
    DEBUG_BUILD && logger.error("Transport disabled");
    return resolvedSyncPromise({});
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations } = this._options;
    this._integrations = setupIntegrations(this, integrations);
    afterSetupIntegrations(this, integrations);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(session, event) {
    let crashed = event.level === "fatal";
    let errored = false;
    const exceptions = event.exception?.values;
    if (exceptions) {
      errored = true;
      for (const ex of exceptions) {
        const mechanism = ex.mechanism;
        if (mechanism?.handled === false) {
          crashed = true;
          break;
        }
      }
    }
    const sessionNonTerminal = session.status === "ok";
    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
    if (shouldUpdateAndSend) {
      updateSession(session, {
        ...crashed && { status: "crashed" },
        errors: session.errors || Number(errored || crashed)
      });
      this.captureSession(session);
    }
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(timeout) {
    return new SyncPromise((resolve) => {
      let ticked = 0;
      const tick = 1;
      const interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve(false);
          }
        }
      }, tick);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== false && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(event, hint, currentScope, isolationScope) {
    const options = this.getOptions();
    const integrations = Object.keys(this._integrations);
    if (!hint.integrations && integrations?.length) {
      hint.integrations = integrations;
    }
    this.emit("preprocessEvent", event, hint);
    if (!event.type) {
      isolationScope.setLastEventId(event.event_id || hint.event_id);
    }
    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then((evt) => {
      if (evt === null) {
        return evt;
      }
      this.emit("postprocessEvent", evt, hint);
      evt.contexts = {
        trace: getTraceContextFromScope(currentScope),
        ...evt.contexts
      };
      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);
      evt.sdkProcessingMetadata = {
        dynamicSamplingContext,
        ...evt.sdkProcessingMetadata
      };
      return evt;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(event, hint = {}, currentScope = getCurrentScope(), isolationScope = getIsolationScope()) {
    if (DEBUG_BUILD && isErrorEvent2(event)) {
      logger.log(`Captured error event \`${getPossibleEventMessages(event)[0] || "<unknown>"}\``);
    }
    return this._processEvent(event, hint, currentScope, isolationScope).then(
      (finalEvent) => {
        return finalEvent.event_id;
      },
      (reason) => {
        if (DEBUG_BUILD) {
          if (_isDoNotSendEventError(reason)) {
            logger.log(reason.message);
          } else if (_isInternalError(reason)) {
            logger.warn(reason.message);
          } else {
            logger.warn(reason);
          }
        }
        return void 0;
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(event, hint, currentScope, isolationScope) {
    const options = this.getOptions();
    const { sampleRate } = options;
    const isTransaction = isTransactionEvent(event);
    const isError3 = isErrorEvent2(event);
    const eventType = event.type || "error";
    const beforeSendLabel = `before send for type \`${eventType}\``;
    const parsedSampleRate = typeof sampleRate === "undefined" ? void 0 : parseSampleRate(sampleRate);
    if (isError3 && typeof parsedSampleRate === "number" && Math.random() > parsedSampleRate) {
      this.recordDroppedEvent("sample_rate", "error");
      return rejectedSyncPromise(
        _makeDoNotSendEventError(
          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`
        )
      );
    }
    const dataCategory = eventType === "replay_event" ? "replay" : eventType;
    return this._prepareEvent(event, hint, currentScope, isolationScope).then((prepared) => {
      if (prepared === null) {
        this.recordDroppedEvent("event_processor", dataCategory);
        throw _makeDoNotSendEventError("An event processor returned `null`, will not send event.");
      }
      const isInternalException = hint.data && hint.data.__sentry__ === true;
      if (isInternalException) {
        return prepared;
      }
      const result2 = processBeforeSend(this, options, prepared, hint);
      return _validateBeforeSendResult(result2, beforeSendLabel);
    }).then((processedEvent) => {
      if (processedEvent === null) {
        this.recordDroppedEvent("before_send", dataCategory);
        if (isTransaction) {
          const spans = event.spans || [];
          const spanCount = 1 + spans.length;
          this.recordDroppedEvent("before_send", "span", spanCount);
        }
        throw _makeDoNotSendEventError(`${beforeSendLabel} returned \`null\`, will not send event.`);
      }
      const session = currentScope.getSession() || isolationScope.getSession();
      if (isError3 && session) {
        this._updateSessionFromEvent(session, processedEvent);
      }
      if (isTransaction) {
        const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;
        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
        const droppedSpanCount = spanCountBefore - spanCountAfter;
        if (droppedSpanCount > 0) {
          this.recordDroppedEvent("before_send", "span", droppedSpanCount);
        }
      }
      const transactionInfo = processedEvent.transaction_info;
      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
        const source = "custom";
        processedEvent.transaction_info = {
          ...transactionInfo,
          source
        };
      }
      this.sendEvent(processedEvent, hint);
      return processedEvent;
    }).then(null, (reason) => {
      if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {
        throw reason;
      }
      this.captureException(reason, {
        data: {
          __sentry__: true
        },
        originalException: reason
      });
      throw _makeInternalError(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
      );
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(promise) {
    this._numProcessing++;
    void promise.then(
      (value) => {
        this._numProcessing--;
        return value;
      },
      (reason) => {
        this._numProcessing--;
        return reason;
      }
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const outcomes = this._outcomes;
    this._outcomes = {};
    return Object.entries(outcomes).map(([key, quantity]) => {
      const [reason, category] = key.split(":");
      return {
        reason,
        category,
        quantity
      };
    });
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    DEBUG_BUILD && logger.log("Flushing outcomes...");
    const outcomes = this._clearOutcomes();
    if (outcomes.length === 0) {
      DEBUG_BUILD && logger.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      DEBUG_BUILD && logger.log("No dsn provided, will not send outcomes");
      return;
    }
    DEBUG_BUILD && logger.log("Sending outcomes:", outcomes);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
    this.sendEnvelope(envelope);
  }
  /**
   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
   */
};
function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
  const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
  if (isThenable(beforeSendResult)) {
    return beforeSendResult.then(
      (event) => {
        if (!isPlainObject(event) && event !== null) {
          throw _makeInternalError(invalidValueError);
        }
        return event;
      },
      (e2) => {
        throw _makeInternalError(`${beforeSendLabel} rejected with ${e2}`);
      }
    );
  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
    throw _makeInternalError(invalidValueError);
  }
  return beforeSendResult;
}
function processBeforeSend(client, options, event, hint) {
  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;
  let processedEvent = event;
  if (isErrorEvent2(processedEvent) && beforeSend) {
    return beforeSend(processedEvent, hint);
  }
  if (isTransactionEvent(processedEvent)) {
    if (beforeSendSpan) {
      const processedRootSpanJson = beforeSendSpan(convertTransactionEventToSpanJson(processedEvent));
      if (!processedRootSpanJson) {
        showSpanDropWarning();
      } else {
        processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));
      }
      if (processedEvent.spans) {
        const processedSpans = [];
        for (const span of processedEvent.spans) {
          const processedSpan = beforeSendSpan(span);
          if (!processedSpan) {
            showSpanDropWarning();
            processedSpans.push(span);
          } else {
            processedSpans.push(processedSpan);
          }
        }
        processedEvent.spans = processedSpans;
      }
    }
    if (beforeSendTransaction) {
      if (processedEvent.spans) {
        const spanCountBefore = processedEvent.spans.length;
        processedEvent.sdkProcessingMetadata = {
          ...event.sdkProcessingMetadata,
          spanCountBeforeProcessing: spanCountBefore
        };
      }
      return beforeSendTransaction(processedEvent, hint);
    }
  }
  return processedEvent;
}
function isErrorEvent2(event) {
  return event.type === void 0;
}
function isTransactionEvent(event) {
  return event.type === "transaction";
}

// ../../node_modules/@sentry/core/build/esm/logs/envelope.js
function createOtelLogEnvelopeItem(log) {
  return [
    {
      type: "otel_log"
    },
    log
  ];
}
function createOtelLogEnvelope(logs, metadata, tunnel, dsn) {
  const headers = {};
  if (metadata?.sdk) {
    headers.sdk = {
      name: metadata.sdk.name,
      version: metadata.sdk.version
    };
  }
  if (!!tunnel && !!dsn) {
    headers.dsn = dsnToString(dsn);
  }
  return createEnvelope(headers, logs.map(createOtelLogEnvelopeItem));
}

// ../../node_modules/@sentry/core/build/esm/logs/exports.js
var CLIENT_TO_LOG_BUFFER_MAP = /* @__PURE__ */ new WeakMap();
function _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {
  const logBuffer = maybeLogBuffer ?? CLIENT_TO_LOG_BUFFER_MAP.get(client) ?? [];
  if (logBuffer.length === 0) {
    return;
  }
  const clientOptions = client.getOptions();
  const envelope = createOtelLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());
  logBuffer.length = 0;
  client.sendEnvelope(envelope);
}

// ../../node_modules/@sentry/core/build/esm/sdk.js
function initAndBind(clientClass, options) {
  if (options.debug === true) {
    if (DEBUG_BUILD) {
      logger.enable();
    } else {
      consoleSandbox(() => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      });
    }
  }
  const scope = getCurrentScope();
  scope.update(options.initialScope);
  const client = new clientClass(options);
  setCurrentClient(client);
  client.init();
  return client;
}
function setCurrentClient(client) {
  getCurrentScope().setClient(client);
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/promisebuffer.js
var SENTRY_BUFFER_FULL_ERROR = Symbol.for("SentryBufferFullError");
function makePromiseBuffer(limit) {
  const buffer = [];
  function isReady() {
    return limit === void 0 || buffer.length < limit;
  }
  function remove3(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(void 0);
  }
  function add2(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(SENTRY_BUFFER_FULL_ERROR);
    }
    const task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    void task.then(() => remove3(task)).then(
      null,
      () => remove3(task).then(null, () => {
      })
    );
    return task;
  }
  function drain(timeout) {
    return new SyncPromise((resolve, reject2) => {
      let counter = buffer.length;
      if (!counter) {
        return resolve(true);
      }
      const capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);
      buffer.forEach((item) => {
        void resolvedSyncPromise(item).then(() => {
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject2);
      });
    });
  }
  return {
    $: buffer,
    add: add2,
    drain
  };
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/ratelimit.js
var DEFAULT_RETRY_AFTER = 60 * 1e3;
function parseRetryAfterHeader(header, now2 = Date.now()) {
  const headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1e3;
  }
  const headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now2;
  }
  return DEFAULT_RETRY_AFTER;
}
function disabledUntil(limits, dataCategory) {
  return limits[dataCategory] || limits.all || 0;
}
function isRateLimited(limits, dataCategory, now2 = Date.now()) {
  return disabledUntil(limits, dataCategory) > now2;
}
function updateRateLimits(limits, { statusCode, headers }, now2 = Date.now()) {
  const updatedRateLimits = {
    ...limits
  };
  const rateLimitHeader = headers?.["x-sentry-rate-limits"];
  const retryAfterHeader = headers?.["retry-after"];
  if (rateLimitHeader) {
    for (const limit of rateLimitHeader.trim().split(",")) {
      const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
      const headerDelay = parseInt(retryAfter, 10);
      const delay2 = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
      if (!categories) {
        updatedRateLimits.all = now2 + delay2;
      } else {
        for (const category of categories.split(";")) {
          if (category === "metric_bucket") {
            if (!namespaces || namespaces.split(";").includes("custom")) {
              updatedRateLimits[category] = now2 + delay2;
            }
          } else {
            updatedRateLimits[category] = now2 + delay2;
          }
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now2 + parseRetryAfterHeader(retryAfterHeader, now2);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now2 + 60 * 1e3;
  }
  return updatedRateLimits;
}

// ../../node_modules/@sentry/core/build/esm/transports/base.js
var DEFAULT_TRANSPORT_BUFFER_SIZE = 64;
function createTransport(options, makeRequest, buffer = makePromiseBuffer(
  options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
)) {
  let rateLimits = {};
  const flush2 = (timeout) => buffer.drain(timeout);
  function send(envelope) {
    const filteredEnvelopeItems = [];
    forEachEnvelopeItem(envelope, (item, type) => {
      const dataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, dataCategory)) {
        options.recordDroppedEvent("ratelimit_backoff", dataCategory);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });
    if (filteredEnvelopeItems.length === 0) {
      return resolvedSyncPromise({});
    }
    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
    const recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (item, type) => {
        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));
      });
    };
    const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(
      (response) => {
        if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
          DEBUG_BUILD && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
        }
        rateLimits = updateRateLimits(rateLimits, response);
        return response;
      },
      (error) => {
        recordEnvelopeLoss("network_error");
        throw error;
      }
    );
    return buffer.add(requestTask).then(
      (result2) => result2,
      (error) => {
        if (error === SENTRY_BUFFER_FULL_ERROR) {
          DEBUG_BUILD && logger.error("Skipped sending event because buffer is full.");
          recordEnvelopeLoss("queue_overflow");
          return resolvedSyncPromise({});
        } else {
          throw error;
        }
      }
    );
  }
  return {
    send,
    flush: flush2
  };
}

// ../../node_modules/@sentry/core/build/esm/utils/ipAddress.js
function addAutoIpAddressToUser(objWithMaybeUser) {
  if (objWithMaybeUser.user?.ip_address === void 0) {
    objWithMaybeUser.user = {
      ...objWithMaybeUser.user,
      ip_address: "{{auto}}"
    };
  }
}
function addAutoIpAddressToSession(session) {
  if ("aggregates" in session) {
    if (session.attrs?.["ip_address"] === void 0) {
      session.attrs = {
        ...session.attrs,
        ip_address: "{{auto}}"
      };
    }
  } else {
    if (session.ipAddress === void 0) {
      session.ipAddress = "{{auto}}";
    }
  }
}

// ../../node_modules/@sentry/core/build/esm/utils/sdkMetadata.js
function applySdkMetadata(options, name, names = [name], source = "npm") {
  const metadata = options._metadata || {};
  if (!metadata.sdk) {
    metadata.sdk = {
      name: `sentry.javascript.${name}`,
      packages: names.map((name2) => ({
        name: `${source}:@sentry/${name2}`,
        version: SDK_VERSION
      })),
      version: SDK_VERSION
    };
  }
  options._metadata = metadata;
}

// ../../node_modules/@sentry/core/build/esm/breadcrumbs.js
var DEFAULT_BREADCRUMBS = 100;
function addBreadcrumb(breadcrumb, hint) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  if (!client) return;
  const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();
  if (maxBreadcrumbs <= 0) return;
  const timestamp = dateTimestampInSeconds();
  const mergedBreadcrumb = { timestamp, ...breadcrumb };
  const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
  if (finalBreadcrumb === null) return;
  if (client.emit) {
    client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
  }
  isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
}

// ../../node_modules/@sentry/core/build/esm/integrations/functiontostring.js
var originalFunctionToString;
var INTEGRATION_NAME = "FunctionToString";
var SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
var _functionToStringIntegration = (() => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      originalFunctionToString = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...args) {
          const originalFunction = getOriginalFunction(this);
          const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
          return originalFunctionToString.apply(context, args);
        };
      } catch {
      }
    },
    setup(client) {
      SETUP_CLIENTS.set(client, true);
    }
  };
});
var functionToStringIntegration = defineIntegration(_functionToStringIntegration);

// ../../node_modules/@sentry/core/build/esm/integrations/eventFilters.js
var DEFAULT_IGNORE_ERRORS = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.
  /^Cannot redefine property: googletag$/,
  // This is thrown when google tag manager is used in combination with an ad blocker
  /^Can't find variable: gmo$/,
  // Error from Google Search App https://issuetracker.google.com/issues/396043331
  /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
  // Random error that happens but not actionable or noticeable to end-users.
  `can't redefine non-configurable property "solana"`,
  // Probably a browser extension or custom browser (Brave) throwing this error
  "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
  // Error thrown by GTM, seemingly not affecting end-users
  "Can't find variable: _AutofillCallbackHandler",
  // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/
  /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
  // unactionable error from CEFSharp, a .NET library that embeds chromium in .NET apps
  /^Java exception was raised during method invocation$/
  // error from Facebook Mobile browser (https://github.com/getsentry/sentry-javascript/issues/15065)
];
var INTEGRATION_NAME2 = "EventFilters";
var eventFiltersIntegration = defineIntegration((options = {}) => {
  let mergedOptions;
  return {
    name: INTEGRATION_NAME2,
    setup(client) {
      const clientOptions = client.getOptions();
      mergedOptions = _mergeOptions(options, clientOptions);
    },
    processEvent(event, _hint, client) {
      if (!mergedOptions) {
        const clientOptions = client.getOptions();
        mergedOptions = _mergeOptions(options, clientOptions);
      }
      return _shouldDropEvent(event, mergedOptions) ? null : event;
    }
  };
});
var inboundFiltersIntegration = defineIntegration(((options = {}) => {
  return {
    ...eventFiltersIntegration(options),
    name: "InboundFilters"
  };
}));
function _mergeOptions(internalOptions = {}, clientOptions = {}) {
  return {
    allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
    denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
    ignoreErrors: [
      ...internalOptions.ignoreErrors || [],
      ...clientOptions.ignoreErrors || [],
      ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
    ],
    ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []]
  };
}
function _shouldDropEvent(event, options) {
  if (!event.type) {
    if (_isIgnoredError(event, options.ignoreErrors)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isUselessError(event)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to not having an error message, error type or stacktrace.
Event: ${getEventDescription(
          event
        )}`
      );
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
  } else if (event.type === "transaction") {
    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
  }
  return false;
}
function _isIgnoredError(event, ignoreErrors) {
  if (!ignoreErrors?.length) {
    return false;
  }
  return getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
}
function _isIgnoredTransaction(event, ignoreTransactions) {
  if (!ignoreTransactions?.length) {
    return false;
  }
  const name = event.transaction;
  return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
}
function _isDeniedUrl(event, denyUrls) {
  if (!denyUrls?.length) {
    return false;
  }
  const url = _getEventFilterUrl(event);
  return !url ? false : stringMatchesSomePattern(url, denyUrls);
}
function _isAllowedUrl(event, allowUrls) {
  if (!allowUrls?.length) {
    return true;
  }
  const url = _getEventFilterUrl(event);
  return !url ? true : stringMatchesSomePattern(url, allowUrls);
}
function _getLastValidUrl(frames = []) {
  for (let i2 = frames.length - 1; i2 >= 0; i2--) {
    const frame = frames[i2];
    if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
      return frame.filename || null;
    }
  }
  return null;
}
function _getEventFilterUrl(event) {
  try {
    const rootException = [...event.exception?.values ?? []].reverse().find((value) => value.mechanism?.parent_id === void 0 && value.stacktrace?.frames?.length);
    const frames = rootException?.stacktrace?.frames;
    return frames ? _getLastValidUrl(frames) : null;
  } catch (oO) {
    DEBUG_BUILD && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
    return null;
  }
}
function _isUselessError(event) {
  if (!event.exception?.values?.length) {
    return false;
  }
  return (
    // No top-level message
    !event.message && // There are no exception values that have a stacktrace, a non-generic-Error type or value
    !event.exception.values.some((value) => value.stacktrace || value.type && value.type !== "Error" || value.value)
  );
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/aggregate-errors.js
function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, key, limit, event, hint) {
  if (!event.exception?.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return;
  }
  const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
  if (originalException) {
    event.exception.values = aggregateExceptionsFromError(
      exceptionFromErrorImplementation,
      parser,
      limit,
      hint.originalException,
      key,
      event.exception.values,
      originalException,
      0
    );
  }
}
function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error, key, prevExceptions, exception, exceptionId) {
  if (prevExceptions.length >= limit + 1) {
    return prevExceptions;
  }
  let newExceptions = [...prevExceptions];
  if (isInstanceOf(error[key], Error)) {
    applyExceptionGroupFieldsForParentException(exception, exceptionId);
    const newException = exceptionFromErrorImplementation(parser, error[key]);
    const newExceptionId = newExceptions.length;
    applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
    newExceptions = aggregateExceptionsFromError(
      exceptionFromErrorImplementation,
      parser,
      limit,
      error[key],
      key,
      [newException, ...newExceptions],
      newException,
      newExceptionId
    );
  }
  if (Array.isArray(error.errors)) {
    error.errors.forEach((childError, i2) => {
      if (isInstanceOf(childError, Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, childError);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, `errors[${i2}]`, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          childError,
          key,
          [newException, ...newExceptions],
          newException,
          newExceptionId
        );
      }
    });
  }
  return newExceptions;
}
function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    ...exception.type === "AggregateError" && { is_exception_group: true },
    exception_id: exceptionId
  };
}
function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    type: "chained",
    source,
    exception_id: exceptionId,
    parent_id: parentId
  };
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/instrument/console.js
function addConsoleInstrumentationHandler(handler) {
  const type = "console";
  addHandler(type, handler);
  maybeInstrument(type, instrumentConsole);
}
function instrumentConsole() {
  if (!("console" in GLOBAL_OBJ)) {
    return;
  }
  CONSOLE_LEVELS.forEach(function(level) {
    if (!(level in GLOBAL_OBJ.console)) {
      return;
    }
    fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
      originalConsoleMethods[level] = originalConsoleMethod;
      return function(...args) {
        const handlerData = { args, level };
        triggerHandlers("console", handlerData);
        const log = originalConsoleMethods[level];
        log?.apply(GLOBAL_OBJ.console, args);
      };
    });
  });
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/severity.js
function severityLevelFromString(level) {
  return level === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(level) ? level : "log";
}

// ../../node_modules/@sentry/core/build/esm/integrations/dedupe.js
var INTEGRATION_NAME3 = "Dedupe";
var _dedupeIntegration = (() => {
  let previousEvent;
  return {
    name: INTEGRATION_NAME3,
    processEvent(currentEvent) {
      if (currentEvent.type) {
        return currentEvent;
      }
      try {
        if (_shouldDropEvent2(currentEvent, previousEvent)) {
          DEBUG_BUILD && logger.warn("Event dropped due to being a duplicate of previously captured event.");
          return null;
        }
      } catch (_oO) {
      }
      return previousEvent = currentEvent;
    }
  };
});
var dedupeIntegration = defineIntegration(_dedupeIntegration);
function _shouldDropEvent2(currentEvent, previousEvent) {
  if (!previousEvent) {
    return false;
  }
  if (_isSameMessageEvent(currentEvent, previousEvent)) {
    return true;
  }
  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
    return true;
  }
  return false;
}
function _isSameMessageEvent(currentEvent, previousEvent) {
  const currentMessage = currentEvent.message;
  const previousMessage = previousEvent.message;
  if (!currentMessage && !previousMessage) {
    return false;
  }
  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
    return false;
  }
  if (currentMessage !== previousMessage) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameExceptionEvent(currentEvent, previousEvent) {
  const previousException = _getExceptionFromEvent(previousEvent);
  const currentException = _getExceptionFromEvent(currentEvent);
  if (!previousException || !currentException) {
    return false;
  }
  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameStacktrace(currentEvent, previousEvent) {
  let currentFrames = getFramesFromEvent(currentEvent);
  let previousFrames = getFramesFromEvent(previousEvent);
  if (!currentFrames && !previousFrames) {
    return true;
  }
  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
    return false;
  }
  currentFrames = currentFrames;
  previousFrames = previousFrames;
  if (previousFrames.length !== currentFrames.length) {
    return false;
  }
  for (let i2 = 0; i2 < previousFrames.length; i2++) {
    const frameA = previousFrames[i2];
    const frameB = currentFrames[i2];
    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
      return false;
    }
  }
  return true;
}
function _isSameFingerprint(currentEvent, previousEvent) {
  let currentFingerprint = currentEvent.fingerprint;
  let previousFingerprint = previousEvent.fingerprint;
  if (!currentFingerprint && !previousFingerprint) {
    return true;
  }
  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
    return false;
  }
  currentFingerprint = currentFingerprint;
  previousFingerprint = previousFingerprint;
  try {
    return !!(currentFingerprint.join("") === previousFingerprint.join(""));
  } catch (_oO) {
    return false;
  }
}
function _getExceptionFromEvent(event) {
  return event.exception?.values && event.exception.values[0];
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/url.js
function parseUrl(url) {
  if (!url) {
    return {};
  }
  const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match) {
    return {};
  }
  const query = match[6] || "";
  const fragment = match[8] || "";
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    search: query,
    hash: fragment,
    relative: match[5] + query + fragment
    // everything minus origin
  };
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/breadcrumb-log-level.js
function getBreadcrumbLogLevelFromHttpStatusCode(statusCode) {
  if (statusCode === void 0) {
    return void 0;
  } else if (statusCode >= 400 && statusCode < 500) {
    return "warning";
  } else if (statusCode >= 500) {
    return "error";
  } else {
    return void 0;
  }
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/supports.js
var WINDOW2 = GLOBAL_OBJ;
function supportsHistory() {
  return "history" in WINDOW2 && !!WINDOW2.history;
}
function supportsFetch() {
  if (!("fetch" in WINDOW2)) {
    return false;
  }
  try {
    new Headers();
    new Request("http://www.example.com");
    new Response();
    return true;
  } catch (e2) {
    return false;
  }
}
function isNativeFunction(func) {
  return func && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
function supportsNativeFetch() {
  if (typeof EdgeRuntime === "string") {
    return true;
  }
  if (!supportsFetch()) {
    return false;
  }
  if (isNativeFunction(WINDOW2.fetch)) {
    return true;
  }
  let result2 = false;
  const doc = WINDOW2.document;
  if (doc && typeof doc.createElement === "function") {
    try {
      const sandbox = doc.createElement("iframe");
      sandbox.hidden = true;
      doc.head.appendChild(sandbox);
      if (sandbox.contentWindow?.fetch) {
        result2 = isNativeFunction(sandbox.contentWindow.fetch);
      }
      doc.head.removeChild(sandbox);
    } catch (err) {
      DEBUG_BUILD2 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
    }
  }
  return result2;
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/instrument/fetch.js
function addFetchInstrumentationHandler(handler, skipNativeFetchCheck) {
  const type = "fetch";
  addHandler(type, handler);
  maybeInstrument(type, () => instrumentFetch(void 0, skipNativeFetchCheck));
}
function instrumentFetch(onFetchResolved, skipNativeFetchCheck = false) {
  if (skipNativeFetchCheck && !supportsNativeFetch()) {
    return;
  }
  fill(GLOBAL_OBJ, "fetch", function(originalFetch) {
    return function(...args) {
      const virtualError = new Error();
      const { method: method2, url } = parseFetchArgs(args);
      const handlerData = {
        args,
        fetchData: {
          method: method2,
          url
        },
        startTimestamp: timestampInSeconds() * 1e3,
        // // Adding the error to be able to fingerprint the failed fetch event in HttpClient instrumentation
        virtualError
      };
      if (!onFetchResolved) {
        triggerHandlers("fetch", {
          ...handlerData
        });
      }
      return originalFetch.apply(GLOBAL_OBJ, args).then(
        async (response) => {
          if (onFetchResolved) {
            onFetchResolved(response);
          } else {
            triggerHandlers("fetch", {
              ...handlerData,
              endTimestamp: timestampInSeconds() * 1e3,
              response
            });
          }
          return response;
        },
        (error) => {
          triggerHandlers("fetch", {
            ...handlerData,
            endTimestamp: timestampInSeconds() * 1e3,
            error
          });
          if (isError(error) && error.stack === void 0) {
            error.stack = virtualError.stack;
            addNonEnumerableProperty(error, "framesToPop", 1);
          }
          if (error instanceof TypeError && (error.message === "Failed to fetch" || error.message === "Load failed" || error.message === "NetworkError when attempting to fetch resource.")) {
            try {
              const url2 = new URL(handlerData.fetchData.url);
              error.message = `${error.message} (${url2.host})`;
            } catch {
            }
          }
          throw error;
        }
      );
    };
  });
}
function hasProp(obj, prop) {
  return !!obj && typeof obj === "object" && !!obj[prop];
}
function getUrlFromResource(resource) {
  if (typeof resource === "string") {
    return resource;
  }
  if (!resource) {
    return "";
  }
  if (hasProp(resource, "url")) {
    return resource.url;
  }
  if (resource.toString) {
    return resource.toString();
  }
  return "";
}
function parseFetchArgs(fetchArgs) {
  if (fetchArgs.length === 0) {
    return { method: "GET", url: "" };
  }
  if (fetchArgs.length === 2) {
    const [url, options] = fetchArgs;
    return {
      url: getUrlFromResource(url),
      method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
    };
  }
  const arg = fetchArgs[0];
  return {
    url: getUrlFromResource(arg),
    method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
  };
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/env.js
function getSDKSource() {
  return "npm";
}

// ../../node_modules/@sentry/core/build/esm/utils-hoist/node-stack-trace.js
function filenameIsInApp(filename, isNative2 = false) {
  const isInternal = isNative2 || filename && // It's not internal if it's an absolute linux path
  !filename.startsWith("/") && // It's not internal if it's an absolute windows path
  !filename.match(/^[A-Z]:/) && // It's not internal if the path is starting with a dot
  !filename.startsWith(".") && // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack
  !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
  return !isInternal && filename !== void 0 && !filename.includes("node_modules/");
}
function node(getModule) {
  const FILENAME_MATCH = /^\s*[-]{4,}$/;
  const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
  return (line) => {
    const lineMatch = line.match(FULL_MATCH);
    if (lineMatch) {
      let object;
      let method2;
      let functionName;
      let typeName;
      let methodName;
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        let methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] === ".") {
          methodStart--;
        }
        if (methodStart > 0) {
          object = functionName.slice(0, methodStart);
          method2 = functionName.slice(methodStart + 1);
          const objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.slice(objectEnd + 1);
            object = object.slice(0, objectEnd);
          }
        }
        typeName = void 0;
      }
      if (method2) {
        typeName = object;
        methodName = method2;
      }
      if (method2 === "<anonymous>") {
        methodName = void 0;
        functionName = void 0;
      }
      if (functionName === void 0) {
        methodName = methodName || UNKNOWN_FUNCTION;
        functionName = typeName ? `${typeName}.${methodName}` : methodName;
      }
      let filename = lineMatch[2]?.startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
      const isNative2 = lineMatch[5] === "native";
      if (filename?.match(/\/[A-Z]:/)) {
        filename = filename.slice(1);
      }
      if (!filename && lineMatch[5] && !isNative2) {
        filename = lineMatch[5];
      }
      return {
        filename: filename ? decodeURI(filename) : void 0,
        module: getModule ? getModule(filename) : void 0,
        function: functionName,
        lineno: _parseIntOrUndefined(lineMatch[3]),
        colno: _parseIntOrUndefined(lineMatch[4]),
        in_app: filenameIsInApp(filename || "", isNative2)
      };
    }
    if (line.match(FILENAME_MATCH)) {
      return {
        filename: line
      };
    }
    return void 0;
  };
}
function nodeStackLineParser(getModule) {
  return [90, node(getModule)];
}
function _parseIntOrUndefined(input) {
  return parseInt(input || "", 10) || void 0;
}

// ../../node_modules/@sentry/browser/build/npm/esm/helpers.js
var WINDOW3 = GLOBAL_OBJ;
var ignoreOnError = 0;
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}
function ignoreNextOnError() {
  ignoreOnError++;
  setTimeout(() => {
    ignoreOnError--;
  });
}
function wrap(fn, options = {}) {
  function isFunction3(fn2) {
    return typeof fn2 === "function";
  }
  if (!isFunction3(fn)) {
    return fn;
  }
  try {
    const wrapper = fn.__sentry_wrapped__;
    if (wrapper) {
      if (typeof wrapper === "function") {
        return wrapper;
      } else {
        return fn;
      }
    }
    if (getOriginalFunction(fn)) {
      return fn;
    }
  } catch (e2) {
    return fn;
  }
  const sentryWrapped = function(...args) {
    try {
      const wrappedArguments = args.map((arg) => wrap(arg, options));
      return fn.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();
      withScope2((scope) => {
        scope.addEventProcessor((event) => {
          if (options.mechanism) {
            addExceptionTypeValue(event, void 0, void 0);
            addExceptionMechanism(event, options.mechanism);
          }
          event.extra = {
            ...event.extra,
            arguments: args
          };
          return event;
        });
        captureException(ex);
      });
      throw ex;
    }
  };
  try {
    for (const property2 in fn) {
      if (Object.prototype.hasOwnProperty.call(fn, property2)) {
        sentryWrapped[property2] = fn[property2];
      }
    }
  } catch {
  }
  markFunctionWrapped(sentryWrapped, fn);
  addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
  try {
    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, "name", {
        get() {
          return fn.name;
        }
      });
    }
  } catch {
  }
  return sentryWrapped;
}

// ../../node_modules/@sentry/browser/build/npm/esm/eventbuilder.js
function exceptionFromError(stackParser, ex) {
  const frames = parseStackFrames(stackParser, ex);
  const exception = {
    type: extractType(ex),
    value: extractMessage(ex)
  };
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  if (exception.type === void 0 && exception.value === "") {
    exception.value = "Unrecoverable error caught";
  }
  return exception;
}
function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
  const client = getClient();
  const normalizeDepth = client?.getOptions().normalizeDepth;
  const errorFromProp = getErrorPropertyFromObject(exception);
  const extra = {
    __serialized__: normalizeToSize(exception, normalizeDepth)
  };
  if (errorFromProp) {
    return {
      exception: {
        values: [exceptionFromError(stackParser, errorFromProp)]
      },
      extra
    };
  }
  const event = {
    exception: {
      values: [
        {
          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
          value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })
        }
      ]
    },
    extra
  };
  if (syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception.values[0].stacktrace = { frames };
    }
  }
  return event;
}
function eventFromError(stackParser, ex) {
  return {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
}
function parseStackFrames(stackParser, ex) {
  const stacktrace = ex.stacktrace || ex.stack || "";
  const skipLines = getSkipFirstStackStringLines(ex);
  const framesToPop = getPopFirstTopFrames(ex);
  try {
    return stackParser(stacktrace, skipLines, framesToPop);
  } catch (e2) {
  }
  return [];
}
var reactMinifiedRegexp = /Minified React error #\d+;/i;
function getSkipFirstStackStringLines(ex) {
  if (ex && reactMinifiedRegexp.test(ex.message)) {
    return 1;
  }
  return 0;
}
function getPopFirstTopFrames(ex) {
  if (typeof ex.framesToPop === "number") {
    return ex.framesToPop;
  }
  return 0;
}
function isWebAssemblyException(exception) {
  if (typeof WebAssembly !== "undefined" && typeof WebAssembly.Exception !== "undefined") {
    return exception instanceof WebAssembly.Exception;
  } else {
    return false;
  }
}
function extractType(ex) {
  const name = ex?.name;
  if (!name && isWebAssemblyException(ex)) {
    const hasTypeInMessage = ex.message && Array.isArray(ex.message) && ex.message.length == 2;
    return hasTypeInMessage ? ex.message[0] : "WebAssembly.Exception";
  }
  return name;
}
function extractMessage(ex) {
  const message = ex?.message;
  if (isWebAssemblyException(ex)) {
    if (Array.isArray(ex.message) && ex.message.length == 2) {
      return ex.message[1];
    }
    return "wasm exception";
  }
  if (!message) {
    return "No error message";
  }
  if (message.error && typeof message.error.message === "string") {
    return message.error.message;
  }
  return message;
}
function eventFromException(stackParser, exception, hint, attachStacktrace) {
  const syntheticException = hint?.syntheticException || void 0;
  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionMechanism(event);
  event.level = "error";
  if (hint?.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const syntheticException = hint?.syntheticException || void 0;
  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
  event.level = level;
  if (hint?.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
  let event;
  if (isErrorEvent(exception) && exception.error) {
    const errorEvent = exception;
    return eventFromError(stackParser, errorEvent.error);
  }
  if (isDOMError(exception) || isDOMException(exception)) {
    const domException = exception;
    if ("stack" in exception) {
      event = eventFromError(stackParser, exception);
    } else {
      const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
      const message = domException.message ? `${name}: ${domException.message}` : name;
      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, message);
    }
    if ("code" in domException) {
      event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
    }
    return event;
  }
  if (isError(exception)) {
    return eventFromError(stackParser, exception);
  }
  if (isPlainObject(exception) || isEvent(exception)) {
    const objectException = exception;
    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionTypeValue(event, `${exception}`, void 0);
  addExceptionMechanism(event, {
    synthetic: true
  });
  return event;
}
function eventFromString(stackParser, message, syntheticException, attachStacktrace) {
  const event = {};
  if (attachStacktrace && syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception = {
        values: [{ value: message, stacktrace: { frames } }]
      };
    }
    addExceptionMechanism(event, { synthetic: true });
  }
  if (isParameterizedString(message)) {
    const { __sentry_template_string__, __sentry_template_values__ } = message;
    event.logentry = {
      message: __sentry_template_string__,
      params: __sentry_template_values__
    };
    return event;
  }
  event.message = message;
  return event;
}
function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {
  const keys2 = extractExceptionKeysForMessage(exception);
  const captureType = isUnhandledRejection ? "promise rejection" : "exception";
  if (isErrorEvent(exception)) {
    return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
  }
  if (isEvent(exception)) {
    const className = getObjectClassName(exception);
    return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
  }
  return `Object captured as ${captureType} with keys: ${keys2}`;
}
function getObjectClassName(obj) {
  try {
    const prototype = Object.getPrototypeOf(obj);
    return prototype ? prototype.constructor.name : void 0;
  } catch (e2) {
  }
}
function getErrorPropertyFromObject(obj) {
  for (const prop in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
      const value = obj[prop];
      if (value instanceof Error) {
        return value;
      }
    }
  }
  return void 0;
}

// ../../node_modules/@sentry/browser/build/npm/esm/client.js
var DEFAULT_FLUSH_INTERVAL = 5e3;
var BrowserClient = class extends Client {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(options) {
    const opts = {
      // We default this to true, as it is the safer scenario
      parentSpanIsAlwaysRootSpan: true,
      ...options
    };
    const sdkSource = WINDOW3.SENTRY_SDK_SOURCE || getSDKSource();
    applySdkMetadata(opts, "browser", ["browser"], sdkSource);
    super(opts);
    const client = this;
    const { sendDefaultPii, _experiments } = client._options;
    const enableLogs = _experiments?.enableLogs;
    if (opts.sendClientReports && WINDOW3.document) {
      WINDOW3.document.addEventListener("visibilitychange", () => {
        if (WINDOW3.document.visibilityState === "hidden") {
          this._flushOutcomes();
          if (enableLogs) {
            _INTERNAL_flushLogsBuffer(client);
          }
        }
      });
    }
    if (enableLogs) {
      client.on("flush", () => {
        _INTERNAL_flushLogsBuffer(client);
      });
      client.on("afterCaptureLog", () => {
        if (client._logFlushIdleTimeout) {
          clearTimeout(client._logFlushIdleTimeout);
        }
        client._logFlushIdleTimeout = setTimeout(() => {
          _INTERNAL_flushLogsBuffer(client);
        }, DEFAULT_FLUSH_INTERVAL);
      });
    }
    if (sendDefaultPii) {
      client.on("postprocessEvent", addAutoIpAddressToUser);
      client.on("beforeSendSession", addAutoIpAddressToSession);
    }
  }
  /**
   * @inheritDoc
   */
  eventFromException(exception, hint) {
    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(message, level = "info", hint) {
    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(event, hint, currentScope, isolationScope) {
    event.platform = event.platform || "javascript";
    return super._prepareEvent(event, hint, currentScope, isolationScope);
  }
};

// ../../node_modules/@sentry-internal/browser-utils/build/esm/debug-build.js
var DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry-internal/browser-utils/build/esm/types.js
var WINDOW4 = GLOBAL_OBJ;

// ../../node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js
var DEBOUNCE_DURATION = 1e3;
var debounceTimerID;
var lastCapturedEventType;
var lastCapturedEventTargetId;
function addClickKeypressInstrumentationHandler(handler) {
  const type = "dom";
  addHandler(type, handler);
  maybeInstrument(type, instrumentDOM);
}
function instrumentDOM() {
  if (!WINDOW4.document) {
    return;
  }
  const triggerDOMHandler = triggerHandlers.bind(null, "dom");
  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
  WINDOW4.document.addEventListener("click", globalDOMEventHandler, false);
  WINDOW4.document.addEventListener("keypress", globalDOMEventHandler, false);
  ["EventTarget", "Node"].forEach((target) => {
    const globalObject = WINDOW4;
    const proto = globalObject[target]?.prototype;
    if (!proto?.hasOwnProperty?.("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(originalAddEventListener) {
      return function(type, listener, options) {
        if (type === "click" || type == "keypress") {
          try {
            const handlers2 = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {};
            const handlerForType = handlers2[type] = handlers2[type] || { refCount: 0 };
            if (!handlerForType.handler) {
              const handler = makeDOMEventHandler(triggerDOMHandler);
              handlerForType.handler = handler;
              originalAddEventListener.call(this, type, handler, options);
            }
            handlerForType.refCount++;
          } catch (e2) {
          }
        }
        return originalAddEventListener.call(this, type, listener, options);
      };
    });
    fill(
      proto,
      "removeEventListener",
      function(originalRemoveEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              const handlers2 = this.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers2[type];
              if (handlerForType) {
                handlerForType.refCount--;
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = void 0;
                  delete handlers2[type];
                }
                if (Object.keys(handlers2).length === 0) {
                  delete this.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e2) {
            }
          }
          return originalRemoveEventListener.call(this, type, listener, options);
        };
      }
    );
  });
}
function isSimilarToLastCapturedEvent(event) {
  if (event.type !== lastCapturedEventType) {
    return false;
  }
  try {
    if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
      return false;
    }
  } catch (e2) {
  }
  return true;
}
function shouldSkipDOMEvent(eventType, target) {
  if (eventType !== "keypress") {
    return false;
  }
  if (!target?.tagName) {
    return true;
  }
  if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
    return false;
  }
  return true;
}
function makeDOMEventHandler(handler, globalListener = false) {
  return (event) => {
    if (!event || event["_sentryCaptured"]) {
      return;
    }
    const target = getEventTarget(event);
    if (shouldSkipDOMEvent(event.type, target)) {
      return;
    }
    addNonEnumerableProperty(event, "_sentryCaptured", true);
    if (target && !target._sentryId) {
      addNonEnumerableProperty(target, "_sentryId", uuid4());
    }
    const name = event.type === "keypress" ? "input" : event.type;
    if (!isSimilarToLastCapturedEvent(event)) {
      const handlerData = { event, name, global: globalListener };
      handler(handlerData);
      lastCapturedEventType = event.type;
      lastCapturedEventTargetId = target ? target._sentryId : void 0;
    }
    clearTimeout(debounceTimerID);
    debounceTimerID = WINDOW4.setTimeout(() => {
      lastCapturedEventTargetId = void 0;
      lastCapturedEventType = void 0;
    }, DEBOUNCE_DURATION);
  };
}
function getEventTarget(event) {
  try {
    return event.target;
  } catch (e2) {
    return null;
  }
}

// ../../node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js
var lastHref;
function addHistoryInstrumentationHandler(handler) {
  const type = "history";
  addHandler(type, handler);
  maybeInstrument(type, instrumentHistory);
}
function instrumentHistory() {
  WINDOW4.addEventListener("popstate", () => {
    const to = WINDOW4.location.href;
    const from = lastHref;
    lastHref = to;
    if (from === to) {
      return;
    }
    const handlerData = { from, to };
    triggerHandlers("history", handlerData);
  });
  if (!supportsHistory()) {
    return;
  }
  function historyReplacementFunction(originalHistoryFunction) {
    return function(...args) {
      const url = args.length > 2 ? args[2] : void 0;
      if (url) {
        const from = lastHref;
        const to = String(url);
        lastHref = to;
        if (from === to) {
          return originalHistoryFunction.apply(this, args);
        }
        const handlerData = { from, to };
        triggerHandlers("history", handlerData);
      }
      return originalHistoryFunction.apply(this, args);
    };
  }
  fill(WINDOW4.history, "pushState", historyReplacementFunction);
  fill(WINDOW4.history, "replaceState", historyReplacementFunction);
}

// ../../node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js
var cachedImplementations = {};
function getNativeImplementation(name) {
  const cached = cachedImplementations[name];
  if (cached) {
    return cached;
  }
  let impl = WINDOW4[name];
  if (isNativeFunction(impl)) {
    return cachedImplementations[name] = impl.bind(WINDOW4);
  }
  const document2 = WINDOW4.document;
  if (document2 && typeof document2.createElement === "function") {
    try {
      const sandbox = document2.createElement("iframe");
      sandbox.hidden = true;
      document2.head.appendChild(sandbox);
      const contentWindow = sandbox.contentWindow;
      if (contentWindow?.[name]) {
        impl = contentWindow[name];
      }
      document2.head.removeChild(sandbox);
    } catch (e2) {
      DEBUG_BUILD3 && logger.warn(`Could not create sandbox iframe for ${name} check, bailing to window.${name}: `, e2);
    }
  }
  if (!impl) {
    return impl;
  }
  return cachedImplementations[name] = impl.bind(WINDOW4);
}
function clearCachedImplementation(name) {
  cachedImplementations[name] = void 0;
}

// ../../node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js
var SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
function addXhrInstrumentationHandler(handler) {
  const type = "xhr";
  addHandler(type, handler);
  maybeInstrument(type, instrumentXHR);
}
function instrumentXHR() {
  if (!WINDOW4.XMLHttpRequest) {
    return;
  }
  const xhrproto = XMLHttpRequest.prototype;
  xhrproto.open = new Proxy(xhrproto.open, {
    apply(originalOpen, xhrOpenThisArg, xhrOpenArgArray) {
      const virtualError = new Error();
      const startTimestamp = timestampInSeconds() * 1e3;
      const method2 = isString(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : void 0;
      const url = parseXhrUrlArg(xhrOpenArgArray[1]);
      if (!method2 || !url) {
        return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);
      }
      xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {
        method: method2,
        url,
        request_headers: {}
      };
      if (method2 === "POST" && url.match(/sentry_key/)) {
        xhrOpenThisArg.__sentry_own_request__ = true;
      }
      const onreadystatechangeHandler = () => {
        const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];
        if (!xhrInfo) {
          return;
        }
        if (xhrOpenThisArg.readyState === 4) {
          try {
            xhrInfo.status_code = xhrOpenThisArg.status;
          } catch (e2) {
          }
          const handlerData = {
            endTimestamp: timestampInSeconds() * 1e3,
            startTimestamp,
            xhr: xhrOpenThisArg,
            virtualError
          };
          triggerHandlers("xhr", handlerData);
        }
      };
      if ("onreadystatechange" in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === "function") {
        xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {
          apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray) {
            onreadystatechangeHandler();
            return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);
          }
        });
      } else {
        xhrOpenThisArg.addEventListener("readystatechange", onreadystatechangeHandler);
      }
      xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {
        apply(originalSetRequestHeader, setRequestHeaderThisArg, setRequestHeaderArgArray) {
          const [header, value] = setRequestHeaderArgArray;
          const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];
          if (xhrInfo && isString(header) && isString(value)) {
            xhrInfo.request_headers[header.toLowerCase()] = value;
          }
          return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);
        }
      });
      return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);
    }
  });
  xhrproto.send = new Proxy(xhrproto.send, {
    apply(originalSend, sendThisArg, sendArgArray) {
      const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];
      if (!sentryXhrData) {
        return originalSend.apply(sendThisArg, sendArgArray);
      }
      if (sendArgArray[0] !== void 0) {
        sentryXhrData.body = sendArgArray[0];
      }
      const handlerData = {
        startTimestamp: timestampInSeconds() * 1e3,
        xhr: sendThisArg
      };
      triggerHandlers("xhr", handlerData);
      return originalSend.apply(sendThisArg, sendArgArray);
    }
  });
}
function parseXhrUrlArg(url) {
  if (isString(url)) {
    return url;
  }
  try {
    return url.toString();
  } catch {
  }
  return void 0;
}

// ../../node_modules/@sentry/browser/build/npm/esm/transports/fetch.js
function makeFetchTransport(options, nativeFetch = getNativeImplementation("fetch")) {
  let pendingBodySize = 0;
  let pendingCount = 0;
  function makeRequest(request2) {
    const requestSize = request2.body.length;
    pendingBodySize += requestSize;
    pendingCount++;
    const requestOptions = {
      body: request2.body,
      method: "POST",
      referrerPolicy: "strict-origin",
      headers: options.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. when finishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
      ...options.fetchOptions
    };
    if (!nativeFetch) {
      clearCachedImplementation("fetch");
      return rejectedSyncPromise("No fetch implementation available");
    }
    try {
      return nativeFetch(options.url, requestOptions).then((response) => {
        pendingBodySize -= requestSize;
        pendingCount--;
        return {
          statusCode: response.status,
          headers: {
            "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
            "retry-after": response.headers.get("Retry-After")
          }
        };
      });
    } catch (e2) {
      clearCachedImplementation("fetch");
      pendingBodySize -= requestSize;
      pendingCount--;
      return rejectedSyncPromise(e2);
    }
  }
  return createTransport(options, makeRequest);
}

// ../../node_modules/@sentry/browser/build/npm/esm/stack-parsers.js
var CHROME_PRIORITY = 30;
var GECKO_PRIORITY = 50;
function createFrame(filename, func, lineno, colno) {
  const frame = {
    filename,
    function: func === "<anonymous>" ? UNKNOWN_FUNCTION : func,
    in_app: true
    // All browser frames are considered in_app
  };
  if (lineno !== void 0) {
    frame.lineno = lineno;
  }
  if (colno !== void 0) {
    frame.colno = colno;
  }
  return frame;
}
var chromeRegexNoFnName = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;
var chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
var chromeStackParserFn = (line) => {
  const noFnParts = chromeRegexNoFnName.exec(line);
  if (noFnParts) {
    const [, filename, line2, col] = noFnParts;
    return createFrame(filename, UNKNOWN_FUNCTION, +line2, +col);
  }
  const parts = chromeRegex.exec(line);
  if (parts) {
    const isEval = parts[2] && parts[2].indexOf("eval") === 0;
    if (isEval) {
      const subMatch = chromeEvalRegex.exec(parts[2]);
      if (subMatch) {
        parts[2] = subMatch[1];
        parts[3] = subMatch[2];
        parts[4] = subMatch[3];
      }
    }
    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
    return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
  }
  return;
};
var chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];
var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var gecko = (line) => {
  const parts = geckoREgex.exec(line);
  if (parts) {
    const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
    if (isEval) {
      const subMatch = geckoEvalRegex.exec(parts[3]);
      if (subMatch) {
        parts[1] = parts[1] || "eval";
        parts[3] = subMatch[1];
        parts[4] = subMatch[2];
        parts[5] = "";
      }
    }
    let filename = parts[3];
    let func = parts[1] || UNKNOWN_FUNCTION;
    [func, filename] = extractSafariExtensionDetails(func, filename);
    return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
  }
  return;
};
var geckoStackLineParser = [GECKO_PRIORITY, gecko];
var defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];
var defaultStackParser = createStackParser(...defaultStackLineParsers);
var extractSafariExtensionDetails = (func, filename) => {
  const isSafariExtension = func.indexOf("safari-extension") !== -1;
  const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
  return isSafariExtension || isSafariWebExtension ? [
    func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
    isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
  ] : [func, filename];
};

// ../../node_modules/@sentry/browser/build/npm/esm/debug-build.js
var DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry/browser/build/npm/esm/integrations/breadcrumbs.js
var MAX_ALLOWED_STRING_LENGTH = 1024;
var INTEGRATION_NAME4 = "Breadcrumbs";
var _breadcrumbsIntegration = ((options = {}) => {
  const _options = {
    console: true,
    dom: true,
    fetch: true,
    history: true,
    sentry: true,
    xhr: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME4,
    setup(client) {
      if (_options.console) {
        addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));
      }
      if (_options.dom) {
        addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));
      }
      if (_options.xhr) {
        addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));
      }
      if (_options.fetch) {
        addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));
      }
      if (_options.history) {
        addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));
      }
      if (_options.sentry) {
        client.on("beforeSendEvent", _getSentryBreadcrumbHandler(client));
      }
    }
  };
});
var breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);
function _getSentryBreadcrumbHandler(client) {
  return function addSentryBreadcrumb(event) {
    if (getClient() !== client) {
      return;
    }
    addBreadcrumb(
      {
        category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
        event_id: event.event_id,
        level: event.level,
        message: getEventDescription(event)
      },
      {
        event
      }
    );
  };
}
function _getDomBreadcrumbHandler(client, dom) {
  return function _innerDomBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    let target;
    let componentName;
    let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
    let maxStringLength = typeof dom === "object" && typeof dom.maxStringLength === "number" ? dom.maxStringLength : void 0;
    if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
      DEBUG_BUILD4 && logger.warn(
        `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`
      );
      maxStringLength = MAX_ALLOWED_STRING_LENGTH;
    }
    if (typeof keyAttrs === "string") {
      keyAttrs = [keyAttrs];
    }
    try {
      const event = handlerData.event;
      const element = _isEvent(event) ? event.target : event;
      target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
      componentName = getComponentName(element);
    } catch (e2) {
      target = "<unknown>";
    }
    if (target.length === 0) {
      return;
    }
    const breadcrumb = {
      category: `ui.${handlerData.name}`,
      message: target
    };
    if (componentName) {
      breadcrumb.data = { "ui.component_name": componentName };
    }
    addBreadcrumb(breadcrumb, {
      event: handlerData.event,
      name: handlerData.name,
      global: handlerData.global
    });
  };
}
function _getConsoleBreadcrumbHandler(client) {
  return function _consoleBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const breadcrumb = {
      category: "console",
      data: {
        arguments: handlerData.args,
        logger: "console"
      },
      level: severityLevelFromString(handlerData.level),
      message: safeJoin(handlerData.args, " ")
    };
    if (handlerData.level === "assert") {
      if (handlerData.args[0] === false) {
        breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
        breadcrumb.data.arguments = handlerData.args.slice(1);
      } else {
        return;
      }
    }
    addBreadcrumb(breadcrumb, {
      input: handlerData.args,
      level: handlerData.level
    });
  };
}
function _getXhrBreadcrumbHandler(client) {
  return function _xhrBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const { startTimestamp, endTimestamp } = handlerData;
    const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
    if (!startTimestamp || !endTimestamp || !sentryXhrData) {
      return;
    }
    const { method: method2, url, status_code, body } = sentryXhrData;
    const data = {
      method: method2,
      url,
      status_code
    };
    const hint = {
      xhr: handlerData.xhr,
      input: body,
      startTimestamp,
      endTimestamp
    };
    const breadcrumb = {
      category: "xhr",
      data,
      type: "http",
      level: getBreadcrumbLogLevelFromHttpStatusCode(status_code)
    };
    client.emit("beforeOutgoingRequestBreadcrumb", breadcrumb, hint);
    addBreadcrumb(breadcrumb, hint);
  };
}
function _getFetchBreadcrumbHandler(client) {
  return function _fetchBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const { startTimestamp, endTimestamp } = handlerData;
    if (!endTimestamp) {
      return;
    }
    if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
      return;
    }
    ({
      method: handlerData.fetchData.method,
      url: handlerData.fetchData.url
    });
    if (handlerData.error) {
      const data = handlerData.fetchData;
      const hint = {
        data: handlerData.error,
        input: handlerData.args,
        startTimestamp,
        endTimestamp
      };
      const breadcrumb = {
        category: "fetch",
        data,
        level: "error",
        type: "http"
      };
      client.emit("beforeOutgoingRequestBreadcrumb", breadcrumb, hint);
      addBreadcrumb(breadcrumb, hint);
    } else {
      const response = handlerData.response;
      const data = {
        ...handlerData.fetchData,
        status_code: response?.status
      };
      handlerData.fetchData.request_body_size;
      handlerData.fetchData.response_body_size;
      response?.status;
      const hint = {
        input: handlerData.args,
        response,
        startTimestamp,
        endTimestamp
      };
      const breadcrumb = {
        category: "fetch",
        data,
        type: "http",
        level: getBreadcrumbLogLevelFromHttpStatusCode(data.status_code)
      };
      client.emit("beforeOutgoingRequestBreadcrumb", breadcrumb, hint);
      addBreadcrumb(breadcrumb, hint);
    }
  };
}
function _getHistoryBreadcrumbHandler(client) {
  return function _historyBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    let from = handlerData.from;
    let to = handlerData.to;
    const parsedLoc = parseUrl(WINDOW3.location.href);
    let parsedFrom = from ? parseUrl(from) : void 0;
    const parsedTo = parseUrl(to);
    if (!parsedFrom?.path) {
      parsedFrom = parsedLoc;
    }
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
      to = parsedTo.relative;
    }
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
      from = parsedFrom.relative;
    }
    addBreadcrumb({
      category: "navigation",
      data: {
        from,
        to
      }
    });
  };
}
function _isEvent(event) {
  return !!event && !!event.target;
}

// ../../node_modules/@sentry/browser/build/npm/esm/integrations/browserapierrors.js
var DEFAULT_EVENT_TARGET = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
];
var INTEGRATION_NAME5 = "BrowserApiErrors";
var _browserApiErrorsIntegration = ((options = {}) => {
  const _options = {
    XMLHttpRequest: true,
    eventTarget: true,
    requestAnimationFrame: true,
    setInterval: true,
    setTimeout: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME5,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      if (_options.setTimeout) {
        fill(WINDOW3, "setTimeout", _wrapTimeFunction);
      }
      if (_options.setInterval) {
        fill(WINDOW3, "setInterval", _wrapTimeFunction);
      }
      if (_options.requestAnimationFrame) {
        fill(WINDOW3, "requestAnimationFrame", _wrapRAF);
      }
      if (_options.XMLHttpRequest && "XMLHttpRequest" in WINDOW3) {
        fill(XMLHttpRequest.prototype, "send", _wrapXHR);
      }
      const eventTargetOption = _options.eventTarget;
      if (eventTargetOption) {
        const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
        eventTarget.forEach(_wrapEventTarget);
      }
    }
  };
});
var browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);
function _wrapTimeFunction(original) {
  return function(...args) {
    const originalCallback = args[0];
    args[0] = wrap(originalCallback, {
      mechanism: {
        data: { function: getFunctionName(original) },
        handled: false,
        type: "instrument"
      }
    });
    return original.apply(this, args);
  };
}
function _wrapRAF(original) {
  return function(callback) {
    return original.apply(this, [
      wrap(callback, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: getFunctionName(original)
          },
          handled: false,
          type: "instrument"
        }
      })
    ]);
  };
}
function _wrapXHR(originalSend) {
  return function(...args) {
    const xhr = this;
    const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
    xmlHttpRequestProps.forEach((prop) => {
      if (prop in xhr && typeof xhr[prop] === "function") {
        fill(xhr, prop, function(original) {
          const wrapOptions = {
            mechanism: {
              data: {
                function: prop,
                handler: getFunctionName(original)
              },
              handled: false,
              type: "instrument"
            }
          };
          const originalFunction = getOriginalFunction(original);
          if (originalFunction) {
            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
          }
          return wrap(original, wrapOptions);
        });
      }
    });
    return originalSend.apply(this, args);
  };
}
function _wrapEventTarget(target) {
  const globalObject = WINDOW3;
  const proto = globalObject[target]?.prototype;
  if (!proto?.hasOwnProperty?.("addEventListener")) {
    return;
  }
  fill(proto, "addEventListener", function(original) {
    return function(eventName, fn, options) {
      try {
        if (isEventListenerObject(fn)) {
          fn.handleEvent = wrap(fn.handleEvent, {
            mechanism: {
              data: {
                function: "handleEvent",
                handler: getFunctionName(fn),
                target
              },
              handled: false,
              type: "instrument"
            }
          });
        }
      } catch {
      }
      return original.apply(this, [
        eventName,
        wrap(fn, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: getFunctionName(fn),
              target
            },
            handled: false,
            type: "instrument"
          }
        }),
        options
      ]);
    };
  });
  fill(proto, "removeEventListener", function(originalRemoveEventListener) {
    return function(eventName, fn, options) {
      try {
        const originalEventHandler = fn.__sentry_wrapped__;
        if (originalEventHandler) {
          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
        }
      } catch (e2) {
      }
      return originalRemoveEventListener.call(this, eventName, fn, options);
    };
  });
}
function isEventListenerObject(obj) {
  return typeof obj.handleEvent === "function";
}

// ../../node_modules/@sentry/browser/build/npm/esm/integrations/browsersession.js
var browserSessionIntegration = defineIntegration(() => {
  return {
    name: "BrowserSession",
    setupOnce() {
      if (typeof WINDOW3.document === "undefined") {
        DEBUG_BUILD4 && logger.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
        return;
      }
      startSession({ ignoreDuration: true });
      captureSession();
      addHistoryInstrumentationHandler(({ from, to }) => {
        if (from !== void 0 && from !== to) {
          startSession({ ignoreDuration: true });
          captureSession();
        }
      });
    }
  };
});

// ../../node_modules/@sentry/browser/build/npm/esm/integrations/globalhandlers.js
var INTEGRATION_NAME6 = "GlobalHandlers";
var _globalHandlersIntegration = ((options = {}) => {
  const _options = {
    onerror: true,
    onunhandledrejection: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME6,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(client) {
      if (_options.onerror) {
        _installGlobalOnErrorHandler(client);
        globalHandlerLog("onerror");
      }
      if (_options.onunhandledrejection) {
        _installGlobalOnUnhandledRejectionHandler(client);
        globalHandlerLog("onunhandledrejection");
      }
    }
  };
});
var globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);
function _installGlobalOnErrorHandler(client) {
  addGlobalErrorInstrumentationHandler((data) => {
    const { stackParser, attachStacktrace } = getOptions();
    if (getClient() !== client || shouldIgnoreOnError()) {
      return;
    }
    const { msg, url, line, column, error } = data;
    const event = _enhanceEventWithInitialFrame(
      eventFromUnknownInput(stackParser, error || msg, void 0, attachStacktrace, false),
      url,
      line,
      column
    );
    event.level = "error";
    captureEvent(event, {
      originalException: error,
      mechanism: {
        handled: false,
        type: "onerror"
      }
    });
  });
}
function _installGlobalOnUnhandledRejectionHandler(client) {
  addGlobalUnhandledRejectionInstrumentationHandler((e2) => {
    const { stackParser, attachStacktrace } = getOptions();
    if (getClient() !== client || shouldIgnoreOnError()) {
      return;
    }
    const error = _getUnhandledRejectionError(e2);
    const event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(stackParser, error, void 0, attachStacktrace, true);
    event.level = "error";
    captureEvent(event, {
      originalException: error,
      mechanism: {
        handled: false,
        type: "onunhandledrejection"
      }
    });
  });
}
function _getUnhandledRejectionError(error) {
  if (isPrimitive(error)) {
    return error;
  }
  try {
    if ("reason" in error) {
      return error.reason;
    }
    if ("detail" in error && "reason" in error.detail) {
      return error.detail.reason;
    }
  } catch {
  }
  return error;
}
function _eventFromRejectionWithPrimitive(reason) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(reason)}`
        }
      ]
    }
  };
}
function _enhanceEventWithInitialFrame(event, url, line, column) {
  const e2 = event.exception = event.exception || {};
  const ev = e2.values = e2.values || [];
  const ev0 = ev[0] = ev[0] || {};
  const ev0s = ev0.stacktrace = ev0.stacktrace || {};
  const ev0sf = ev0s.frames = ev0s.frames || [];
  const colno = column;
  const lineno = line;
  const filename = isString(url) && url.length > 0 ? url : getLocationHref();
  if (ev0sf.length === 0) {
    ev0sf.push({
      colno,
      filename,
      function: UNKNOWN_FUNCTION,
      in_app: true,
      lineno
    });
  }
  return event;
}
function globalHandlerLog(type) {
  DEBUG_BUILD4 && logger.log(`Global Handler attached: ${type}`);
}
function getOptions() {
  const client = getClient();
  const options = client?.getOptions() || {
    stackParser: () => [],
    attachStacktrace: false
  };
  return options;
}

// ../../node_modules/@sentry/browser/build/npm/esm/integrations/httpcontext.js
var httpContextIntegration = defineIntegration(() => {
  return {
    name: "HttpContext",
    preprocessEvent(event) {
      if (!WINDOW3.navigator && !WINDOW3.location && !WINDOW3.document) {
        return;
      }
      const url = event.request?.url || getLocationHref();
      const { referrer } = WINDOW3.document || {};
      const { userAgent } = WINDOW3.navigator || {};
      const headers = {
        ...event.request?.headers,
        ...referrer && { Referer: referrer },
        ...userAgent && { "User-Agent": userAgent }
      };
      const request2 = {
        ...event.request,
        ...url && { url },
        headers
      };
      event.request = request2;
    }
  };
});

// ../../node_modules/@sentry/browser/build/npm/esm/integrations/linkederrors.js
var DEFAULT_KEY = "cause";
var DEFAULT_LIMIT = 5;
var INTEGRATION_NAME7 = "LinkedErrors";
var _linkedErrorsIntegration = ((options = {}) => {
  const limit = options.limit || DEFAULT_LIMIT;
  const key = options.key || DEFAULT_KEY;
  return {
    name: INTEGRATION_NAME7,
    preprocessEvent(event, hint, client) {
      const options2 = client.getOptions();
      applyAggregateErrorsToEvent(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        exceptionFromError,
        options2.stackParser,
        key,
        limit,
        event,
        hint
      );
    }
  };
});
var linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);

// ../../node_modules/@sentry/browser/build/npm/esm/sdk.js
function getDefaultIntegrations(_options) {
  return [
    // TODO(v10): Replace with `eventFiltersIntegration` once we remove the deprecated `inboundFiltersIntegration`
    // eslint-disable-next-line deprecation/deprecation
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    browserApiErrorsIntegration(),
    breadcrumbsIntegration(),
    globalHandlersIntegration(),
    linkedErrorsIntegration(),
    dedupeIntegration(),
    httpContextIntegration(),
    browserSessionIntegration()
  ];
}
function applyDefaultOptions(optionsArg = {}) {
  const defaultOptions = {
    defaultIntegrations: getDefaultIntegrations(),
    release: typeof __SENTRY_RELEASE__ === "string" ? __SENTRY_RELEASE__ : WINDOW3.SENTRY_RELEASE?.id,
    // This supports the variable that sentry-webpack-plugin injects
    sendClientReports: true
  };
  return {
    ...defaultOptions,
    ...dropTopLevelUndefinedKeys(optionsArg)
  };
}
function dropTopLevelUndefinedKeys(obj) {
  const mutatetedObj = {};
  for (const k2 of Object.getOwnPropertyNames(obj)) {
    const key = k2;
    if (obj[key] !== void 0) {
      mutatetedObj[key] = obj[key];
    }
  }
  return mutatetedObj;
}
function shouldShowBrowserExtensionError() {
  const windowWithMaybeExtension = typeof WINDOW3.window !== "undefined" && WINDOW3;
  if (!windowWithMaybeExtension) {
    return false;
  }
  const extensionKey = windowWithMaybeExtension.chrome ? "chrome" : "browser";
  const extensionObject = windowWithMaybeExtension[extensionKey];
  const runtimeId = extensionObject?.runtime?.id;
  const href = getLocationHref() || "";
  const extensionProtocols = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"];
  const isDedicatedExtensionPage = !!runtimeId && WINDOW3 === WINDOW3.top && extensionProtocols.some((protocol) => href.startsWith(`${protocol}//`));
  const isNWjs = typeof windowWithMaybeExtension.nw !== "undefined";
  return !!runtimeId && !isDedicatedExtensionPage && !isNWjs;
}
function init(browserOptions = {}) {
  const options = applyDefaultOptions(browserOptions);
  if (!options.skipBrowserExtensionCheck && shouldShowBrowserExtensionError()) {
    if (DEBUG_BUILD4) {
      consoleSandbox(() => {
        console.error(
          "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
        );
      });
    }
    return;
  }
  if (DEBUG_BUILD4 && !supportsFetch()) {
    logger.warn(
      "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
    );
  }
  const clientOptions = {
    ...options,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || makeFetchTransport
  };
  return initAndBind(BrowserClient, clientOptions);
}

// ../../node_modules/@sentry/electron/esm/common/scope.js
function getScopeData() {
  const globalScope = getGlobalScope().getScopeData();
  const isolationScope = getIsolationScope().getScopeData();
  const currentScope = getCurrentScope().getScopeData();
  mergeScopeData(globalScope, isolationScope);
  mergeScopeData(globalScope, currentScope);
  globalScope.eventProcessors = [];
  return globalScope;
}
function addScopeListener(callback) {
  getIsolationScope().addScopeListener((isolation) => {
    const merged = getScopeData();
    callback(merged, isolation);
  });
  getCurrentScope().addScopeListener((current) => {
    const merged = getScopeData();
    callback(merged, current);
  });
  getGlobalScope().addScopeListener((global2) => {
    const merged = getScopeData();
    callback(merged, global2);
  });
}

// ../../node_modules/@sentry/electron/esm/common/ipc.js
var IPCMode;
(function(IPCMode2) {
  IPCMode2[IPCMode2["Classic"] = 1] = "Classic";
  IPCMode2[IPCMode2["Protocol"] = 2] = "Protocol";
  IPCMode2[IPCMode2["Both"] = 3] = "Both";
})(IPCMode || (IPCMode = {}));
var PROTOCOL_SCHEME = "sentry-ipc";
var IPCChannel;
(function(IPCChannel2) {
  IPCChannel2["RENDERER_START"] = "sentry-electron.renderer-start";
  IPCChannel2["SCOPE"] = "sentry-electron.scope";
  IPCChannel2["ENVELOPE"] = "sentry-electron.envelope";
  IPCChannel2["STATUS"] = "sentry-electron.status";
  IPCChannel2["ADD_METRIC"] = "sentry-electron.add-metric";
})(IPCChannel || (IPCChannel = {}));
var RENDERER_ID_HEADER = "sentry-electron-renderer-id";

// ../../node_modules/@sentry/electron/esm/renderer/ipc.js
function buildUrl(channel) {
  return `${PROTOCOL_SCHEME}://${channel}/sentry_key`;
}
function getImplementation() {
  if (window.__SENTRY_IPC__) {
    return window.__SENTRY_IPC__;
  } else {
    logger.log("IPC was not configured in preload script, falling back to custom protocol and fetch");
    const id = window.__SENTRY_RENDERER_ID__ = uuid4();
    const headers = { [RENDERER_ID_HEADER]: id };
    return {
      sendRendererStart: () => {
        fetch(buildUrl(IPCChannel.RENDERER_START), { method: "POST", body: "", headers }).catch(() => {
          console.error(`Sentry SDK failed to establish connection with the Electron main process.
  - Ensure you have initialized the SDK in the main process
  - If your renderers use custom sessions, be sure to set 'getSessions' in the main process options
  - If you are bundling your main process code and using Electron < v5, you'll need to manually configure a preload script`);
        });
      },
      sendScope: (body) => {
        fetch(buildUrl(IPCChannel.SCOPE), { method: "POST", body, headers }).catch(() => {
        });
      },
      sendEnvelope: (body) => {
        fetch(buildUrl(IPCChannel.ENVELOPE), { method: "POST", body, headers }).catch(() => {
        });
      },
      sendStatus: (status) => {
        fetch(buildUrl(IPCChannel.STATUS), { method: "POST", body: JSON.stringify({ status }), headers }).catch(() => {
        });
      }
    };
  }
}
var cachedInterface;
function getIPC() {
  if (!cachedInterface) {
    cachedInterface = getImplementation();
    cachedInterface.sendRendererStart();
  }
  return cachedInterface;
}

// ../../node_modules/@sentry/electron/esm/renderer/integrations/scope-to-main.js
var scopeToMainIntegration = defineIntegration(() => {
  return {
    name: "ScopeToMain",
    setup() {
      const ipc = getIPC();
      addScopeListener((merged, changed) => {
        ipc.sendScope(JSON.stringify(normalize(merged, 20, 2e3)));
        changed.clearBreadcrumbs();
        changed.clearAttachments();
      });
    }
  };
});

// ../../node_modules/@sentry/electron/esm/renderer/transport.js
function makeRendererTransport(options) {
  const ipc = getIPC();
  return createTransport(options, async (request2) => {
    ipc.sendEnvelope(request2.body);
    return { statusCode: 200 };
  });
}

// ../../node_modules/@sentry/electron/esm/renderer/anr.js
function enableAnrRendererMessages(options) {
  const config2 = {
    pollInterval: 1e3,
    anrThreshold: 5e3,
    captureStackTrace: false,
    ...options
  };
  const ipc = getIPC();
  ipc.sendStatus({ status: document.visibilityState, config: config2 });
  setInterval(() => {
    ipc.sendStatus({ status: "alive", config: config2 });
  }, config2.pollInterval);
}

// ../../node_modules/@sentry/electron/esm/renderer/stack-parse.js
var STACKTRACE_FRAME_LIMIT2 = 50;
var [, chrome] = chromeStackLineParser;
var [, node2] = nodeStackLineParser();
var electronRendererStackParser = (stack, skipFirst = 0) => {
  const frames = [];
  for (const line of stack.split("\n").slice(skipFirst)) {
    const chromeFrame = chrome(line);
    const nodeFrame = node2(line);
    if (chromeFrame && nodeFrame?.in_app !== false) {
      frames.push(chromeFrame);
    } else if (nodeFrame) {
      if (nodeFrame.module === void 0) {
        delete nodeFrame.module;
      }
      frames.push(nodeFrame);
    }
    if (frames.length >= STACKTRACE_FRAME_LIMIT2) {
      break;
    }
  }
  return stripSentryFramesAndReverse(frames);
};

// ../../node_modules/@sentry/electron/esm/renderer/sdk.js
function getDefaultIntegrations2(options) {
  return [
    ...getDefaultIntegrations(options).filter((i2) => i2.name !== "BrowserSession"),
    scopeToMainIntegration()
  ];
}
function init2(options = {}, originalInit = init) {
  if (window?.__SENTRY__RENDERER_INIT__) {
    logger.warn(`The browser SDK has already been initialized.
If init has been called in the preload and contextIsolation is disabled, is not required to call init in the renderer`);
    return;
  }
  window.__SENTRY__RENDERER_INIT__ = true;
  options.sendClientReports = false;
  if (options.defaultIntegrations === void 0) {
    options.defaultIntegrations = getDefaultIntegrations2(options);
  }
  if (options.stackParser === void 0) {
    options.stackParser = electronRendererStackParser;
  }
  if (options.dsn === void 0) {
    options.dsn = "https://12345@dummy.dsn/12345";
  }
  if (options.transport === void 0) {
    options.transport = makeRendererTransport;
  }
  if (options.anrDetection) {
    enableAnrRendererMessages(options.anrDetection === true ? {} : options.anrDetection);
  }
  delete options.initialScope;
  originalInit(options);
}

// ../../node_modules/es-toolkit/dist/compat/index.mjs
var compat_exports2 = {};
__export(compat_exports2, {
  add: () => add,
  after: () => after,
  ary: () => ary2,
  assign: () => assign,
  assignIn: () => assignIn,
  assignInWith: () => assignInWith,
  assignWith: () => assignWith,
  at: () => at,
  attempt: () => attempt,
  before: () => before,
  bind: () => bind,
  bindAll: () => bindAll,
  bindKey: () => bindKey,
  camelCase: () => camelCase2,
  capitalize: () => capitalize2,
  castArray: () => castArray,
  ceil: () => ceil,
  chunk: () => chunk2,
  clamp: () => clamp2,
  clone: () => clone,
  cloneDeep: () => cloneDeep2,
  cloneDeepWith: () => cloneDeepWith2,
  cloneWith: () => cloneWith,
  compact: () => compact2,
  concat: () => concat,
  cond: () => cond,
  conforms: () => conforms,
  conformsTo: () => conformsTo,
  constant: () => constant,
  countBy: () => countBy,
  create: () => create,
  curry: () => curry,
  curryRight: () => curryRight,
  debounce: () => debounce2,
  deburr: () => deburr2,
  default: () => toolkit,
  defaultTo: () => defaultTo,
  defaults: () => defaults,
  defaultsDeep: () => defaultsDeep,
  defer: () => defer,
  delay: () => delay,
  difference: () => difference2,
  differenceBy: () => differenceBy2,
  differenceWith: () => differenceWith2,
  divide: () => divide,
  drop: () => drop2,
  dropRight: () => dropRight2,
  dropRightWhile: () => dropRightWhile2,
  dropWhile: () => dropWhile2,
  each: () => forEach,
  eachRight: () => forEachRight,
  endsWith: () => endsWith,
  eq: () => eq,
  escape: () => escape3,
  escapeRegExp: () => escapeRegExp2,
  every: () => every,
  extend: () => assignIn,
  extendWith: () => assignInWith,
  fill: () => fill3,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex,
  findKey: () => findKey2,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  findLastKey: () => findLastKey,
  first: () => head2,
  flatMap: () => flatMap,
  flatMapDeep: () => flatMapDeep,
  flatMapDepth: () => flatMapDepth,
  flatten: () => flatten2,
  flattenDeep: () => flattenDeep,
  flattenDepth: () => flattenDepth,
  flip: () => flip,
  floor: () => floor,
  flow: () => flow2,
  flowRight: () => flowRight2,
  forEach: () => forEach,
  forEachRight: () => forEachRight,
  forIn: () => forIn,
  forInRight: () => forInRight,
  forOwn: () => forOwn,
  forOwnRight: () => forOwnRight,
  fromPairs: () => fromPairs,
  functions: () => functions,
  functionsIn: () => functionsIn,
  get: () => get,
  groupBy: () => groupBy2,
  gt: () => gt,
  gte: () => gte,
  has: () => has,
  hasIn: () => hasIn,
  head: () => head2,
  identity: () => identity2,
  inRange: () => inRange2,
  includes: () => includes,
  indexOf: () => indexOf,
  initial: () => initial2,
  intersection: () => intersection2,
  intersectionBy: () => intersectionBy2,
  intersectionWith: () => intersectionWith2,
  invert: () => invert2,
  invertBy: () => invertBy,
  invoke: () => invoke,
  invokeMap: () => invokeMap,
  isArguments: () => isArguments,
  isArray: () => isArray,
  isArrayBuffer: () => isArrayBuffer2,
  isArrayLike: () => isArrayLike,
  isArrayLikeObject: () => isArrayLikeObject,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer2,
  isDate: () => isDate2,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isEqualWith: () => isEqualWith2,
  isError: () => isError2,
  isFinite: () => isFinite2,
  isFunction: () => isFunction2,
  isInteger: () => isInteger,
  isLength: () => isLength2,
  isMap: () => isMap2,
  isMatch: () => isMatch,
  isMatchWith: () => isMatchWith,
  isNaN: () => isNaN2,
  isNative: () => isNative,
  isNil: () => isNil2,
  isNull: () => isNull2,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isObjectLike: () => isObjectLike,
  isPlainObject: () => isPlainObject3,
  isRegExp: () => isRegExp3,
  isSafeInteger: () => isSafeInteger,
  isSet: () => isSet2,
  isString: () => isString2,
  isSymbol: () => isSymbol,
  isTypedArray: () => isTypedArray2,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap2,
  isWeakSet: () => isWeakSet2,
  iteratee: () => iteratee,
  join: () => join,
  kebabCase: () => kebabCase2,
  keyBy: () => keyBy,
  keys: () => keys,
  keysIn: () => keysIn,
  last: () => last2,
  lastIndexOf: () => lastIndexOf,
  lowerCase: () => lowerCase2,
  lowerFirst: () => lowerFirst2,
  lt: () => lt,
  lte: () => lte,
  map: () => map,
  mapKeys: () => mapKeys2,
  mapValues: () => mapValues2,
  matches: () => matches,
  matchesProperty: () => matchesProperty,
  max: () => max,
  maxBy: () => maxBy2,
  mean: () => mean,
  meanBy: () => meanBy2,
  memoize: () => memoize,
  merge: () => merge2,
  mergeWith: () => mergeWith,
  method: () => method,
  methodOf: () => methodOf,
  min: () => min,
  minBy: () => minBy2,
  multiply: () => multiply,
  negate: () => negate,
  noop: () => noop2,
  now: () => now,
  nth: () => nth,
  nthArg: () => nthArg,
  omit: () => omit,
  omitBy: () => omitBy,
  once: () => once2,
  orderBy: () => orderBy,
  over: () => over,
  overArgs: () => overArgs,
  overEvery: () => overEvery,
  overSome: () => overSome,
  pad: () => pad2,
  padEnd: () => padEnd,
  padStart: () => padStart,
  parseInt: () => parseInt2,
  partial: () => partial2,
  partialRight: () => partialRight2,
  partition: () => partition,
  pick: () => pick,
  pickBy: () => pickBy,
  property: () => property,
  propertyOf: () => propertyOf,
  pull: () => pull2,
  pullAll: () => pullAll,
  pullAllBy: () => pullAllBy,
  pullAllWith: () => pullAllWith,
  pullAt: () => pullAt,
  random: () => random2,
  range: () => range2,
  rangeRight: () => rangeRight,
  rearg: () => rearg,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reject: () => reject,
  remove: () => remove2,
  repeat: () => repeat,
  replace: () => replace,
  rest: () => rest2,
  result: () => result,
  reverse: () => reverse,
  round: () => round,
  sample: () => sample2,
  sampleSize: () => sampleSize2,
  set: () => set,
  setWith: () => setWith,
  shuffle: () => shuffle2,
  size: () => size,
  slice: () => slice,
  snakeCase: () => snakeCase2,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  sortedIndexBy: () => sortedIndexBy,
  sortedIndexOf: () => sortedIndexOf,
  sortedLastIndex: () => sortedLastIndex,
  sortedLastIndexBy: () => sortedLastIndexBy,
  sortedLastIndexOf: () => sortedLastIndexOf,
  split: () => split,
  spread: () => spread,
  startCase: () => startCase,
  startsWith: () => startsWith,
  stubArray: () => stubArray,
  stubFalse: () => stubFalse,
  stubObject: () => stubObject,
  stubString: () => stubString,
  stubTrue: () => stubTrue,
  subtract: () => subtract,
  sum: () => sum,
  sumBy: () => sumBy,
  tail: () => tail2,
  take: () => take2,
  takeRight: () => takeRight2,
  takeRightWhile: () => takeRightWhile,
  takeWhile: () => takeWhile,
  template: () => template,
  templateSettings: () => templateSettings,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray2,
  toDefaulted: () => toDefaulted,
  toFinite: () => toFinite,
  toInteger: () => toInteger,
  toLength: () => toLength,
  toLower: () => toLower,
  toNumber: () => toNumber,
  toPairs: () => toPairs,
  toPairsIn: () => toPairsIn,
  toPath: () => toPath,
  toPlainObject: () => toPlainObject,
  toSafeInteger: () => toSafeInteger,
  toString: () => toString,
  toUpper: () => toUpper,
  transform: () => transform,
  trim: () => trim2,
  trimEnd: () => trimEnd2,
  trimStart: () => trimStart2,
  truncate: () => truncate2,
  unary: () => unary,
  unescape: () => unescape3,
  union: () => union,
  unionBy: () => unionBy,
  unionWith: () => unionWith,
  uniq: () => uniq2,
  uniqBy: () => uniqBy2,
  uniqWith: () => uniqWith2,
  uniqueId: () => uniqueId,
  unset: () => unset,
  unzip: () => unzip2,
  unzipWith: () => unzipWith,
  update: () => update,
  updateWith: () => updateWith,
  upperCase: () => upperCase2,
  upperFirst: () => upperFirst2,
  values: () => values,
  valuesIn: () => valuesIn,
  without: () => without2,
  words: () => words2,
  wrap: () => wrap2,
  xor: () => xor,
  xorBy: () => xorBy,
  xorWith: () => xorWith,
  zip: () => zip2,
  zipObject: () => zipObject,
  zipObjectDeep: () => zipObjectDeep,
  zipWith: () => zipWith
});

// ../../node_modules/es-toolkit/dist/compat/array/castArray.mjs
function castArray(value) {
  if (arguments.length === 0) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}

// ../../node_modules/es-toolkit/dist/array/chunk.mjs
function chunk(arr, size2) {
  if (!Number.isInteger(size2) || size2 <= 0) {
    throw new Error("Size must be an integer greater than zero.");
  }
  const chunkLength = Math.ceil(arr.length / size2);
  const result2 = Array(chunkLength);
  for (let index = 0; index < chunkLength; index++) {
    const start = index * size2;
    const end = start + size2;
    result2[index] = arr.slice(start, end);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/toArray.mjs
function toArray(value) {
  return Array.isArray(value) ? value : Array.from(value);
}

// ../../node_modules/es-toolkit/dist/predicate/isLength.mjs
function isLength(value) {
  return Number.isSafeInteger(value) && value >= 0;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isArrayLike.mjs
function isArrayLike(value) {
  return value != null && typeof value !== "function" && isLength(value.length);
}

// ../../node_modules/es-toolkit/dist/compat/array/chunk.mjs
function chunk2(arr, size2 = 1) {
  size2 = Math.max(Math.floor(size2), 0);
  if (size2 === 0 || !isArrayLike(arr)) {
    return [];
  }
  return chunk(toArray(arr), size2);
}

// ../../node_modules/es-toolkit/dist/array/compact.mjs
function compact(arr) {
  const result2 = [];
  for (let i2 = 0; i2 < arr.length; i2++) {
    const item = arr[i2];
    if (item) {
      result2.push(item);
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/compact.mjs
function compact2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return compact(Array.from(arr));
}

// ../../node_modules/es-toolkit/dist/array/flatten.mjs
function flatten(arr, depth = 1) {
  const result2 = [];
  const flooredDepth = Math.floor(depth);
  const recursive = (arr2, currentDepth) => {
    for (let i2 = 0; i2 < arr2.length; i2++) {
      const item = arr2[i2];
      if (Array.isArray(item) && currentDepth < flooredDepth) {
        recursive(item, currentDepth + 1);
      } else {
        result2.push(item);
      }
    }
  };
  recursive(arr, 0);
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/concat.mjs
function concat(...values2) {
  return flatten(values2);
}

// ../../node_modules/es-toolkit/dist/function/identity.mjs
function identity(x3) {
  return x3;
}

// ../../node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs
function isUnsafeProperty(key) {
  return key === "__proto__";
}

// ../../node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs
function isDeepKey(key) {
  switch (typeof key) {
    case "number":
    case "symbol": {
      return false;
    }
    case "string": {
      return key.includes(".") || key.includes("[") || key.includes("]");
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/_internal/toKey.mjs
function toKey(value) {
  if (typeof value === "string" || typeof value === "symbol") {
    return value;
  }
  if (Object.is(value?.valueOf?.(), -0)) {
    return "-0";
  }
  return String(value);
}

// ../../node_modules/es-toolkit/dist/compat/util/toPath.mjs
function toPath(deepKey) {
  const result2 = [];
  const length = deepKey.length;
  if (length === 0) {
    return result2;
  }
  let index = 0;
  let key = "";
  let quoteChar = "";
  let bracket = false;
  if (deepKey.charCodeAt(0) === 46) {
    result2.push("");
    index++;
  }
  while (index < length) {
    const char = deepKey[index];
    if (quoteChar) {
      if (char === "\\" && index + 1 < length) {
        index++;
        key += deepKey[index];
      } else if (char === quoteChar) {
        quoteChar = "";
      } else {
        key += char;
      }
    } else if (bracket) {
      if (char === '"' || char === "'") {
        quoteChar = char;
      } else if (char === "]") {
        bracket = false;
        result2.push(key);
        key = "";
      } else {
        key += char;
      }
    } else {
      if (char === "[") {
        bracket = true;
        if (key) {
          result2.push(key);
          key = "";
        }
      } else if (char === ".") {
        if (key) {
          result2.push(key);
          key = "";
        }
      } else {
        key += char;
      }
    }
    index++;
  }
  if (key) {
    result2.push(key);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/get.mjs
function get(object, path4, defaultValue) {
  if (object == null) {
    return defaultValue;
  }
  switch (typeof path4) {
    case "string": {
      if (isUnsafeProperty(path4)) {
        return defaultValue;
      }
      const result2 = object[path4];
      if (result2 === void 0) {
        if (isDeepKey(path4)) {
          return get(object, toPath(path4), defaultValue);
        } else {
          return defaultValue;
        }
      }
      return result2;
    }
    case "number":
    case "symbol": {
      if (typeof path4 === "number") {
        path4 = toKey(path4);
      }
      const result2 = object[path4];
      if (result2 === void 0) {
        return defaultValue;
      }
      return result2;
    }
    default: {
      if (Array.isArray(path4)) {
        return getWithPath(object, path4, defaultValue);
      }
      if (Object.is(path4?.valueOf(), -0)) {
        path4 = "-0";
      } else {
        path4 = String(path4);
      }
      if (isUnsafeProperty(path4)) {
        return defaultValue;
      }
      const result2 = object[path4];
      if (result2 === void 0) {
        return defaultValue;
      }
      return result2;
    }
  }
}
function getWithPath(object, path4, defaultValue) {
  if (path4.length === 0) {
    return defaultValue;
  }
  let current = object;
  for (let index = 0; index < path4.length; index++) {
    if (current == null) {
      return defaultValue;
    }
    if (isUnsafeProperty(path4[index])) {
      return defaultValue;
    }
    current = current[path4[index]];
  }
  if (current === void 0) {
    return defaultValue;
  }
  return current;
}

// ../../node_modules/es-toolkit/dist/compat/object/property.mjs
function property(path4) {
  return function(object) {
    return get(object, path4);
  };
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isObject.mjs
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}

// ../../node_modules/es-toolkit/dist/predicate/isPrimitive.mjs
function isPrimitive2(value) {
  return value == null || typeof value !== "object" && typeof value !== "function";
}

// ../../node_modules/es-toolkit/dist/compat/util/eq.mjs
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isMatchWith.mjs
function isMatchWith(target, source, compare) {
  if (typeof compare !== "function") {
    return isMatch(target, source);
  }
  return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object, source2, stack) {
    const isEqual2 = compare(objValue, srcValue, key, object, source2, stack);
    if (isEqual2 !== void 0) {
      return Boolean(isEqual2);
    }
    return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
  }, /* @__PURE__ */ new Map());
}
function isMatchWithInternal(target, source, compare, stack) {
  if (source === target) {
    return true;
  }
  switch (typeof source) {
    case "object": {
      return isObjectMatch(target, source, compare, stack);
    }
    case "function": {
      const sourceKeys = Object.keys(source);
      if (sourceKeys.length > 0) {
        return isMatchWithInternal(target, { ...source }, compare, stack);
      }
      return eq(target, source);
    }
    default: {
      if (!isObject(target)) {
        return eq(target, source);
      }
      if (typeof source === "string") {
        return source === "";
      }
      return true;
    }
  }
}
function isObjectMatch(target, source, compare, stack) {
  if (source == null) {
    return true;
  }
  if (Array.isArray(source)) {
    return isArrayMatch(target, source, compare, stack);
  }
  if (source instanceof Map) {
    return isMapMatch(target, source, compare, stack);
  }
  if (source instanceof Set) {
    return isSetMatch(target, source, compare, stack);
  }
  const keys2 = Object.keys(source);
  if (target == null) {
    return keys2.length === 0;
  }
  if (keys2.length === 0) {
    return true;
  }
  if (stack && stack.has(source)) {
    return stack.get(source) === target;
  }
  if (stack) {
    stack.set(source, target);
  }
  try {
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      if (!isPrimitive2(target) && !(key in target)) {
        return false;
      }
      if (source[key] === void 0 && target[key] !== void 0) {
        return false;
      }
      if (source[key] === null && target[key] !== null) {
        return false;
      }
      const isEqual2 = compare(target[key], source[key], key, target, source, stack);
      if (!isEqual2) {
        return false;
      }
    }
    return true;
  } finally {
    if (stack) {
      stack.delete(source);
    }
  }
}
function isMapMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Map)) {
    return false;
  }
  for (const [key, sourceValue] of source.entries()) {
    const targetValue = target.get(key);
    const isEqual2 = compare(targetValue, sourceValue, key, target, source, stack);
    if (isEqual2 === false) {
      return false;
    }
  }
  return true;
}
function isArrayMatch(target, source, compare, stack) {
  if (source.length === 0) {
    return true;
  }
  if (!Array.isArray(target)) {
    return false;
  }
  const countedIndex = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < source.length; i2++) {
    const sourceItem = source[i2];
    let found = false;
    for (let j3 = 0; j3 < target.length; j3++) {
      if (countedIndex.has(j3)) {
        continue;
      }
      const targetItem = target[j3];
      let matches2 = false;
      const isEqual2 = compare(targetItem, sourceItem, i2, target, source, stack);
      if (isEqual2) {
        matches2 = true;
      }
      if (matches2) {
        countedIndex.add(j3);
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function isSetMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Set)) {
    return false;
  }
  return isArrayMatch([...target], [...source], compare, stack);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isMatch.mjs
function isMatch(target, source) {
  return isMatchWith(target, source, () => void 0);
}

// ../../node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}

// ../../node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}

// ../../node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag2 = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// ../../node_modules/es-toolkit/dist/predicate/isTypedArray.mjs
function isTypedArray(x3) {
  return ArrayBuffer.isView(x3) && !(x3 instanceof DataView);
}

// ../../node_modules/es-toolkit/dist/object/cloneDeepWith.mjs
function cloneDeepWith(obj, cloneValue) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
}
function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
  if (cloned != null) {
    return cloned;
  }
  if (isPrimitive2(valueToClone)) {
    return valueToClone;
  }
  if (stack.has(valueToClone)) {
    return stack.get(valueToClone);
  }
  if (Array.isArray(valueToClone)) {
    const result2 = new Array(valueToClone.length);
    stack.set(valueToClone, result2);
    for (let i2 = 0; i2 < valueToClone.length; i2++) {
      result2[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
    }
    if (Object.hasOwn(valueToClone, "index")) {
      result2.index = valueToClone.index;
    }
    if (Object.hasOwn(valueToClone, "input")) {
      result2.input = valueToClone.input;
    }
    return result2;
  }
  if (valueToClone instanceof Date) {
    return new Date(valueToClone.getTime());
  }
  if (valueToClone instanceof RegExp) {
    const result2 = new RegExp(valueToClone.source, valueToClone.flags);
    result2.lastIndex = valueToClone.lastIndex;
    return result2;
  }
  if (valueToClone instanceof Map) {
    const result2 = /* @__PURE__ */ new Map();
    stack.set(valueToClone, result2);
    for (const [key, value] of valueToClone) {
      result2.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
    }
    return result2;
  }
  if (valueToClone instanceof Set) {
    const result2 = /* @__PURE__ */ new Set();
    stack.set(valueToClone, result2);
    for (const value of valueToClone) {
      result2.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
    }
    return result2;
  }
  if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
    return valueToClone.subarray();
  }
  if (isTypedArray(valueToClone)) {
    const result2 = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
    stack.set(valueToClone, result2);
    for (let i2 = 0; i2 < valueToClone.length; i2++) {
      result2[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
    }
    return result2;
  }
  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
    return valueToClone.slice(0);
  }
  if (valueToClone instanceof DataView) {
    const result2 = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (typeof File !== "undefined" && valueToClone instanceof File) {
    const result2 = new File([valueToClone], valueToClone.name, {
      type: valueToClone.type
    });
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (valueToClone instanceof Blob) {
    const result2 = new Blob([valueToClone], { type: valueToClone.type });
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (valueToClone instanceof Error) {
    const result2 = new valueToClone.constructor();
    stack.set(valueToClone, result2);
    result2.message = valueToClone.message;
    result2.name = valueToClone.name;
    result2.stack = valueToClone.stack;
    result2.cause = valueToClone.cause;
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
    const result2 = Object.create(Object.getPrototypeOf(valueToClone));
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  return valueToClone;
}
function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
  const keys2 = [...Object.keys(source), ...getSymbols(source)];
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const descriptor = Object.getOwnPropertyDescriptor(target, key);
    if (descriptor == null || descriptor.writable) {
      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
    }
  }
}
function isCloneableObject(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag2:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}

// ../../node_modules/es-toolkit/dist/object/cloneDeep.mjs
function cloneDeep(obj) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/matches.mjs
function matches(source) {
  source = cloneDeep(source);
  return (target) => {
    return isMatch(target, source);
  };
}

// ../../node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs
function cloneDeepWith2(obj, customizer) {
  return cloneDeepWith(obj, (value, key, object, stack) => {
    const cloned = customizer?.(value, key, object, stack);
    if (cloned != null) {
      return cloned;
    }
    if (typeof obj !== "object") {
      return void 0;
    }
    switch (Object.prototype.toString.call(obj)) {
      case numberTag:
      case stringTag:
      case booleanTag: {
        const result2 = new obj.constructor(obj?.valueOf());
        copyProperties(result2, obj);
        return result2;
      }
      case argumentsTag: {
        const result2 = {};
        copyProperties(result2, obj);
        result2.length = obj.length;
        result2[Symbol.iterator] = obj[Symbol.iterator];
        return result2;
      }
      default: {
        return void 0;
      }
    }
  });
}

// ../../node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs
function cloneDeep2(obj) {
  return cloneDeepWith2(obj);
}

// ../../node_modules/es-toolkit/dist/compat/_internal/isIndex.mjs
var IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
  switch (typeof value) {
    case "number": {
      return Number.isInteger(value) && value >= 0 && value < length;
    }
    case "symbol": {
      return false;
    }
    case "string": {
      return IS_UNSIGNED_INTEGER.test(value);
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs
function isArguments(value) {
  return value !== null && typeof value === "object" && getTag(value) === "[object Arguments]";
}

// ../../node_modules/es-toolkit/dist/compat/object/has.mjs
function has(object, path4) {
  let resolvedPath;
  if (Array.isArray(path4)) {
    resolvedPath = path4;
  } else if (typeof path4 === "string" && isDeepKey(path4) && object?.[path4] == null) {
    resolvedPath = toPath(path4);
  } else {
    resolvedPath = [path4];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object;
  for (let i2 = 0; i2 < resolvedPath.length; i2++) {
    const key = resolvedPath[i2];
    if (current == null || !Object.hasOwn(current, key)) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key];
  }
  return true;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/matchesProperty.mjs
function matchesProperty(property2, source) {
  switch (typeof property2) {
    case "object": {
      if (Object.is(property2?.valueOf(), -0)) {
        property2 = "-0";
      }
      break;
    }
    case "number": {
      property2 = toKey(property2);
      break;
    }
  }
  source = cloneDeep2(source);
  return function(target) {
    const result2 = get(target, property2);
    if (result2 === void 0) {
      return has(target, property2);
    }
    if (source === void 0) {
      return result2 === void 0;
    }
    return isMatch(result2, source);
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/iteratee.mjs
function iteratee(value) {
  if (value == null) {
    return identity;
  }
  switch (typeof value) {
    case "function": {
      return value;
    }
    case "object": {
      if (Array.isArray(value) && value.length === 2) {
        return matchesProperty(value[0], value[1]);
      }
      return matches(value);
    }
    case "string":
    case "symbol":
    case "number": {
      return property(value);
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/array/countBy.mjs
function countBy(collection, iteratee$1) {
  if (collection == null) {
    return {};
  }
  const array = isArrayLike(collection) ? Array.from(collection) : Object.values(collection);
  const mapper = iteratee(iteratee$1 ?? void 0);
  const result2 = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < array.length; i2++) {
    const item = array[i2];
    const key = mapper(item);
    result2[key] = (result2[key] ?? 0) + 1;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/array/difference.mjs
function difference(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => !secondSet.has(item));
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.mjs
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

// ../../node_modules/es-toolkit/dist/compat/array/difference.mjs
function difference2(arr, ...values2) {
  if (!isArrayLikeObject(arr)) {
    return [];
  }
  const arr1 = toArray(arr);
  const arr2 = [];
  for (let i2 = 0; i2 < values2.length; i2++) {
    const value = values2[i2];
    if (isArrayLikeObject(value)) {
      arr2.push(...Array.from(value));
    }
  }
  return difference(arr1, arr2);
}

// ../../node_modules/es-toolkit/dist/array/last.mjs
function last(arr) {
  return arr[arr.length - 1];
}

// ../../node_modules/es-toolkit/dist/compat/array/last.mjs
function last2(array) {
  if (!isArrayLike(array)) {
    return void 0;
  }
  return last(toArray(array));
}

// ../../node_modules/es-toolkit/dist/array/differenceBy.mjs
function differenceBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map((item) => mapper(item)));
  return firstArr.filter((item) => {
    return !mappedSecondSet.has(mapper(item));
  });
}

// ../../node_modules/es-toolkit/dist/compat/_internal/flattenArrayLike.mjs
function flattenArrayLike(values2) {
  const result2 = [];
  for (let i2 = 0; i2 < values2.length; i2++) {
    const arrayLike = values2[i2];
    if (!isArrayLikeObject(arrayLike)) {
      continue;
    }
    for (let j3 = 0; j3 < arrayLike.length; j3++) {
      result2.push(arrayLike[j3]);
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/differenceBy.mjs
function differenceBy2(arr, ..._values) {
  if (!isArrayLikeObject(arr)) {
    return [];
  }
  const iteratee$1 = last2(_values);
  const values2 = flattenArrayLike(_values);
  if (isArrayLikeObject(iteratee$1)) {
    return difference(Array.from(arr), values2);
  }
  return differenceBy(Array.from(arr), values2, iteratee(iteratee$1));
}

// ../../node_modules/es-toolkit/dist/array/differenceWith.mjs
function differenceWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.every((secondItem) => {
      return !areItemsEqual(firstItem, secondItem);
    });
  });
}

// ../../node_modules/es-toolkit/dist/compat/array/differenceWith.mjs
function differenceWith2(array, ...values2) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const comparator = last2(values2);
  const flattenedValues = flattenArrayLike(values2);
  if (typeof comparator === "function") {
    return differenceWith(Array.from(array), flattenedValues, comparator);
  }
  return difference(Array.from(array), flattenedValues);
}

// ../../node_modules/es-toolkit/dist/array/drop.mjs
function drop(arr, itemsCount) {
  itemsCount = Math.max(itemsCount, 0);
  return arr.slice(itemsCount);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isSymbol.mjs
function isSymbol(value) {
  return typeof value === "symbol" || value instanceof Symbol;
}

// ../../node_modules/es-toolkit/dist/compat/util/toNumber.mjs
function toNumber(value) {
  if (isSymbol(value)) {
    return NaN;
  }
  return Number(value);
}

// ../../node_modules/es-toolkit/dist/compat/util/toFinite.mjs
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === Infinity || value === -Infinity) {
    const sign = value < 0 ? -1 : 1;
    return sign * Number.MAX_VALUE;
  }
  return value === value ? value : 0;
}

// ../../node_modules/es-toolkit/dist/compat/util/toInteger.mjs
function toInteger(value) {
  const finite = toFinite(value);
  const remainder = finite % 1;
  return remainder ? finite - remainder : finite;
}

// ../../node_modules/es-toolkit/dist/compat/array/drop.mjs
function drop2(collection, itemsCount = 1, guard) {
  if (!isArrayLike(collection)) {
    return [];
  }
  itemsCount = guard ? 1 : toInteger(itemsCount);
  return drop(toArray(collection), itemsCount);
}

// ../../node_modules/es-toolkit/dist/array/dropRight.mjs
function dropRight(arr, itemsCount) {
  itemsCount = Math.min(-itemsCount, 0);
  if (itemsCount === 0) {
    return arr.slice();
  }
  return arr.slice(0, itemsCount);
}

// ../../node_modules/es-toolkit/dist/compat/array/dropRight.mjs
function dropRight2(collection, itemsCount = 1, guard) {
  if (!isArrayLike(collection)) {
    return [];
  }
  itemsCount = guard ? 1 : toInteger(itemsCount);
  return dropRight(toArray(collection), itemsCount);
}

// ../../node_modules/es-toolkit/dist/array/dropRightWhile.mjs
function dropRightWhile(arr, canContinueDropping) {
  for (let i2 = arr.length - 1; i2 >= 0; i2--) {
    if (!canContinueDropping(arr[i2], i2, arr)) {
      return arr.slice(0, i2 + 1);
    }
  }
  return [];
}

// ../../node_modules/es-toolkit/dist/compat/array/dropRightWhile.mjs
function dropRightWhile2(arr, predicate = identity) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return dropRightWhileImpl(Array.from(arr), predicate);
}
function dropRightWhileImpl(arr, predicate) {
  switch (typeof predicate) {
    case "function": {
      return dropRightWhile(arr, (item, index, arr2) => Boolean(predicate(item, index, arr2)));
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key = predicate[0];
        const value = predicate[1];
        return dropRightWhile(arr, matchesProperty(key, value));
      } else {
        return dropRightWhile(arr, matches(predicate));
      }
    }
    case "symbol":
    case "number":
    case "string": {
      return dropRightWhile(arr, property(predicate));
    }
  }
}

// ../../node_modules/es-toolkit/dist/array/dropWhile.mjs
function dropWhile(arr, canContinueDropping) {
  const dropEndIndex = arr.findIndex((item, index, arr2) => !canContinueDropping(item, index, arr2));
  if (dropEndIndex === -1) {
    return [];
  }
  return arr.slice(dropEndIndex);
}

// ../../node_modules/es-toolkit/dist/compat/array/dropWhile.mjs
function dropWhile2(arr, predicate = identity) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return dropWhileImpl(toArray(arr), predicate);
}
function dropWhileImpl(arr, predicate) {
  switch (typeof predicate) {
    case "function": {
      return dropWhile(arr, (item, index, arr2) => Boolean(predicate(item, index, arr2)));
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key = predicate[0];
        const value = predicate[1];
        return dropWhile(arr, matchesProperty(key, value));
      } else {
        return dropWhile(arr, matches(predicate));
      }
    }
    case "number":
    case "symbol":
    case "string": {
      return dropWhile(arr, property(predicate));
    }
  }
}

// ../../node_modules/es-toolkit/dist/math/range.mjs
function range(start, end, step = 1) {
  if (end == null) {
    end = start;
    start = 0;
  }
  if (!Number.isInteger(step) || step === 0) {
    throw new Error(`The step value must be a non-zero integer.`);
  }
  const length = Math.max(Math.ceil((end - start) / step), 0);
  const result2 = new Array(length);
  for (let i2 = 0; i2 < length; i2++) {
    result2[i2] = start + i2 * step;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/forEach.mjs
function forEach(collection, callback = identity) {
  if (!collection) {
    return collection;
  }
  const keys2 = isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = collection[key];
    const result2 = callback(value, key, collection);
    if (result2 === false) {
      break;
    }
  }
  return collection;
}

// ../../node_modules/es-toolkit/dist/compat/array/forEachRight.mjs
function forEachRight(collection, callback = identity) {
  if (!collection) {
    return collection;
  }
  const keys2 = isArrayLike(collection) ? range(0, collection.length) : Object.keys(collection);
  for (let i2 = keys2.length - 1; i2 >= 0; i2--) {
    const key = keys2[i2];
    const value = collection[key];
    const result2 = callback(value, key, collection);
    if (result2 === false) {
      break;
    }
  }
  return collection;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.mjs
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  if (typeof index === "number" && isArrayLike(object) && isIndex(index) && index < object.length || typeof index === "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}

// ../../node_modules/es-toolkit/dist/compat/array/every.mjs
function every(source, doesMatch, guard) {
  if (!source) {
    return true;
  }
  if (guard && isIterateeCall(source, doesMatch, guard)) {
    doesMatch = void 0;
  }
  if (!doesMatch) {
    doesMatch = identity;
  }
  let predicate;
  switch (typeof doesMatch) {
    case "function": {
      predicate = doesMatch;
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        predicate = matchesProperty(key, value);
      } else {
        predicate = matches(doesMatch);
      }
      break;
    }
    case "symbol":
    case "number":
    case "string": {
      predicate = property(doesMatch);
    }
  }
  if (!isArrayLike(source)) {
    const keys2 = Object.keys(source);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const value = source[key];
      if (!predicate(value, key, source)) {
        return false;
      }
    }
    return true;
  }
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!predicate(source[i2], i2, source)) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/es-toolkit/dist/array/fill.mjs
function fill2(array, value, start = 0, end = array.length) {
  const length = array.length;
  const finalStart = Math.max(start >= 0 ? start : length + start, 0);
  const finalEnd = Math.min(end >= 0 ? end : length + end, length);
  for (let i2 = finalStart; i2 < finalEnd; i2++) {
    array[i2] = value;
  }
  return array;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isString.mjs
function isString2(value) {
  return typeof value === "string" || value instanceof String;
}

// ../../node_modules/es-toolkit/dist/compat/array/fill.mjs
function fill3(array, value, start = 0, end = array ? array.length : 0) {
  if (!isArrayLike(array)) {
    return [];
  }
  if (isString2(array)) {
    return array;
  }
  start = Math.floor(start);
  end = Math.floor(end);
  if (!start) {
    start = 0;
  }
  if (!end) {
    end = 0;
  }
  return fill2(array, value, start, end);
}

// ../../node_modules/es-toolkit/dist/compat/array/filter.mjs
function filter(source, predicate = identity) {
  if (!source) {
    return [];
  }
  predicate = iteratee(predicate);
  if (!Array.isArray(source)) {
    const result3 = [];
    const keys2 = Object.keys(source);
    const length2 = isArrayLike(source) ? source.length : keys2.length;
    for (let i2 = 0; i2 < length2; i2++) {
      const key = keys2[i2];
      const value = source[key];
      if (predicate(value, key, source)) {
        result3.push(value);
      }
    }
    return result3;
  }
  const result2 = [];
  const length = source.length;
  for (let i2 = 0; i2 < length; i2++) {
    const value = source[i2];
    if (predicate(value, i2, source)) {
      result2.push(value);
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/find.mjs
function find(source, _doesMatch = identity, fromIndex = 0) {
  if (!source) {
    return void 0;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(source.length + fromIndex, 0);
  }
  const doesMatch = iteratee(_doesMatch);
  if (typeof doesMatch === "function" && !Array.isArray(source)) {
    const keys2 = Object.keys(source);
    for (let i2 = fromIndex; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const value = source[key];
      if (doesMatch(value, key, source)) {
        return value;
      }
    }
    return void 0;
  }
  const values2 = Array.isArray(source) ? source.slice(fromIndex) : Object.values(source).slice(fromIndex);
  return values2.find(doesMatch);
}

// ../../node_modules/es-toolkit/dist/compat/array/findIndex.mjs
function findIndex(arr, doesMatch, fromIndex = 0) {
  if (!arr) {
    return -1;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(arr.length + fromIndex, 0);
  }
  const subArray = Array.from(arr).slice(fromIndex);
  let index = -1;
  switch (typeof doesMatch) {
    case "function": {
      index = subArray.findIndex(doesMatch);
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        index = subArray.findIndex(matchesProperty(key, value));
      } else {
        index = subArray.findIndex(matches(doesMatch));
      }
      break;
    }
    case "number":
    case "symbol":
    case "string": {
      index = subArray.findIndex(property(doesMatch));
    }
  }
  return index === -1 ? -1 : index + fromIndex;
}

// ../../node_modules/es-toolkit/dist/compat/array/findLast.mjs
function findLast(source, _doesMatch = identity, fromIndex) {
  if (!source) {
    return void 0;
  }
  const length = Array.isArray(source) ? source.length : Object.keys(source).length;
  fromIndex = toInteger(fromIndex ?? length - 1);
  if (fromIndex < 0) {
    fromIndex = Math.max(length + fromIndex, 0);
  } else {
    fromIndex = Math.min(fromIndex, length - 1);
  }
  const doesMatch = iteratee(_doesMatch);
  if (typeof doesMatch === "function" && !Array.isArray(source)) {
    const keys2 = Object.keys(source);
    for (let i2 = fromIndex; i2 >= 0; i2--) {
      const key = keys2[i2];
      const value = source[key];
      if (doesMatch(value, key, source)) {
        return value;
      }
    }
    return void 0;
  }
  const values2 = Array.isArray(source) ? source.slice(0, fromIndex + 1) : Object.values(source).slice(0, fromIndex + 1);
  return values2.findLast(doesMatch);
}

// ../../node_modules/es-toolkit/dist/compat/array/findLastIndex.mjs
function findLastIndex(arr, doesMatch = identity, fromIndex = arr ? arr.length - 1 : 0) {
  if (!arr) {
    return -1;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(arr.length + fromIndex, 0);
  } else {
    fromIndex = Math.min(fromIndex, arr.length - 1);
  }
  const subArray = toArray(arr).slice(0, fromIndex + 1);
  switch (typeof doesMatch) {
    case "function": {
      return subArray.findLastIndex(doesMatch);
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        return subArray.findLastIndex(matchesProperty(key, value));
      } else {
        return subArray.findLastIndex(matches(doesMatch));
      }
    }
    case "number":
    case "symbol":
    case "string": {
      return subArray.findLastIndex(property(doesMatch));
    }
  }
}

// ../../node_modules/es-toolkit/dist/array/head.mjs
function head(arr) {
  return arr[0];
}

// ../../node_modules/es-toolkit/dist/compat/array/head.mjs
function head2(arr) {
  if (!isArrayLike(arr)) {
    return void 0;
  }
  return head(toArray(arr));
}

// ../../node_modules/es-toolkit/dist/compat/array/flatten.mjs
function flatten2(value, depth = 1) {
  const result2 = [];
  const flooredDepth = Math.floor(depth);
  if (!isArrayLike(value)) {
    return result2;
  }
  const recursive = (arr, currentDepth) => {
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      if (currentDepth < flooredDepth && (Array.isArray(item) || Boolean(item?.[Symbol.isConcatSpreadable]) || item !== null && typeof item === "object" && Object.prototype.toString.call(item) === "[object Arguments]")) {
        if (Array.isArray(item)) {
          recursive(item, currentDepth + 1);
        } else {
          recursive(Array.from(item), currentDepth + 1);
        }
      } else {
        result2.push(item);
      }
    }
  };
  recursive(Array.from(value), 0);
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/flattenDepth.mjs
function flattenDepth(array, depth = 1) {
  return flatten2(array, depth);
}

// ../../node_modules/es-toolkit/dist/compat/array/map.mjs
function map(collection, _iteratee) {
  if (!collection) {
    return [];
  }
  const keys2 = isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);
  const iteratee$1 = iteratee(_iteratee ?? identity);
  const result2 = new Array(keys2.length);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = collection[key];
    result2[i2] = iteratee$1(value, key, collection);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/predicate/isNil.mjs
function isNil(x3) {
  return x3 == null;
}

// ../../node_modules/es-toolkit/dist/compat/array/flatMap.mjs
function flatMap(collection, iteratee2) {
  if (isNil(collection)) {
    return [];
  }
  const mapped = isNil(iteratee2) ? map(collection) : map(collection, iteratee2);
  return flattenDepth(mapped, 1);
}

// ../../node_modules/es-toolkit/dist/compat/array/flatMapDepth.mjs
function flatMapDepth(collection, iteratee$1 = identity, depth = 1) {
  if (collection == null) {
    return [];
  }
  const iterateeFn = iteratee(iteratee$1);
  const mapped = map(collection, iterateeFn);
  return flatten2(mapped, depth);
}

// ../../node_modules/es-toolkit/dist/compat/array/flatMapDeep.mjs
function flatMapDeep(collection, iteratee2) {
  return flatMapDepth(collection, iteratee2, Infinity);
}

// ../../node_modules/es-toolkit/dist/compat/array/flattenDeep.mjs
function flattenDeep(value) {
  return flattenDepth(value, Infinity);
}

// ../../node_modules/es-toolkit/dist/array/groupBy.mjs
function groupBy(arr, getKeyFromItem) {
  const result2 = {};
  for (let i2 = 0; i2 < arr.length; i2++) {
    const item = arr[i2];
    const key = getKeyFromItem(item);
    if (!Object.hasOwn(result2, key)) {
      result2[key] = [];
    }
    result2[key].push(item);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/groupBy.mjs
function groupBy2(source, _getKeyFromItem) {
  if (source == null) {
    return {};
  }
  const items = isArrayLike(source) ? Array.from(source) : Object.values(source);
  const getKeyFromItem = iteratee(_getKeyFromItem ?? identity);
  return groupBy(items, getKeyFromItem);
}

// ../../node_modules/es-toolkit/dist/compat/array/includes.mjs
function includes(source, target, fromIndex, guard) {
  if (source == null) {
    return false;
  }
  if (guard || !fromIndex) {
    fromIndex = 0;
  } else {
    fromIndex = toInteger(fromIndex);
  }
  if (isString2(source)) {
    if (fromIndex > source.length || target instanceof RegExp) {
      return false;
    }
    if (fromIndex < 0) {
      fromIndex = Math.max(0, source.length + fromIndex);
    }
    return source.includes(target, fromIndex);
  }
  if (Array.isArray(source)) {
    return source.includes(target, fromIndex);
  }
  const keys2 = Object.keys(source);
  if (fromIndex < 0) {
    fromIndex = Math.max(0, keys2.length + fromIndex);
  }
  for (let i2 = fromIndex; i2 < keys2.length; i2++) {
    const value = Reflect.get(source, keys2[i2]);
    if (eq(value, target)) {
      return true;
    }
  }
  return false;
}

// ../../node_modules/es-toolkit/dist/compat/array/indexOf.mjs
function indexOf(array, searchElement, fromIndex) {
  if (!isArrayLike(array)) {
    return -1;
  }
  if (Number.isNaN(searchElement)) {
    fromIndex = fromIndex ?? 0;
    if (fromIndex < 0) {
      fromIndex = Math.max(0, array.length + fromIndex);
    }
    for (let i2 = fromIndex; i2 < array.length; i2++) {
      if (Number.isNaN(array[i2])) {
        return i2;
      }
    }
    return -1;
  }
  return Array.from(array).indexOf(searchElement, fromIndex);
}

// ../../node_modules/es-toolkit/dist/array/initial.mjs
function initial(arr) {
  return arr.slice(0, -1);
}

// ../../node_modules/es-toolkit/dist/compat/array/initial.mjs
function initial2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return initial(Array.from(arr));
}

// ../../node_modules/es-toolkit/dist/array/intersection.mjs
function intersection(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => {
    return secondSet.has(item);
  });
}

// ../../node_modules/es-toolkit/dist/array/uniq.mjs
function uniq(arr) {
  return Array.from(new Set(arr));
}

// ../../node_modules/es-toolkit/dist/compat/array/intersection.mjs
function intersection2(...arrays) {
  if (arrays.length === 0) {
    return [];
  }
  if (!isArrayLikeObject(arrays[0])) {
    return [];
  }
  let result2 = uniq(Array.from(arrays[0]));
  for (let i2 = 1; i2 < arrays.length; i2++) {
    const array = arrays[i2];
    if (!isArrayLikeObject(array)) {
      return [];
    }
    result2 = intersection(result2, Array.from(array));
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/array/intersectionBy.mjs
function intersectionBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map(mapper));
  return firstArr.filter((item) => mappedSecondSet.has(mapper(item)));
}

// ../../node_modules/es-toolkit/dist/compat/array/intersectionBy.mjs
function intersectionBy2(array, ...values2) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const lastValue = last(values2);
  if (lastValue === void 0) {
    return Array.from(array);
  }
  let result2 = uniq(Array.from(array));
  const count = isArrayLikeObject(lastValue) ? values2.length : values2.length - 1;
  for (let i2 = 0; i2 < count; ++i2) {
    const value = values2[i2];
    if (!isArrayLikeObject(value)) {
      return [];
    }
    if (isArrayLikeObject(lastValue)) {
      result2 = intersectionBy(result2, Array.from(value), identity);
    } else if (typeof lastValue === "function") {
      result2 = intersectionBy(result2, Array.from(value), (value2) => lastValue(value2));
    } else if (typeof lastValue === "string") {
      result2 = intersectionBy(result2, Array.from(value), property(lastValue));
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/array/intersectionWith.mjs
function intersectionWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.some((secondItem) => {
      return areItemsEqual(firstItem, secondItem);
    });
  });
}

// ../../node_modules/es-toolkit/dist/compat/array/uniq.mjs
function uniq2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return uniq(Array.from(arr));
}

// ../../node_modules/es-toolkit/dist/compat/array/intersectionWith.mjs
function intersectionWith2(firstArr, ...otherArrs) {
  if (firstArr == null) {
    return [];
  }
  const _comparator = last2(otherArrs);
  let comparator = eq;
  let uniq$1 = uniq2;
  if (typeof _comparator === "function") {
    comparator = _comparator;
    uniq$1 = uniqPreserve0;
    otherArrs.pop();
  }
  let result2 = uniq$1(Array.from(firstArr));
  for (let i2 = 0; i2 < otherArrs.length; ++i2) {
    const otherArr = otherArrs[i2];
    if (otherArr == null) {
      return [];
    }
    result2 = intersectionWith(result2, Array.from(otherArr), comparator);
  }
  return result2;
}
function uniqPreserve0(arr) {
  const result2 = [];
  const added = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < arr.length; i2++) {
    const item = arr[i2];
    if (added.has(item)) {
      continue;
    }
    result2.push(item);
    added.add(item);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/predicate/isFunction.mjs
function isFunction(value) {
  return typeof value === "function";
}

// ../../node_modules/es-toolkit/dist/compat/array/invokeMap.mjs
function invokeMap(collection, path4, ...args) {
  if (isNil(collection)) {
    return [];
  }
  const values2 = isArrayLike(collection) ? Array.from(collection) : Object.values(collection);
  const result2 = [];
  for (let i2 = 0; i2 < values2.length; i2++) {
    const value = values2[i2];
    if (isFunction(path4)) {
      result2.push(path4.apply(value, args));
      continue;
    }
    const method2 = get(value, path4);
    let thisContext = value;
    if (Array.isArray(path4)) {
      const pathExceptLast = path4.slice(0, -1);
      if (pathExceptLast.length > 0) {
        thisContext = get(value, pathExceptLast);
      }
    } else if (typeof path4 === "string" && path4.includes(".")) {
      const parts = path4.split(".");
      const pathExceptLast = parts.slice(0, -1).join(".");
      thisContext = get(value, pathExceptLast);
    }
    result2.push(method2 == null ? void 0 : method2.apply(thisContext, args));
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/join.mjs
function join(array, separator) {
  if (!isArrayLike(array)) {
    return "";
  }
  return Array.from(array).join(separator);
}

// ../../node_modules/es-toolkit/dist/compat/array/reduce.mjs
function reduce(collection, iteratee2 = identity, accumulator) {
  if (!collection) {
    return accumulator;
  }
  let keys2;
  let startIndex = 0;
  if (isArrayLike(collection)) {
    keys2 = range(0, collection.length);
    if (accumulator == null && collection.length > 0) {
      accumulator = collection[0];
      startIndex += 1;
    }
  } else {
    keys2 = Object.keys(collection);
    if (accumulator == null) {
      accumulator = collection[keys2[0]];
      startIndex += 1;
    }
  }
  for (let i2 = startIndex; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = collection[key];
    accumulator = iteratee2(accumulator, value, key, collection);
  }
  return accumulator;
}

// ../../node_modules/es-toolkit/dist/compat/array/keyBy.mjs
function keyBy(collection, iteratee$1) {
  if (!isArrayLike(collection) && !isObjectLike(collection)) {
    return {};
  }
  const keyFn = iteratee(iteratee$1 ?? identity);
  return reduce(collection, (result2, value) => {
    const key = keyFn(value);
    result2[key] = value;
    return result2;
  }, {});
}

// ../../node_modules/es-toolkit/dist/compat/array/lastIndexOf.mjs
function lastIndexOf(array, searchElement, fromIndex) {
  if (!isArrayLike(array) || array.length === 0) {
    return -1;
  }
  const length = array.length;
  let index = fromIndex ?? length - 1;
  if (fromIndex != null) {
    index = index < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);
  }
  if (Number.isNaN(searchElement)) {
    for (let i2 = index; i2 >= 0; i2--) {
      if (Number.isNaN(array[i2])) {
        return i2;
      }
    }
  }
  return Array.from(array).lastIndexOf(searchElement, index);
}

// ../../node_modules/es-toolkit/dist/compat/array/nth.mjs
function nth(array, n2 = 0) {
  if (!isArrayLikeObject(array) || array.length === 0) {
    return void 0;
  }
  n2 = toInteger(n2);
  if (n2 < 0) {
    n2 += array.length;
  }
  return array[n2];
}

// ../../node_modules/es-toolkit/dist/compat/_internal/compareValues.mjs
function getPriority(a2) {
  if (typeof a2 === "symbol") {
    return 1;
  }
  if (a2 === null) {
    return 2;
  }
  if (a2 === void 0) {
    return 3;
  }
  if (a2 !== a2) {
    return 4;
  }
  return 0;
}
var compareValues = (a2, b2, order) => {
  if (a2 !== b2) {
    const aPriority = getPriority(a2);
    const bPriority = getPriority(b2);
    if (aPriority === bPriority && aPriority === 0) {
      if (a2 < b2) {
        return order === "desc" ? 1 : -1;
      }
      if (a2 > b2) {
        return order === "desc" ? -1 : 1;
      }
    }
    return order === "desc" ? bPriority - aPriority : aPriority - bPriority;
  }
  return 0;
};

// ../../node_modules/es-toolkit/dist/compat/_internal/isKey.mjs
var regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var regexIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (Array.isArray(value)) {
    return false;
  }
  if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
}

// ../../node_modules/es-toolkit/dist/compat/array/orderBy.mjs
function orderBy(collection, criteria, orders, guard) {
  if (collection == null) {
    return [];
  }
  orders = guard ? void 0 : orders;
  if (!Array.isArray(collection)) {
    collection = Object.values(collection);
  }
  if (!Array.isArray(criteria)) {
    criteria = criteria == null ? [null] : [criteria];
  }
  if (criteria.length === 0) {
    criteria = [null];
  }
  if (!Array.isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }
  orders = orders.map((order) => String(order));
  const getValueByNestedPath = (object, path4) => {
    let target = object;
    for (let i2 = 0; i2 < path4.length && target != null; ++i2) {
      target = target[path4[i2]];
    }
    return target;
  };
  const getValueByCriterion = (criterion, object) => {
    if (object == null || criterion == null) {
      return object;
    }
    if (typeof criterion === "object" && "key" in criterion) {
      if (Object.hasOwn(object, criterion.key)) {
        return object[criterion.key];
      }
      return getValueByNestedPath(object, criterion.path);
    }
    if (typeof criterion === "function") {
      return criterion(object);
    }
    if (Array.isArray(criterion)) {
      return getValueByNestedPath(object, criterion);
    }
    if (typeof object === "object") {
      return object[criterion];
    }
    return object;
  };
  const preparedCriteria = criteria.map((criterion) => {
    if (Array.isArray(criterion) && criterion.length === 1) {
      criterion = criterion[0];
    }
    if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey(criterion)) {
      return criterion;
    }
    return { key: criterion, path: toPath(criterion) };
  });
  const preparedCollection = collection.map((item) => ({
    original: item,
    criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
  }));
  return preparedCollection.slice().sort((a2, b2) => {
    for (let i2 = 0; i2 < preparedCriteria.length; i2++) {
      const comparedResult = compareValues(a2.criteria[i2], b2.criteria[i2], orders[i2]);
      if (comparedResult !== 0) {
        return comparedResult;
      }
    }
    return 0;
  }).map((item) => item.original);
}

// ../../node_modules/es-toolkit/dist/compat/array/partition.mjs
function partition(source, predicate = identity) {
  if (!source) {
    return [[], []];
  }
  const collection = isArrayLike(source) ? source : Object.values(source);
  predicate = iteratee(predicate);
  const matched = [];
  const unmatched = [];
  for (let i2 = 0; i2 < collection.length; i2++) {
    const value = collection[i2];
    if (predicate(value)) {
      matched.push(value);
    } else {
      unmatched.push(value);
    }
  }
  return [matched, unmatched];
}

// ../../node_modules/es-toolkit/dist/array/pull.mjs
function pull(arr, valuesToRemove) {
  const valuesSet = new Set(valuesToRemove);
  let resultIndex = 0;
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (valuesSet.has(arr[i2])) {
      continue;
    }
    if (!Object.hasOwn(arr, i2)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i2];
  }
  arr.length = resultIndex;
  return arr;
}

// ../../node_modules/es-toolkit/dist/compat/array/pull.mjs
function pull2(arr, ...valuesToRemove) {
  return pull(arr, valuesToRemove);
}

// ../../node_modules/es-toolkit/dist/compat/array/pullAll.mjs
function pullAll(arr, valuesToRemove = []) {
  return pull(arr, Array.from(valuesToRemove));
}

// ../../node_modules/es-toolkit/dist/compat/array/pullAllBy.mjs
function pullAllBy(arr, valuesToRemove, _getValue) {
  const getValue = iteratee(_getValue);
  const valuesSet = new Set(Array.from(valuesToRemove).map((x3) => getValue(x3)));
  let resultIndex = 0;
  for (let i2 = 0; i2 < arr.length; i2++) {
    const value = getValue(arr[i2]);
    if (valuesSet.has(value)) {
      continue;
    }
    if (!Object.hasOwn(arr, i2)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i2];
  }
  arr.length = resultIndex;
  return arr;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/copyArray.mjs
function copyArray(source, array) {
  const length = source.length;
  if (array == null) {
    array = Array(length);
  }
  for (let i2 = 0; i2 < length; i2++) {
    array[i2] = source[i2];
  }
  return array;
}

// ../../node_modules/es-toolkit/dist/compat/array/pullAllWith.mjs
function pullAllWith(array, values2, comparator) {
  if (array?.length == null || values2?.length == null) {
    return array;
  }
  if (array === values2) {
    values2 = copyArray(values2);
  }
  let resultLength = 0;
  if (comparator == null) {
    comparator = (a2, b2) => eq(a2, b2);
  }
  const valuesArray = Array.isArray(values2) ? values2 : Array.from(values2);
  const hasUndefined = valuesArray.includes(void 0);
  for (let i2 = 0; i2 < array.length; i2++) {
    if (i2 in array) {
      const shouldRemove = valuesArray.some((value) => comparator(array[i2], value));
      if (!shouldRemove) {
        array[resultLength++] = array[i2];
      }
      continue;
    }
    if (!hasUndefined) {
      delete array[resultLength++];
    }
  }
  array.length = resultLength;
  return array;
}

// ../../node_modules/es-toolkit/dist/compat/object/at.mjs
function at(object, ...paths) {
  if (paths.length === 0) {
    return [];
  }
  const allPaths = [];
  for (let i2 = 0; i2 < paths.length; i2++) {
    const path4 = paths[i2];
    if (!isArrayLike(path4) || isString2(path4)) {
      allPaths.push(path4);
      continue;
    }
    for (let j3 = 0; j3 < path4.length; j3++) {
      allPaths.push(path4[j3]);
    }
  }
  const result2 = [];
  for (let i2 = 0; i2 < allPaths.length; i2++) {
    result2.push(get(object, allPaths[i2]));
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/unset.mjs
function unset(obj, path4) {
  if (obj == null) {
    return true;
  }
  switch (typeof path4) {
    case "symbol":
    case "number":
    case "object": {
      if (Array.isArray(path4)) {
        return unsetWithPath(obj, path4);
      }
      if (typeof path4 === "number") {
        path4 = toKey(path4);
      } else if (typeof path4 === "object") {
        if (Object.is(path4?.valueOf(), -0)) {
          path4 = "-0";
        } else {
          path4 = String(path4);
        }
      }
      if (isUnsafeProperty(path4)) {
        return false;
      }
      if (obj?.[path4] === void 0) {
        return true;
      }
      try {
        delete obj[path4];
        return true;
      } catch {
        return false;
      }
    }
    case "string": {
      if (obj?.[path4] === void 0 && isDeepKey(path4)) {
        return unsetWithPath(obj, toPath(path4));
      }
      if (isUnsafeProperty(path4)) {
        return false;
      }
      try {
        delete obj[path4];
        return true;
      } catch {
        return false;
      }
    }
  }
}
function unsetWithPath(obj, path4) {
  const parent = get(obj, path4.slice(0, -1), obj);
  const lastKey = path4[path4.length - 1];
  if (parent?.[lastKey] === void 0) {
    return true;
  }
  if (isUnsafeProperty(lastKey)) {
    return false;
  }
  try {
    delete parent[lastKey];
    return true;
  } catch {
    return false;
  }
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isArray.mjs
function isArray(value) {
  return Array.isArray(value);
}

// ../../node_modules/es-toolkit/dist/compat/array/pullAt.mjs
function pullAt(array, ..._indices) {
  const indices = flattenDepth(_indices, 1);
  if (!array) {
    return Array(indices.length);
  }
  const result2 = at(array, indices);
  const indicesToPull = indices.map((index) => isIndex(index, array.length) ? Number(index) : index).sort((a2, b2) => b2 - a2);
  for (const index of new Set(indicesToPull)) {
    if (isIndex(index, array.length)) {
      Array.prototype.splice.call(array, index, 1);
      continue;
    }
    if (isKey(index, array)) {
      delete array[toKey(index)];
      continue;
    }
    const path4 = isArray(index) ? index : toPath(index);
    unset(array, path4);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/reduceRight.mjs
function reduceRight(collection, iteratee2 = identity, accumulator) {
  if (!collection) {
    return accumulator;
  }
  let keys2;
  let startIndex;
  if (isArrayLike(collection)) {
    keys2 = range(0, collection.length).reverse();
    if (accumulator == null && collection.length > 0) {
      accumulator = collection[collection.length - 1];
      startIndex = 1;
    } else {
      startIndex = 0;
    }
  } else {
    keys2 = Object.keys(collection).reverse();
    if (accumulator == null) {
      accumulator = collection[keys2[0]];
      startIndex = 1;
    } else {
      startIndex = 0;
    }
  }
  for (let i2 = startIndex; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = collection[key];
    accumulator = iteratee2(accumulator, value, key, collection);
  }
  return accumulator;
}

// ../../node_modules/es-toolkit/dist/compat/function/negate.mjs
function negate(func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return function(...args) {
    return !func.apply(this, args);
  };
}

// ../../node_modules/es-toolkit/dist/compat/array/reject.mjs
function reject(source, predicate = identity) {
  return filter(source, negate(iteratee(predicate)));
}

// ../../node_modules/es-toolkit/dist/array/remove.mjs
function remove(arr, shouldRemoveElement) {
  const originalArr = arr.slice();
  const removed = [];
  let resultIndex = 0;
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (shouldRemoveElement(arr[i2], i2, originalArr)) {
      removed.push(arr[i2]);
      continue;
    }
    if (!Object.hasOwn(arr, i2)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i2];
  }
  arr.length = resultIndex;
  return removed;
}

// ../../node_modules/es-toolkit/dist/compat/array/remove.mjs
function remove2(arr, shouldRemoveElement = identity) {
  return remove(arr, iteratee(shouldRemoveElement));
}

// ../../node_modules/es-toolkit/dist/compat/array/reverse.mjs
function reverse(array) {
  if (array == null) {
    return array;
  }
  return array.reverse();
}

// ../../node_modules/es-toolkit/dist/array/sample.mjs
function sample(arr) {
  const randomIndex = Math.floor(Math.random() * arr.length);
  return arr[randomIndex];
}

// ../../node_modules/es-toolkit/dist/compat/array/sample.mjs
function sample2(collection) {
  if (collection == null) {
    return void 0;
  }
  if (isArrayLike(collection)) {
    return sample(toArray(collection));
  }
  return sample(Object.values(collection));
}

// ../../node_modules/es-toolkit/dist/math/random.mjs
function random(minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
  }
  return Math.random() * (maximum - minimum) + minimum;
}

// ../../node_modules/es-toolkit/dist/math/randomInt.mjs
function randomInt(minimum, maximum) {
  return Math.floor(random(minimum, maximum));
}

// ../../node_modules/es-toolkit/dist/array/sampleSize.mjs
function sampleSize(array, size2) {
  if (size2 > array.length) {
    throw new Error("Size must be less than or equal to the length of array.");
  }
  const result2 = new Array(size2);
  const selected = /* @__PURE__ */ new Set();
  for (let step = array.length - size2, resultIndex = 0; step < array.length; step++, resultIndex++) {
    let index = randomInt(0, step + 1);
    if (selected.has(index)) {
      index = step;
    }
    selected.add(index);
    result2[resultIndex] = array[index];
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/math/clamp.mjs
function clamp(value, bound1, bound2) {
  if (bound2 == null) {
    return Math.min(value, bound1);
  }
  return Math.min(Math.max(value, bound1), bound2);
}

// ../../node_modules/es-toolkit/dist/compat/math/clamp.mjs
function clamp2(value, bound1, bound2) {
  if (Number.isNaN(bound1)) {
    bound1 = 0;
  }
  if (Number.isNaN(bound2)) {
    bound2 = 0;
  }
  return clamp(value, bound1, bound2);
}

// ../../node_modules/es-toolkit/dist/predicate/isMap.mjs
function isMap(value) {
  return value instanceof Map;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isMap.mjs
function isMap2(value) {
  return isMap(value);
}

// ../../node_modules/es-toolkit/dist/compat/util/toArray.mjs
function toArray2(value) {
  if (value == null) {
    return [];
  }
  if (isArrayLike(value) || isMap2(value)) {
    return Array.from(value);
  }
  if (typeof value === "object") {
    return Object.values(value);
  }
  return [];
}

// ../../node_modules/es-toolkit/dist/compat/array/sampleSize.mjs
function sampleSize2(collection, size2, guard) {
  const arrayCollection = toArray2(collection);
  if (guard ? isIterateeCall(collection, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = clamp2(toInteger(size2), 0, arrayCollection.length);
  }
  return sampleSize(arrayCollection, size2);
}

// ../../node_modules/es-toolkit/dist/array/shuffle.mjs
function shuffle(arr) {
  const result2 = arr.slice();
  for (let i2 = result2.length - 1; i2 >= 1; i2--) {
    const j3 = Math.floor(Math.random() * (i2 + 1));
    [result2[i2], result2[j3]] = [result2[j3], result2[i2]];
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/values.mjs
function values(object) {
  if (object == null) {
    return [];
  }
  return Object.values(object);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isNil.mjs
function isNil2(x3) {
  return x3 == null;
}

// ../../node_modules/es-toolkit/dist/compat/array/shuffle.mjs
function shuffle2(collection) {
  if (isNil2(collection)) {
    return [];
  }
  if (isArray(collection)) {
    return shuffle(collection);
  }
  if (isArrayLike(collection)) {
    return shuffle(Array.from(collection));
  }
  if (isObjectLike(collection)) {
    return shuffle(values(collection));
  }
  return [];
}

// ../../node_modules/es-toolkit/dist/compat/array/size.mjs
function size(target) {
  if (isNil(target)) {
    return 0;
  }
  if (target instanceof Map || target instanceof Set) {
    return target.size;
  }
  return Object.keys(target).length;
}

// ../../node_modules/es-toolkit/dist/compat/array/slice.mjs
function slice(array, start, end) {
  if (!isArrayLike(array)) {
    return [];
  }
  const length = array.length;
  if (end === void 0) {
    end = length;
  } else if (typeof end !== "number" && isIterateeCall(array, start, end)) {
    start = 0;
    end = length;
  }
  start = toInteger(start);
  end = toInteger(end);
  if (start < 0) {
    start = Math.max(length + start, 0);
  } else {
    start = Math.min(start, length);
  }
  if (end < 0) {
    end = Math.max(length + end, 0);
  } else {
    end = Math.min(end, length);
  }
  const resultLength = Math.max(end - start, 0);
  const result2 = new Array(resultLength);
  for (let i2 = 0; i2 < resultLength; ++i2) {
    result2[i2] = array[start + i2];
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/some.mjs
function some(source, predicate, guard) {
  if (!source) {
    return false;
  }
  if (guard != null) {
    predicate = void 0;
  }
  if (!predicate) {
    predicate = identity;
  }
  const values2 = Array.isArray(source) ? source : Object.values(source);
  switch (typeof predicate) {
    case "function": {
      if (!Array.isArray(source)) {
        const keys2 = Object.keys(source);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key = keys2[i2];
          const value = source[key];
          if (predicate(value, key, source)) {
            return true;
          }
        }
        return false;
      }
      for (let i2 = 0; i2 < source.length; i2++) {
        if (predicate(source[i2], i2, source)) {
          return true;
        }
      }
      return false;
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key = predicate[0];
        const value = predicate[1];
        const matchFunc = matchesProperty(key, value);
        if (Array.isArray(source)) {
          for (let i2 = 0; i2 < source.length; i2++) {
            if (matchFunc(source[i2])) {
              return true;
            }
          }
          return false;
        }
        return values2.some(matchFunc);
      } else {
        const matchFunc = matches(predicate);
        if (Array.isArray(source)) {
          for (let i2 = 0; i2 < source.length; i2++) {
            if (matchFunc(source[i2])) {
              return true;
            }
          }
          return false;
        }
        return values2.some(matchFunc);
      }
    }
    case "number":
    case "symbol":
    case "string": {
      const propFunc = property(predicate);
      if (Array.isArray(source)) {
        for (let i2 = 0; i2 < source.length; i2++) {
          if (propFunc(source[i2])) {
            return true;
          }
        }
        return false;
      }
      return values2.some(propFunc);
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/array/sortBy.mjs
function sortBy(collection, ...criteria) {
  const length = criteria.length;
  if (length > 1 && isIterateeCall(collection, criteria[0], criteria[1])) {
    criteria = [];
  } else if (length > 2 && isIterateeCall(criteria[0], criteria[1], criteria[2])) {
    criteria = [criteria[0]];
  }
  return orderBy(collection, flatten(criteria), ["asc"]);
}

// ../../node_modules/es-toolkit/dist/predicate/isNull.mjs
function isNull(x3) {
  return x3 === null;
}

// ../../node_modules/es-toolkit/dist/predicate/isUndefined.mjs
function isUndefined(x3) {
  return x3 === void 0;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isNaN.mjs
function isNaN2(value) {
  return Number.isNaN(value);
}

// ../../node_modules/es-toolkit/dist/compat/array/sortedIndexBy.mjs
var MAX_ARRAY_LENGTH = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;
function sortedIndexBy(array, value, iteratee$1 = iteratee, retHighest) {
  let low = 0;
  let high = array == null ? 0 : array.length;
  if (high === 0 || isNil2(array)) {
    return 0;
  }
  const iterateeFunction = iteratee(iteratee$1);
  const transformedValue = iterateeFunction(value);
  const valIsNaN = isNaN2(transformedValue);
  const valIsNull = isNull(transformedValue);
  const valIsSymbol = isSymbol(transformedValue);
  const valIsUndefined = isUndefined(transformedValue);
  while (low < high) {
    let setLow;
    const mid = Math.floor((low + high) / 2);
    const computed = iterateeFunction(array[mid]);
    const othIsDefined = !isUndefined(computed);
    const othIsNull = isNull(computed);
    const othIsReflexive = !isNaN2(computed);
    const othIsSymbol = isSymbol(computed);
    if (valIsNaN) {
      setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= transformedValue : computed < transformedValue;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return Math.min(high, MAX_ARRAY_INDEX);
}

// ../../node_modules/es-toolkit/dist/predicate/isSymbol.mjs
function isSymbol2(value) {
  return typeof value === "symbol";
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isNumber.mjs
function isNumber(value) {
  return typeof value === "number" || value instanceof Number;
}

// ../../node_modules/es-toolkit/dist/compat/array/sortedIndex.mjs
var MAX_ARRAY_LENGTH2 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH2 >>> 1;
function sortedIndex(array, value) {
  if (isNil(array)) {
    return 0;
  }
  let low = 0, high = isNil(array) ? low : array.length;
  if (isNumber(value) && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      const mid = low + high >>> 1;
      const compute = array[mid];
      if (!isNull(compute) && !isSymbol2(compute) && compute < value) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return sortedIndexBy(array, value, (value2) => value2);
}

// ../../node_modules/es-toolkit/dist/compat/array/sortedIndexOf.mjs
function sortedIndexOf(array, value) {
  if (!array?.length) {
    return -1;
  }
  const index = sortedIndex(array, value);
  if (index < array.length && eq(array[index], value)) {
    return index;
  }
  return -1;
}

// ../../node_modules/es-toolkit/dist/compat/array/sortedLastIndexBy.mjs
function sortedLastIndexBy(array, value, iteratee2) {
  return sortedIndexBy(array, value, iteratee2, true);
}

// ../../node_modules/es-toolkit/dist/compat/array/sortedLastIndex.mjs
var MAX_ARRAY_LENGTH3 = 4294967295;
var HALF_MAX_ARRAY_LENGTH2 = MAX_ARRAY_LENGTH3 >>> 1;
function sortedLastIndex(array, value) {
  if (isNil(array)) {
    return 0;
  }
  let high = array.length;
  if (!isNumber(value) || Number.isNaN(value) || high > HALF_MAX_ARRAY_LENGTH2) {
    return sortedLastIndexBy(array, value, (value2) => value2);
  }
  let low = 0;
  while (low < high) {
    const mid = low + high >>> 1;
    const compute = array[mid];
    if (!isNull(compute) && !isSymbol2(compute) && compute <= value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return high;
}

// ../../node_modules/es-toolkit/dist/compat/array/sortedLastIndexOf.mjs
function sortedLastIndexOf(array, value) {
  if (!array?.length) {
    return -1;
  }
  const index = sortedLastIndex(array, value) - 1;
  if (index >= 0 && eq(array[index], value)) {
    return index;
  }
  return -1;
}

// ../../node_modules/es-toolkit/dist/array/tail.mjs
function tail(arr) {
  return arr.slice(1);
}

// ../../node_modules/es-toolkit/dist/compat/array/tail.mjs
function tail2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return tail(toArray(arr));
}

// ../../node_modules/es-toolkit/dist/array/take.mjs
function take(arr, count, guard) {
  count = guard || count === void 0 ? 1 : toInteger(count);
  return arr.slice(0, count);
}

// ../../node_modules/es-toolkit/dist/compat/array/take.mjs
function take2(arr, count = 1, guard) {
  count = guard ? 1 : toInteger(count);
  if (count < 1 || !isArrayLike(arr)) {
    return [];
  }
  return take(toArray(arr), count);
}

// ../../node_modules/es-toolkit/dist/array/takeRight.mjs
function takeRight(arr, count = 1, guard) {
  count = guard || count === void 0 ? 1 : toInteger(count);
  if (count <= 0 || arr == null || arr.length === 0) {
    return [];
  }
  return arr.slice(-count);
}

// ../../node_modules/es-toolkit/dist/compat/array/takeRight.mjs
function takeRight2(arr, count = 1, guard) {
  count = guard ? 1 : toInteger(count);
  if (count <= 0 || !isArrayLike(arr)) {
    return [];
  }
  return takeRight(toArray(arr), count);
}

// ../../node_modules/es-toolkit/dist/function/negate.mjs
function negate2(func) {
  return ((...args) => !func(...args));
}

// ../../node_modules/es-toolkit/dist/compat/array/takeRightWhile.mjs
function takeRightWhile(_array, predicate) {
  if (!isArrayLikeObject(_array)) {
    return [];
  }
  const array = toArray(_array);
  const index = array.findLastIndex(negate2(iteratee(predicate ?? identity)));
  return array.slice(index + 1);
}

// ../../node_modules/es-toolkit/dist/compat/function/identity.mjs
function identity2(x3) {
  return x3;
}

// ../../node_modules/es-toolkit/dist/compat/array/takeWhile.mjs
function takeWhile(array, predicate) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const _array = toArray(array);
  const index = _array.findIndex(negate(iteratee(predicate ?? identity2)));
  return index === -1 ? _array : _array.slice(0, index);
}

// ../../node_modules/es-toolkit/dist/compat/array/union.mjs
function union(...arrays) {
  const validArrays = arrays.filter(isArrayLikeObject);
  const flattened = flattenDepth(validArrays, 1);
  return uniq(flattened);
}

// ../../node_modules/es-toolkit/dist/array/uniqBy.mjs
function uniqBy(arr, mapper) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < arr.length; i2++) {
    const item = arr[i2];
    const key = mapper(item);
    if (!map2.has(key)) {
      map2.set(key, item);
    }
  }
  return Array.from(map2.values());
}

// ../../node_modules/es-toolkit/dist/compat/array/unionBy.mjs
function unionBy(...values2) {
  const lastValue = last(values2);
  const flattened = flattenArrayLike(values2);
  if (isArrayLikeObject(lastValue) || lastValue == null) {
    return uniq(flattened);
  }
  return uniqBy(flattened, iteratee(lastValue));
}

// ../../node_modules/es-toolkit/dist/array/uniqWith.mjs
function uniqWith(arr, areItemsEqual) {
  const result2 = [];
  for (let i2 = 0; i2 < arr.length; i2++) {
    const item = arr[i2];
    const isUniq = result2.every((v3) => !areItemsEqual(v3, item));
    if (isUniq) {
      result2.push(item);
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/unionWith.mjs
function unionWith(...values2) {
  const lastValue = last(values2);
  const flattened = flattenArrayLike(values2);
  if (isArrayLikeObject(lastValue) || lastValue == null) {
    return uniq(flattened);
  }
  return uniqWith(flattened, lastValue);
}

// ../../node_modules/es-toolkit/dist/compat/array/uniqBy.mjs
function uniqBy2(array, iteratee$1 = identity) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  return uniqBy(Array.from(array), iteratee(iteratee$1));
}

// ../../node_modules/es-toolkit/dist/compat/array/uniqWith.mjs
function uniqWith2(arr, comparator) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return typeof comparator === "function" ? uniqWith(Array.from(arr), comparator) : uniq2(Array.from(arr));
}

// ../../node_modules/es-toolkit/dist/array/unzip.mjs
function unzip(zipped) {
  let maxLen = 0;
  for (let i2 = 0; i2 < zipped.length; i2++) {
    if (zipped[i2].length > maxLen) {
      maxLen = zipped[i2].length;
    }
  }
  const result2 = new Array(maxLen);
  for (let i2 = 0; i2 < maxLen; i2++) {
    result2[i2] = new Array(zipped.length);
    for (let j3 = 0; j3 < zipped.length; j3++) {
      result2[i2][j3] = zipped[j3][i2];
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/unzip.mjs
function unzip2(array) {
  if (!isArrayLikeObject(array) || !array.length) {
    return [];
  }
  array = isArray(array) ? array : Array.from(array);
  array = array.filter((item) => isArrayLikeObject(item));
  return unzip(array);
}

// ../../node_modules/es-toolkit/dist/compat/array/unzipWith.mjs
function unzipWith(array, iteratee2) {
  if (!isArrayLikeObject(array) || !array.length) {
    return [];
  }
  const unzipped = isArray(array) ? unzip(array) : unzip(Array.from(array, (value) => Array.from(value)));
  if (!iteratee2) {
    return unzipped;
  }
  const result2 = new Array(unzipped.length);
  for (let i2 = 0; i2 < unzipped.length; i2++) {
    const value = unzipped[i2];
    result2[i2] = iteratee2(...value);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/array/without.mjs
function without(array, ...values2) {
  return difference(array, values2);
}

// ../../node_modules/es-toolkit/dist/compat/array/without.mjs
function without2(array, ...values2) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  return without(Array.from(array), ...values2);
}

// ../../node_modules/es-toolkit/dist/compat/array/xor.mjs
function xor(...arrays) {
  const itemCounts = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const array = arrays[i2];
    if (!isArrayLikeObject(array)) {
      continue;
    }
    const itemSet = new Set(toArray2(array));
    for (const item of itemSet) {
      if (!itemCounts.has(item)) {
        itemCounts.set(item, 1);
      } else {
        itemCounts.set(item, itemCounts.get(item) + 1);
      }
    }
  }
  const result2 = [];
  for (const [item, count] of itemCounts) {
    if (count === 1) {
      result2.push(item);
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/array/windowed.mjs
function windowed(arr, size2, step = 1, { partialWindows = false } = {}) {
  if (size2 <= 0 || !Number.isInteger(size2)) {
    throw new Error("Size must be a positive integer.");
  }
  if (step <= 0 || !Number.isInteger(step)) {
    throw new Error("Step must be a positive integer.");
  }
  const result2 = [];
  const end = partialWindows ? arr.length : arr.length - size2 + 1;
  for (let i2 = 0; i2 < end; i2 += step) {
    result2.push(arr.slice(i2, i2 + size2));
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/xorBy.mjs
function xorBy(...values2) {
  const lastValue = last2(values2);
  let mapper = identity;
  if (!isArrayLikeObject(lastValue) && lastValue != null) {
    mapper = iteratee(lastValue);
    values2 = values2.slice(0, -1);
  }
  const arrays = values2.filter(isArrayLikeObject);
  const union2 = unionBy(...arrays, mapper);
  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionBy2(arr1, arr2, mapper));
  return differenceBy2(union2, unionBy(...intersections, mapper), mapper);
}

// ../../node_modules/es-toolkit/dist/compat/array/xorWith.mjs
function xorWith(...values2) {
  const lastValue = last2(values2);
  let comparator = (a2, b2) => a2 === b2;
  if (typeof lastValue === "function") {
    comparator = lastValue;
    values2 = values2.slice(0, -1);
  }
  const arrays = values2.filter(isArrayLikeObject);
  const union2 = unionWith(...arrays, comparator);
  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionWith2(arr1, arr2, comparator));
  return differenceWith2(union2, unionWith(...intersections, comparator), comparator);
}

// ../../node_modules/es-toolkit/dist/array/zip.mjs
function zip(...arrs) {
  let rowCount = 0;
  for (let i2 = 0; i2 < arrs.length; i2++) {
    if (arrs[i2].length > rowCount) {
      rowCount = arrs[i2].length;
    }
  }
  const columnCount = arrs.length;
  const result2 = Array(rowCount);
  for (let i2 = 0; i2 < rowCount; ++i2) {
    const row = Array(columnCount);
    for (let j3 = 0; j3 < columnCount; ++j3) {
      row[j3] = arrs[j3][i2];
    }
    result2[i2] = row;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/zip.mjs
function zip2(...arrays) {
  if (!arrays.length) {
    return [];
  }
  return zip(...arrays.filter((group) => isArrayLikeObject(group)));
}

// ../../node_modules/es-toolkit/dist/compat/_internal/assignValue.mjs
var assignValue = (object, key, value) => {
  const objValue = object[key];
  if (!(Object.hasOwn(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    object[key] = value;
  }
};

// ../../node_modules/es-toolkit/dist/compat/array/zipObject.mjs
function zipObject(keys2 = [], values2 = []) {
  const result2 = {};
  for (let i2 = 0; i2 < keys2.length; i2++) {
    assignValue(result2, keys2[i2], values2[i2]);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/updateWith.mjs
function updateWith(obj, path4, updater, customizer) {
  if (obj == null && !isObject(obj)) {
    return obj;
  }
  const resolvedPath = isKey(path4, obj) ? [path4] : Array.isArray(path4) ? path4 : typeof path4 === "string" ? toPath(path4) : [path4];
  let current = obj;
  for (let i2 = 0; i2 < resolvedPath.length && current != null; i2++) {
    const key = toKey(resolvedPath[i2]);
    if (isUnsafeProperty(key)) {
      continue;
    }
    let newValue;
    if (i2 === resolvedPath.length - 1) {
      newValue = updater(current[key]);
    } else {
      const objValue = current[key];
      const customizerResult = customizer?.(objValue, key, obj);
      newValue = customizerResult !== void 0 ? customizerResult : isObject(objValue) ? objValue : isIndex(resolvedPath[i2 + 1]) ? [] : {};
    }
    assignValue(current, key, newValue);
    current = current[key];
  }
  return obj;
}

// ../../node_modules/es-toolkit/dist/compat/object/set.mjs
function set(obj, path4, value) {
  return updateWith(obj, path4, () => value, () => void 0);
}

// ../../node_modules/es-toolkit/dist/compat/array/zipObjectDeep.mjs
function zipObjectDeep(keys2, values2) {
  const result2 = {};
  if (!isArrayLike(keys2)) {
    return result2;
  }
  if (!isArrayLike(values2)) {
    values2 = [];
  }
  const zipped = zip(Array.from(keys2), Array.from(values2));
  for (let i2 = 0; i2 < zipped.length; i2++) {
    const [key, value] = zipped[i2];
    if (key != null) {
      set(result2, key, value);
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/array/zipWith.mjs
function zipWith(...combine) {
  let iteratee2 = combine.pop();
  if (!isFunction(iteratee2)) {
    combine.push(iteratee2);
    iteratee2 = void 0;
  }
  if (!combine?.length) {
    return [];
  }
  const result2 = unzip2(combine);
  if (iteratee2 == null) {
    return result2;
  }
  return result2.map((group) => iteratee2(...group));
}

// ../../node_modules/es-toolkit/dist/compat/function/after.mjs
function after(n2, func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  n2 = toInteger(n2);
  return function(...args) {
    if (--n2 < 1) {
      return func.apply(this, args);
    }
  };
}

// ../../node_modules/es-toolkit/dist/function/ary.mjs
function ary(func, n2) {
  return function(...args) {
    return func.apply(this, args.slice(0, n2));
  };
}

// ../../node_modules/es-toolkit/dist/compat/function/ary.mjs
function ary2(func, n2 = func.length, guard) {
  if (guard) {
    n2 = func.length;
  }
  if (Number.isNaN(n2) || n2 < 0) {
    n2 = 0;
  }
  return ary(func, n2);
}

// ../../node_modules/es-toolkit/dist/compat/function/attempt.mjs
function attempt(func, ...args) {
  try {
    return func(...args);
  } catch (e2) {
    return e2 instanceof Error ? e2 : new Error(e2);
  }
}

// ../../node_modules/es-toolkit/dist/compat/function/before.mjs
function before(n2, func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  let result2;
  n2 = toInteger(n2);
  return function(...args) {
    if (--n2 > 0) {
      result2 = func.apply(this, args);
    }
    if (n2 <= 1 && func) {
      func = void 0;
    }
    return result2;
  };
}

// ../../node_modules/es-toolkit/dist/compat/function/bind.mjs
function bind(func, thisObj, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i2 = 0; i2 < partialArgs.length; i2++) {
      const arg = partialArgs[i2];
      if (arg === bind.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i2 = startIndex; i2 < providedArgs.length; i2++) {
      args.push(providedArgs[i2]);
    }
    if (this instanceof bound) {
      return new func(...args);
    }
    return func.apply(thisObj, args);
  };
  return bound;
}
var bindPlaceholder = Symbol("bind.placeholder");
bind.placeholder = bindPlaceholder;

// ../../node_modules/es-toolkit/dist/compat/function/bindKey.mjs
function bindKey(object, key, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i2 = 0; i2 < partialArgs.length; i2++) {
      const arg = partialArgs[i2];
      if (arg === bindKey.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i2 = startIndex; i2 < providedArgs.length; i2++) {
      args.push(providedArgs[i2]);
    }
    if (this instanceof bound) {
      return new object[key](...args);
    }
    return object[key].apply(object, args);
  };
  return bound;
}
var bindKeyPlaceholder = Symbol("bindKey.placeholder");
bindKey.placeholder = bindKeyPlaceholder;

// ../../node_modules/es-toolkit/dist/compat/function/curry.mjs
function curry(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curry.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurry(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function makeCurry(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curry.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurry(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function composeArgs(providedArgs, partialArgs) {
  const args = [];
  let startIndex = 0;
  for (let i2 = 0; i2 < partialArgs.length; i2++) {
    const arg = partialArgs[i2];
    if (arg === curry.placeholder && startIndex < providedArgs.length) {
      args.push(providedArgs[startIndex++]);
    } else {
      args.push(arg);
    }
  }
  for (let i2 = startIndex; i2 < providedArgs.length; i2++) {
    args.push(providedArgs[i2]);
  }
  return args;
}
var curryPlaceholder = Symbol("curry.placeholder");
curry.placeholder = curryPlaceholder;

// ../../node_modules/es-toolkit/dist/compat/function/curryRight.mjs
function curryRight(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curryRight.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurryRight(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function makeCurryRight(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curryRight.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs2(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurryRight(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function composeArgs2(providedArgs, partialArgs) {
  const placeholderLength = partialArgs.filter((arg) => arg === curryRight.placeholder).length;
  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
  const args = [];
  let providedIndex = 0;
  for (let i2 = 0; i2 < rangeLength; i2++) {
    args.push(providedArgs[providedIndex++]);
  }
  for (let i2 = 0; i2 < partialArgs.length; i2++) {
    const arg = partialArgs[i2];
    if (arg === curryRight.placeholder) {
      if (providedIndex < providedArgs.length) {
        args.push(providedArgs[providedIndex++]);
      } else {
        args.push(arg);
      }
    } else {
      args.push(arg);
    }
  }
  return args;
}
var curryRightPlaceholder = Symbol("curryRight.placeholder");
curryRight.placeholder = curryRightPlaceholder;

// ../../node_modules/es-toolkit/dist/function/debounce.mjs
function debounce(func, debounceMs, { signal, edges } = {}) {
  let pendingThis = void 0;
  let pendingArgs = null;
  const leading = edges != null && edges.includes("leading");
  const trailing = edges == null || edges.includes("trailing");
  const invoke2 = () => {
    if (pendingArgs !== null) {
      func.apply(pendingThis, pendingArgs);
      pendingThis = void 0;
      pendingArgs = null;
    }
  };
  const onTimerEnd = () => {
    if (trailing) {
      invoke2();
    }
    cancel();
  };
  let timeoutId = null;
  const schedule = () => {
    if (timeoutId != null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      timeoutId = null;
      onTimerEnd();
    }, debounceMs);
  };
  const cancelTimer = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  const cancel = () => {
    cancelTimer();
    pendingThis = void 0;
    pendingArgs = null;
  };
  const flush2 = () => {
    invoke2();
  };
  const debounced = function(...args) {
    if (signal?.aborted) {
      return;
    }
    pendingThis = this;
    pendingArgs = args;
    const isFirstCall = timeoutId == null;
    schedule();
    if (leading && isFirstCall) {
      invoke2();
    }
  };
  debounced.schedule = schedule;
  debounced.cancel = cancel;
  debounced.flush = flush2;
  signal?.addEventListener("abort", cancel, { once: true });
  return debounced;
}

// ../../node_modules/es-toolkit/dist/compat/function/debounce.mjs
function debounce2(func, debounceMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = false, trailing = true, maxWait } = options;
  const edges = Array(2);
  if (leading) {
    edges[0] = "leading";
  }
  if (trailing) {
    edges[1] = "trailing";
  }
  let result2 = void 0;
  let pendingAt = null;
  const _debounced = debounce(function(...args) {
    result2 = func.apply(this, args);
    pendingAt = null;
  }, debounceMs, { edges });
  const debounced = function(...args) {
    if (maxWait != null) {
      if (pendingAt === null) {
        pendingAt = Date.now();
      }
      if (Date.now() - pendingAt >= maxWait) {
        result2 = func.apply(this, args);
        pendingAt = Date.now();
        _debounced.cancel();
        _debounced.schedule();
        return result2;
      }
    }
    _debounced.apply(this, args);
    return result2;
  };
  const flush2 = () => {
    _debounced.flush();
    return result2;
  };
  debounced.cancel = _debounced.cancel;
  debounced.flush = flush2;
  return debounced;
}

// ../../node_modules/es-toolkit/dist/compat/function/defer.mjs
function defer(func, ...args) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return setTimeout(func, 1, ...args);
}

// ../../node_modules/es-toolkit/dist/compat/function/delay.mjs
function delay(func, wait, ...args) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return setTimeout(func, toNumber(wait) || 0, ...args);
}

// ../../node_modules/es-toolkit/dist/compat/function/flip.mjs
function flip(func) {
  return function(...args) {
    return func.apply(this, args.reverse());
  };
}

// ../../node_modules/es-toolkit/dist/function/flow.mjs
function flow(...funcs) {
  return function(...args) {
    let result2 = funcs.length ? funcs[0].apply(this, args) : args[0];
    for (let i2 = 1; i2 < funcs.length; i2++) {
      result2 = funcs[i2].call(this, result2);
    }
    return result2;
  };
}

// ../../node_modules/es-toolkit/dist/compat/function/flow.mjs
function flow2(...funcs) {
  const flattenFuncs = flatten(funcs, 1);
  if (flattenFuncs.some((func) => typeof func !== "function")) {
    throw new TypeError("Expected a function");
  }
  return flow(...flattenFuncs);
}

// ../../node_modules/es-toolkit/dist/function/flowRight.mjs
function flowRight(...funcs) {
  return flow(...funcs.reverse());
}

// ../../node_modules/es-toolkit/dist/compat/function/flowRight.mjs
function flowRight2(...funcs) {
  const flattenFuncs = flatten(funcs, 1);
  if (flattenFuncs.some((func) => typeof func !== "function")) {
    throw new TypeError("Expected a function");
  }
  return flowRight(...flattenFuncs);
}

// ../../node_modules/es-toolkit/dist/compat/function/memoize.mjs
function memoize(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  const memoized = function(...args) {
    const key = resolver ? resolver.apply(this, args) : args[0];
    const cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result2 = func.apply(this, args);
    memoized.cache = cache.set(key, result2) || cache;
    return result2;
  };
  const CacheConstructor = memoize.Cache || Map;
  memoized.cache = new CacheConstructor();
  return memoized;
}
memoize.Cache = Map;

// ../../node_modules/es-toolkit/dist/compat/function/nthArg.mjs
function nthArg(n2 = 0) {
  return function(...args) {
    return args.at(toInteger(n2));
  };
}

// ../../node_modules/es-toolkit/dist/function/once.mjs
function once(func) {
  let called = false;
  let cache;
  return function(...args) {
    if (!called) {
      called = true;
      cache = func(...args);
    }
    return cache;
  };
}

// ../../node_modules/es-toolkit/dist/compat/function/once.mjs
function once2(func) {
  return once(func);
}

// ../../node_modules/es-toolkit/dist/compat/function/overArgs.mjs
function overArgs(func, ..._transforms) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  const transforms = _transforms.flat();
  return function(...args) {
    const length = Math.min(args.length, transforms.length);
    const transformedArgs = [...args];
    for (let i2 = 0; i2 < length; i2++) {
      const transform2 = iteratee(transforms[i2] ?? identity);
      transformedArgs[i2] = transform2.call(this, args[i2]);
    }
    return func.apply(this, transformedArgs);
  };
}

// ../../node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return partialImpl(func, placeholderSymbol, ...partialArgs);
}
function partialImpl(func, placeholder, ...partialArgs) {
  const partialed = function(...providedArgs) {
    let providedArgsIndex = 0;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    const remainingArgs = providedArgs.slice(providedArgsIndex);
    return func.apply(this, substitutedArgs.concat(remainingArgs));
  };
  if (func.prototype) {
    partialed.prototype = Object.create(func.prototype);
  }
  return partialed;
}
var placeholderSymbol = Symbol("partial.placeholder");
partial.placeholder = placeholderSymbol;

// ../../node_modules/es-toolkit/dist/compat/function/partial.mjs
function partial2(func, ...partialArgs) {
  return partialImpl(func, partial2.placeholder, ...partialArgs);
}
partial2.placeholder = Symbol("compat.partial.placeholder");

// ../../node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
}
function partialRightImpl(func, placeholder, ...partialArgs) {
  const partialedRight = function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const remainingArgs = providedArgs.slice(0, rangeLength);
    let providedArgsIndex = rangeLength;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    return func.apply(this, remainingArgs.concat(substitutedArgs));
  };
  if (func.prototype) {
    partialedRight.prototype = Object.create(func.prototype);
  }
  return partialedRight;
}
var placeholderSymbol2 = Symbol("partialRight.placeholder");
partialRight.placeholder = placeholderSymbol2;

// ../../node_modules/es-toolkit/dist/compat/function/partialRight.mjs
function partialRight2(func, ...partialArgs) {
  return partialRightImpl(func, partialRight2.placeholder, ...partialArgs);
}
partialRight2.placeholder = Symbol("compat.partialRight.placeholder");

// ../../node_modules/es-toolkit/dist/compat/function/rearg.mjs
function rearg(func, ...indices) {
  const flattenIndices = flatten2(indices);
  return function(...args) {
    const reorderedArgs = flattenIndices.map((i2) => args[i2]).slice(0, args.length);
    for (let i2 = reorderedArgs.length; i2 < args.length; i2++) {
      reorderedArgs.push(args[i2]);
    }
    return func.apply(this, reorderedArgs);
  };
}

// ../../node_modules/es-toolkit/dist/function/rest.mjs
function rest(func, startIndex = func.length - 1) {
  return function(...args) {
    const rest3 = args.slice(startIndex);
    const params = args.slice(0, startIndex);
    while (params.length < startIndex) {
      params.push(void 0);
    }
    return func.apply(this, [...params, rest3]);
  };
}

// ../../node_modules/es-toolkit/dist/compat/function/rest.mjs
function rest2(func, start = func.length - 1) {
  start = Number.parseInt(start, 10);
  if (Number.isNaN(start) || start < 0) {
    start = func.length - 1;
  }
  return rest(func, start);
}

// ../../node_modules/es-toolkit/dist/compat/function/spread.mjs
function spread(func, argsIndex = 0) {
  argsIndex = Number.parseInt(argsIndex, 10);
  if (Number.isNaN(argsIndex) || argsIndex < 0) {
    argsIndex = 0;
  }
  return function(...args) {
    const array = args[argsIndex];
    const params = args.slice(0, argsIndex);
    if (array) {
      params.push(...array);
    }
    return func.apply(this, params);
  };
}

// ../../node_modules/es-toolkit/dist/compat/function/throttle.mjs
function throttle(func, throttleMs = 0, options = {}) {
  const { leading = true, trailing = true } = options;
  return debounce2(func, throttleMs, {
    leading,
    maxWait: throttleMs,
    trailing
  });
}

// ../../node_modules/es-toolkit/dist/compat/function/unary.mjs
function unary(func) {
  return ary2(func, 1);
}

// ../../node_modules/es-toolkit/dist/compat/function/wrap.mjs
function wrap2(value, wrapper) {
  return function(...args) {
    const wrapFn = isFunction(wrapper) ? wrapper : identity;
    return wrapFn.apply(this, [value, ...args]);
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/toString.mjs
function toString(value) {
  if (value == null) {
    return "";
  }
  if (typeof value === "string") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(toString).join(",");
  }
  const result2 = String(value);
  if (result2 === "0" && Object.is(Number(value), -0)) {
    return "-0";
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/math/add.mjs
function add(value, other) {
  if (value === void 0 && other === void 0) {
    return 0;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value + other;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/decimalAdjust.mjs
function decimalAdjust(type, number, precision = 0) {
  number = Number(number);
  if (Object.is(number, -0)) {
    number = "-0";
  }
  precision = Math.min(Number.parseInt(precision, 10), 292);
  if (precision) {
    const [magnitude, exponent = 0] = number.toString().split("e");
    let adjustedValue = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));
    if (Object.is(adjustedValue, -0)) {
      adjustedValue = "-0";
    }
    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split("e");
    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);
  }
  return Math[type](Number(number));
}

// ../../node_modules/es-toolkit/dist/compat/math/ceil.mjs
function ceil(number, precision = 0) {
  return decimalAdjust("ceil", number, precision);
}

// ../../node_modules/es-toolkit/dist/compat/math/divide.mjs
function divide(value, other) {
  if (value === void 0 && other === void 0) {
    return 1;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value / other;
}

// ../../node_modules/es-toolkit/dist/compat/math/floor.mjs
function floor(number, precision = 0) {
  return decimalAdjust("floor", number, precision);
}

// ../../node_modules/es-toolkit/dist/math/inRange.mjs
function inRange(value, minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("The maximum value must be greater than the minimum value.");
  }
  return minimum <= value && value < maximum;
}

// ../../node_modules/es-toolkit/dist/compat/math/inRange.mjs
function inRange2(value, minimum, maximum) {
  if (!minimum) {
    minimum = 0;
  }
  if (maximum != null && !maximum) {
    maximum = 0;
  }
  if (minimum != null && typeof minimum !== "number") {
    minimum = Number(minimum);
  }
  if (maximum == null && minimum === 0) {
    return false;
  }
  if (maximum != null && typeof maximum !== "number") {
    maximum = Number(maximum);
  }
  if (maximum != null && minimum > maximum) {
    [minimum, maximum] = [maximum, minimum];
  }
  if (minimum === maximum) {
    return false;
  }
  return inRange(value, minimum, maximum);
}

// ../../node_modules/es-toolkit/dist/compat/math/max.mjs
function max(items) {
  if (!items || items.length === 0) {
    return void 0;
  }
  let maxResult = void 0;
  for (let i2 = 0; i2 < items.length; i2++) {
    const current = items[i2];
    if (current == null || Number.isNaN(current) || typeof current === "symbol") {
      continue;
    }
    if (maxResult === void 0 || current > maxResult) {
      maxResult = current;
    }
  }
  return maxResult;
}

// ../../node_modules/es-toolkit/dist/array/maxBy.mjs
function maxBy(items, getValue) {
  if (items.length === 0) {
    return void 0;
  }
  let maxElement = items[0];
  let max2 = getValue(maxElement);
  for (let i2 = 1; i2 < items.length; i2++) {
    const element = items[i2];
    const value = getValue(element);
    if (value > max2) {
      max2 = value;
      maxElement = element;
    }
  }
  return maxElement;
}

// ../../node_modules/es-toolkit/dist/compat/math/maxBy.mjs
function maxBy2(items, iteratee$1) {
  if (items == null) {
    return void 0;
  }
  return maxBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}

// ../../node_modules/es-toolkit/dist/compat/math/sumBy.mjs
function sumBy(array, iteratee$1) {
  if (!array || !array.length) {
    return 0;
  }
  if (iteratee$1 != null) {
    iteratee$1 = iteratee(iteratee$1);
  }
  let result2 = void 0;
  for (let i2 = 0; i2 < array.length; i2++) {
    const current = iteratee$1 ? iteratee$1(array[i2]) : array[i2];
    if (current !== void 0) {
      if (result2 === void 0) {
        result2 = current;
      } else {
        result2 += current;
      }
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/math/sum.mjs
function sum(array) {
  return sumBy(array);
}

// ../../node_modules/es-toolkit/dist/compat/math/mean.mjs
function mean(nums) {
  const length = nums ? nums.length : 0;
  return length === 0 ? NaN : sum(nums) / length;
}

// ../../node_modules/es-toolkit/dist/math/sum.mjs
function sum2(nums) {
  let result2 = 0;
  for (let i2 = 0; i2 < nums.length; i2++) {
    result2 += nums[i2];
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/math/mean.mjs
function mean2(nums) {
  return sum2(nums) / nums.length;
}

// ../../node_modules/es-toolkit/dist/math/meanBy.mjs
function meanBy(items, getValue) {
  const nums = items.map((x3) => getValue(x3));
  return mean2(nums);
}

// ../../node_modules/es-toolkit/dist/compat/math/meanBy.mjs
function meanBy2(items, iteratee$1) {
  if (items == null) {
    return NaN;
  }
  return meanBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}

// ../../node_modules/es-toolkit/dist/compat/math/min.mjs
function min(items) {
  if (!items || items.length === 0) {
    return void 0;
  }
  let minResult = void 0;
  for (let i2 = 0; i2 < items.length; i2++) {
    const current = items[i2];
    if (current == null || Number.isNaN(current) || typeof current === "symbol") {
      continue;
    }
    if (minResult === void 0 || current < minResult) {
      minResult = current;
    }
  }
  return minResult;
}

// ../../node_modules/es-toolkit/dist/array/minBy.mjs
function minBy(items, getValue) {
  if (items.length === 0) {
    return void 0;
  }
  let minElement = items[0];
  let min2 = getValue(minElement);
  for (let i2 = 1; i2 < items.length; i2++) {
    const element = items[i2];
    const value = getValue(element);
    if (value < min2) {
      min2 = value;
      minElement = element;
    }
  }
  return minElement;
}

// ../../node_modules/es-toolkit/dist/compat/math/minBy.mjs
function minBy2(items, iteratee$1) {
  if (items == null) {
    return void 0;
  }
  return minBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}

// ../../node_modules/es-toolkit/dist/compat/math/multiply.mjs
function multiply(value, other) {
  if (value === void 0 && other === void 0) {
    return 1;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value * other;
}

// ../../node_modules/es-toolkit/dist/compat/math/parseInt.mjs
function parseInt2(string, radix = 0, guard) {
  if (guard) {
    radix = 0;
  }
  return Number.parseInt(string, radix);
}

// ../../node_modules/es-toolkit/dist/compat/math/random.mjs
function random2(...args) {
  let minimum = 0;
  let maximum = 1;
  let floating = false;
  switch (args.length) {
    case 1: {
      if (typeof args[0] === "boolean") {
        floating = args[0];
      } else {
        maximum = args[0];
      }
      break;
    }
    case 2: {
      if (typeof args[1] === "boolean") {
        maximum = args[0];
        floating = args[1];
      } else {
        minimum = args[0];
        maximum = args[1];
      }
    }
    case 3: {
      if (typeof args[2] === "object" && args[2] != null && args[2][args[1]] === args[0]) {
        minimum = 0;
        maximum = args[0];
        floating = false;
      } else {
        minimum = args[0];
        maximum = args[1];
        floating = args[2];
      }
    }
  }
  if (typeof minimum !== "number") {
    minimum = Number(minimum);
  }
  if (typeof maximum !== "number") {
    minimum = Number(maximum);
  }
  if (!minimum) {
    minimum = 0;
  }
  if (!maximum) {
    maximum = 0;
  }
  if (minimum > maximum) {
    [minimum, maximum] = [maximum, minimum];
  }
  minimum = clamp2(minimum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  maximum = clamp2(maximum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  if (minimum === maximum) {
    return minimum;
  }
  if (floating) {
    return random(minimum, maximum + 1);
  } else {
    return randomInt(minimum, maximum + 1);
  }
}

// ../../node_modules/es-toolkit/dist/compat/math/range.mjs
function range2(start, end, step) {
  if (step && typeof step !== "number" && isIterateeCall(start, end, step)) {
    end = step = void 0;
  }
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
  const result2 = new Array(length);
  for (let index = 0; index < length; index++) {
    result2[index] = start;
    start += step;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/math/rangeRight.mjs
function rangeRight(start, end, step) {
  if (step && typeof step !== "number" && isIterateeCall(start, end, step)) {
    end = step = void 0;
  }
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
  const result2 = new Array(length);
  for (let index = length - 1; index >= 0; index--) {
    result2[index] = start;
    start += step;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/math/round.mjs
function round(number, precision = 0) {
  return decimalAdjust("round", number, precision);
}

// ../../node_modules/es-toolkit/dist/compat/math/subtract.mjs
function subtract(value, other) {
  if (value === void 0 && other === void 0) {
    return 0;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value - other;
}

// ../../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject2(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}

// ../../node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a2, b2, areValuesEqual) {
  return isEqualWithImpl(a2, b2, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a2, b2, property2, aParent, bParent, stack, areValuesEqual) {
  const result2 = areValuesEqual(a2, b2, property2, aParent, bParent, stack);
  if (result2 !== void 0) {
    return result2;
  }
  if (typeof a2 === typeof b2) {
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a2 === b2;
      }
      case "number": {
        return a2 === b2 || Object.is(a2, b2);
      }
      case "function": {
        return a2 === b2;
      }
      case "object": {
        return areObjectsEqual(a2, b2, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a2, b2, stack, areValuesEqual);
}
function areObjectsEqual(a2, b2, stack, areValuesEqual) {
  if (Object.is(a2, b2)) {
    return true;
  }
  let aTag = getTag(a2);
  let bTag = getTag(b2);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a2.toString() === b2.toString();
    case numberTag: {
      const x3 = a2.valueOf();
      const y2 = b2.valueOf();
      return eq(x3, y2);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a2.valueOf(), b2.valueOf());
    case regexpTag: {
      return a2.source === b2.source && a2.flags === b2.flags;
    }
    case functionTag: {
      return a2 === b2;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a2);
  const bStack = stack.get(b2);
  if (aStack != null && bStack != null) {
    return aStack === b2;
  }
  stack.set(a2, b2);
  stack.set(b2, a2);
  try {
    switch (aTag) {
      case mapTag: {
        if (a2.size !== b2.size) {
          return false;
        }
        for (const [key, value] of a2.entries()) {
          if (!b2.has(key) || !isEqualWithImpl(value, b2.get(key), key, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag2: {
        if (a2.size !== b2.size) {
          return false;
        }
        const aValues = Array.from(a2.values());
        const bValues = Array.from(b2.values());
        for (let i2 = 0; i2 < aValues.length; i2++) {
          const aValue = aValues[i2];
          const index = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a2, b2, stack, areValuesEqual);
          });
          if (index === -1) {
            return false;
          }
          bValues.splice(index, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b2)) {
          return false;
        }
        if (a2.length !== b2.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.length; i2++) {
          if (!isEqualWithImpl(a2[i2], b2[i2], i2, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a2.byteLength !== b2.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a2.byteLength !== b2.byteLength || a2.byteOffset !== b2.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      }
      case errorTag: {
        return a2.name === b2.name && a2.message === b2.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a2.constructor, b2.constructor, stack, areValuesEqual) || isPlainObject2(a2) && isPlainObject2(b2);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
        const bKeys = [...Object.keys(b2), ...getSymbols(b2)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i2 = 0; i2 < aKeys.length; i2++) {
          const propKey = aKeys[i2];
          const aProp = a2[propKey];
          if (!Object.hasOwn(b2, propKey)) {
            return false;
          }
          const bProp = b2[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a2);
    stack.delete(b2);
  }
}

// ../../node_modules/es-toolkit/dist/function/noop.mjs
function noop() {
}

// ../../node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual(a2, b2) {
  return isEqualWith(a2, b2, noop);
}

// ../../node_modules/es-toolkit/dist/compat/function/noop.mjs
function noop2(..._2) {
}

// ../../node_modules/es-toolkit/dist/predicate/isBuffer.mjs
function isBuffer(x3) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer(x3);
}

// ../../node_modules/es-toolkit/dist/compat/_internal/isPrototype.mjs
function isPrototype(value) {
  const constructor = value?.constructor;
  const prototype = typeof constructor === "function" ? constructor.prototype : Object.prototype;
  return value === prototype;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isTypedArray.mjs
function isTypedArray2(x3) {
  return isTypedArray(x3);
}

// ../../node_modules/es-toolkit/dist/compat/util/times.mjs
function times(n2, getValue) {
  n2 = toInteger(n2);
  if (n2 < 1 || !Number.isSafeInteger(n2)) {
    return [];
  }
  const result2 = new Array(n2);
  for (let i2 = 0; i2 < n2; i2++) {
    result2[i2] = typeof getValue === "function" ? getValue(i2) : i2;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/keys.mjs
function keys(object) {
  if (isArrayLike(object)) {
    return arrayLikeKeys(object);
  }
  const result2 = Object.keys(Object(object));
  if (!isPrototype(object)) {
    return result2;
  }
  return result2.filter((key) => key !== "constructor");
}
function arrayLikeKeys(object) {
  const indices = times(object.length, (index) => `${index}`);
  const filteredKeys = new Set(indices);
  if (isBuffer(object)) {
    filteredKeys.add("offset");
    filteredKeys.add("parent");
  }
  if (isTypedArray2(object)) {
    filteredKeys.add("buffer");
    filteredKeys.add("byteLength");
    filteredKeys.add("byteOffset");
  }
  return [...indices, ...Object.keys(object).filter((key) => !filteredKeys.has(key))];
}

// ../../node_modules/es-toolkit/dist/compat/object/assign.mjs
function assign(object, ...sources) {
  for (let i2 = 0; i2 < sources.length; i2++) {
    assignImpl(object, sources[i2]);
  }
  return object;
}
function assignImpl(object, source) {
  const keys$1 = keys(source);
  for (let i2 = 0; i2 < keys$1.length; i2++) {
    const key = keys$1[i2];
    if (!(key in object) || !eq(object[key], source[key])) {
      object[key] = source[key];
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/object/keysIn.mjs
function keysIn(object) {
  if (object == null) {
    return [];
  }
  switch (typeof object) {
    case "object":
    case "function": {
      if (isArrayLike(object)) {
        return arrayLikeKeysIn(object);
      }
      if (isPrototype(object)) {
        return prototypeKeysIn(object);
      }
      return keysInImpl(object);
    }
    default: {
      return keysInImpl(Object(object));
    }
  }
}
function keysInImpl(object) {
  const result2 = [];
  for (const key in object) {
    result2.push(key);
  }
  return result2;
}
function prototypeKeysIn(object) {
  const keys2 = keysInImpl(object);
  return keys2.filter((key) => key !== "constructor");
}
function arrayLikeKeysIn(object) {
  const indices = times(object.length, (index) => `${index}`);
  const filteredKeys = new Set(indices);
  if (isBuffer(object)) {
    filteredKeys.add("offset");
    filteredKeys.add("parent");
  }
  if (isTypedArray2(object)) {
    filteredKeys.add("buffer");
    filteredKeys.add("byteLength");
    filteredKeys.add("byteOffset");
  }
  return [...indices, ...keysInImpl(object).filter((key) => !filteredKeys.has(key))];
}

// ../../node_modules/es-toolkit/dist/compat/object/assignIn.mjs
function assignIn(object, ...sources) {
  for (let i2 = 0; i2 < sources.length; i2++) {
    assignInImpl(object, sources[i2]);
  }
  return object;
}
function assignInImpl(object, source) {
  const keys2 = keysIn(source);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    if (!(key in object) || !eq(object[key], source[key])) {
      object[key] = source[key];
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/object/assignInWith.mjs
function assignInWith(object, ...sources) {
  let getValueToAssign = sources[sources.length - 1];
  if (typeof getValueToAssign === "function") {
    sources.pop();
  } else {
    getValueToAssign = void 0;
  }
  for (let i2 = 0; i2 < sources.length; i2++) {
    assignInWithImpl(object, sources[i2], getValueToAssign);
  }
  return object;
}
function assignInWithImpl(object, source, getValueToAssign) {
  const keys2 = keysIn(source);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const objValue = object[key];
    const srcValue = source[key];
    const newValue = getValueToAssign?.(objValue, srcValue, key, object, source) ?? srcValue;
    if (!(key in object) || !eq(objValue, newValue)) {
      object[key] = newValue;
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/object/assignWith.mjs
function assignWith(object, ...sources) {
  let getValueToAssign = sources[sources.length - 1];
  if (typeof getValueToAssign === "function") {
    sources.pop();
  } else {
    getValueToAssign = void 0;
  }
  for (let i2 = 0; i2 < sources.length; i2++) {
    assignWithImpl(object, sources[i2], getValueToAssign);
  }
  return object;
}
function assignWithImpl(object, source, getValueToAssign) {
  const keys$1 = keys(source);
  for (let i2 = 0; i2 < keys$1.length; i2++) {
    const key = keys$1[i2];
    const objValue = object[key];
    const srcValue = source[key];
    const newValue = getValueToAssign?.(objValue, srcValue, key, object, source) ?? srcValue;
    if (!(key in object) || !eq(objValue, newValue)) {
      object[key] = newValue;
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/object/clone.mjs
function clone(obj) {
  if (isPrimitive2(obj)) {
    return obj;
  }
  const tag = getTag(obj);
  if (!isCloneableObject2(obj)) {
    return {};
  }
  if (isArray(obj)) {
    const result3 = Array.from(obj);
    if (obj.length > 0 && typeof obj[0] === "string" && Object.hasOwn(obj, "index")) {
      result3.index = obj.index;
      result3.input = obj.input;
    }
    return result3;
  }
  if (isTypedArray2(obj)) {
    const typedArray = obj;
    const Ctor = typedArray.constructor;
    return new Ctor(typedArray.buffer, typedArray.byteOffset, typedArray.length);
  }
  if (tag === arrayBufferTag) {
    return new ArrayBuffer(obj.byteLength);
  }
  if (tag === dataViewTag) {
    const dataView = obj;
    const buffer = dataView.buffer;
    const byteOffset = dataView.byteOffset;
    const byteLength = dataView.byteLength;
    const clonedBuffer = new ArrayBuffer(byteLength);
    const srcView = new Uint8Array(buffer, byteOffset, byteLength);
    const destView = new Uint8Array(clonedBuffer);
    destView.set(srcView);
    return new DataView(clonedBuffer);
  }
  if (tag === booleanTag || tag === numberTag || tag === stringTag) {
    const Ctor = obj.constructor;
    const clone5 = new Ctor(obj.valueOf());
    if (tag === stringTag) {
      cloneStringObjectProperties(clone5, obj);
    } else {
      copyOwnProperties(clone5, obj);
    }
    return clone5;
  }
  if (tag === dateTag) {
    return new Date(Number(obj));
  }
  if (tag === regexpTag) {
    const regExp = obj;
    const clone5 = new RegExp(regExp.source, regExp.flags);
    clone5.lastIndex = regExp.lastIndex;
    return clone5;
  }
  if (tag === symbolTag) {
    return Object(Symbol.prototype.valueOf.call(obj));
  }
  if (tag === mapTag) {
    const map2 = obj;
    const result3 = /* @__PURE__ */ new Map();
    map2.forEach((obj2, key) => {
      result3.set(key, obj2);
    });
    return result3;
  }
  if (tag === setTag2) {
    const set2 = obj;
    const result3 = /* @__PURE__ */ new Set();
    set2.forEach((obj2) => {
      result3.add(obj2);
    });
    return result3;
  }
  if (tag === argumentsTag) {
    const args = obj;
    const result3 = {};
    copyOwnProperties(result3, args);
    result3.length = args.length;
    result3[Symbol.iterator] = args[Symbol.iterator];
    return result3;
  }
  const result2 = {};
  copyPrototype(result2, obj);
  copyOwnProperties(result2, obj);
  copySymbolProperties(result2, obj);
  return result2;
}
function isCloneableObject2(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag2:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function copyOwnProperties(target, source) {
  for (const key in source) {
    if (Object.hasOwn(source, key)) {
      target[key] = source[key];
    }
  }
}
function copySymbolProperties(target, source) {
  const symbols = Object.getOwnPropertySymbols(source);
  for (let i2 = 0; i2 < symbols.length; i2++) {
    const symbol = symbols[i2];
    if (Object.prototype.propertyIsEnumerable.call(source, symbol)) {
      target[symbol] = source[symbol];
    }
  }
}
function cloneStringObjectProperties(target, source) {
  const stringLength = source.valueOf().length;
  for (const key in source) {
    if (Object.hasOwn(source, key) && (Number.isNaN(Number(key)) || Number(key) >= stringLength)) {
      target[key] = source[key];
    }
  }
}
function copyPrototype(target, source) {
  const proto = Object.getPrototypeOf(source);
  if (proto !== null) {
    const Ctor = source.constructor;
    if (typeof Ctor === "function") {
      Object.setPrototypeOf(target, proto);
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/object/cloneWith.mjs
function cloneWith(value, customizer) {
  if (!customizer) {
    return clone(value);
  }
  const result2 = customizer(value);
  if (result2 !== void 0) {
    return result2;
  }
  return clone(value);
}

// ../../node_modules/es-toolkit/dist/compat/object/create.mjs
function create(prototype, properties) {
  const proto = isObject(prototype) ? Object.create(prototype) : {};
  if (properties != null) {
    const propsKeys = keys(properties);
    for (let i2 = 0; i2 < propsKeys.length; i2++) {
      const key = propsKeys[i2];
      const propsValue = properties[key];
      assignValue(proto, key, propsValue);
    }
  }
  return proto;
}

// ../../node_modules/es-toolkit/dist/compat/object/defaults.mjs
function defaults(object, ...sources) {
  object = Object(object);
  const objectProto = Object.prototype;
  let length = sources.length;
  const guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  for (let i2 = 0; i2 < length; i2++) {
    const source = sources[i2];
    const keys2 = Object.keys(source);
    for (let j3 = 0; j3 < keys2.length; j3++) {
      const key = keys2[j3];
      const value = object[key];
      if (value === void 0 || !Object.hasOwn(object, key) && eq(value, objectProto[key])) {
        object[key] = source[key];
      }
    }
  }
  return object;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs
function isPlainObject3(object) {
  if (typeof object !== "object") {
    return false;
  }
  if (object == null) {
    return false;
  }
  if (Object.getPrototypeOf(object) === null) {
    return true;
  }
  if (Object.prototype.toString.call(object) !== "[object Object]") {
    const tag = object[Symbol.toStringTag];
    if (tag == null) {
      return false;
    }
    const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;
    if (isTagReadonly) {
      return false;
    }
    return object.toString() === `[object ${tag}]`;
  }
  let proto = object;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(object) === proto;
}

// ../../node_modules/es-toolkit/dist/compat/object/defaultsDeep.mjs
function defaultsDeep(target, ...sources) {
  target = Object(target);
  for (let i2 = 0; i2 < sources.length; i2++) {
    const source = sources[i2];
    if (source != null) {
      const stack = /* @__PURE__ */ new WeakMap();
      defaultsDeepRecursive(target, source, stack);
    }
  }
  return target;
}
function defaultsDeepRecursive(target, source, stack) {
  for (const key in source) {
    const sourceValue = source[key];
    const targetValue = target[key];
    const targetHasKey = Object.hasOwn(target, key);
    if (!targetHasKey || targetValue === void 0) {
      if (stack.has(sourceValue)) {
        target[key] = stack.get(sourceValue);
      } else if (isPlainObject3(sourceValue)) {
        const newObj = {};
        stack.set(sourceValue, newObj);
        target[key] = newObj;
        defaultsDeepRecursive(newObj, sourceValue, stack);
      } else {
        target[key] = sourceValue;
      }
    } else if (isPlainObject3(targetValue) && isPlainObject3(sourceValue)) {
      const inStack = stack.has(sourceValue);
      if (!inStack || inStack && stack.get(sourceValue) !== targetValue) {
        stack.set(sourceValue, targetValue);
        defaultsDeepRecursive(targetValue, sourceValue, stack);
      }
    }
  }
}

// ../../node_modules/es-toolkit/dist/object/findKey.mjs
function findKey(obj, predicate) {
  const keys2 = Object.keys(obj);
  return keys2.find((key) => predicate(obj[key], key, obj));
}

// ../../node_modules/es-toolkit/dist/compat/object/findKey.mjs
function findKey2(obj, predicate) {
  if (!isObject(obj)) {
    return void 0;
  }
  const iteratee$1 = iteratee(predicate ?? identity2);
  return findKey(obj, iteratee$1);
}

// ../../node_modules/es-toolkit/dist/compat/object/findLastKey.mjs
function findLastKey(obj, predicate) {
  if (!isObject(obj)) {
    return void 0;
  }
  const iteratee$1 = iteratee(predicate ?? identity2);
  const keys2 = Object.keys(obj);
  return keys2.findLast((key) => iteratee$1(obj[key], key, obj));
}

// ../../node_modules/es-toolkit/dist/compat/object/forIn.mjs
function forIn(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  for (const key in object) {
    const result2 = iteratee2(object[key], key, object);
    if (result2 === false) {
      break;
    }
  }
  return object;
}

// ../../node_modules/es-toolkit/dist/compat/object/forInRight.mjs
function forInRight(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const keys2 = [];
  for (const key in object) {
    keys2.push(key);
  }
  for (let i2 = keys2.length - 1; i2 >= 0; i2--) {
    const key = keys2[i2];
    const result2 = iteratee2(object[key], key, object);
    if (result2 === false) {
      break;
    }
  }
  return object;
}

// ../../node_modules/es-toolkit/dist/compat/object/forOwn.mjs
function forOwn(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const iterable = Object(object);
  const keys$1 = keys(object);
  for (let i2 = 0; i2 < keys$1.length; ++i2) {
    const key = keys$1[i2];
    if (iteratee2(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

// ../../node_modules/es-toolkit/dist/compat/object/forOwnRight.mjs
function forOwnRight(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const iterable = Object(object);
  const keys$1 = keys(object);
  for (let i2 = keys$1.length - 1; i2 >= 0; --i2) {
    const key = keys$1[i2];
    if (iteratee2(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

// ../../node_modules/es-toolkit/dist/compat/object/fromPairs.mjs
function fromPairs(pairs) {
  if (!isArrayLike(pairs)) {
    return {};
  }
  const result2 = {};
  for (let i2 = 0; i2 < pairs.length; i2++) {
    const [key, value] = pairs[i2];
    result2[key] = value;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/functions.mjs
function functions(object) {
  if (object == null) {
    return [];
  }
  return keys(object).filter((key) => typeof object[key] === "function");
}

// ../../node_modules/es-toolkit/dist/compat/object/functionsIn.mjs
function functionsIn(object) {
  if (object == null) {
    return [];
  }
  const result2 = [];
  for (const key in object) {
    if (isFunction(object[key])) {
      result2.push(key);
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/hasIn.mjs
function hasIn(object, path4) {
  if (object == null) {
    return false;
  }
  let resolvedPath;
  if (Array.isArray(path4)) {
    resolvedPath = path4;
  } else if (typeof path4 === "string" && isDeepKey(path4) && object[path4] == null) {
    resolvedPath = toPath(path4);
  } else {
    resolvedPath = [path4];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object;
  for (let i2 = 0; i2 < resolvedPath.length; i2++) {
    const key = resolvedPath[i2];
    if (current == null || !(key in Object(current))) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key];
  }
  return true;
}

// ../../node_modules/es-toolkit/dist/object/invert.mjs
function invert(obj) {
  const result2 = {};
  const keys2 = Object.keys(obj);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = obj[key];
    result2[value] = key;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/invert.mjs
function invert2(obj) {
  return invert(obj);
}

// ../../node_modules/es-toolkit/dist/compat/object/invertBy.mjs
function invertBy(object, iteratee$1) {
  const result2 = {};
  if (isNil(object)) {
    return result2;
  }
  if (iteratee$1 == null) {
    iteratee$1 = identity;
  }
  const keys2 = Object.keys(object);
  const getString = iteratee(iteratee$1);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = object[key];
    const valueStr = getString(value);
    if (Array.isArray(result2[valueStr])) {
      result2[valueStr].push(key);
    } else {
      result2[valueStr] = [key];
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/object/mapKeys.mjs
function mapKeys(object, getNewKey) {
  const result2 = {};
  const keys2 = Object.keys(object);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = object[key];
    result2[getNewKey(value, key, object)] = value;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/mapKeys.mjs
function mapKeys2(object, getNewKey = identity) {
  if (object == null) {
    return {};
  }
  return mapKeys(object, iteratee(getNewKey));
}

// ../../node_modules/es-toolkit/dist/object/mapValues.mjs
function mapValues(object, getNewValue) {
  const result2 = {};
  const keys2 = Object.keys(object);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = object[key];
    result2[key] = getNewValue(value, key, object);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/mapValues.mjs
function mapValues2(object, getNewValue = identity) {
  if (object == null) {
    return {};
  }
  return mapValues(object, iteratee(getNewValue));
}

// ../../node_modules/es-toolkit/dist/object/clone.mjs
function clone2(obj) {
  if (isPrimitive2(obj)) {
    return obj;
  }
  if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && obj instanceof SharedArrayBuffer) {
    return obj.slice(0);
  }
  const prototype = Object.getPrototypeOf(obj);
  const Constructor = prototype.constructor;
  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {
    return new Constructor(obj);
  }
  if (obj instanceof RegExp) {
    const newRegExp = new Constructor(obj);
    newRegExp.lastIndex = obj.lastIndex;
    return newRegExp;
  }
  if (obj instanceof DataView) {
    return new Constructor(obj.buffer.slice(0));
  }
  if (obj instanceof Error) {
    const newError = new Constructor(obj.message);
    newError.stack = obj.stack;
    newError.name = obj.name;
    newError.cause = obj.cause;
    return newError;
  }
  if (typeof File !== "undefined" && obj instanceof File) {
    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
    return newFile;
  }
  if (typeof obj === "object") {
    const newObject = Object.create(prototype);
    return Object.assign(newObject, obj);
  }
  return obj;
}

// ../../node_modules/es-toolkit/dist/compat/object/mergeWith.mjs
function mergeWith(object, ...otherArgs) {
  const sources = otherArgs.slice(0, -1);
  const merge3 = otherArgs[otherArgs.length - 1];
  let result2 = object;
  for (let i2 = 0; i2 < sources.length; i2++) {
    const source = sources[i2];
    result2 = mergeWithDeep(result2, source, merge3, /* @__PURE__ */ new Map());
  }
  return result2;
}
function mergeWithDeep(target, source, merge3, stack) {
  if (isPrimitive2(target)) {
    target = Object(target);
  }
  if (source == null || typeof source !== "object") {
    return target;
  }
  if (stack.has(source)) {
    return clone2(stack.get(source));
  }
  stack.set(source, target);
  if (Array.isArray(source)) {
    source = source.slice();
    for (let i2 = 0; i2 < source.length; i2++) {
      source[i2] = source[i2] ?? void 0;
    }
  }
  const sourceKeys = [...Object.keys(source), ...getSymbols(source)];
  for (let i2 = 0; i2 < sourceKeys.length; i2++) {
    const key = sourceKeys[i2];
    if (isUnsafeProperty(key)) {
      continue;
    }
    let sourceValue = source[key];
    let targetValue = target[key];
    if (isArguments(sourceValue)) {
      sourceValue = { ...sourceValue };
    }
    if (isArguments(targetValue)) {
      targetValue = { ...targetValue };
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(sourceValue)) {
      sourceValue = cloneDeep2(sourceValue);
    }
    if (Array.isArray(sourceValue)) {
      if (typeof targetValue === "object" && targetValue != null) {
        const cloned = [];
        const targetKeys = Reflect.ownKeys(targetValue);
        for (let i3 = 0; i3 < targetKeys.length; i3++) {
          const targetKey = targetKeys[i3];
          cloned[targetKey] = targetValue[targetKey];
        }
        targetValue = cloned;
      } else {
        targetValue = [];
      }
    }
    const merged = merge3(targetValue, sourceValue, key, target, source, stack);
    if (merged != null) {
      target[key] = merged;
    } else if (Array.isArray(sourceValue)) {
      target[key] = mergeWithDeep(targetValue, sourceValue, merge3, stack);
    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
      target[key] = mergeWithDeep(targetValue, sourceValue, merge3, stack);
    } else if (targetValue == null && isPlainObject3(sourceValue)) {
      target[key] = mergeWithDeep({}, sourceValue, merge3, stack);
    } else if (targetValue == null && isTypedArray2(sourceValue)) {
      target[key] = cloneDeep2(sourceValue);
    } else if (targetValue === void 0 || sourceValue !== void 0) {
      target[key] = sourceValue;
    }
  }
  return target;
}

// ../../node_modules/es-toolkit/dist/compat/object/merge.mjs
function merge2(object, ...sources) {
  return mergeWith(object, ...sources, noop);
}

// ../../node_modules/es-toolkit/dist/compat/object/omit.mjs
function omit(obj, ...keysArr) {
  if (obj == null) {
    return {};
  }
  const result2 = cloneDeep(obj);
  for (let i2 = 0; i2 < keysArr.length; i2++) {
    let keys2 = keysArr[i2];
    switch (typeof keys2) {
      case "object": {
        if (!Array.isArray(keys2)) {
          keys2 = Array.from(keys2);
        }
        for (let j3 = 0; j3 < keys2.length; j3++) {
          const key = keys2[j3];
          unset(result2, key);
        }
        break;
      }
      case "string":
      case "symbol":
      case "number": {
        unset(result2, keys2);
        break;
      }
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/getSymbolsIn.mjs
function getSymbolsIn(object) {
  const result2 = [];
  while (object) {
    result2.push(...getSymbols(object));
    object = Object.getPrototypeOf(object);
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/omitBy.mjs
function omitBy(object, shouldOmit) {
  if (object == null) {
    return {};
  }
  const result2 = {};
  const predicate = iteratee(shouldOmit ?? identity2);
  const keys2 = isArrayLike(object) ? range(0, object.length) : [...keysIn(object), ...getSymbolsIn(object)];
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = isSymbol(keys2[i2]) ? keys2[i2] : keys2[i2].toString();
    const value = object[key];
    if (!predicate(value, key, object)) {
      result2[key] = value;
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/pick.mjs
function pick(obj, ...keysArr) {
  if (isNil2(obj)) {
    return {};
  }
  const result2 = {};
  for (let i2 = 0; i2 < keysArr.length; i2++) {
    let keys2 = keysArr[i2];
    switch (typeof keys2) {
      case "object": {
        if (!Array.isArray(keys2)) {
          if (isArrayLike(keys2)) {
            keys2 = Array.from(keys2);
          } else {
            keys2 = [keys2];
          }
        }
        break;
      }
      case "string":
      case "symbol":
      case "number": {
        keys2 = [keys2];
        break;
      }
    }
    for (const key of keys2) {
      const value = get(obj, key);
      if (value === void 0 && !has(obj, key)) {
        continue;
      }
      if (typeof key === "string" && Object.hasOwn(obj, key)) {
        result2[key] = value;
      } else {
        set(result2, key, value);
      }
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/pickBy.mjs
function pickBy(obj, shouldPick) {
  if (obj == null) {
    return {};
  }
  const predicate = iteratee(shouldPick ?? identity2);
  const result2 = {};
  const keys2 = isArrayLike(obj) ? range(0, obj.length) : [...keysIn(obj), ...getSymbolsIn(obj)];
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = isSymbol(keys2[i2]) ? keys2[i2] : keys2[i2].toString();
    const value = obj[key];
    if (predicate(value, key, obj)) {
      result2[key] = value;
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/propertyOf.mjs
function propertyOf(object) {
  return function(path4) {
    return get(object, path4);
  };
}

// ../../node_modules/es-toolkit/dist/compat/object/result.mjs
function result(object, path4, defaultValue) {
  if (isKey(path4, object)) {
    path4 = [path4];
  } else if (!Array.isArray(path4)) {
    path4 = toPath(toString(path4));
  }
  const pathLength = Math.max(path4.length, 1);
  for (let index = 0; index < pathLength; index++) {
    const value = object == null ? void 0 : object[toKey(path4[index])];
    if (value === void 0) {
      return typeof defaultValue === "function" ? defaultValue.call(object) : defaultValue;
    }
    object = typeof value === "function" ? value.call(object) : value;
  }
  return object;
}

// ../../node_modules/es-toolkit/dist/compat/object/setWith.mjs
function setWith(obj, path4, value, customizer) {
  let customizerFn;
  if (typeof customizer === "function") {
    customizerFn = customizer;
  } else {
    customizerFn = () => void 0;
  }
  return updateWith(obj, path4, () => value, customizerFn);
}

// ../../node_modules/es-toolkit/dist/compat/object/toDefaulted.mjs
function toDefaulted(object, ...sources) {
  const cloned = cloneDeep2(object);
  return defaults(cloned, ...sources);
}

// ../../node_modules/es-toolkit/dist/compat/_internal/mapToEntries.mjs
function mapToEntries(map2) {
  const arr = new Array(map2.size);
  const keys2 = map2.keys();
  const values2 = map2.values();
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = [keys2.next().value, values2.next().value];
  }
  return arr;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/setToEntries.mjs
function setToEntries(set2) {
  const arr = new Array(set2.size);
  const values2 = set2.values();
  for (let i2 = 0; i2 < arr.length; i2++) {
    const value = values2.next().value;
    arr[i2] = [value, value];
  }
  return arr;
}

// ../../node_modules/es-toolkit/dist/compat/object/toPairs.mjs
function toPairs(object) {
  if (object == null) {
    return [];
  }
  if (object instanceof Set) {
    return setToEntries(object);
  }
  if (object instanceof Map) {
    return mapToEntries(object);
  }
  const keys$1 = keys(object);
  const result2 = new Array(keys$1.length);
  for (let i2 = 0; i2 < keys$1.length; i2++) {
    const key = keys$1[i2];
    const value = object[key];
    result2[i2] = [key, value];
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/object/toPairsIn.mjs
function toPairsIn(object) {
  if (object == null) {
    return [];
  }
  if (object instanceof Set) {
    return setToEntries(object);
  }
  if (object instanceof Map) {
    return mapToEntries(object);
  }
  const keys2 = keysIn(object);
  const result2 = new Array(keys2.length);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const value = object[key];
    result2[i2] = [key, value];
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isBuffer.mjs
function isBuffer2(x3) {
  return isBuffer(x3);
}

// ../../node_modules/es-toolkit/dist/compat/object/transform.mjs
function transform(object, iteratee$1 = identity, accumulator) {
  const isArrayOrBufferOrTypedArray = Array.isArray(object) || isBuffer2(object) || isTypedArray2(object);
  iteratee$1 = iteratee(iteratee$1);
  if (accumulator == null) {
    if (isArrayOrBufferOrTypedArray) {
      accumulator = [];
    } else if (isObject(object) && isFunction(object.constructor)) {
      accumulator = Object.create(Object.getPrototypeOf(object));
    } else {
      accumulator = {};
    }
  }
  if (object == null) {
    return accumulator;
  }
  forEach(object, (value, key, object2) => iteratee$1(accumulator, value, key, object2));
  return accumulator;
}

// ../../node_modules/es-toolkit/dist/compat/object/update.mjs
function update(obj, path4, updater) {
  return updateWith(obj, path4, updater, () => void 0);
}

// ../../node_modules/es-toolkit/dist/compat/object/valuesIn.mjs
function valuesIn(object) {
  const keys2 = keysIn(object);
  const result2 = new Array(keys2.length);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    result2[i2] = object[key];
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isFunction.mjs
function isFunction2(value) {
  return typeof value === "function";
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isLength.mjs
function isLength2(value) {
  return Number.isSafeInteger(value) && value >= 0;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isNative.mjs
var functionToString = Function.prototype.toString;
var REGEXP_SYNTAX_CHARS = /[\\^$.*+?()[\]{}|]/g;
var IS_NATIVE_FUNCTION_REGEXP = RegExp(`^${functionToString.call(Object.prototype.hasOwnProperty).replace(REGEXP_SYNTAX_CHARS, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?")}$`);
function isNative(value) {
  if (typeof value !== "function") {
    return false;
  }
  if (globalThis?.["__core-js_shared__"] != null) {
    throw new Error("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
  }
  return IS_NATIVE_FUNCTION_REGEXP.test(functionToString.call(value));
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isNull.mjs
function isNull2(value) {
  return value === null;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isUndefined.mjs
function isUndefined2(x3) {
  return isUndefined(x3);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/conformsTo.mjs
function conformsTo(target, source) {
  if (source == null) {
    return true;
  }
  if (target == null) {
    return Object.keys(source).length === 0;
  }
  const keys2 = Object.keys(source);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const predicate = source[key];
    const value = target[key];
    if (value === void 0 && !(key in target)) {
      return false;
    }
    if (typeof predicate === "function" && !predicate(value)) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/conforms.mjs
function conforms(source) {
  source = cloneDeep(source);
  return function(object) {
    return conformsTo(object, source);
  };
}

// ../../node_modules/es-toolkit/dist/predicate/isArrayBuffer.mjs
function isArrayBuffer(value) {
  return value instanceof ArrayBuffer;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isArrayBuffer.mjs
function isArrayBuffer2(value) {
  return isArrayBuffer(value);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isBoolean.mjs
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}

// ../../node_modules/es-toolkit/dist/predicate/isDate.mjs
function isDate(value) {
  return value instanceof Date;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isDate.mjs
function isDate2(value) {
  return isDate(value);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isElement.mjs
function isElement2(value) {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject3(value);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isEmpty.mjs
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value)) {
    if (typeof value.splice !== "function" && typeof value !== "string" && (typeof Buffer === "undefined" || !Buffer.isBuffer(value)) && !isTypedArray2(value) && !isArguments(value)) {
      return false;
    }
    return value.length === 0;
  }
  if (typeof value === "object") {
    if (value instanceof Map || value instanceof Set) {
      return value.size === 0;
    }
    const keys2 = Object.keys(value);
    if (isPrototype(value)) {
      return keys2.filter((x3) => x3 !== "constructor").length === 0;
    }
    return keys2.length === 0;
  }
  return true;
}

// ../../node_modules/es-toolkit/dist/function/after.mjs
function after2(n2, func) {
  if (!Number.isInteger(n2) || n2 < 0) {
    throw new Error(`n must be a non-negative integer.`);
  }
  let counter = 0;
  return (...args) => {
    if (++counter >= n2) {
      return func(...args);
    }
    return void 0;
  };
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isEqualWith.mjs
function isEqualWith2(a2, b2, areValuesEqual) {
  if (typeof areValuesEqual !== "function") {
    areValuesEqual = () => void 0;
  }
  return isEqualWith(a2, b2, (...args) => {
    const result2 = areValuesEqual(...args);
    if (result2 !== void 0) {
      return Boolean(result2);
    }
    if (a2 instanceof Map && b2 instanceof Map) {
      return isEqualWith2(Array.from(a2), Array.from(b2), after2(2, areValuesEqual));
    }
    if (a2 instanceof Set && b2 instanceof Set) {
      return isEqualWith2(Array.from(a2), Array.from(b2), after2(2, areValuesEqual));
    }
  });
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isError.mjs
function isError2(value) {
  return getTag(value) === "[object Error]";
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isFinite.mjs
function isFinite2(value) {
  return Number.isFinite(value);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isInteger.mjs
function isInteger(value) {
  return Number.isInteger(value);
}

// ../../node_modules/es-toolkit/dist/predicate/isRegExp.mjs
function isRegExp2(value) {
  return value instanceof RegExp;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isRegExp.mjs
function isRegExp3(value) {
  return isRegExp2(value);
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isSafeInteger.mjs
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}

// ../../node_modules/es-toolkit/dist/predicate/isSet.mjs
function isSet(value) {
  return value instanceof Set;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isSet.mjs
function isSet2(value) {
  return isSet(value);
}

// ../../node_modules/es-toolkit/dist/predicate/isWeakMap.mjs
function isWeakMap(value) {
  return value instanceof WeakMap;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isWeakMap.mjs
function isWeakMap2(value) {
  return isWeakMap(value);
}

// ../../node_modules/es-toolkit/dist/predicate/isWeakSet.mjs
function isWeakSet(value) {
  return value instanceof WeakSet;
}

// ../../node_modules/es-toolkit/dist/compat/predicate/isWeakSet.mjs
function isWeakSet2(value) {
  return isWeakSet(value);
}

// ../../node_modules/es-toolkit/dist/string/capitalize.mjs
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

// ../../node_modules/es-toolkit/dist/compat/string/capitalize.mjs
function capitalize2(str) {
  return capitalize(toString(str));
}

// ../../node_modules/es-toolkit/dist/compat/util/bindAll.mjs
function bindAll(object, ...methodNames) {
  if (object == null) {
    return object;
  }
  if (!isObject(object)) {
    return object;
  }
  if (isArray(object) && methodNames.length === 0) {
    return object;
  }
  const methods = [];
  for (let i2 = 0; i2 < methodNames.length; i2++) {
    const name = methodNames[i2];
    if (isArray(name)) {
      methods.push(...name);
    } else if (name && typeof name === "object" && "length" in name) {
      methods.push(...Array.from(name));
    } else {
      methods.push(name);
    }
  }
  if (methods.length === 0) {
    return object;
  }
  for (let i2 = 0; i2 < methods.length; i2++) {
    const key = methods[i2];
    const stringKey = toString(key);
    const func = object[stringKey];
    if (isFunction(func)) {
      object[stringKey] = func.bind(object);
    }
  }
  return object;
}

// ../../node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = /\p{Lu}?\p{Ll}+|[0-9]+|\p{Lu}+(?!\p{Ll})|\p{Emoji_Presentation}|\p{Extended_Pictographic}|\p{L}+/gu;
function words(str) {
  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
}

// ../../node_modules/es-toolkit/dist/string/camelCase.mjs
function camelCase(str) {
  const words$1 = words(str);
  if (words$1.length === 0) {
    return "";
  }
  const [first, ...rest3] = words$1;
  return `${first.toLowerCase()}${rest3.map((word) => capitalize(word)).join("")}`;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/normalizeForCase.mjs
function normalizeForCase(str) {
  if (typeof str !== "string") {
    str = toString(str);
  }
  return str.replace(/['\u2019]/g, "");
}

// ../../node_modules/es-toolkit/dist/compat/string/camelCase.mjs
function camelCase2(str) {
  return camelCase(normalizeForCase(str));
}

// ../../node_modules/es-toolkit/dist/string/deburr.mjs
var deburrMap = new Map(Object.entries({
  \u00C6: "Ae",
  \u00D0: "D",
  \u00D8: "O",
  \u00DE: "Th",
  \u00DF: "ss",
  \u00E6: "ae",
  \u00F0: "d",
  \u00F8: "o",
  \u00FE: "th",
  \u0110: "D",
  \u0111: "d",
  \u0126: "H",
  \u0127: "h",
  \u0131: "i",
  \u0132: "IJ",
  \u0133: "ij",
  \u0138: "k",
  \u013F: "L",
  \u0140: "l",
  \u0141: "L",
  \u0142: "l",
  \u0149: "'n",
  \u014A: "N",
  \u014B: "n",
  \u0152: "Oe",
  \u0153: "oe",
  \u0166: "T",
  \u0167: "t",
  \u017F: "s"
}));
function deburr(str) {
  str = str.normalize("NFD");
  let result2 = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    const char = str[i2];
    if (char >= "\u0300" && char <= "\u036F" || char >= "\uFE20" && char <= "\uFE23") {
      continue;
    }
    result2 += deburrMap.get(char) ?? char;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/string/deburr.mjs
function deburr2(str) {
  return deburr(toString(str));
}

// ../../node_modules/es-toolkit/dist/compat/string/endsWith.mjs
function endsWith(str, target, position) {
  if (str == null || target == null) {
    return false;
  }
  if (position == null) {
    position = str.length;
  }
  return str.endsWith(target, position);
}

// ../../node_modules/es-toolkit/dist/string/escape.mjs
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escape2(str) {
  return str.replace(/[&<>"']/g, (match) => htmlEscapes[match]);
}

// ../../node_modules/es-toolkit/dist/compat/string/escape.mjs
function escape3(string) {
  return escape2(toString(string));
}

// ../../node_modules/es-toolkit/dist/string/escapeRegExp.mjs
function escapeRegExp(str) {
  return str.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
}

// ../../node_modules/es-toolkit/dist/compat/string/escapeRegExp.mjs
function escapeRegExp2(str) {
  return escapeRegExp(toString(str));
}

// ../../node_modules/es-toolkit/dist/string/kebabCase.mjs
function kebabCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join("-");
}

// ../../node_modules/es-toolkit/dist/compat/string/kebabCase.mjs
function kebabCase2(str) {
  return kebabCase(normalizeForCase(str));
}

// ../../node_modules/es-toolkit/dist/string/lowerCase.mjs
function lowerCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join(" ");
}

// ../../node_modules/es-toolkit/dist/compat/string/lowerCase.mjs
function lowerCase2(str) {
  return lowerCase(normalizeForCase(str));
}

// ../../node_modules/es-toolkit/dist/string/lowerFirst.mjs
function lowerFirst(str) {
  return str.substring(0, 1).toLowerCase() + str.substring(1);
}

// ../../node_modules/es-toolkit/dist/compat/string/lowerFirst.mjs
function lowerFirst2(str) {
  return lowerFirst(toString(str));
}

// ../../node_modules/es-toolkit/dist/string/pad.mjs
function pad(str, length, chars = " ") {
  return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);
}

// ../../node_modules/es-toolkit/dist/compat/string/pad.mjs
function pad2(str, length, chars) {
  return pad(toString(str), length, chars);
}

// ../../node_modules/es-toolkit/dist/compat/string/padEnd.mjs
function padEnd(str, length = 0, chars = " ") {
  return toString(str).padEnd(length, chars);
}

// ../../node_modules/es-toolkit/dist/compat/string/padStart.mjs
function padStart(str, length = 0, chars = " ") {
  return toString(str).padStart(length, chars);
}

// ../../node_modules/es-toolkit/dist/compat/string/repeat.mjs
function repeat(str, n2, guard) {
  if (guard ? isIterateeCall(str, n2, guard) : n2 === void 0) {
    n2 = 1;
  } else {
    n2 = toInteger(n2);
  }
  return toString(str).repeat(n2);
}

// ../../node_modules/es-toolkit/dist/compat/string/replace.mjs
function replace(target, pattern, replacement) {
  if (arguments.length < 3) {
    return toString(target);
  }
  return toString(target).replace(pattern, replacement);
}

// ../../node_modules/es-toolkit/dist/string/snakeCase.mjs
function snakeCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join("_");
}

// ../../node_modules/es-toolkit/dist/compat/string/snakeCase.mjs
function snakeCase2(str) {
  return snakeCase(normalizeForCase(str));
}

// ../../node_modules/es-toolkit/dist/compat/string/split.mjs
function split(string, separator, limit) {
  return toString(string).split(separator, limit);
}

// ../../node_modules/es-toolkit/dist/compat/string/startCase.mjs
function startCase(str) {
  const words$1 = words(normalizeForCase(str).trim());
  let result2 = "";
  for (let i2 = 0; i2 < words$1.length; i2++) {
    const word = words$1[i2];
    if (result2) {
      result2 += " ";
    }
    if (word === word.toUpperCase()) {
      result2 += word;
    } else {
      result2 += word[0].toUpperCase() + word.slice(1).toLowerCase();
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/string/startsWith.mjs
function startsWith(str, target, position) {
  if (str == null || target == null) {
    return false;
  }
  if (position == null) {
    position = 0;
  }
  return str.startsWith(target, position);
}

// ../../node_modules/es-toolkit/dist/compat/string/template.mjs
var esTemplateRegExp = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var unEscapedRegExp = /['\n\r\u2028\u2029\\]/g;
var noMatchExp = /($^)/;
var escapeMap = /* @__PURE__ */ new Map([
  ["\\", "\\"],
  ["'", "'"],
  ["\n", "n"],
  ["\r", "r"],
  ["\u2028", "u2028"],
  ["\u2029", "u2029"]
]);
function escapeString(match) {
  return `\\${escapeMap.get(match)}`;
}
var templateSettings = {
  escape: /<%-([\s\S]+?)%>/g,
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  variable: "",
  imports: {
    _: {
      escape: escape3,
      template
    }
  }
};
function template(string, options, guard) {
  string = toString(string);
  if (guard) {
    options = templateSettings;
  }
  options = defaults({ ...options }, templateSettings);
  const delimitersRegExp = new RegExp([
    options.escape?.source ?? noMatchExp.source,
    options.interpolate?.source ?? noMatchExp.source,
    options.interpolate ? esTemplateRegExp.source : noMatchExp.source,
    options.evaluate?.source ?? noMatchExp.source,
    "$"
  ].join("|"), "g");
  let lastIndex = 0;
  let isEvaluated = false;
  let source = `__p += ''`;
  for (const match of string.matchAll(delimitersRegExp)) {
    const [fullMatch, escapeValue, interpolateValue, esTemplateValue, evaluateValue] = match;
    const { index } = match;
    source += ` + '${string.slice(lastIndex, index).replace(unEscapedRegExp, escapeString)}'`;
    if (escapeValue) {
      source += ` + _.escape(${escapeValue})`;
    }
    if (interpolateValue) {
      source += ` + ((${interpolateValue}) == null ? '' : ${interpolateValue})`;
    } else if (esTemplateValue) {
      source += ` + ((${esTemplateValue}) == null ? '' : ${esTemplateValue})`;
    }
    if (evaluateValue) {
      source += `;
${evaluateValue};
 __p += ''`;
      isEvaluated = true;
    }
    lastIndex = index + fullMatch.length;
  }
  const imports = defaults({ ...options.imports }, templateSettings.imports);
  const importsKeys = Object.keys(imports);
  const importValues = Object.values(imports);
  const sourceURL = `//# sourceURL=${options.sourceURL ? String(options.sourceURL).replace(/[\r\n]/g, " ") : `es-toolkit.templateSource[${Date.now()}]`}
`;
  const compiledFunction = `function(${options.variable || "obj"}) {
    let __p = '';
    ${options.variable ? "" : "if (obj == null) { obj = {}; }"}
    ${isEvaluated ? `function print() { __p += Array.prototype.join.call(arguments, ''); }` : ""}
    ${options.variable ? source : `with(obj) {
${source}
}`}
    return __p;
  }`;
  const result2 = attempt(() => new Function(...importsKeys, `${sourceURL}return ${compiledFunction}`)(...importValues));
  result2.source = compiledFunction;
  if (result2 instanceof Error) {
    throw result2;
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/string/toLower.mjs
function toLower(value) {
  return toString(value).toLowerCase();
}

// ../../node_modules/es-toolkit/dist/compat/string/toUpper.mjs
function toUpper(value) {
  return toString(value).toUpperCase();
}

// ../../node_modules/es-toolkit/dist/string/trimEnd.mjs
function trimEnd(str, chars) {
  if (chars === void 0) {
    return str.trimEnd();
  }
  let endIndex = str.length;
  switch (typeof chars) {
    case "string": {
      if (chars.length !== 1) {
        throw new Error(`The 'chars' parameter should be a single character string.`);
      }
      while (endIndex > 0 && str[endIndex - 1] === chars) {
        endIndex--;
      }
      break;
    }
    case "object": {
      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {
        endIndex--;
      }
    }
  }
  return str.substring(0, endIndex);
}

// ../../node_modules/es-toolkit/dist/string/trimStart.mjs
function trimStart(str, chars) {
  if (chars === void 0) {
    return str.trimStart();
  }
  let startIndex = 0;
  switch (typeof chars) {
    case "string": {
      while (startIndex < str.length && str[startIndex] === chars) {
        startIndex++;
      }
      break;
    }
    case "object": {
      while (startIndex < str.length && chars.includes(str[startIndex])) {
        startIndex++;
      }
    }
  }
  return str.substring(startIndex);
}

// ../../node_modules/es-toolkit/dist/string/trim.mjs
function trim(str, chars) {
  if (chars === void 0) {
    return str.trim();
  }
  return trimStart(trimEnd(str, chars), chars);
}

// ../../node_modules/es-toolkit/dist/compat/string/trim.mjs
function trim2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trim();
  }
  switch (typeof chars) {
    case "object": {
      if (Array.isArray(chars)) {
        return trim(str, chars.flatMap((x3) => x3.toString().split("")));
      } else {
        return trim(str, chars.toString().split(""));
      }
    }
    default: {
      return trim(str, chars.toString().split(""));
    }
  }
}

// ../../node_modules/es-toolkit/dist/compat/string/trimEnd.mjs
function trimEnd2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trimEnd();
  }
  return trimEnd(str, chars.toString().split(""));
}

// ../../node_modules/es-toolkit/dist/compat/string/trimStart.mjs
function trimStart2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trimStart();
  }
  return trimStart(str, chars.toString().split(""));
}

// ../../node_modules/es-toolkit/dist/compat/string/truncate.mjs
var regexMultiByte = /[\u200d\ud800-\udfff\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff\ufe0e\ufe0f]/;
function truncate2(string, options) {
  string = string != null ? `${string}` : "";
  let length = 30;
  let omission = "...";
  if (isObject(options)) {
    length = parseLength(options.length);
    omission = "omission" in options ? `${options.omission}` : "...";
  }
  let i2 = string.length;
  const lengthOmission = Array.from(omission).length;
  const lengthBase = Math.max(length - lengthOmission, 0);
  let strArray = void 0;
  const unicode = regexMultiByte.test(string);
  if (unicode) {
    strArray = Array.from(string);
    i2 = strArray.length;
  }
  if (length >= i2) {
    return string;
  }
  if (i2 <= lengthOmission) {
    return omission;
  }
  let base = strArray === void 0 ? string.slice(0, lengthBase) : strArray?.slice(0, lengthBase).join("");
  const separator = options?.separator;
  if (!separator) {
    base += omission;
    return base;
  }
  const search = separator instanceof RegExp ? separator.source : separator;
  const flags = "u" + (separator instanceof RegExp ? separator.flags.replace("u", "") : "");
  const withoutSeparator = new RegExp(`(?<result>.*(?:(?!${search}).))(?:${search})`, flags).exec(base);
  return (!withoutSeparator?.groups ? base : withoutSeparator.groups.result) + omission;
}
function parseLength(length) {
  if (length == null) {
    return 30;
  }
  if (length <= 0) {
    return 0;
  }
  return length;
}

// ../../node_modules/es-toolkit/dist/string/unescape.mjs
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
function unescape2(str) {
  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, (match) => htmlUnescapes[match] || "'");
}

// ../../node_modules/es-toolkit/dist/compat/string/unescape.mjs
function unescape3(str) {
  return unescape2(toString(str));
}

// ../../node_modules/es-toolkit/dist/string/upperCase.mjs
function upperCase(str) {
  const words$1 = words(str);
  let result2 = "";
  for (let i2 = 0; i2 < words$1.length; i2++) {
    result2 += words$1[i2].toUpperCase();
    if (i2 < words$1.length - 1) {
      result2 += " ";
    }
  }
  return result2;
}

// ../../node_modules/es-toolkit/dist/compat/string/upperCase.mjs
function upperCase2(str) {
  return upperCase(normalizeForCase(str));
}

// ../../node_modules/es-toolkit/dist/string/upperFirst.mjs
function upperFirst(str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}

// ../../node_modules/es-toolkit/dist/compat/string/upperFirst.mjs
function upperFirst2(str) {
  return upperFirst(toString(str));
}

// ../../node_modules/es-toolkit/dist/compat/string/words.mjs
var rNonCharLatin = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\xd7\\xf7";
var rUnicodeUpper = "\\p{Lu}";
var rUnicodeLower = "\\p{Ll}";
var rMisc = "(?:[\\p{Lm}\\p{Lo}]\\p{M}*)";
var rNumber = "\\d";
var rUnicodeOptContrLower = "(?:['\u2019](?:d|ll|m|re|s|t|ve))?";
var rUnicodeOptContrUpper = "(?:['\u2019](?:D|LL|M|RE|S|T|VE))?";
var rUnicodeBreak = `[\\p{Z}\\p{P}${rNonCharLatin}]`;
var rUnicodeMiscUpper = `(?:${rUnicodeUpper}|${rMisc})`;
var rUnicodeMiscLower = `(?:${rUnicodeLower}|${rMisc})`;
var rUnicodeWord = RegExp([
  `${rUnicodeUpper}?${rUnicodeLower}+${rUnicodeOptContrLower}(?=${rUnicodeBreak}|${rUnicodeUpper}|$)`,
  `${rUnicodeMiscUpper}+${rUnicodeOptContrUpper}(?=${rUnicodeBreak}|${rUnicodeUpper}${rUnicodeMiscLower}|$)`,
  `${rUnicodeUpper}?${rUnicodeMiscLower}+${rUnicodeOptContrLower}`,
  `${rUnicodeUpper}+${rUnicodeOptContrUpper}`,
  `${rNumber}*(?:1ST|2ND|3RD|(?![123])${rNumber}TH)(?=\\b|[a-z_])`,
  `${rNumber}*(?:1st|2nd|3rd|(?![123])${rNumber}th)(?=\\b|[A-Z_])`,
  `${rNumber}+`,
  "\\p{Emoji_Presentation}",
  "\\p{Extended_Pictographic}"
].join("|"), "gu");
function words2(str, pattern = rUnicodeWord, guard) {
  const input = toString(str);
  if (guard) {
    pattern = rUnicodeWord;
  }
  if (typeof pattern === "number") {
    pattern = pattern.toString();
  }
  const words3 = Array.from(input.match(pattern) ?? []);
  return words3.filter((x3) => x3 !== "");
}

// ../../node_modules/es-toolkit/dist/compat/util/cond.mjs
function cond(pairs) {
  const length = pairs.length;
  const processedPairs = pairs.map((pair) => {
    const predicate = pair[0];
    const func = pair[1];
    if (!isFunction(func)) {
      throw new TypeError("Expected a function");
    }
    return [iteratee(predicate), func];
  });
  return function(...args) {
    for (let i2 = 0; i2 < length; i2++) {
      const pair = processedPairs[i2];
      const predicate = pair[0];
      const func = pair[1];
      if (predicate.apply(this, args)) {
        return func.apply(this, args);
      }
    }
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/constant.mjs
function constant(value) {
  return () => value;
}

// ../../node_modules/es-toolkit/dist/compat/util/defaultTo.mjs
function defaultTo(value, defaultValue) {
  if (value == null || Number.isNaN(value)) {
    return defaultValue;
  }
  return value;
}

// ../../node_modules/es-toolkit/dist/compat/util/gt.mjs
function gt(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value > other;
  }
  return toNumber(value) > toNumber(other);
}

// ../../node_modules/es-toolkit/dist/compat/util/gte.mjs
function gte(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value >= other;
  }
  return toNumber(value) >= toNumber(other);
}

// ../../node_modules/es-toolkit/dist/compat/util/invoke.mjs
function invoke(object, path4, ...args) {
  args = args.flat(1);
  if (object == null) {
    return;
  }
  switch (typeof path4) {
    case "string": {
      if (typeof object === "object" && Object.hasOwn(object, path4)) {
        return invokeImpl(object, [path4], args);
      }
      return invokeImpl(object, toPath(path4), args);
    }
    case "number":
    case "symbol": {
      return invokeImpl(object, [path4], args);
    }
    default: {
      if (Array.isArray(path4)) {
        return invokeImpl(object, path4, args);
      } else {
        return invokeImpl(object, [path4], args);
      }
    }
  }
}
function invokeImpl(object, path4, args) {
  const parent = get(object, path4.slice(0, -1), object);
  if (parent == null) {
    return void 0;
  }
  let lastKey = last2(path4);
  const lastValue = lastKey?.valueOf();
  if (typeof lastValue === "number") {
    lastKey = toKey(lastValue);
  } else {
    lastKey = String(lastKey);
  }
  const func = get(parent, lastKey);
  return func?.apply(parent, args);
}

// ../../node_modules/es-toolkit/dist/compat/util/lt.mjs
function lt(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value < other;
  }
  return toNumber(value) < toNumber(other);
}

// ../../node_modules/es-toolkit/dist/compat/util/lte.mjs
function lte(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value <= other;
  }
  return toNumber(value) <= toNumber(other);
}

// ../../node_modules/es-toolkit/dist/compat/util/method.mjs
function method(path4, ...args) {
  return function(object) {
    return invoke(object, path4, args);
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/methodOf.mjs
function methodOf(object, ...args) {
  return function(path4) {
    return invoke(object, path4, args);
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/now.mjs
function now() {
  return Date.now();
}

// ../../node_modules/es-toolkit/dist/compat/util/over.mjs
function over(...iteratees) {
  if (iteratees.length === 1 && Array.isArray(iteratees[0])) {
    iteratees = iteratees[0];
  }
  const funcs = iteratees.map((item) => iteratee(item));
  return function(...args) {
    return funcs.map((func) => func.apply(this, args));
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/overEvery.mjs
function overEvery(...predicates) {
  return function(...values2) {
    for (let i2 = 0; i2 < predicates.length; ++i2) {
      const predicate = predicates[i2];
      if (!Array.isArray(predicate)) {
        if (!iteratee(predicate).apply(this, values2)) {
          return false;
        }
        continue;
      }
      for (let j3 = 0; j3 < predicate.length; ++j3) {
        if (!iteratee(predicate[j3]).apply(this, values2)) {
          return false;
        }
      }
    }
    return true;
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/overSome.mjs
function overSome(...predicates) {
  return function(...values2) {
    for (let i2 = 0; i2 < predicates.length; ++i2) {
      const predicate = predicates[i2];
      if (!Array.isArray(predicate)) {
        if (iteratee(predicate).apply(this, values2)) {
          return true;
        }
        continue;
      }
      for (let j3 = 0; j3 < predicate.length; ++j3) {
        if (iteratee(predicate[j3]).apply(this, values2)) {
          return true;
        }
      }
    }
    return false;
  };
}

// ../../node_modules/es-toolkit/dist/compat/util/stubArray.mjs
function stubArray() {
  return [];
}

// ../../node_modules/es-toolkit/dist/compat/util/stubFalse.mjs
function stubFalse() {
  return false;
}

// ../../node_modules/es-toolkit/dist/compat/util/stubObject.mjs
function stubObject() {
  return {};
}

// ../../node_modules/es-toolkit/dist/compat/util/stubString.mjs
function stubString() {
  return "";
}

// ../../node_modules/es-toolkit/dist/compat/util/stubTrue.mjs
function stubTrue() {
  return true;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/MAX_ARRAY_LENGTH.mjs
var MAX_ARRAY_LENGTH4 = 4294967295;

// ../../node_modules/es-toolkit/dist/compat/util/toLength.mjs
function toLength(value) {
  if (value == null) {
    return 0;
  }
  const length = Math.floor(Number(value));
  return clamp2(length, 0, MAX_ARRAY_LENGTH4);
}

// ../../node_modules/es-toolkit/dist/compat/util/toPlainObject.mjs
function toPlainObject(value) {
  const plainObject = {};
  const valueKeys = keysIn(value);
  for (let i2 = 0; i2 < valueKeys.length; i2++) {
    const key = valueKeys[i2];
    const objValue = value[key];
    if (key === "__proto__") {
      Object.defineProperty(plainObject, key, {
        configurable: true,
        enumerable: true,
        value: objValue,
        writable: true
      });
    } else {
      plainObject[key] = objValue;
    }
  }
  return plainObject;
}

// ../../node_modules/es-toolkit/dist/compat/_internal/MAX_SAFE_INTEGER.mjs
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

// ../../node_modules/es-toolkit/dist/compat/util/toSafeInteger.mjs
function toSafeInteger(value) {
  if (value == null) {
    return 0;
  }
  return clamp2(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
}

// ../../node_modules/es-toolkit/dist/compat/util/uniqueId.mjs
var idCounter = 0;
function uniqueId(prefix2 = "") {
  const id = ++idCounter;
  return `${prefix2}${id}`;
}

// ../../node_modules/es-toolkit/dist/compat/compat.mjs
var compat_exports = {};
__export(compat_exports, {
  add: () => add,
  after: () => after,
  ary: () => ary2,
  assign: () => assign,
  assignIn: () => assignIn,
  assignInWith: () => assignInWith,
  assignWith: () => assignWith,
  at: () => at,
  attempt: () => attempt,
  before: () => before,
  bind: () => bind,
  bindAll: () => bindAll,
  bindKey: () => bindKey,
  camelCase: () => camelCase2,
  capitalize: () => capitalize2,
  castArray: () => castArray,
  ceil: () => ceil,
  chunk: () => chunk2,
  clamp: () => clamp2,
  clone: () => clone,
  cloneDeep: () => cloneDeep2,
  cloneDeepWith: () => cloneDeepWith2,
  cloneWith: () => cloneWith,
  compact: () => compact2,
  concat: () => concat,
  cond: () => cond,
  conforms: () => conforms,
  conformsTo: () => conformsTo,
  constant: () => constant,
  countBy: () => countBy,
  create: () => create,
  curry: () => curry,
  curryRight: () => curryRight,
  debounce: () => debounce2,
  deburr: () => deburr2,
  defaultTo: () => defaultTo,
  defaults: () => defaults,
  defaultsDeep: () => defaultsDeep,
  defer: () => defer,
  delay: () => delay,
  difference: () => difference2,
  differenceBy: () => differenceBy2,
  differenceWith: () => differenceWith2,
  divide: () => divide,
  drop: () => drop2,
  dropRight: () => dropRight2,
  dropRightWhile: () => dropRightWhile2,
  dropWhile: () => dropWhile2,
  each: () => forEach,
  eachRight: () => forEachRight,
  endsWith: () => endsWith,
  eq: () => eq,
  escape: () => escape3,
  escapeRegExp: () => escapeRegExp2,
  every: () => every,
  extend: () => assignIn,
  extendWith: () => assignInWith,
  fill: () => fill3,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex,
  findKey: () => findKey2,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  findLastKey: () => findLastKey,
  first: () => head2,
  flatMap: () => flatMap,
  flatMapDeep: () => flatMapDeep,
  flatMapDepth: () => flatMapDepth,
  flatten: () => flatten2,
  flattenDeep: () => flattenDeep,
  flattenDepth: () => flattenDepth,
  flip: () => flip,
  floor: () => floor,
  flow: () => flow2,
  flowRight: () => flowRight2,
  forEach: () => forEach,
  forEachRight: () => forEachRight,
  forIn: () => forIn,
  forInRight: () => forInRight,
  forOwn: () => forOwn,
  forOwnRight: () => forOwnRight,
  fromPairs: () => fromPairs,
  functions: () => functions,
  functionsIn: () => functionsIn,
  get: () => get,
  groupBy: () => groupBy2,
  gt: () => gt,
  gte: () => gte,
  has: () => has,
  hasIn: () => hasIn,
  head: () => head2,
  identity: () => identity2,
  inRange: () => inRange2,
  includes: () => includes,
  indexOf: () => indexOf,
  initial: () => initial2,
  intersection: () => intersection2,
  intersectionBy: () => intersectionBy2,
  intersectionWith: () => intersectionWith2,
  invert: () => invert2,
  invertBy: () => invertBy,
  invoke: () => invoke,
  invokeMap: () => invokeMap,
  isArguments: () => isArguments,
  isArray: () => isArray,
  isArrayBuffer: () => isArrayBuffer2,
  isArrayLike: () => isArrayLike,
  isArrayLikeObject: () => isArrayLikeObject,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer2,
  isDate: () => isDate2,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isEqualWith: () => isEqualWith2,
  isError: () => isError2,
  isFinite: () => isFinite2,
  isFunction: () => isFunction2,
  isInteger: () => isInteger,
  isLength: () => isLength2,
  isMap: () => isMap2,
  isMatch: () => isMatch,
  isMatchWith: () => isMatchWith,
  isNaN: () => isNaN2,
  isNative: () => isNative,
  isNil: () => isNil2,
  isNull: () => isNull2,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isObjectLike: () => isObjectLike,
  isPlainObject: () => isPlainObject3,
  isRegExp: () => isRegExp3,
  isSafeInteger: () => isSafeInteger,
  isSet: () => isSet2,
  isString: () => isString2,
  isSymbol: () => isSymbol,
  isTypedArray: () => isTypedArray2,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap2,
  isWeakSet: () => isWeakSet2,
  iteratee: () => iteratee,
  join: () => join,
  kebabCase: () => kebabCase2,
  keyBy: () => keyBy,
  keys: () => keys,
  keysIn: () => keysIn,
  last: () => last2,
  lastIndexOf: () => lastIndexOf,
  lowerCase: () => lowerCase2,
  lowerFirst: () => lowerFirst2,
  lt: () => lt,
  lte: () => lte,
  map: () => map,
  mapKeys: () => mapKeys2,
  mapValues: () => mapValues2,
  matches: () => matches,
  matchesProperty: () => matchesProperty,
  max: () => max,
  maxBy: () => maxBy2,
  mean: () => mean,
  meanBy: () => meanBy2,
  memoize: () => memoize,
  merge: () => merge2,
  mergeWith: () => mergeWith,
  method: () => method,
  methodOf: () => methodOf,
  min: () => min,
  minBy: () => minBy2,
  multiply: () => multiply,
  negate: () => negate,
  noop: () => noop2,
  now: () => now,
  nth: () => nth,
  nthArg: () => nthArg,
  omit: () => omit,
  omitBy: () => omitBy,
  once: () => once2,
  orderBy: () => orderBy,
  over: () => over,
  overArgs: () => overArgs,
  overEvery: () => overEvery,
  overSome: () => overSome,
  pad: () => pad2,
  padEnd: () => padEnd,
  padStart: () => padStart,
  parseInt: () => parseInt2,
  partial: () => partial2,
  partialRight: () => partialRight2,
  partition: () => partition,
  pick: () => pick,
  pickBy: () => pickBy,
  property: () => property,
  propertyOf: () => propertyOf,
  pull: () => pull2,
  pullAll: () => pullAll,
  pullAllBy: () => pullAllBy,
  pullAllWith: () => pullAllWith,
  pullAt: () => pullAt,
  random: () => random2,
  range: () => range2,
  rangeRight: () => rangeRight,
  rearg: () => rearg,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reject: () => reject,
  remove: () => remove2,
  repeat: () => repeat,
  replace: () => replace,
  rest: () => rest2,
  result: () => result,
  reverse: () => reverse,
  round: () => round,
  sample: () => sample2,
  sampleSize: () => sampleSize2,
  set: () => set,
  setWith: () => setWith,
  shuffle: () => shuffle2,
  size: () => size,
  slice: () => slice,
  snakeCase: () => snakeCase2,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  sortedIndexBy: () => sortedIndexBy,
  sortedIndexOf: () => sortedIndexOf,
  sortedLastIndex: () => sortedLastIndex,
  sortedLastIndexBy: () => sortedLastIndexBy,
  sortedLastIndexOf: () => sortedLastIndexOf,
  split: () => split,
  spread: () => spread,
  startCase: () => startCase,
  startsWith: () => startsWith,
  stubArray: () => stubArray,
  stubFalse: () => stubFalse,
  stubObject: () => stubObject,
  stubString: () => stubString,
  stubTrue: () => stubTrue,
  subtract: () => subtract,
  sum: () => sum,
  sumBy: () => sumBy,
  tail: () => tail2,
  take: () => take2,
  takeRight: () => takeRight2,
  takeRightWhile: () => takeRightWhile,
  takeWhile: () => takeWhile,
  template: () => template,
  templateSettings: () => templateSettings,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray2,
  toDefaulted: () => toDefaulted,
  toFinite: () => toFinite,
  toInteger: () => toInteger,
  toLength: () => toLength,
  toLower: () => toLower,
  toNumber: () => toNumber,
  toPairs: () => toPairs,
  toPairsIn: () => toPairsIn,
  toPath: () => toPath,
  toPlainObject: () => toPlainObject,
  toSafeInteger: () => toSafeInteger,
  toString: () => toString,
  toUpper: () => toUpper,
  transform: () => transform,
  trim: () => trim2,
  trimEnd: () => trimEnd2,
  trimStart: () => trimStart2,
  truncate: () => truncate2,
  unary: () => unary,
  unescape: () => unescape3,
  union: () => union,
  unionBy: () => unionBy,
  unionWith: () => unionWith,
  uniq: () => uniq2,
  uniqBy: () => uniqBy2,
  uniqWith: () => uniqWith2,
  uniqueId: () => uniqueId,
  unset: () => unset,
  unzip: () => unzip2,
  unzipWith: () => unzipWith,
  update: () => update,
  updateWith: () => updateWith,
  upperCase: () => upperCase2,
  upperFirst: () => upperFirst2,
  values: () => values,
  valuesIn: () => valuesIn,
  without: () => without2,
  words: () => words2,
  wrap: () => wrap2,
  xor: () => xor,
  xorBy: () => xorBy,
  xorWith: () => xorWith,
  zip: () => zip2,
  zipObject: () => zipObject,
  zipObjectDeep: () => zipObjectDeep,
  zipWith: () => zipWith
});

// ../../node_modules/es-toolkit/dist/compat/toolkit.mjs
var toolkit = ((value) => {
  return value;
});
Object.assign(toolkit, compat_exports);
toolkit.partial.placeholder = toolkit;
toolkit.partialRight.placeholder = toolkit;

// src/common/sentry.ts
init_constants();
var APP_START_TIME = performance.now();
var SENTRY_OPTIONS = {
  sampleRate: 0.5,
  dsn: getSentryDsn(),
  environment: getAppEnvironment(),
  release: getAppVersion()
};

// ../insomnia-scripting-environment/src/objects/properties.ts
var import_clone5 = __toESM(require_clone());
var import_deep_equal = __toESM(require_deep_equal());

// ../../node_modules/@faker-js/faker/dist/chunk-W5EWQAXN.js
var e = [{ name: "Aegean Airlines", iataCode: "A3" }, { name: "Aeroflot", iataCode: "SU" }, { name: "Aerolineas Argentinas", iataCode: "AR" }, { name: "Aeromexico", iataCode: "AM" }, { name: "Air Algerie", iataCode: "AH" }, { name: "Air Arabia", iataCode: "G9" }, { name: "Air Canada", iataCode: "AC" }, { name: "Air China", iataCode: "CA" }, { name: "Air Europa", iataCode: "UX" }, { name: "Air France", iataCode: "AF" }, { name: "Air India", iataCode: "AI" }, { name: "Air Mauritius", iataCode: "MK" }, { name: "Air New Zealand", iataCode: "NZ" }, { name: "Air Niugini", iataCode: "PX" }, { name: "Air Tahiti", iataCode: "VT" }, { name: "Air Tahiti Nui", iataCode: "TN" }, { name: "Air Transat", iataCode: "TS" }, { name: "AirAsia X", iataCode: "D7" }, { name: "AirAsia", iataCode: "AK" }, { name: "Aircalin", iataCode: "SB" }, { name: "Alaska Airlines", iataCode: "AS" }, { name: "Alitalia", iataCode: "AZ" }, { name: "All Nippon Airways", iataCode: "NH" }, { name: "Allegiant Air", iataCode: "G4" }, { name: "American Airlines", iataCode: "AA" }, { name: "Asiana Airlines", iataCode: "OZ" }, { name: "Avianca", iataCode: "AV" }, { name: "Azul Linhas Aereas Brasileiras", iataCode: "AD" }, { name: "Azur Air", iataCode: "ZF" }, { name: "Beijing Capital Airlines", iataCode: "JD" }, { name: "Boliviana de Aviacion", iataCode: "OB" }, { name: "British Airways", iataCode: "BA" }, { name: "Cathay Pacific", iataCode: "CX" }, { name: "Cebu Pacific Air", iataCode: "5J" }, { name: "China Airlines", iataCode: "CI" }, { name: "China Eastern Airlines", iataCode: "MU" }, { name: "China Southern Airlines", iataCode: "CZ" }, { name: "Condor", iataCode: "DE" }, { name: "Copa Airlines", iataCode: "CM" }, { name: "Delta Air Lines", iataCode: "DL" }, { name: "Easyfly", iataCode: "VE" }, { name: "EasyJet", iataCode: "U2" }, { name: "EcoJet", iataCode: "8J" }, { name: "Egyptair", iataCode: "MS" }, { name: "El Al", iataCode: "LY" }, { name: "Emirates Airlines", iataCode: "EK" }, { name: "Ethiopian Airlines", iataCode: "ET" }, { name: "Etihad Airways", iataCode: "EY" }, { name: "EVA Air", iataCode: "BR" }, { name: "Fiji Airways", iataCode: "FJ" }, { name: "Finnair", iataCode: "AY" }, { name: "Flybondi", iataCode: "FO" }, { name: "Flydubai", iataCode: "FZ" }, { name: "FlySafair", iataCode: "FA" }, { name: "Frontier Airlines", iataCode: "F9" }, { name: "Garuda Indonesia", iataCode: "GA" }, { name: "Go First", iataCode: "G8" }, { name: "Gol Linhas Aereas Inteligentes", iataCode: "G3" }, { name: "Hainan Airlines", iataCode: "HU" }, { name: "Hawaiian Airlines", iataCode: "HA" }, { name: "IndiGo Airlines", iataCode: "6E" }, { name: "Japan Airlines", iataCode: "JL" }, { name: "Jeju Air", iataCode: "7C" }, { name: "Jet2", iataCode: "LS" }, { name: "JetBlue Airways", iataCode: "B6" }, { name: "JetSMART", iataCode: "JA" }, { name: "Juneyao Airlines", iataCode: "HO" }, { name: "Kenya Airways", iataCode: "KQ" }, { name: "KLM Royal Dutch Airlines", iataCode: "KL" }, { name: "Korean Air", iataCode: "KE" }, { name: "Kulula.com", iataCode: "MN" }, { name: "LATAM Airlines", iataCode: "LA" }, { name: "Lion Air", iataCode: "JT" }, { name: "LOT Polish Airlines", iataCode: "LO" }, { name: "Lufthansa", iataCode: "LH" }, { name: "Libyan Airlines", iataCode: "LN" }, { name: "Linea Aerea Amaszonas", iataCode: "Z8" }, { name: "Malaysia Airlines", iataCode: "MH" }, { name: "Nordwind Airlines", iataCode: "N4" }, { name: "Norwegian Air Shuttle", iataCode: "DY" }, { name: "Oman Air", iataCode: "WY" }, { name: "Pakistan International Airlines", iataCode: "PK" }, { name: "Pegasus Airlines", iataCode: "PC" }, { name: "Philippine Airlines", iataCode: "PR" }, { name: "Qantas Group", iataCode: "QF" }, { name: "Qatar Airways", iataCode: "QR" }, { name: "Republic Airways", iataCode: "YX" }, { name: "Royal Air Maroc", iataCode: "AT" }, { name: "Ryanair", iataCode: "FR" }, { name: "S7 Airlines", iataCode: "S7" }, { name: "SAS", iataCode: "SK" }, { name: "Satena", iataCode: "9R" }, { name: "Saudia", iataCode: "SV" }, { name: "Shandong Airlines", iataCode: "SC" }, { name: "Sichuan Airlines", iataCode: "3U" }, { name: "Singapore Airlines", iataCode: "SQ" }, { name: "Sky Airline", iataCode: "H2" }, { name: "SkyWest Airlines", iataCode: "OO" }, { name: "South African Airways", iataCode: "SA" }, { name: "Southwest Airlines", iataCode: "WN" }, { name: "SpiceJet", iataCode: "SG" }, { name: "Spirit Airlines", iataCode: "NK" }, { name: "Spring Airlines", iataCode: "9S" }, { name: "SriLankan Airlines", iataCode: "UL" }, { name: "Star Peru", iataCode: "2I" }, { name: "Sun Country Airlines", iataCode: "SY" }, { name: "SunExpress", iataCode: "XQ" }, { name: "TAP Air Portugal", iataCode: "TP" }, { name: "Thai AirAsia", iataCode: "FD" }, { name: "Thai Airways", iataCode: "TG" }, { name: "TUI Airways", iataCode: "BY" }, { name: "Tunisair", iataCode: "TU" }, { name: "Turkish Airlines", iataCode: "TK" }, { name: "Ukraine International", iataCode: "PS" }, { name: "United Airlines", iataCode: "UA" }, { name: "Ural Airlines", iataCode: "U6" }, { name: "VietJet Air", iataCode: "VJ" }, { name: "Vietnam Airlines", iataCode: "VN" }, { name: "Virgin Atlantic Airways", iataCode: "VS" }, { name: "Virgin Australia", iataCode: "VA" }, { name: "VivaAerobus", iataCode: "VB" }, { name: "VOEPASS Linhas Aereas", iataCode: "2Z" }, { name: "Volaris", iataCode: "Y4" }, { name: "WestJet", iataCode: "WS" }, { name: "Wingo", iataCode: "P5" }, { name: "Wizz Air", iataCode: "W6" }];
var a = [{ name: "Aerospatiale/BAC Concorde", iataTypeCode: "SSC" }, { name: "Airbus A300", iataTypeCode: "AB3" }, { name: "Airbus A310", iataTypeCode: "310" }, { name: "Airbus A310-200", iataTypeCode: "312" }, { name: "Airbus A310-300", iataTypeCode: "313" }, { name: "Airbus A318", iataTypeCode: "318" }, { name: "Airbus A319", iataTypeCode: "319" }, { name: "Airbus A319neo", iataTypeCode: "31N" }, { name: "Airbus A320", iataTypeCode: "320" }, { name: "Airbus A320neo", iataTypeCode: "32N" }, { name: "Airbus A321", iataTypeCode: "321" }, { name: "Airbus A321neo", iataTypeCode: "32Q" }, { name: "Airbus A330", iataTypeCode: "330" }, { name: "Airbus A330-200", iataTypeCode: "332" }, { name: "Airbus A330-300", iataTypeCode: "333" }, { name: "Airbus A330-800neo", iataTypeCode: "338" }, { name: "Airbus A330-900neo", iataTypeCode: "339" }, { name: "Airbus A340", iataTypeCode: "340" }, { name: "Airbus A340-200", iataTypeCode: "342" }, { name: "Airbus A340-300", iataTypeCode: "343" }, { name: "Airbus A340-500", iataTypeCode: "345" }, { name: "Airbus A340-600", iataTypeCode: "346" }, { name: "Airbus A350", iataTypeCode: "350" }, { name: "Airbus A350-900", iataTypeCode: "359" }, { name: "Airbus A350-1000", iataTypeCode: "351" }, { name: "Airbus A380", iataTypeCode: "380" }, { name: "Airbus A380-800", iataTypeCode: "388" }, { name: "Antonov An-12", iataTypeCode: "ANF" }, { name: "Antonov An-24", iataTypeCode: "AN4" }, { name: "Antonov An-26", iataTypeCode: "A26" }, { name: "Antonov An-28", iataTypeCode: "A28" }, { name: "Antonov An-30", iataTypeCode: "A30" }, { name: "Antonov An-32", iataTypeCode: "A32" }, { name: "Antonov An-72", iataTypeCode: "AN7" }, { name: "Antonov An-124 Ruslan", iataTypeCode: "A4F" }, { name: "Antonov An-140", iataTypeCode: "A40" }, { name: "Antonov An-148", iataTypeCode: "A81" }, { name: "Antonov An-158", iataTypeCode: "A58" }, { name: "Antonov An-225 Mriya", iataTypeCode: "A5F" }, { name: "Boeing 707", iataTypeCode: "703" }, { name: "Boeing 717", iataTypeCode: "717" }, { name: "Boeing 720B", iataTypeCode: "B72" }, { name: "Boeing 727", iataTypeCode: "727" }, { name: "Boeing 727-100", iataTypeCode: "721" }, { name: "Boeing 727-200", iataTypeCode: "722" }, { name: "Boeing 737 MAX 7", iataTypeCode: "7M7" }, { name: "Boeing 737 MAX 8", iataTypeCode: "7M8" }, { name: "Boeing 737 MAX 9", iataTypeCode: "7M9" }, { name: "Boeing 737 MAX 10", iataTypeCode: "7MJ" }, { name: "Boeing 737", iataTypeCode: "737" }, { name: "Boeing 737-100", iataTypeCode: "731" }, { name: "Boeing 737-200", iataTypeCode: "732" }, { name: "Boeing 737-300", iataTypeCode: "733" }, { name: "Boeing 737-400", iataTypeCode: "734" }, { name: "Boeing 737-500", iataTypeCode: "735" }, { name: "Boeing 737-600", iataTypeCode: "736" }, { name: "Boeing 737-700", iataTypeCode: "73G" }, { name: "Boeing 737-800", iataTypeCode: "738" }, { name: "Boeing 737-900", iataTypeCode: "739" }, { name: "Boeing 747", iataTypeCode: "747" }, { name: "Boeing 747-100", iataTypeCode: "741" }, { name: "Boeing 747-200", iataTypeCode: "742" }, { name: "Boeing 747-300", iataTypeCode: "743" }, { name: "Boeing 747-400", iataTypeCode: "744" }, { name: "Boeing 747-400D", iataTypeCode: "74J" }, { name: "Boeing 747-8", iataTypeCode: "748" }, { name: "Boeing 747SP", iataTypeCode: "74L" }, { name: "Boeing 747SR", iataTypeCode: "74R" }, { name: "Boeing 757", iataTypeCode: "757" }, { name: "Boeing 757-200", iataTypeCode: "752" }, { name: "Boeing 757-300", iataTypeCode: "753" }, { name: "Boeing 767", iataTypeCode: "767" }, { name: "Boeing 767-200", iataTypeCode: "762" }, { name: "Boeing 767-300", iataTypeCode: "763" }, { name: "Boeing 767-400", iataTypeCode: "764" }, { name: "Boeing 777", iataTypeCode: "777" }, { name: "Boeing 777-200", iataTypeCode: "772" }, { name: "Boeing 777-200LR", iataTypeCode: "77L" }, { name: "Boeing 777-300", iataTypeCode: "773" }, { name: "Boeing 777-300ER", iataTypeCode: "77W" }, { name: "Boeing 787", iataTypeCode: "787" }, { name: "Boeing 787-8", iataTypeCode: "788" }, { name: "Boeing 787-9", iataTypeCode: "789" }, { name: "Boeing 787-10", iataTypeCode: "781" }, { name: "Canadair Challenger", iataTypeCode: "CCJ" }, { name: "Canadair CL-44", iataTypeCode: "CL4" }, { name: "Canadair Regional Jet 100", iataTypeCode: "CR1" }, { name: "Canadair Regional Jet 200", iataTypeCode: "CR2" }, { name: "Canadair Regional Jet 700", iataTypeCode: "CR7" }, { name: "Canadair Regional Jet 705", iataTypeCode: "CRA" }, { name: "Canadair Regional Jet 900", iataTypeCode: "CR9" }, { name: "Canadair Regional Jet 1000", iataTypeCode: "CRK" }, { name: "De Havilland Canada DHC-2 Beaver", iataTypeCode: "DHP" }, { name: "De Havilland Canada DHC-2 Turbo-Beaver", iataTypeCode: "DHR" }, { name: "De Havilland Canada DHC-3 Otter", iataTypeCode: "DHL" }, { name: "De Havilland Canada DHC-4 Caribou", iataTypeCode: "DHC" }, { name: "De Havilland Canada DHC-6 Twin Otter", iataTypeCode: "DHT" }, { name: "De Havilland Canada DHC-7 Dash 7", iataTypeCode: "DH7" }, { name: "De Havilland Canada DHC-8-100 Dash 8 / 8Q", iataTypeCode: "DH1" }, { name: "De Havilland Canada DHC-8-200 Dash 8 / 8Q", iataTypeCode: "DH2" }, { name: "De Havilland Canada DHC-8-300 Dash 8 / 8Q", iataTypeCode: "DH3" }, { name: "De Havilland Canada DHC-8-400 Dash 8Q", iataTypeCode: "DH4" }, { name: "De Havilland DH.104 Dove", iataTypeCode: "DHD" }, { name: "De Havilland DH.114 Heron", iataTypeCode: "DHH" }, { name: "Douglas DC-3", iataTypeCode: "D3F" }, { name: "Douglas DC-6", iataTypeCode: "D6F" }, { name: "Douglas DC-8-50", iataTypeCode: "D8T" }, { name: "Douglas DC-8-62", iataTypeCode: "D8L" }, { name: "Douglas DC-8-72", iataTypeCode: "D8Q" }, { name: "Douglas DC-9-10", iataTypeCode: "D91" }, { name: "Douglas DC-9-20", iataTypeCode: "D92" }, { name: "Douglas DC-9-30", iataTypeCode: "D93" }, { name: "Douglas DC-9-40", iataTypeCode: "D94" }, { name: "Douglas DC-9-50", iataTypeCode: "D95" }, { name: "Douglas DC-10", iataTypeCode: "D10" }, { name: "Douglas DC-10-10", iataTypeCode: "D1X" }, { name: "Douglas DC-10-30", iataTypeCode: "D1Y" }, { name: "Embraer 170", iataTypeCode: "E70" }, { name: "Embraer 175", iataTypeCode: "E75" }, { name: "Embraer 190", iataTypeCode: "E90" }, { name: "Embraer 195", iataTypeCode: "E95" }, { name: "Embraer E190-E2", iataTypeCode: "290" }, { name: "Embraer E195-E2", iataTypeCode: "295" }, { name: "Embraer EMB.110 Bandeirante", iataTypeCode: "EMB" }, { name: "Embraer EMB.120 Brasilia", iataTypeCode: "EM2" }, { name: "Embraer Legacy 600", iataTypeCode: "ER3" }, { name: "Embraer Phenom 100", iataTypeCode: "EP1" }, { name: "Embraer Phenom 300", iataTypeCode: "EP3" }, { name: "Embraer RJ135", iataTypeCode: "ER3" }, { name: "Embraer RJ140", iataTypeCode: "ERD" }, { name: "Embraer RJ145 Amazon", iataTypeCode: "ER4" }, { name: "Ilyushin IL18", iataTypeCode: "IL8" }, { name: "Ilyushin IL62", iataTypeCode: "IL6" }, { name: "Ilyushin IL76", iataTypeCode: "IL7" }, { name: "Ilyushin IL86", iataTypeCode: "ILW" }, { name: "Ilyushin IL96-300", iataTypeCode: "I93" }, { name: "Ilyushin IL114", iataTypeCode: "I14" }, { name: "Lockheed L-182 / 282 / 382 (L-100) Hercules", iataTypeCode: "LOH" }, { name: "Lockheed L-188 Electra", iataTypeCode: "LOE" }, { name: "Lockheed L-1011 Tristar", iataTypeCode: "L10" }, { name: "Lockheed L-1049 Super Constellation", iataTypeCode: "L49" }, { name: "McDonnell Douglas MD11", iataTypeCode: "M11" }, { name: "McDonnell Douglas MD80", iataTypeCode: "M80" }, { name: "McDonnell Douglas MD81", iataTypeCode: "M81" }, { name: "McDonnell Douglas MD82", iataTypeCode: "M82" }, { name: "McDonnell Douglas MD83", iataTypeCode: "M83" }, { name: "McDonnell Douglas MD87", iataTypeCode: "M87" }, { name: "McDonnell Douglas MD88", iataTypeCode: "M88" }, { name: "McDonnell Douglas MD90", iataTypeCode: "M90" }, { name: "Sukhoi Superjet 100-95", iataTypeCode: "SU9" }, { name: "Tupolev Tu-134", iataTypeCode: "TU3" }, { name: "Tupolev Tu-154", iataTypeCode: "TU5" }, { name: "Tupolev Tu-204", iataTypeCode: "T20" }, { name: "Yakovlev Yak-40", iataTypeCode: "YK4" }, { name: "Yakovlev Yak-42", iataTypeCode: "YK2" }];
var r = [{ name: "Adelaide International Airport", iataCode: "ADL" }, { name: "Adolfo Suarez Madrid-Barajas Airport", iataCode: "MAD" }, { name: "Aeroparque Jorge Newbery Airport", iataCode: "AEP" }, { name: "Afonso Pena International Airport", iataCode: "CWB" }, { name: "Alfonso Bonilla Aragon International Airport", iataCode: "CLO" }, { name: "Amsterdam Airport Schiphol", iataCode: "AMS" }, { name: "Arturo Merino Benitez International Airport", iataCode: "SCL" }, { name: "Auckland International Airport", iataCode: "AKL" }, { name: "Beijing Capital International Airport", iataCode: "PEK" }, { name: "Belem Val de Cans International Airport", iataCode: "BEL" }, { name: "Belo Horizonte Tancredo Neves International Airport", iataCode: "CNF" }, { name: "Berlin-Tegel Airport", iataCode: "TXL" }, { name: "Bole International Airport", iataCode: "ADD" }, { name: "Brasilia-Presidente Juscelino Kubitschek International Airport", iataCode: "BSB" }, { name: "Brisbane International Airport", iataCode: "BNE" }, { name: "Brussels Airport", iataCode: "BRU" }, { name: "Cairns Airport", iataCode: "CNS" }, { name: "Cairo International Airport", iataCode: "CAI" }, { name: "Canberra Airport", iataCode: "CBR" }, { name: "Capetown International Airport", iataCode: "CPT" }, { name: "Charles de Gaulle International Airport", iataCode: "CDG" }, { name: "Charlotte Douglas International Airport", iataCode: "CLT" }, { name: "Chengdu Shuangliu International Airport", iataCode: "CTU" }, { name: "Chhatrapati Shivaji International Airport", iataCode: "BOM" }, { name: "Chicago O'Hare International Airport", iataCode: "ORD" }, { name: "Chongqing Jiangbei International Airport", iataCode: "CKG" }, { name: "Christchurch International Airport", iataCode: "CHC" }, { name: "Copenhagen Kastrup Airport", iataCode: "CPH" }, { name: "Dallas Fort Worth International Airport", iataCode: "DFW" }, { name: "Daniel K. Inouye International Airport", iataCode: "HNL" }, { name: "Denver International Airport", iataCode: "DEN" }, { name: "Don Mueang International Airport", iataCode: "DMK" }, { name: "Dubai International Airport", iataCode: "DXB" }, { name: "Dublin Airport", iataCode: "DUB" }, { name: "Dusseldorf Airport", iataCode: "DUS" }, { name: "El Dorado International Airport", iataCode: "BOG" }, { name: "Eleftherios Venizelos International Airport", iataCode: "ATH" }, { name: "Faa'a International Airport", iataCode: "PPT" }, { name: "Fort Lauderdale Hollywood International Airport", iataCode: "FLL" }, { name: "Fortaleza Pinto Martins International Airport", iataCode: "FOR" }, { name: "Frankfurt am Main Airport", iataCode: "FRA" }, { name: "George Bush Intercontinental Houston Airport", iataCode: "IAH" }, { name: "Gold Coast Airport", iataCode: "OOL" }, { name: "Guarulhos - Governador Andre Franco Montoro International Airport", iataCode: "GRU" }, { name: "Hartsfield-Jackson Atlanta International Airport", iataCode: "ATL" }, { name: "Helsinki Vantaa Airport", iataCode: "HEL" }, { name: "Hobart International Airport", iataCode: "HBA" }, { name: "Hong Kong International Airport", iataCode: "HKG" }, { name: "Houari Boumediene Airport", iataCode: "ALG" }, { name: "Hurgada International Airport", iataCode: "HRG" }, { name: "Incheon International Airport", iataCode: "ICN" }, { name: "Indira Gandhi International Airport", iataCode: "DEL" }, { name: "Istanbul Airport", iataCode: "IST" }, { name: "Jacksons International Airport", iataCode: "POM" }, { name: "Jeju International Airport", iataCode: "CJU" }, { name: "John F Kennedy International Airport", iataCode: "JFK" }, { name: "Jorge Chavez International Airport", iataCode: "LIM" }, { name: "Jose Maria Cordova International Airport", iataCode: "MDE" }, { name: "Josep Tarradellas Barcelona-El Prat Airport", iataCode: "BCN" }, { name: "Kahului Airport", iataCode: "OGG" }, { name: "King Abdulaziz International Airport", iataCode: "JED" }, { name: "Kuala Lumpur International Airport", iataCode: "KUL" }, { name: "Kunming Changshui International Airport", iataCode: "KMG" }, { name: "La Tontouta International Airport", iataCode: "NOU" }, { name: "Leonardo da Vinci-Fiumicino Airport", iataCode: "FCO" }, { name: "London Heathrow Airport", iataCode: "LHR" }, { name: "Los Angeles International Airport", iataCode: "LAX" }, { name: "McCarran International Airport", iataCode: "LAS" }, { name: "Melbourne International Airport", iataCode: "MEL" }, { name: "Mexico City International Airport", iataCode: "MEX" }, { name: "Miami International Airport", iataCode: "MIA" }, { name: "Ministro Pistarini International Airport", iataCode: "EZE" }, { name: "Minneapolis-St Paul International/Wold-Chamberlain Airport", iataCode: "MSP" }, { name: "Mohammed V International Airport", iataCode: "CMN" }, { name: "Moscow Domodedovo Airport", iataCode: "DME" }, { name: "Munich Airport", iataCode: "MUC" }, { name: "Murtala Muhammed International Airport", iataCode: "LOS" }, { name: "Nadi International Airport", iataCode: "NAN" }, { name: "Nairobi Jomo Kenyatta International Airport", iataCode: "NBO" }, { name: "Narita International Airport", iataCode: "NRT" }, { name: "Newark Liberty International Airport", iataCode: "EWR" }, { name: "Ninoy Aquino International Airport", iataCode: "MNL" }, { name: "Noumea Magenta Airport", iataCode: "GEA" }, { name: "O. R. Tambo International Airport", iataCode: "JNB" }, { name: "Orlando International Airport", iataCode: "MCO" }, { name: "Oslo Lufthavn", iataCode: "OSL" }, { name: "Perth Airport", iataCode: "PER" }, { name: "Phoenix Sky Harbor International Airport", iataCode: "PHX" }, { name: "Recife Guararapes-Gilberto Freyre International Airport", iataCode: "REC" }, { name: "Rio de Janeiro Galeao International Airport", iataCode: "GIG" }, { name: "Salgado Filho International Airport", iataCode: "POA" }, { name: "Salvador Deputado Luis Eduardo Magalhaes International Airport", iataCode: "SSA" }, { name: "San Francisco International Airport", iataCode: "SFO" }, { name: "Santos Dumont Airport", iataCode: "SDU" }, { name: "Sao Paulo-Congonhas Airport", iataCode: "CGH" }, { name: "Seattle Tacoma International Airport", iataCode: "SEA" }, { name: "Shanghai Hongqiao International Airport", iataCode: "SHA" }, { name: "Shanghai Pudong International Airport", iataCode: "PVG" }, { name: "Shenzhen Bao'an International Airport", iataCode: "SZX" }, { name: "Sheremetyevo International Airport", iataCode: "SVO" }, { name: "Singapore Changi Airport", iataCode: "SIN" }, { name: "Soekarno-Hatta International Airport", iataCode: "CGK" }, { name: 'Stockholm-Arlanda Airport"', iataCode: "ARN" }, { name: "Suvarnabhumi Airport", iataCode: "BKK" }, { name: "Sydney Kingsford Smith International Airport", iataCode: "SYD" }, { name: "Taiwan Taoyuan International Airport", iataCode: "TPE" }, { name: "Tan Son Nhat International Airport", iataCode: "SGN" }, { name: "Tokyo Haneda International Airport", iataCode: "HND" }, { name: "Toronto Pearson International Airport", iataCode: "YYZ" }, { name: "Tunis Carthage International Airport", iataCode: "TUN" }, { name: "Vancouver International Airport", iataCode: "YVR" }, { name: "Vienna International Airport", iataCode: "VIE" }, { name: "Viracopos International Airport", iataCode: "VCP" }, { name: "Vnukovo International Airport", iataCode: "VKO" }, { name: "Wellington International Airport", iataCode: "WLG" }, { name: "Xi'an Xianyang International Airport", iataCode: "XIY" }, { name: "Zhukovsky International Airport", iataCode: "ZIA" }, { name: "Zurich Airport", iataCode: "ZRH" }];
var Za = { airline: e, airplane: a, airport: r };
var o = Za;
var n = ["American black bear", "Asian black bear", "Brown bear", "Giant panda", "Polar bear", "Sloth bear", "Spectacled bear", "Sun bear"];
var i = ["Abert's Towhee", "Acadian Flycatcher", "Acorn Woodpecker", "Alder Flycatcher", "Aleutian Tern", "Allen's Hummingbird", "Altamira Oriole", "American Avocet", "American Bittern", "American Black Duck", "American Coot", "American Crow", "American Dipper", "American Golden-Plover", "American Goldfinch", "American Kestrel", "American Oystercatcher", "American Pipit", "American Redstart", "American Robin", "American Tree Sparrow", "American White Pelican", "American Wigeon", "American Woodcock", "Ancient Murrelet", "Anhinga", "Anna's Hummingbird", "Antillean Nighthawk", "Antillean Palm Swift", "Aplomado Falcon", "Arctic Loon", "Arctic Tern", "Arctic Warbler", "Ash-throated Flycatcher", "Ashy Storm-Petrel", "Asian Brown Flycatcher", "Atlantic Puffin", "Audubon's Oriole", "Audubon's Shearwater", "Aztec Thrush", "Azure Gallinule", "Bachman's Sparrow", "Bachman's Warbler", "Bahama Mockingbird", "Bahama Swallow", "Bahama Woodstar", "Baikal Teal", "Baird's Sandpiper", "Baird's Sparrow", "Bald Eagle", "Baltimore Oriole", "Bananaquit", "Band-rumped Storm-Petrel", "Band-tailed Gull", "Band-tailed Pigeon", "Bank Swallow", "Bar-tailed Godwit", "Barn Owl", "Barn Swallow", "Barnacle Goose", "Barred Owl", "Barrow's Goldeneye", "Bay-breasted Warbler", "Bean Goose", "Bell's Vireo", "Belted Kingfisher", "Bendire's Thrasher", "Berylline Hummingbird", "Bewick's Wren", "Bicknell's Thrush", "Black Catbird", "Black Guillemot", "Black Noddy", "Black Oystercatcher", "Black Phoebe", "Black Rail", "Black Rosy-Finch", "Black Scoter", "Black Skimmer", "Black Storm-Petrel", "Black Swift", "Black Tern", "Black Turnstone", "Black Vulture", "Black-and-white Warbler", "Black-backed Wagtail", "Black-backed Woodpecker", "Black-bellied Plover", "Black-bellied Whistling-Duck", "Black-billed Cuckoo", "Black-billed Magpie", "Black-browed Albatross", "Black-capped Chickadee", "Black-capped Gnatcatcher", "Black-capped Petrel", "Black-capped Vireo", "Black-chinned Hummingbird", "Black-chinned Sparrow", "Black-crowned Night-Heron", "Black-faced Grassquit", "Black-footed Albatross", "Black-headed Grosbeak", "Black-headed Gull", "Black-legged Kittiwake", "Black-necked Stilt", "Black-tailed Gnatcatcher", "Black-tailed Godwit", "Black-tailed Gull", "Black-throated Blue Warbler", "Black-throated Gray Warbler", "Black-throated Green Warbler", "Black-throated Sparrow", "Black-vented Oriole", "Black-vented Shearwater", "Black-whiskered Vireo", "Black-winged Stilt", "Blackburnian Warbler", "Blackpoll Warbler", "Blue Bunting", "Blue Grosbeak", "Blue Grouse", "Blue Jay", "Blue Mockingbird", "Blue-footed Booby", "Blue-gray Gnatcatcher", "Blue-headed Vireo", "Blue-throated Hummingbird", "Blue-winged Teal", "Blue-winged Warbler", "Bluethroat", "Boat-tailed Grackle", "Bobolink", "Bohemian Waxwing", "Bonaparte's Gull", "Boreal Chickadee", "Boreal Owl", "Botteri's Sparrow", "Brambling", "Brandt's Cormorant", "Brant", "Brewer's Blackbird", "Brewer's Sparrow", "Bridled Tern", "Bridled Titmouse", "Bristle-thighed Curlew", "Broad-billed Hummingbird", "Broad-billed Sandpiper", "Broad-tailed Hummingbird", "Broad-winged Hawk", "Bronzed Cowbird", "Brown Booby", "Brown Creeper", "Brown Jay", "Brown Noddy", "Brown Pelican", "Brown Shrike", "Brown Thrasher", "Brown-capped Rosy-Finch", "Brown-chested Martin", "Brown-crested Flycatcher", "Brown-headed Cowbird", "Brown-headed Nuthatch", "Budgerigar", "Buff-bellied Hummingbird", "Buff-breasted Flycatcher", "Buff-breasted Sandpiper", "Buff-collared Nightjar", "Bufflehead", "Buller's Shearwater", "Bullock's Oriole", "Bumblebee Hummingbird", "Burrowing Owl", "Bushtit", "Cactus Wren", "California Condor", "California Gnatcatcher", "California Gull", "California Quail", "California Thrasher", "California Towhee", "Calliope Hummingbird", "Canada Goose", "Canada Warbler", "Canvasback", "Canyon Towhee", "Canyon Wren", "Cape May Warbler", "Caribbean Elaenia", "Carolina Chickadee", "Carolina Parakeet", "Carolina Wren", "Caspian Tern", "Cassin's Auklet", "Cassin's Finch", "Cassin's Kingbird", "Cassin's Sparrow", "Cassin's Vireo", "Cattle Egret", "Cave Swallow", "Cedar Waxwing", "Cerulean Warbler", "Chestnut-backed Chickadee", "Chestnut-collared Longspur", "Chestnut-sided Warbler", "Chihuahuan Raven", "Chimney Swift", "Chinese Egret", "Chipping Sparrow", "Chuck-will's-widow", "Chukar", "Cinnamon Hummingbird", "Cinnamon Teal", "Citrine Wagtail", "Clapper Rail", "Clark's Grebe", "Clark's Nutcracker", "Clay-colored Robin", "Clay-colored Sparrow", "Cliff Swallow", "Colima Warbler", "Collared Forest-Falcon", "Collared Plover", "Common Black-Hawk", "Common Chaffinch", "Common Crane", "Common Cuckoo", "Common Eider", "Common Goldeneye", "Common Grackle", "Common Greenshank", "Common Ground-Dove", "Common House-Martin", "Common Loon", "Common Merganser", "Common Moorhen", "Common Murre", "Common Nighthawk", "Common Pauraque", "Common Pochard", "Common Poorwill", "Common Raven", "Common Redpoll", "Common Ringed Plover", "Common Rosefinch", "Common Sandpiper", "Common Snipe", "Common Swift", "Common Tern", "Common Yellowthroat", "Connecticut Warbler", "Cook's Petrel", "Cooper's Hawk", "Cordilleran Flycatcher", "Corn Crake", "Cory's Shearwater", "Costa's Hummingbird", "Couch's Kingbird", "Crane Hawk", "Craveri's Murrelet", "Crescent-chested Warbler", "Crested Auklet", "Crested Caracara", "Crested Myna", "Crimson-collared Grosbeak", "Crissal Thrasher", "Cuban Martin", "Curlew Sandpiper", "Curve-billed Thrasher", "Dark-eyed Junco", "Dickcissel", "Double-crested Cormorant", "Double-striped Thick-knee", "Dovekie", "Downy Woodpecker", "Dunlin", "Dusky Flycatcher", "Dusky Thrush", "Dusky Warbler", "Dusky-capped Flycatcher", "Eared Grebe", "Eared Trogon", "Eastern Bluebird", "Eastern Kingbird", "Eastern Meadowlark", "Eastern Phoebe", "Eastern Screech-Owl", "Eastern Towhee", "Eastern Wood-Pewee", "Elegant Tern", "Elegant Trogon", "Elf Owl", "Emperor Goose", "Eskimo Curlew", "Eurasian Blackbird", "Eurasian Bullfinch", "Eurasian Collared-Dove", "Eurasian Coot", "Eurasian Curlew", "Eurasian Dotterel", "Eurasian Hobby", "Eurasian Jackdaw", "Eurasian Kestrel", "Eurasian Oystercatcher", "Eurasian Siskin", "Eurasian Tree Sparrow", "Eurasian Wigeon", "Eurasian Woodcock", "Eurasian Wryneck", "European Golden-Plover", "European Starling", "European Storm-Petrel", "European Turtle-Dove", "Evening Grosbeak", "Eyebrowed Thrush", "Falcated Duck", "Fan-tailed Warbler", "Far Eastern Curlew", "Ferruginous Hawk", "Ferruginous Pygmy-Owl", "Field Sparrow", "Fieldfare", "Fish Crow", "Five-striped Sparrow", "Flame-colored Tanager", "Flammulated Owl", "Flesh-footed Shearwater", "Florida Scrub-Jay", "Fork-tailed Flycatcher", "Fork-tailed Storm-Petrel", "Fork-tailed Swift", "Forster's Tern", "Fox Sparrow", "Franklin's Gull", "Fulvous Whistling-Duck", "Gadwall", "Gambel's Quail", "Garganey", "Gila Woodpecker", "Gilded Flicker", "Glaucous Gull", "Glaucous-winged Gull", "Glossy Ibis", "Golden Eagle", "Golden-cheeked Warbler", "Golden-crowned Kinglet", "Golden-crowned Sparrow", "Golden-crowned Warbler", "Golden-fronted Woodpecker", "Golden-winged Warbler", "Grace's Warbler", "Grasshopper Sparrow", "Gray Bunting", "Gray Catbird", "Gray Flycatcher", "Gray Hawk", "Gray Jay", "Gray Kingbird", "Gray Partridge", "Gray Silky-flycatcher", "Gray Vireo", "Gray Wagtail", "Gray-breasted Martin", "Gray-cheeked Thrush", "Gray-crowned Rosy-Finch", "Gray-crowned Yellowthroat", "Gray-headed Chickadee", "Gray-spotted Flycatcher", "Gray-tailed Tattler", "Great Auk", "Great Black-backed Gull", "Great Blue Heron", "Great Cormorant", "Great Crested Flycatcher", "Great Egret", "Great Frigatebird", "Great Gray Owl", "Great Horned Owl", "Great Kiskadee", "Great Knot", "Great Skua", "Great Spotted Woodpecker", "Great-tailed Grackle", "Greater Flamingo", "Greater Pewee", "Greater Prairie-chicken", "Greater Roadrunner", "Greater Scaup", "Greater Shearwater", "Greater White-fronted Goose", "Greater Yellowlegs", "Green Heron", "Green Jay", "Green Kingfisher", "Green Sandpiper", "Green Violet-ear", "Green-breasted Mango", "Green-tailed Towhee", "Green-winged Teal", "Greenish Elaenia", "Groove-billed Ani", "Gull-billed Tern", "Gyrfalcon", "Hairy Woodpecker", "Hammond's Flycatcher", "Harlequin Duck", "Harris's Hawk", "Harris's Sparrow", "Hawfinch", "Heermann's Gull", "Henslow's Sparrow", "Hepatic Tanager", "Herald Petrel", "Hermit Thrush", "Hermit Warbler", "Herring Gull", "Himalayan Snowcock", "Hoary Redpoll", "Hooded Merganser", "Hooded Oriole", "Hooded Warbler", "Hook-billed Kite", "Hoopoe", "Horned Grebe", "Horned Lark", "Horned Puffin", "House Finch", "House Sparrow", "House Wren", "Hudsonian Godwit", "Hutton's Vireo", "Iceland Gull", "Inca Dove", "Indigo Bunting", "Island Scrub-Jay", "Ivory Gull", "Ivory-billed Woodpecker", "Jabiru", "Jack Snipe", "Jungle Nightjar", "Juniper Titmouse", "Kentucky Warbler", "Key West Quail-Dove", "Killdeer", "King Eider", "King Rail", "Kirtland's Warbler", "Kittlitz's Murrelet", "La Sagra's Flycatcher", "Labrador Duck", "Ladder-backed Woodpecker", "Lanceolated Warbler", "Lapland Longspur", "Large-billed Tern", "Lark Bunting", "Lark Sparrow", "Laughing Gull", "Lawrence's Goldfinch", "Laysan Albatross", "Lazuli Bunting", "Le Conte's Sparrow", "Le Conte's Thrasher", "Leach's Storm-Petrel", "Least Auklet", "Least Bittern", "Least Flycatcher", "Least Grebe", "Least Sandpiper", "Least Storm-Petrel", "Least Tern", "Lesser Black-backed Gull", "Lesser Frigatebird", "Lesser Goldfinch", "Lesser Nighthawk", "Lesser Prairie-chicken", "Lesser Scaup", "Lesser White-fronted Goose", "Lesser Yellowlegs", "Lewis's Woodpecker", "Limpkin", "Lincoln's Sparrow", "Little Blue Heron", "Little Bunting", "Little Curlew", "Little Egret", "Little Gull", "Little Ringed Plover", "Little Shearwater", "Little Stint", "Loggerhead Kingbird", "Loggerhead Shrike", "Long-billed Curlew", "Long-billed Dowitcher", "Long-billed Murrelet", "Long-billed Thrasher", "Long-eared Owl", "Long-tailed Jaeger", "Long-toed Stint", "Louisiana Waterthrush", "Lucifer Hummingbird", "Lucy's Warbler", "MacGillivray's Warbler", "Magnificent Frigatebird", "Magnificent Hummingbird", "Magnolia Warbler", "Mallard", "Mangrove Cuckoo", "Manx Shearwater", "Marbled Godwit", "Marbled Murrelet", "Marsh Sandpiper", "Marsh Wren", "Masked Booby", "Masked Duck", "Masked Tityra", "McCown's Longspur", "McKay's Bunting", "Merlin", "Mew Gull", "Mexican Chickadee", "Mexican Jay", "Middendorff's Grasshopper-Warbler", "Mississippi Kite", "Mongolian Plover", "Monk Parakeet", "Montezuma Quail", "Mottled Duck", "Mottled Owl", "Mottled Petrel", "Mountain Bluebird", "Mountain Chickadee", "Mountain Plover", "Mountain Quail", "Mourning Dove", "Mourning Warbler", "Mugimaki Flycatcher", "Murphy's Petrel", "Muscovy Duck", "Mute Swan", "Narcissus Flycatcher", "Nashville Warbler", "Nelson's Sharp-tailed Sparrow", "Neotropic Cormorant", "Northern Beardless-Tyrannulet", "Northern Bobwhite", "Northern Cardinal", "Northern Flicker", "Northern Fulmar", "Northern Gannet", "Northern Goshawk", "Northern Harrier", "Northern Hawk Owl", "Northern Jacana", "Northern Lapwing", "Northern Mockingbird", "Northern Parula", "Northern Pintail", "Northern Pygmy-Owl", "Northern Rough-winged Swallow", "Northern Saw-whet Owl", "Northern Shoveler", "Northern Shrike", "Northern Waterthrush", "Northern Wheatear", "Northwestern Crow", "Nuttall's Woodpecker", "Nutting's Flycatcher", "Oak Titmouse", "Oldsquaw", "Olive Sparrow", "Olive Warbler", "Olive-backed Pipit", "Olive-sided Flycatcher", "Orange-crowned Warbler", "Orchard Oriole", "Oriental Cuckoo", "Oriental Greenfinch", "Oriental Pratincole", "Oriental Scops-Owl", "Oriental Turtle-Dove", "Osprey", "Ovenbird", "Pacific Golden-Plover", "Pacific Loon", "Pacific-slope Flycatcher", "Paint-billed Crake", "Painted Bunting", "Painted Redstart", "Pallas's Bunting", "Palm Warbler", "Parakeet Auklet", "Parasitic Jaeger", "Passenger Pigeon", "Pechora Pipit", "Pectoral Sandpiper", "Pelagic Cormorant", "Peregrine Falcon", "Phainopepla", "Philadelphia Vireo", "Pied-billed Grebe", "Pigeon Guillemot", "Pileated Woodpecker", "Pin-tailed Snipe", "Pine Bunting", "Pine Grosbeak", "Pine Siskin", "Pine Warbler", "Pink-footed Goose", "Pink-footed Shearwater", "Pinyon Jay", "Piping Plover", "Plain Chachalaca", "Plain-capped Starthroat", "Plumbeous Vireo", "Pomarine Jaeger", "Prairie Falcon", "Prairie Warbler", "Prothonotary Warbler", "Purple Finch", "Purple Gallinule", "Purple Martin", "Purple Sandpiper", "Pygmy Nuthatch", "Pyrrhuloxia", "Razorbill", "Red Crossbill", "Red Knot", "Red Phalarope", "Red-bellied Woodpecker", "Red-billed Pigeon", "Red-billed Tropicbird", "Red-breasted Flycatcher", "Red-breasted Merganser", "Red-breasted Nuthatch", "Red-breasted Sapsucker", "Red-cockaded Woodpecker", "Red-crowned Parrot", "Red-eyed Vireo", "Red-faced Cormorant", "Red-faced Warbler", "Red-flanked Bluetail", "Red-footed Booby", "Red-headed Woodpecker", "Red-legged Kittiwake", "Red-naped Sapsucker", "Red-necked Grebe", "Red-necked Phalarope", "Red-necked Stint", "Red-shouldered Hawk", "Red-tailed Hawk", "Red-tailed Tropicbird", "Red-throated Loon", "Red-throated Pipit", "Red-whiskered Bulbul", "Red-winged Blackbird", "Reddish Egret", "Redhead", "Redwing", "Reed Bunting", "Rhinoceros Auklet", "Ring-billed Gull", "Ring-necked Duck", "Ring-necked Pheasant", "Ringed Kingfisher", "Roadside Hawk", "Rock Dove", "Rock Ptarmigan", "Rock Sandpiper", "Rock Wren", "Rose-breasted Grosbeak", "Rose-throated Becard", "Roseate Spoonbill", "Roseate Tern", "Ross's Goose", "Ross's Gull", "Rough-legged Hawk", "Royal Tern", "Ruby-crowned Kinglet", "Ruby-throated Hummingbird", "Ruddy Duck", "Ruddy Ground-Dove", "Ruddy Quail-Dove", "Ruddy Turnstone", "Ruff", "Ruffed Grouse", "Rufous Hummingbird", "Rufous-backed Robin", "Rufous-capped Warbler", "Rufous-crowned Sparrow", "Rufous-winged Sparrow", "Rustic Bunting", "Rusty Blackbird", "Sabine's Gull", "Sage Grouse", "Sage Sparrow", "Sage Thrasher", "Saltmarsh Sharp-tailed Sparrow", "Sanderling", "Sandhill Crane", "Sandwich Tern", "Savannah Sparrow", "Say's Phoebe", "Scaled Quail", "Scaly-naped Pigeon", "Scarlet Ibis", "Scarlet Tanager", "Scissor-tailed Flycatcher", "Scott's Oriole", "Seaside Sparrow", "Sedge Wren", "Semipalmated Plover", "Semipalmated Sandpiper", "Sharp-shinned Hawk", "Sharp-tailed Grouse", "Sharp-tailed Sandpiper", "Shiny Cowbird", "Short-billed Dowitcher", "Short-eared Owl", "Short-tailed Albatross", "Short-tailed Hawk", "Short-tailed Shearwater", "Shy Albatross", "Siberian Accentor", "Siberian Blue Robin", "Siberian Flycatcher", "Siberian Rubythroat", "Sky Lark", "Slate-throated Redstart", "Slaty-backed Gull", "Slender-billed Curlew", "Smew", "Smith's Longspur", "Smooth-billed Ani", "Snail Kite", "Snow Bunting", "Snow Goose", "Snowy Egret", "Snowy Owl", "Snowy Plover", "Solitary Sandpiper", "Song Sparrow", "Sooty Shearwater", "Sooty Tern", "Sora", "South Polar Skua", "Southern Martin", "Spectacled Eider", "Spoonbill Sandpiper", "Spot-billed Duck", "Spot-breasted Oriole", "Spotted Dove", "Spotted Owl", "Spotted Rail", "Spotted Redshank", "Spotted Sandpiper", "Spotted Towhee", "Sprague's Pipit", "Spruce Grouse", "Stejneger's Petrel", "Steller's Eider", "Steller's Jay", "Steller's Sea-Eagle", "Stilt Sandpiper", "Stonechat", "Streak-backed Oriole", "Streaked Shearwater", "Strickland's Woodpecker", "Stripe-headed Tanager", "Sulphur-bellied Flycatcher", "Summer Tanager", "Surf Scoter", "Surfbird", "Swainson's Hawk", "Swainson's Thrush", "Swainson's Warbler", "Swallow-tailed Kite", "Swamp Sparrow", "Tamaulipas Crow", "Tawny-shouldered Blackbird", "Temminck's Stint", "Tennessee Warbler", "Terek Sandpiper", "Thayer's Gull", "Thick-billed Kingbird", "Thick-billed Murre", "Thick-billed Parrot", "Thick-billed Vireo", "Three-toed Woodpecker", "Townsend's Solitaire", "Townsend's Warbler", "Tree Pipit", "Tree Swallow", "Tricolored Blackbird", "Tricolored Heron", "Tropical Kingbird", "Tropical Parula", "Trumpeter Swan", "Tufted Duck", "Tufted Flycatcher", "Tufted Puffin", "Tufted Titmouse", "Tundra Swan", "Turkey Vulture", "Upland Sandpiper", "Varied Bunting", "Varied Thrush", "Variegated Flycatcher", "Vaux's Swift", "Veery", "Verdin", "Vermilion Flycatcher", "Vesper Sparrow", "Violet-crowned Hummingbird", "Violet-green Swallow", "Virginia Rail", "Virginia's Warbler", "Wandering Albatross", "Wandering Tattler", "Warbling Vireo", "Wedge-rumped Storm-Petrel", "Wedge-tailed Shearwater", "Western Bluebird", "Western Grebe", "Western Gull", "Western Kingbird", "Western Meadowlark", "Western Reef-Heron", "Western Sandpiper", "Western Screech-Owl", "Western Scrub-Jay", "Western Tanager", "Western Wood-Pewee", "Whimbrel", "Whip-poor-will", "Whiskered Auklet", "Whiskered Screech-Owl", "Whiskered Tern", "White Ibis", "White Wagtail", "White-breasted Nuthatch", "White-cheeked Pintail", "White-chinned Petrel", "White-collared Seedeater", "White-collared Swift", "White-crowned Pigeon", "White-crowned Sparrow", "White-eared Hummingbird", "White-eyed Vireo", "White-faced Ibis", "White-faced Storm-Petrel", "White-headed Woodpecker", "White-rumped Sandpiper", "White-tailed Eagle", "White-tailed Hawk", "White-tailed Kite", "White-tailed Ptarmigan", "White-tailed Tropicbird", "White-throated Needletail", "White-throated Robin", "White-throated Sparrow", "White-throated Swift", "White-tipped Dove", "White-winged Crossbill", "White-winged Dove", "White-winged Parakeet", "White-winged Scoter", "White-winged Tern", "Whooper Swan", "Whooping Crane", "Wild Turkey", "Willet", "Williamson's Sapsucker", "Willow Flycatcher", "Willow Ptarmigan", "Wilson's Phalarope", "Wilson's Plover", "Wilson's Storm-Petrel", "Wilson's Warbler", "Winter Wren", "Wood Duck", "Wood Sandpiper", "Wood Stork", "Wood Thrush", "Wood Warbler", "Worm-eating Warbler", "Worthen's Sparrow", "Wrentit", "Xantus's Hummingbird", "Xantus's Murrelet", "Yellow Bittern", "Yellow Grosbeak", "Yellow Rail", "Yellow Wagtail", "Yellow Warbler", "Yellow-bellied Flycatcher", "Yellow-bellied Sapsucker", "Yellow-billed Cuckoo", "Yellow-billed Loon", "Yellow-billed Magpie", "Yellow-breasted Bunting", "Yellow-breasted Chat", "Yellow-crowned Night-Heron", "Yellow-eyed Junco", "Yellow-faced Grassquit", "Yellow-footed Gull", "Yellow-green Vireo", "Yellow-headed Blackbird", "Yellow-legged Gull", "Yellow-nosed Albatross", "Yellow-rumped Warbler", "Yellow-throated Vireo", "Yellow-throated Warbler", "Yucatan Vireo", "Zenaida Dove", "Zone-tailed Hawk"];
var t = ["Abyssinian", "American Bobtail", "American Curl", "American Shorthair", "American Wirehair", "Balinese", "Bengal", "Birman", "Bombay", "British Shorthair", "Burmese", "Chartreux", "Chausie", "Cornish Rex", "Devon Rex", "Donskoy", "Egyptian Mau", "Exotic Shorthair", "Havana", "Highlander", "Himalayan", "Japanese Bobtail", "Korat", "Kurilian Bobtail", "LaPerm", "Maine Coon", "Manx", "Minskin", "Munchkin", "Nebelung", "Norwegian Forest Cat", "Ocicat", "Ojos Azules", "Oriental", "Persian", "Peterbald", "Pixiebob", "Ragdoll", "Russian Blue", "Savannah", "Scottish Fold", "Selkirk Rex", "Serengeti", "Siamese", "Siberian", "Singapura", "Snowshoe", "Sokoke", "Somali", "Sphynx", "Thai", "Tonkinese", "Toyger", "Turkish Angora", "Turkish Van"];
var l = ["Amazon River Dolphin", "Arnoux's Beaked Whale", "Atlantic Humpbacked Dolphin", "Atlantic Spotted Dolphin", "Atlantic White-Sided Dolphin", "Australian Snubfin Dolphin", "Australian humpback Dolphin", "Blue Whale", "Bottlenose Dolphin", "Bryde\u2019s whale", "Burrunan Dolphin", "Chilean Dolphin", "Chinese River Dolphin", "Chinese White Dolphin", "Clymene Dolphin", "Commerson\u2019s Dolphin", "Costero", "Dusky Dolphin", "False Killer Whale", "Fin Whale", "Fraser\u2019s Dolphin", "Ganges River Dolphin", "Guiana Dolphin", "Heaviside\u2019s Dolphin", "Hector\u2019s Dolphin", "Hourglass Dolphin", "Humpback whale", "Indo-Pacific Bottlenose Dolphin", "Indo-Pacific Hump-backed Dolphin", "Irrawaddy Dolphin", "Killer Whale (Orca)", "La Plata Dolphin", "Long-Beaked Common Dolphin", "Long-finned Pilot Whale", "Longman's Beaked Whale", "Melon-headed Whale", "Northern Rightwhale Dolphin", "Omura\u2019s whale", "Pacific White-Sided Dolphin", "Pantropical Spotted Dolphin", "Peale\u2019s Dolphin", "Pygmy Killer Whale", "Risso\u2019s Dolphin", "Rough-Toothed Dolphin", "Sei Whale", "Short-Beaked Common Dolphin", "Short-finned Pilot Whale", "Southern Bottlenose Whale", "Southern Rightwhale Dolphin", "Sperm Whale", "Spinner Dolphin", "Striped Dolphin", "Tucuxi", "White-Beaked Dolphin"];
var s = ["Aberdeen Angus", "Abergele", "Abigar", "Abondance", "Abyssinian Shorthorned Zebu", "Aceh", "Achham", "Adamawa", "Adaptaur", "Afar", "Africangus", "Afrikaner", "Agerolese", "Alambadi", "Alatau", "Albanian", "Albera", "Alderney", "Alentejana", "Aleutian wild cattle", "Aliad Dinka", "Alistana-Sanabresa", "Allmogekor", "Alur", "American", "American Angus", "American Beef Friesian", "American Brown Swiss", "American Milking Devon", "American White Park", "Amerifax", "Amrit Mahal", "Amsterdam Island cattle", "Anatolian Black", "Andalusian Black", "Andalusian Blond", "Andalusian Grey", "Angeln", "Angoni", "Ankina", "Ankole", "Ankole-Watusi", "Aracena", "Arado", "Argentine Criollo", "Argentine Friesian", "Armorican", "Arouquesa", "Arsi", "Asturian Mountain", "Asturian Valley", "Aubrac", "Aulie-Ata", "Aure et Saint-Girons", "Australian Braford", "Australian Brangus", "Australian Charbray", "Australian Friesian Sahiwal", "Australian Lowline", "Australian Milking Zebu", "Australian Shorthorn", "Austrian Simmental", "Austrian Yellow", "Avile\xF1a-Negra Ib\xE9rica", "Av\xE9tonou", "Aweil Dinka", "Ayrshire", "Azaouak", "Azebuado", "Azerbaijan Zebu", "Azores", "Bachaur cattle", "Baherie cattle", "Bakosi cattle", "Balancer", "Baoule", "Bargur cattle", "Barros\xE3", "Barzona", "Bazadaise", "Beef Freisian", "Beefalo", "Beefmaker", "Beefmaster", "Begayt", "Belgian Blue", "Belgian Red", "Belgian Red Pied", "Belgian White-and-Red", "Belmont Red", "Belted Galloway", "Bernese", "Berrenda cattle", "Betizu", "Bianca Modenese", "Blaarkop", "Black Angus", "Black Baldy", "Black Hereford", "Blanca Cacere\xF1a", "Blanco Orejinegro BON", "Blonde d'Aquitaine", "Blue Albion", "Blue Grey", "Bohuskulla", "Bonsmara", "Boran", "Bo\u0161karin", "Braford", "Brahman", "Brahmousin", "Brangus", "Braunvieh", "Brava", "Breed", "British Friesian", "British White", "Brown Carpathian", "Brown Caucasian", "Brown Swiss", "Bue Lingo", "Burlina", "Bushuyev", "Butana cattle", "Bu\u0161a cattle", "Cachena", "Caldelana", "Camargue", "Campbell Island cattle", "Canadian Speckle Park", "Canadienne", "Canaria", "Canchim", "Caracu", "Carinthian Blondvieh", "Carora", "Charbray", "Charolais", "Chateaubriand", "Chiangus", "Chianina", "Chillingham cattle", "Chinese Black Pied", "Cholistani", "Coloursided White Back", "Commercial", "Corriente", "Corsican cattle", "Coste\xF1o con Cuernos", "Crioulo Lageano", "C\xE1rdena Andaluza", "Dajal", "Dangi cattle", "Danish Black-Pied", "Danish Jersey", "Danish Red", "Deep Red cattle", "Deoni", "Devon", "Dexter cattle", "Dhanni", "Doayo cattle", "Doela", "Drakensberger", "Droughtmaster", "Dulong'", "Dutch Belted", "Dutch Friesian", "Dwarf Lulu", "D\xF8lafe", "East Anatolian Red", "Eastern Finncattle", "Eastern Red Polled", "Enderby Island cattle", "English Longhorn", "Ennstaler Bergscheck", "Estonian Holstein", "Estonian Native", "Estonian Red cattle", "Finncattle", "Finnish Ayrshire", "Finnish Holstein-Friesian", "Fj\xE4ll", "Fleckvieh", "Florida Cracker cattle", "Fogera", "French Simmental", "Fribourgeoise", "Friesian Red and White", "Fulani Sudanese", "F\u0113ng Cattle", "Galician Blond", "Galloway cattle", "Gangatiri", "Gaolao", "Garvonesa", "Gascon cattle", "Gelbvieh", "Georgian Mountain cattle", "German Angus", "German Black Pied Dairy", "German Black Pied cattle", "German Red Pied", "Gir", "Glan cattle", "Gloucester", "Gobra", "Greek Shorthorn", "Greek Steppe", "Greyman cattle", "Gudali", "Guernsey cattle", "Guzer\xE1", "Hallikar4", "Hanwoo", "Hariana cattle", "Hart\xF3n del Valle", "Harzer Rotvieh", "Hays Converter", "Heck cattle", "Hereford", "Herens", "Highland cattle", "Hinterwald", "Holando-Argentino", "Holstein Friesian cattle", "Horro", "Hungarian Grey", "Hu\xE1ng Cattle", "Hybridmaster", "Iberian cattle", "Icelandic", "Illawarra cattle", "Improved Red and White", "Indo-Brazilian", "Irish Moiled", "Israeli Holstein", "Israeli Red", "Istoben cattle", "Istrian cattle", "Jamaica Black", "Jamaica Hope", "Jamaica Red", "Japanese Brown", "Jarmelista", "Javari cattle", "Jersey cattle", "Jutland cattle", "Kabin Buri cattle", "Kalmyk cattle", "Kamphaeng Saen cattle", "Kangayam", "Kankrej", "Karan Swiss", "Kasaragod Dwarf cattle", "Kathiawadi", "Kazakh Whiteheaded", "Kenana cattle", "Kenkatha cattle", "Kerry cattle", "Kherigarh", "Khillari cattle", "Kholomogory", "Korat Wagyu", "Kostroma cattle", "Krishna Valley cattle", "Kurgan cattle", "Kuri", "La Reina cattle", "Lakenvelder cattle", "Lampurger", "Latvian Blue", "Latvian Brown", "Latvian Danish Red", "Lebedyn", "Levantina", "Limia cattle", "Limousin", "Limpurger", "Lincoln Red", "Lineback", "Lithuanian Black-and-White", "Lithuanian Light Grey", "Lithuanian Red", "Lithuanian White-Backed", "Lohani cattle", "Lourdais", "Lucerna cattle", "Luing", "Madagascar Zebu", "Madura", "Maine-Anjou", "Malnad Gidda", "Malvi", "Mandalong Special", "Mantequera Leonesa", "Maramure\u015F Brown", "Marchigiana", "Maremmana", "Marinhoa", "Maronesa", "Masai", "Mashona", "Menorquina", "Mertolenga", "Meuse-Rhine-Issel", "Mewati", "Milking Shorthorn", "Minhota", "Mirandesa", "Mirkadim", "Moc\u0103ni\u0163\u0103", "Mollie", "Monchina", "Mongolian", "Montb\xE9liarde", "Morucha", "Murboden", "Murnau-Werdenfels", "Murray Grey", "Muturu", "N'Dama", "Nagori", "Negra Andaluza", "Nelore", "Nguni", "Nimari", "Normande", "North Bengal Grey", "Northern Finncattle", "Northern Shorthorn", "Norwegian Red", "Ongole", "Original Simmental", "Pajuna", "Palmera", "Pantaneiro", "Parda Alpina", "Parthenaise", "Pasiega", "Pembroke", "Philippine Native", "Pie Rouge des Plaines", "Piedmontese cattle", "Pineywoods", "Pinzgauer", "Pirenaica", "Podolac", "Podolica", "Polish Black-and-White", "Polish Red", "Poll Shorthorn", "Polled Hereford", "Polled Shorthorn", "Ponwar", "Preta", "Pulikulam", "Punganur", "Pustertaler Sprinzen", "Qinchaun", "Queensland Miniature Boran", "RX3", "Ramo Grande", "Randall", "Raramuri Criollo", "Rathi", "Raya", "Red Angus", "Red Brangus", "Red Chittagong", "Red Fulani", "Red Gorbatov", "Red Holstein", "Red Kandhari", "Red Mingrelian", "Red Poll", "Red Polled \xD8stland", "Red Sindhi", "Retinta", "Riggit Galloway", "Ringam\xE5la", "Rohjan", "Romagnola", "Romanian B\u0103l\u0163ata", "Romanian Steppe Gray", "Romosinuano", "Russian Black Pied", "R\xE4tisches Grauvieh", "Sahiwal", "Salers", "Salorn", "Sanga", "Sanhe", "Santa Cruz", "Santa Gertrudis", "Sayaguesa", "Schwyz", "Selembu", "Senepol", "Serbian Pied", "Serbian Steppe", "Sheko", "Shetland", "Shorthorn", "Siboney de Cuba", "Simbrah", "Simford", "Simmental", "Siri", "South Devon", "Spanish Fighting Bull", "Speckle Park", "Square Meater", "Sussex", "Swedish Friesian", "Swedish Polled", "Swedish Red Pied", "Swedish Red Polled", "Swedish Red-and-White", "Tabapu\xE3", "Tarentaise", "Tasmanian Grey", "Tauros", "Telemark", "Texas Longhorn", "Texon", "Thai Black", "Thai Fighting Bull", "Thai Friesian", "Thai Milking Zebu", "Tharparkar", "Tswana", "Tudanca", "Tuli", "Tulim", "Turkish Grey Steppe", "Tux-Zillertal", "Tyrol Grey", "Ukrainian Grey", "Umblachery", "Valdostana Castana", "Valdostana Pezzata Nera", "Valdostana Pezzata Rossa", "Vaynol", "Vechur8", "Vestland Fjord", "Vestland Red Polled", "Vianesa", "Volinian Beef", "Vorderwald", "Vosgienne", "V\xE4neko", "Waguli", "Wagyu", "Wangus", "Welsh Black", "Western Finncattle", "White C\xE1ceres", "White Fulani", "White Lamphun", "White Park", "Whitebred Shorthorn", "Xingjiang Brown", "Yakutian", "Yanbian", "Yanhuang", "Yurino", "Zebu", "\xC9vol\xE8ne cattle", "\u017Bubro\u0144"];
var d = ["African Slender-snouted Crocodile", "Alligator mississippiensis", "American Crocodile", "Australian Freshwater Crocodile", "Black Caiman", "Broad-snouted Caiman", "Chinese Alligator", "Cuban Crocodile", "Cuvier\u2019s Dwarf Caiman", "Dwarf Crocodile", "Gharial", "Morelet\u2019s Crocodile", "Mugger Crocodile", "New Guinea Freshwater Crocodile", "Nile Crocodile", "Orinoco Crocodile", "Philippine Crocodile", "Saltwater Crocodile", "Schneider\u2019s Smooth-fronted Caiman", "Siamese Crocodile", "Spectacled Caiman", "Tomistoma", "West African Crocodile", "Yacare Caiman"];
var u = ["Affenpinscher", "Afghan Hound", "Aidi", "Airedale Terrier", "Akbash", "Akita", "Alano Espa\xF1ol", "Alapaha Blue Blood Bulldog", "Alaskan Husky", "Alaskan Klee Kai", "Alaskan Malamute", "Alopekis", "Alpine Dachsbracke", "American Bulldog", "American Bully", "American Cocker Spaniel", "American English Coonhound", "American Foxhound", "American Hairless Terrier", "American Pit Bull Terrier", "American Staffordshire Terrier", "American Water Spaniel", "Andalusian Hound", "Anglo-Fran\xE7ais de Petite V\xE9nerie", "Appenzeller Sennenhund", "Ariegeois", "Armant", "Armenian Gampr dog", "Artois Hound", "Australian Cattle Dog", "Australian Kelpie", "Australian Shepherd", "Australian Stumpy Tail Cattle Dog", "Australian Terrier", "Austrian Black and Tan Hound", "Austrian Pinscher", "Azawakh", "Bakharwal dog", "Banjara Hound", "Barbado da Terceira", "Barbet", "Basenji", "Basque Shepherd Dog", "Basset Art\xE9sien Normand", "Basset Bleu de Gascogne", "Basset Fauve de Bretagne", "Basset Hound", "Bavarian Mountain Hound", "Beagle", "Beagle-Harrier", "Bearded Collie", "Beauceron", "Bedlington Terrier", "Belgian Shepherd", "Bergamasco Shepherd", "Berger Picard", "Bernese Mountain Dog", "Bhotia", "Bichon Fris\xE9", "Billy", "Black Mouth Cur", "Black Norwegian Elkhound", "Black Russian Terrier", "Black and Tan Coonhound", "Bloodhound", "Blue Lacy", "Blue Picardy Spaniel", "Bluetick Coonhound", "Boerboel", "Bohemian Shepherd", "Bolognese", "Border Collie", "Border Terrier", "Borzoi", "Bosnian Coarse-haired Hound", "Boston Terrier", "Bouvier des Ardennes", "Bouvier des Flandres", "Boxer", "Boykin Spaniel", "Bracco Italiano", "Braque Francais", "Braque Saint-Germain", "Braque d'Auvergne", "Braque de l'Ari\xE8ge", "Braque du Bourbonnais", "Briard", "Briquet Griffon Vend\xE9en", "Brittany", "Broholmer", "Bruno Jura Hound", "Brussels Griffon", "Bucovina Shepherd Dog", "Bull Arab", "Bull Terrier", "Bulldog", "Bullmastiff", "Bully Kutta", "Burgos Pointer", "Cairn Terrier", "Campeiro Bulldog", "Can de Chira", "Canaan Dog", "Canadian Eskimo Dog", "Cane Corso", "Cane Paratore", "Cane di Oropa", "Cantabrian Water Dog", "Cardigan Welsh Corgi", "Carea Castellano Manchego", "Carolina Dog", "Carpathian Shepherd Dog", "Catahoula Leopard Dog", "Catalan Sheepdog", "Caucasian Shepherd Dog", "Cavalier King Charles Spaniel", "Central Asian Shepherd Dog", "Cesky Fousek", "Cesky Terrier", "Chesapeake Bay Retriever", "Chien Fran\xE7ais Blanc et Noir", "Chien Fran\xE7ais Blanc et Orange", "Chien Fran\xE7ais Tricolore", "Chihuahua", "Chilean Terrier", "Chinese Chongqing Dog", "Chinese Crested Dog", "Chinook", "Chippiparai", "Chongqing dog", "Chortai", "Chow Chow", "Cimarr\xF3n Uruguayo", "Cirneco dell'Etna", "Clumber Spaniel", "Colombian fino hound", "Coton de Tulear", "Cretan Hound", "Croatian Sheepdog", "Curly-Coated Retriever", "Cursinu", "Czechoslovakian Wolfdog", "C\xE3o Fila de S\xE3o Miguel", "C\xE3o da Serra de Aires", "C\xE3o de Castro Laboreiro", "C\xE3o de Gado Transmontano", "Dachshund", "Dalmatian", "Dandie Dinmont Terrier", "Danish-Swedish Farmdog", "Denmark Feist", "Dingo", "Doberman Pinscher", "Dogo Argentino", "Dogo Guatemalteco", "Dogo Sardesco", "Dogue Brasileiro", "Dogue de Bordeaux", "Drentse Patrijshond", "Drever", "Dunker", "Dutch Shepherd", "Dutch Smoushond", "East European Shepherd", "East Siberian Laika", "English Cocker Spaniel", "English Foxhound", "English Mastiff", "English Setter", "English Shepherd", "English Springer Spaniel", "English Toy Terrier", "Entlebucher Mountain Dog", "Estonian Hound", "Estrela Mountain Dog", "Eurasier", "Field Spaniel", "Fila Brasileiro", "Finnish Hound", "Finnish Lapphund", "Finnish Spitz", "Flat-Coated Retriever", "French Bulldog", "French Spaniel", "Galgo Espa\xF1ol", "Galician Shepherd Dog", "Garafian Shepherd", "Gascon Saintongeois", "Georgian Shepherd", "German Hound", "German Longhaired Pointer", "German Pinscher", "German Roughhaired Pointer", "German Shepherd Dog", "German Shorthaired Pointer", "German Spaniel", "German Spitz", "German Wirehaired Pointer", "Giant Schnauzer", "Glen of Imaal Terrier", "Golden Retriever", "Gordon Setter", "Go\u0144czy Polski", "Grand Anglo-Fran\xE7ais Blanc et Noir", "Grand Anglo-Fran\xE7ais Blanc et Orange", "Grand Anglo-Fran\xE7ais Tricolore", "Grand Basset Griffon Vend\xE9en", "Grand Bleu de Gascogne", "Grand Griffon Vend\xE9en", "Great Dane", "Greater Swiss Mountain Dog", "Greek Harehound", "Greek Shepherd", "Greenland Dog", "Greyhound", "Griffon Bleu de Gascogne", "Griffon Fauve de Bretagne", "Griffon Nivernais", "Gull Dong", "Gull Terrier", "Hamiltonst\xF6vare", "Hanover Hound", "Harrier", "Havanese", "Hierran Wolfdog", "Hokkaido", "Hovawart", "Huntaway", "Hygen Hound", "H\xE4llefors Elkhound", "Ibizan Hound", "Icelandic Sheepdog", "Indian Spitz", "Indian pariah dog", "Irish Red and White Setter", "Irish Setter", "Irish Terrier", "Irish Water Spaniel", "Irish Wolfhound", "Istrian Coarse-haired Hound", "Istrian Shorthaired Hound", "Italian Greyhound", "Jack Russell Terrier", "Jagdterrier", "Japanese Chin", "Japanese Spitz", "Japanese Terrier", "Jindo", "Jonangi", "Kai Ken", "Kaikadi", "Kangal Shepherd Dog", "Kanni", "Karakachan dog", "Karelian Bear Dog", "Kars", "Karst Shepherd", "Keeshond", "Kerry Beagle", "Kerry Blue Terrier", "King Charles Spaniel", "King Shepherd", "Kintamani", "Kishu", "Kokoni", "Kombai", "Komondor", "Kooikerhondje", "Koolie", "Koyun dog", "Kromfohrl\xE4nder", "Kuchi", "Kuvasz", "Labrador Retriever", "Lagotto Romagnolo", "Lakeland Terrier", "Lancashire Heeler", "Landseer", "Lapponian Herder", "Large M\xFCnsterl\xE4nder", "Leonberger", "Levriero Sardo", "Lhasa Apso", "Lithuanian Hound", "Lupo Italiano", "L\xF6wchen", "Mackenzie River Husky", "Magyar ag\xE1r", "Mahratta Greyhound", "Maltese", "Manchester Terrier", "Maremmano-Abruzzese Sheepdog", "McNab dog", "Miniature American Shepherd", "Miniature Bull Terrier", "Miniature Fox Terrier", "Miniature Pinscher", "Miniature Schnauzer", "Molossus of Epirus", "Montenegrin Mountain Hound", "Mountain Cur", "Mountain Feist", "Mucuchies", "Mudhol Hound", "Mudi", "Neapolitan Mastiff", "New Guinea Singing Dog", "New Zealand Heading Dog", "Newfoundland", "Norfolk Terrier", "Norrbottenspets", "Northern Inuit Dog", "Norwegian Buhund", "Norwegian Elkhound", "Norwegian Lundehund", "Norwich Terrier", "Nova Scotia Duck Tolling Retriever", "Old Croatian Sighthound", "Old Danish Pointer", "Old English Sheepdog", "Old English Terrier", "Olde English Bulldogge", "Otterhound", "Pachon Navarro", "Paisley Terrier", "Pampas Deerhound", "Papillon", "Parson Russell Terrier", "Pastore della Lessinia e del Lagorai", "Patagonian Sheepdog", "Patterdale Terrier", "Pekingese", "Pembroke Welsh Corgi", "Perro Majorero", "Perro de Pastor Mallorquin", "Perro de Presa Canario", "Perro de Presa Mallorquin", "Peruvian Inca Orchid", "Petit Basset Griffon Vend\xE9en", "Petit Bleu de Gascogne", "Phal\xE8ne", "Pharaoh Hound", "Phu Quoc Ridgeback", "Picardy Spaniel", "Plott Hound", "Plummer Terrier", "Podenco Canario", "Podenco Valenciano", "Pointer", "Poitevin", "Polish Greyhound", "Polish Hound", "Polish Lowland Sheepdog", "Polish Tatra Sheepdog", "Pomeranian", "Pont-Audemer Spaniel", "Poodle", "Porcelaine", "Portuguese Podengo", "Portuguese Pointer", "Portuguese Water Dog", "Posavac Hound", "Pra\u017Esk\xFD Krysa\u0159\xEDk", "Pshdar Dog", "Pudelpointer", "Pug", "Puli", "Pumi", "Pungsan Dog", "Pyrenean Mastiff", "Pyrenean Mountain Dog", "Pyrenean Sheepdog", "Rafeiro do Alentejo", "Rajapalayam", "Rampur Greyhound", "Rat Terrier", "Ratonero Bodeguero Andaluz", "Ratonero Mallorquin", "Ratonero Murciano de Huerta", "Ratonero Valenciano", "Redbone Coonhound", "Rhodesian Ridgeback", "Romanian Mioritic Shepherd Dog", "Romanian Raven Shepherd Dog", "Rottweiler", "Rough Collie", "Russian Spaniel", "Russian Toy", "Russo-European Laika", "Saarloos Wolfdog", "Sabueso Espa\xF1ol", "Saint Bernard", "Saint Hubert Jura Hound", "Saint-Usuge Spaniel", "Saluki", "Samoyed", "Sapsali", "Sarabi dog", "Sardinian Shepherd Dog", "Schapendoes", "Schillerst\xF6vare", "Schipperke", "Schweizer Laufhund", "Schweizerischer Niederlaufhund", "Scottish Deerhound", "Scottish Terrier", "Sealyham Terrier", "Segugio Italiano", "Segugio Maremmano", "Segugio dell'Appennino", "Seppala Siberian Sleddog", "Serbian Hound", "Serbian Tricolour Hound", "Serrano Bulldog", "Shar Pei", "Shetland Sheepdog", "Shiba Inu", "Shih Tzu", "Shikoku", "Shiloh Shepherd", "Siberian Husky", "Silken Windhound", "Silky Terrier", "Sinhala Hound", "Skye Terrier", "Sloughi", "Slovakian Wirehaired Pointer", "Slovensk\xFD Cuvac", "Slovensk\xFD Kopov", "Smalandst\xF6vare", "Small Greek domestic dog", "Small M\xFCnsterl\xE4nder", "Smooth Collie", "Smooth Fox Terrier", "Soft-Coated Wheaten Terrier", "South Russian Ovcharka", "Spanish Mastiff", "Spanish Water Dog", "Spinone Italiano", "Sporting Lucas Terrier", "Stabyhoun", "Staffordshire Bull Terrier", "Standard Schnauzer", "Stephens Stock", "Styrian Coarse-haired Hound", "Sussex Spaniel", "Swedish Elkhound", "Swedish Lapphund", "Swedish Vallhund", "Swedish White Elkhound", "Taigan", "Taiwan Dog", "Tamaskan Dog", "Teddy Roosevelt Terrier", "Telomian", "Tenterfield Terrier", "Terrier Brasileiro", "Thai Bangkaew Dog", "Thai Ridgeback", "Tibetan Mastiff", "Tibetan Spaniel", "Tibetan Terrier", "Tornjak", "Tosa", "Toy Fox Terrier", "Toy Manchester Terrier", "Transylvanian Hound", "Treeing Cur", "Treeing Feist", "Treeing Tennessee Brindle", "Treeing Walker Coonhound", "Trigg Hound", "Tyrolean Hound", "Vikhan", "Villano de Las Encartaciones", "Villanuco de Las Encartaciones", "Vizsla", "Volpino Italiano", "Weimaraner", "Welsh Sheepdog", "Welsh Springer Spaniel", "Welsh Terrier", "West Highland White Terrier", "West Siberian Laika", "Westphalian Dachsbracke", "Wetterhoun", "Whippet", "White Shepherd", "White Swiss Shepherd Dog", "Wire Fox Terrier", "Wirehaired Pointing Griffon", "Wirehaired Vizsla", "Xiasi Dog", "Xoloitzcuintli", "Yakutian Laika", "Yorkshire Terrier", "\u0160arplaninac"];
var c = ["Alaska pollock", "Albacore", "Amur catfish", "Araucanian herring", "Argentine hake", "Asari", "Asian swamp eel", "Atlantic cod", "Atlantic herring", "Atlantic horse mackerel", "Atlantic mackerel", "Atlantic menhaden", "Atlantic salmon", "Bigeye scad", "Bigeye tuna", "Bighead carp", "Black carp", "Blood cockle", "Blue swimming crab", "Blue whiting", "Bombay-duck", "Bonga shad", "California pilchard", "Cape horse mackerel", "Capelin", "Catla", "Channel catfish", "Chilean jack mackerel", "Chinese perch", "Chinese softshell turtle", "Chub mackerel", "Chum salmon", "Common carp", "Crucian carp", "Daggertooth pike conger", "European anchovy", "European pilchard", "European sprat", "Filipino Venus", "Gazami crab", "Goldstripe sardinella", "Grass carp", "Gulf menhaden", "Haddock", "Hilsa shad", "Indian mackerel", "Indian oil sardine", "Iridescent shark", "Japanese anchovy", "Japanese cockle", "Japanese common catfish", "Japanese flying squid", "Japanese jack mackerel", "Japanese littleneck", "Japanese pilchard", "Jumbo flying squid", "Kawakawa", "Korean bullhead", "Largehead hairtail", "Longtail tuna", "Madeiran sardinella", "Mandarin fish", "Milkfish", "Mrigal carp", "Narrow-barred Spanish mackerel", "Nile perch", "Nile tilapia", "North Pacific hake", "Northern snakehead", "Pacific anchoveta", "Pacific cod", "Pacific herring", "Pacific sand lance", "Pacific sandlance", "Pacific saury", "Pacific thread herring", "Peruvian anchoveta", "Pink salmon", "Pollock", "Pond loach", "Rainbow trout", "Rohu", "Round sardinella", "Short mackerel", "Silver carp", "Silver cyprinid", "Skipjack tuna", "Southern African anchovy", "Southern rough shrimp", "Whiteleg shrimp", "Wuchang bream", "Yellow croaker", "Yellowfin tuna", "Yellowhead catfish", "Yellowstripe scad"];
var m = ["Abaco Barb", "Abtenauer", "Abyssinian", "Aegidienberger", "Akhal-Teke", "Albanian Horse", "Altai Horse", "Alt\xE8r Real", "American Albino", "American Cream Draft", "American Indian Horse", "American Paint Horse", "American Quarter Horse", "American Saddlebred", "American Warmblood", "Andalusian Horse", "Andravida Horse", "Anglo-Arabian", "Anglo-Arabo-Sardo", "Anglo-Kabarda", "Appaloosa", "AraAppaloosa", "Arabian Horse", "Ardennes Horse", "Arenberg-Nordkirchen", "Argentine Criollo", "Asian wild Horse", "Assateague Horse", "Asturc\xF3n", "Augeron", "Australian Brumby", "Australian Draught Horse", "Australian Stock Horse", "Austrian Warmblood", "Auvergne Horse", "Auxois", "Azerbaijan Horse", "Azteca Horse", "Baise Horse", "Bale", "Balearic Horse", "Balikun Horse", "Baluchi Horse", "Banker Horse", "Barb Horse", "Bardigiano", "Bashkir Curly", "Basque Mountain Horse", "Bavarian Warmblood", "Belgian Half-blood", "Belgian Horse", "Belgian Warmblood", "Bhutia Horse", "Black Forest Horse", "Blazer Horse", "Boerperd", "Borana", "Boulonnais Horse", "Brabant", "Brandenburger", "Brazilian Sport Horse", "Breton Horse", "Brumby", "Budyonny Horse", "Burguete Horse", "Burmese Horse", "Byelorussian Harness Horse", "Calabrese Horse", "Camargue Horse", "Camarillo White Horse", "Campeiro", "Campolina", "Canadian Horse", "Canadian Pacer", "Carolina Marsh Tacky", "Carthusian Horse", "Caspian Horse", "Castilian Horse", "Castillonnais", "Catria Horse", "Cavallo Romano della Maremma Laziale", "Cerbat Mustang", "Chickasaw Horse", "Chilean Corralero", "Choctaw Horse", "Cleveland Bay", "Clydesdale Horse", "Cob", "Coldblood Trotter", "Colonial Spanish Horse", "Colorado Ranger", "Comtois Horse", "Corsican Horse", "Costa Rican Saddle Horse", "Cretan Horse", "Criollo Horse", "Croatian Coldblood", "Cuban Criollo", "Cumberland Island Horse", "Curly Horse", "Czech Warmblood", "Daliboz", "Danish Warmblood", "Danube Delta Horse", "Dole Gudbrandsdal", "Don", "Dongola Horse", "Draft Trotter", "Dutch Harness Horse", "Dutch Heavy Draft", "Dutch Warmblood", "Dzungarian Horse", "East Bulgarian", "East Friesian Horse", "Estonian Draft", "Estonian Horse", "Falabella", "Faroese", "Finnhorse", "Fjord Horse", "Fleuve", "Florida Cracker Horse", "Foutank\xE9", "Frederiksborg Horse", "Freiberger", "French Trotter", "Friesian Cross", "Friesian Horse", "Friesian Sporthorse", "Furioso-North Star", "Galice\xF1o", "Galician Pony", "Gelderland Horse", "Georgian Grande Horse", "German Warmblood", "Giara Horse", "Gidran", "Groningen Horse", "Gypsy Horse", "Hackney Horse", "Haflinger", "Hanoverian Horse", "Heck Horse", "Heihe Horse", "Henson Horse", "Hequ Horse", "Hirzai", "Hispano-Bret\xF3n", "Holsteiner Horse", "Horro", "Hungarian Warmblood", "Icelandic Horse", "Iomud", "Irish Draught", "Irish Sport Horse sometimes called Irish Hunter", "Italian Heavy Draft", "Italian Trotter", "Jaca Navarra", "Jeju Horse", "Jutland Horse", "Kabarda Horse", "Kafa", "Kaimanawa Horses", "Kalmyk Horse", "Karabair", "Karabakh Horse", "Karachai Horse", "Karossier", "Kathiawari", "Kazakh Horse", "Kentucky Mountain Saddle Horse", "Kiger Mustang", "Kinsky Horse", "Kisber Felver", "Kiso Horse", "Kladruber", "Knabstrupper", "Konik", "Kundudo", "Kustanair", "Kyrgyz Horse", "Latvian Horse", "Lipizzan", "Lithuanian Heavy Draught", "Lokai", "Losino Horse", "Lusitano", "Lyngshest", "M'Bayar", "M'Par", "Mallorqu\xEDn", "Malopolski", "Mangalarga", "Mangalarga Marchador", "Maremmano", "Marisme\xF1o Horse", "Marsh Tacky", "Marwari Horse", "Mecklenburger", "Menorqu\xEDn", "Messara Horse", "Metis Trotter", "Mez\u0151hegyesi Sport Horse", "Me\u0111imurje Horse", "Miniature Horse", "Misaki Horse", "Missouri Fox Trotter", "Monchina", "Mongolian Horse", "Mongolian Wild Horse", "Monterufolino", "Morab", "Morgan Horse", "Mountain Pleasure Horse", "Moyle Horse", "Murakoz Horse", "Murgese", "Mustang Horse", "M\xE9rens Horse", "Namib Desert Horse", "Nangchen Horse", "National Show Horse", "Nez Perce Horse", "Nivernais Horse", "Nokota Horse", "Noma", "Nonius Horse", "Nooitgedachter", "Nordlandshest", "Noriker Horse", "Norman Cob", "North American Single-Footer Horse", "North Swedish Horse", "Norwegian Coldblood Trotter", "Norwegian Fjord", "Novokirghiz", "Oberlander Horse", "Ogaden", "Oldenburg Horse", "Orlov trotter", "Ostfriesen", "Paint", "Pampa Horse", "Paso Fino", "Pentro Horse", "Percheron", "Persano Horse", "Peruvian Paso", "Pintabian", "Pleven Horse", "Poitevin Horse", "Posavac Horse", "Pottok", "Pryor Mountain Mustang", "Przewalski's Horse", "Pura Raza Espa\xF1ola", "Purosangue Orientale", "Qatgani", "Quarab", "Quarter Horse", "Racking Horse", "Retuerta Horse", "Rhenish German Coldblood", "Rhinelander Horse", "Riwoche Horse", "Rocky Mountain Horse", "Romanian Sporthorse", "Rottaler", "Russian Don", "Russian Heavy Draft", "Russian Trotter", "Saddlebred", "Salerno Horse", "Samolaco Horse", "San Fratello Horse", "Sarcidano Horse", "Sardinian Anglo-Arab", "Schleswig Coldblood", "Schwarzw\xE4lder Kaltblut", "Selale", "Sella Italiano", "Selle Fran\xE7ais", "Shagya Arabian", "Shan Horse", "Shire Horse", "Siciliano Indigeno", "Silesian Horse", "Sokolsky Horse", "Sorraia", "South German Coldblood", "Soviet Heavy Draft", "Spanish Anglo-Arab", "Spanish Barb", "Spanish Jennet Horse", "Spanish Mustang", "Spanish Tarpan", "Spanish-Norman Horse", "Spiti Horse", "Spotted Saddle Horse", "Standardbred Horse", "Suffolk Punch", "Swedish Ardennes", "Swedish Warmblood", "Swedish coldblood trotter", "Swiss Warmblood", "Taish\u016B Horse", "Takhi", "Tawleed", "Tchernomor", "Tennessee Walking Horse", "Tersk Horse", "Thoroughbred", "Tiger Horse", "Tinker Horse", "Tolfetano", "Tori Horse", "Trait Du Nord", "Trakehner", "Tsushima", "Tuigpaard", "Ukrainian Riding Horse", "Unmol Horse", "Uzunyayla", "Ventasso Horse", "Virginia Highlander", "Vlaamperd", "Vladimir Heavy Draft", "Vyatka", "Waler", "Waler Horse", "Walkaloosa", "Warlander", "Warmblood", "Welsh Cob", "Westphalian Horse", "Wielkopolski", "W\xFCrttemberger", "Xilingol Horse", "Yakutian Horse", "Yili Horse", "Yonaguni Horse", "Zaniskari", "Zhemaichu", "Zweibr\xFCcker", "\u017Demaitukas"];
var h = ["Acacia-ants", "Acorn-plum gall", "Aerial yellowjacket", "Africanized honey bee", "Allegheny mound ant", "Almond stone wasp", "Ant", "Arboreal ant", "Argentine ant", "Asian paper wasp", "Baldfaced hornet", "Bee", "Bigheaded ant", "Black and yellow mud dauber", "Black carpenter ant", "Black imported fire ant", "Blue horntail woodwasp", "Blue orchard bee", "Braconid wasp", "Bumble bee", "Carpenter ant", "Carpenter wasp", "Chalcid wasp", "Cicada killer", "Citrus blackfly parasitoid", "Common paper wasp", "Crazy ant", "Cuckoo wasp", "Cynipid gall wasp", "Eastern Carpenter bee", "Eastern yellowjacket", "Elm sawfly", "Encyrtid wasp", "Erythrina gall wasp", "Eulophid wasp", "European hornet", "European imported fire ant", "False honey ant", "Fire ant", "Forest bachac", "Forest yellowjacket", "German yellowjacket", "Ghost ant", "Giant ichneumon wasp", "Giant resin bee", "Giant wood wasp", "Golden northern bumble bee", "Golden paper wasp", "Gouty oak gall", "Grass Carrying Wasp", "Great black wasp", "Great golden digger wasp", "Hackberry nipple gall parasitoid", "Honey bee", "Horned oak gall", "Horse guard wasp", "Hunting wasp", "Ichneumonid wasp", "Keyhole wasp", "Knopper gall", "Large garden bumble bee", "Large oak-apple gall", "Leafcutting bee", "Little fire ant", "Little yellow ant", "Long-horned bees", "Long-legged ant", "Macao paper wasp", "Mallow bee", "Marble gall", "Mossyrose gall wasp", "Mud-daubers", "Multiflora rose seed chalcid", "Oak apple gall wasp", "Oak rough bulletgall wasp", "Oak saucer gall", "Oak shoot sawfly", "Odorous house ant", "Orange-tailed bumble bee", "Orangetailed potter wasp", "Oriental chestnut gall wasp", "Paper wasp", "Pavement ant", "Pigeon tremex", "Pip gall wasp", "Prairie yellowjacket", "Pteromalid wasp", "Pyramid ant", "Raspberry Horntail", "Red ant", "Red carpenter ant", "Red harvester ant", "Red imported fire ant", "Red wasp", "Red wood ant", "Red-tailed wasp", "Reddish carpenter ant", "Rough harvester ant", "Sawfly parasitic wasp", "Scale parasitoid", "Silky ant", "Sirex woodwasp", "Siricid woodwasp", "Smaller yellow ant", "Southeastern blueberry bee", "Southern fire ant", "Southern yellowjacket", "Sphecid wasp", "Stony gall", "Sweat bee", "Texas leafcutting ant", "Tiphiid wasp", "Torymid wasp", "Tramp ant", "Valentine ant", "Velvet ant", "Vespid wasp", "Weevil parasitoid", "Western harvester ant", "Western paper wasp", "Western thatching ant", "Western yellowjacket", "White-horned horntail", "Willow shoot sawfly", "Woodwasp", "Wool sower gall maker", "Yellow Crazy Ant", "Yellow and black potter wasp", "Yellow-horned horntail"];
var y = ["Asiatic Lion", "Barbary Lion", "Cape lion", "Masai Lion", "Northeast Congo Lion", "Transvaal lion", "West African Lion"];
var p = ["Ace", "Archie", "Bailey", "Bandit", "Bella", "Bentley", "Bruno", "Buddy", "Charlie", "Coco", "Cookie", "Cooper", "Daisy", "Dixie", "Finn", "Ginger", "Gracie", "Gus", "Hank", "Jack", "Jax", "Joey", "Kobe", "Leo", "Lola", "Louie", "Lucy", "Maggie", "Max", "Mia", "Milo", "Molly", "Murphey", "Nala", "Nova", "Ollie", "Oreo", "Rosie", "Scout", "Stella", "Teddy", "Tuffy"];
var g = ["American", "American Chinchilla", "American Fuzzy Lop", "American Sable", "Argente Brun", "Belgian Hare", "Beveren", "Blanc de Hotot", "Britannia Petite", "Californian", "Champagne D\u2019Argent", "Checkered Giant", "Cinnamon", "Cr\xE8me D\u2019Argent", "Dutch", "Dwarf Hotot", "English Angora", "English Lop", "English Spot", "Flemish Giant", "Florida White", "French Angora", "French Lop", "Giant Angora", "Giant Chinchilla", "Harlequin", "Havana", "Himalayan", "Holland Lop", "Jersey Wooly", "Lilac", "Lionhead", "Mini Lop", "Mini Rex", "Mini Satin", "Netherland Dwarf", "New Zealand", "Palomino", "Polish", "Rex", "Rhinelander", "Satin", "Satin Angora", "Silver", "Silver Fox", "Silver Marten", "Standard Chinchilla", "Tan", "Thrianta"];
var b = ["Abrocoma", "Abrocoma schistacea", "Aconaemys", "Aconaemys porteri", "African brush-tailed porcupine", "Andean mountain cavy", "Argentine tuco-tuco", "Ashy chinchilla rat", "Asiatic brush-tailed porcupine", "Atherurus", "Azara's agouti", "Azara's tuco-tuco", "Bahia porcupine", "Bathyergus", "Bathyergus janetta", "Bathyergus suillus", "Bennett's chinchilla rat", "Bicolored-spined porcupine", "Black agouti", "Black dwarf porcupine", "Black-rumped agouti", "Black-tailed hairy dwarf porcupine", "Bolivian chinchilla rat", "Bolivian tuco-tuco", "Bonetto's tuco-tuco", "Brandt's yellow-toothed cavy", "Brazilian guinea pig", "Brazilian porcupine", "Brazilian tuco-tuco", "Bridge's degu", "Brown hairy dwarf porcupine", "Budin's chinchilla rat, A. budini", "Cape porcupine", "Catamarca tuco-tuco", "Cavia", "Central American agouti", "Chacoan tuco-tuco", "Chilean rock rat", "Chinchilla", "Coendou", "Coiban agouti", "Colburn's tuco-tuco", "Collared tuco-tuco", "Common degu", "Common yellow-toothed cavy", "Conover's tuco-tuco", "Coruro", "Crested agouti", "Crested porcupine", "Cryptomys", "Cryptomys bocagei", "Cryptomys damarensis", "Cryptomys foxi", "Cryptomys hottentotus", "Cryptomys mechowi", "Cryptomys ochraceocinereus", "Cryptomys zechi", "Ctenomys", "Cuniculus", "Cuscomys", "Cuscomys ashanika", "Dactylomys", "Dactylomys boliviensis", "Dactylomys dactylinus", "Dactylomys peruanus", "Dasyprocta", "Domestic guinea pig", "Emily's tuco-tuco", "Erethizon", "Famatina chinchilla rat", "Frosted hairy dwarf porcupine", "Fukomys", "Fukomys amatus", "Fukomys anselli", "Fukomys bocagei", "Fukomys damarensis", "Fukomys darlingi", "Fukomys foxi", "Fukomys ilariae", "Fukomys kafuensis", "Fukomys mechowii", "Fukomys micklemi", "Fukomys occlusus", "Fukomys ochraceocinereus", "Fukomys whytei", "Fukomys zechi", "Furtive tuco-tuco", "Galea", "Georychus", "Georychus capensis", "Golden viscacha-rat", "Goya tuco-tuco", "Greater guinea pig", "Green acouchi", "Haig's tuco-tuco", "Heliophobius", "Heliophobius argenteocinereus", "Heterocephalus", "Heterocephalus glaber", "Highland tuco-tuco", "Hystrix", "Indian porcupine", "Isla Mocha degu", "Kalinowski agouti", "Kannabateomys", "Kannabateomys amblyonyx", "Lagidium", "Lagostomus", "Lewis' tuco-tuco", "Long-tailed chinchilla", "Long-tailed porcupine", "Los Chalchaleros' viscacha-rat", "Lowland paca", "Magellanic tuco-tuco", "Malayan porcupine", "Maule tuco-tuco", "Mendoza tuco-tuco", "Mexican agouti", "Mexican hairy dwarf porcupine", "Microcavia", "Montane guinea pig", "Moon-toothed degu", "Mottled tuco-tuco", "Mountain degu", "Mountain paca", "Mountain viscacha-rat", "Myoprocta", "Natterer's tuco-tuco", "North American porcupine", "Northern viscacha", "Octodon", "Octodontomys", "Octomys", "Olallamys", "Olallamys albicauda", "Olallamys edax", "Orinoco agouti", "Paraguaian hairy dwarf porcupine", "Pearson's tuco-tuco", "Peruvian tuco-tuco", "Philippine porcupine", "Pipanacoctomys", "Plains viscacha", "Plains viscacha-rat", "Porteous' tuco-tuco", "Punta de Vacas chinchilla rat", "Red acouchi", "Red-rumped agouti", "Reddish tuco-tuco", "Rio Negro tuco-tuco", "Robust tuco-tuco", "Roosmalen's dwarf porcupine", "Rothschild's porcupine", "Ruatan Island agouti", "Sage's rock rat", "Salinoctomys", "Salta tuco-tuco", "San Luis tuco-tuco", "Santa Catarina's guinea pig", "Shiny guinea pig", "Shipton's mountain cavy", "Short-tailed chinchilla", "Silky tuco-tuco", "Social tuco-tuco", "Southern mountain cavy", "Southern tuco-tuco", "Southern viscacha", "Spalacopus", "Spix's yellow-toothed cavy", "Steinbach's tuco-tuco", "Streaked dwarf porcupine", "Strong tuco-tuco", "Stump-tailed porcupine", "Sumatran porcupine", "Sunda porcupine", "Talas tuco-tuco", "Tawny tuco-tuco", "Thick-spined porcupine", "Tiny tuco-tuco", "Trichys", "Tucuman tuco-tuco", "Tympanoctomys", "Uspallata chinchilla rat", "White-toothed tuco-tuco", "Wolffsohn's viscacha"];
var C = ["Abaco Island boa", "Aesculapian snake", "African beaked snake", "African puff adder", "African rock python", "African twig snake", "African wolf snake", "Amazon tree boa", "Amazonian palm viper", "American Vine Snake", "American copperhead", "Amethystine python", "Anaconda", "Andaman cat snake", "Andaman cobra", "Angolan python", "Annulated sea snake", "Arabian cobra", "Arafura file snake", "Arizona black rattlesnake", "Arizona coral snake", "Aruba rattlesnake", "Asian Vine Snake, Whip Snake", "Asian cobra", "Asian keelback", "Asian pipe snake", "Asp", "Asp viper", "Assam keelback", "Australian copperhead", "Australian scrub python", "Baird's rat snake", "Baja California lyresnake", "Ball Python", "Ball python", "Bamboo pitviper", "Bamboo viper", "Banded Flying Snake", "Banded cat-eyed snake", "Banded krait", "Banded pitviper", "Banded water cobra", "Barbour's pit viper", "Barred wolf snake", "Beaked sea snake", "Beauty rat snake", "Beddome's cat snake", "Beddome's coral snake", "Bimini racer", "Bird snake", "Bismarck ringed python", "Black headed python", "Black krait", "Black mamba", "Black rat snake", "Black snake", "Black tree cobra", "Black-banded trinket snake", "Black-headed snake", "Black-necked cobra", "Black-necked spitting cobra", "Black-speckled palm-pitviper", "Black-striped keelback", "Black-tailed horned pit viper", "Blanding's tree snake", "Blind snake", "Blonde hognose snake", "Blood python", "Blue krait", "Blunt-headed tree snake", "Bluntnose viper", "Boa", "Boa constrictor", "Bocourt's water snake", "Boelen python", "Boiga", "Bolivian anaconda", "Boomslang", "Bornean pitviper", "Borneo short-tailed python", "Brahminy blind snake", "Brazilian coral snake", "Brazilian mud Viper", "Brazilian smooth snake", "Bredl's python", "Brongersma's pitviper", "Brown snake", "Brown spotted pitviper[4]", "Brown tree snake", "Brown water python", "Brown white-lipped python", "Buff striped keelback", "Bull snake", "Burmese keelback", "Burmese krait", "Burmese python", "Burrowing cobra", "Burrowing viper", "Bush viper", "Bushmaster", "Buttermilk racer", "Calabar python", "California kingsnake", "Canebrake", "Cantil", "Cantor's pitviper", "Cape cobra", "Cape coral snake", "Cape gopher snake", "Carpet viper", "Cascabel", "Caspian cobra", "Cat snake", "Cat-eyed night snake", "Cat-eyed snake", "Central American lyre snake", "Central ranges taipan", "Centralian carpet python", "Ceylon krait", "Chappell Island tiger snake", "Checkered garter snake", "Checkered keelback", "Chicken snake", "Chihuahuan ridge-nosed rattlesnake", "Children's python", "Chinese tree viper", "Coachwhip snake", "Coastal carpet python", "Coastal taipan", "Cobra", "Collett's snake", "Colorado desert sidewinder", "Common adder", "Common cobra", "Common garter snake", "Common ground snake", "Common keelback", "Common lancehead", "Common tiger snake", "Common worm snake", "Congo snake", "Congo water cobra", "Copperhead", "Coral snake", "Corn snake", "Coronado Island rattlesnake", "Cottonmouth", "Crossed viper", "Crowned snake", "Cuban boa", "Cuban wood snake", "Cyclades blunt-nosed viper", "Dauan Island water python", "De Schauensee's anaconda", "Death Adder", "Desert death adder", "Desert kingsnake", "Desert woma python", "Diamond python", "Dog-toothed cat snake", "Down's tiger snake", "Dubois's sea snake", "Dumeril's boa", "Durango rock rattlesnake", "Dusky pigmy rattlesnake", "Dusty hognose snake", "Dwarf beaked snake", "Dwarf boa", "Dwarf pipe snake", "Dwarf sand adder", "Eastern brown snake", "Eastern coral snake", "Eastern diamondback rattlesnake", "Eastern green mamba", "Eastern hognose snake", "Eastern lyre snake", "Eastern mud snake", "Eastern racer", "Eastern tiger snake", "Eastern water cobra", "Eastern yellowbelly sad racer", "Egg-eater", "Egyptian asp", "Egyptian cobra", "Elegant pitviper", "Emerald tree boa", "Equatorial spitting cobra", "European asp", "European smooth snake", "Eyelash palm-pitviper", "Eyelash pit viper", "Eyelash viper", "False cobra", "False horned viper", "False water cobra", "Fan-Si-Pan horned pitviper", "Fea's viper", "Fer-de-lance", "Fierce snake", "Fifty pacer", "Fishing snake", "Flat-nosed pitviper", "Flinders python", "Flying snake", "Forest cobra", "Forest flame snake", "Forsten's cat snake", "Fox snake, three species of Pantherophis", "Gaboon viper", "Garter snake", "Giant Malagasy hognose snake", "Godman's pit viper", "Gold tree cobra", "Gold-ringed cat snake", "Golden tree snake", "Grand Canyon rattlesnake", "Grass snake", "Gray cat snake", "Great Basin rattlesnake", "Great Lakes bush viper", "Great Plains rat snake", "Green anaconda", "Green cat-eyed snake", "Green mamba", "Green palm viper", "Green rat snake", "Green snake", "Green tree pit viper", "Green tree python", "Grey Lora", "Grey-banded kingsnake", "Ground snake", "Guatemalan palm viper", "Guatemalan tree viper", "Habu", "Habu pit viper", "Hagen's pitviper", "Hairy bush viper", "Halmahera python", "Hardwicke's sea snake", "Harlequin coral snake", "High Woods coral snake", "Hill keelback", "Himalayan keelback", "Hogg Island boa", "Hognose snake", "Hognosed viper", "Honduran palm viper", "Hook Nosed Sea Snake", "Hopi rattlesnake", "Horned adder", "Horned desert viper", "Horned viper", "Horseshoe pitviper", "Hundred pacer", "Hutton's tree viper", "Ikaheka snake", "Indian cobra", "Indian flying snake", "Indian krait", "Indian python", "Indian tree viper", "Indigo snake", "Indochinese spitting cobra", "Indonesian water python", "Inland carpet python", "Inland taipan", "Jamaican Tree Snake", "Jamaican boa", "Jan's hognose snake", "Japanese forest rat snake", "Japanese rat snake", "Japanese striped snake", "Javan spitting cobra", "Jerdon's pitviper", "Jumping viper", "Jungle carpet python", "Kanburian pit viper", "Kaulback's lance-headed pitviper", "Kayaudi dwarf reticulated python", "Kaznakov's viper", "Keelback", "Kham Plateau pitviper", "Khasi Hills keelback", "King Island tiger snake", "King brown", "King cobra", "King rat snake", "King snake", "Krait", "Krefft's tiger snake", "Lance-headed rattlesnake", "Lancehead", "Large shield snake", "Large-eyed pitviper", "Large-scaled tree viper", "Leaf viper", "Leaf-nosed viper", "Lesser black krait", "Levant viper", "Long-nosed adder", "Long-nosed tree snake", "Long-nosed viper", "Long-nosed whip snake", "Long-tailed rattlesnake", "Longnosed worm snake", "Lora", "Lyre snake", "Machete savane", "Macklot's python", "Madagascar ground boa", "Madagascar tree boa", "Malabar rock pitviper", "Malayan krait", "Malayan long-glanded coral snake", "Malayan pit viper", "Malcolm's tree viper", "Mamba", "Mamushi", "Manchurian Black Water Snake", "Mandalay cobra", "Mandarin rat snake", "Mangrove pit viper", "Mangrove snake", "Mangshan pitviper", "Many-banded krait", "Many-banded tree snake", "Many-horned adder", "Many-spotted cat snake", "Massasauga rattlesnake", "McMahon's viper", "Mexican black kingsnake", "Mexican green rattlesnake", "Mexican hognose snake", "Mexican palm-pitviper", "Mexican parrot snake", "Mexican racer", "Mexican vine snake", "Mexican west coast rattlesnake", "Midget faded rattlesnake", "Milk snake", "Moccasin snake", "Modest keelback", "Mojave desert sidewinder", "Mojave rattlesnake", "Mole viper", "Mollucan python", "Moluccan flying snake", "Montpellier snake", "Motuo bamboo pitviper", "Mountain adder", "Mozambique spitting cobra", "Mud adder", "Mud snake", "Mussurana", "Namaqua dwarf adder", "Namib dwarf sand adder", "Narrowhead Garter Snake", "New Guinea carpet python", "Nichell snake", "Nicobar Island keelback", "Nicobar bamboo pitviper", "Night snake", "Nightingale adder", "Nilgiri keelback", "Nitsche's bush viper", "Nitsche's tree viper", "North Philippine cobra", "North eastern king snake", "Northeastern hill krait", "Northern black-tailed rattlesnake", "Northern tree snake", "Northern water snake", "Northern white-lipped python", "Northwestern carpet python", "Nose-horned viper", "Nubian spitting cobra", "Oaxacan small-headed rattlesnake", "Oenpelli python", "Olive python", "Olive sea snake", "Orange-collared keelback", "Ornate flying snake", "Palestine viper", "Pallas' viper", "Palm viper", "Papuan python", "Paradise flying snake", "Parrot snake", "Patchnose snake", "Paupan taipan", "Pelagic sea snake", "Peninsula tiger snake", "Peringuey's adder", "Perrotet's shieldtail snake", "Persian rat snake", "Philippine cobra", "Philippine pitviper", "Pine snake", "Pipe snake", "Pit viper", "Pointed-scaled pit viper[5]", "Pope's tree viper", "Portuguese viper", "Prairie kingsnake", "Puerto Rican boa", "Puff adder", "Pygmy python", "Python", "Queen snake", "Racer", "Raddysnake", "Rainbow boa", "Rat snake", "Rattler", "Rattlesnake", "Red blood python", "Red diamond rattlesnake", "Red spitting cobra", "Red-backed rat snake", "Red-bellied black snake", "Red-headed krait", "Red-necked keelback", "Red-tailed bamboo pitviper", "Red-tailed boa", "Red-tailed pipe snake", "Reticulated python", "Rhinoceros viper", "Rhombic night adder", "Ribbon snake", "Rinkhals", "Rinkhals cobra", "River jack", "Rosy boa", "Rough green snake", "Rough-scaled bush viper", "Rough-scaled python", "Rough-scaled tree viper", "Royal python", "Rubber boa", "Rufous beaked snake", "Rungwe tree viper", "San Francisco garter snake", "Sand adder", "Sand boa", "Savu python", "Saw-scaled viper", "Scarlet kingsnake", "Schlegel's viper", "Schultze's pitviper", "Sea snake", "Sedge viper", "Selayer reticulated python", "Sharp-nosed viper", "Shield-nosed cobra", "Shield-tailed snake", "Siamese palm viper", "Side-striped palm-pitviper", "Sidewinder", "Sikkim keelback", "Sinai desert cobra", "Sind krait", "Small-eyed snake", "Smooth green snake", "Smooth snake", "Snorkel viper", "Snouted cobra", "Sonoran sidewinder", "South American hognose snake", "South eastern corn snake", "Southern Indonesian spitting cobra", "Southern Pacific rattlesnake", "Southern Philippine cobra", "Southern black racer", "Southern white-lipped python", "Southwestern black spitting cobra", "Southwestern blackhead snake", "Southwestern carpet python", "Southwestern speckled rattlesnake", "Speckle-bellied keelback", "Speckled kingsnake", "Spectacled cobra", "Spiny bush viper", "Spitting cobra", "Spotted python", "Sri Lankan pit viper", "Stejneger's bamboo pitviper", "Stiletto snake", "Stimson's python", "Stoke's sea snake", "Storm water cobra", "Striped snake", "Sumatran short-tailed python", "Sumatran tree viper", "Sunbeam snake", "Taipan", "Taiwan cobra", "Tan racer", "Tancitaran dusky rattlesnake", "Tanimbar python", "Tasmanian tiger snake", "Tawny cat snake", "Temple pit viper", "Temple viper", "Tentacled snake", "Texas Coral Snake", "Texas blind snake", "Texas garter snake", "Texas lyre snake", "Texas night snake", "Thai cobra", "Three-lined ground snake", "Tibetan bamboo pitviper", "Tic polonga", "Tiger pit viper", "Tiger rattlesnake", "Tiger snake", "Tigre snake", "Timber rattlesnake", "Timor python", "Titanboa", "Tree boa", "Tree snake", "Tree viper", "Trinket snake", "Tropical rattlesnake", "Twig snake", "Twin Headed King Snake", "Twin-Barred tree snake", "Twin-spotted rat snake", "Twin-spotted rattlesnake", "Undulated pit viper", "Uracoan rattlesnake", "Ursini's viper", "Urutu", "Vine snake", "Viper", "Viper Adder", "Vipera ammodytes", "Wagler's pit viper", "Wart snake", "Water adder", "Water moccasin", "Water snake", "West Indian racer", "Western blind snake", "Western carpet python", "Western coral snake", "Western diamondback rattlesnake", "Western green mamba", "Western ground snake", "Western hog-nosed viper", "Western mud snake", "Western tiger snake", "Western woma python", "Wetar Island python", "Whip snake", "White-lipped keelback", "White-lipped python", "White-lipped tree viper", "Wirot's pit viper", "Wolf snake", "Woma python", "Worm snake", "Wutu", "Wynaad keelback", "Yarara", "Yellow anaconda", "Yellow-banded sea snake", "Yellow-bellied sea snake", "Yellow-lined palm viper", "Yellow-lipped sea snake", "Yellow-striped rat snake", "Yunnan keelback", "Zebra snake", "Zebra spitting cobra"];
var S = ["bat", "bear", "bee", "bird", "butterfly", "cat", "cow", "crocodile", "deer", "dog", "dolphin", "eagle", "elephant", "fish", "flamingo", "fox", "frog", "gecko", "giraffe", "gorilla", "hamster", "hippopotamus", "horse", "kangaroo", "koala", "lion", "monkey", "ostrich", "panda", "parrot", "peacock", "penguin", "polar bear", "rabbit", "rhinoceros", "sea lion", "shark", "snake", "squirrel", "tiger", "turtle", "whale", "wolf", "zebra"];
var _a = { bear: n, bird: i, cat: t, cetacean: l, cow: s, crocodilia: d, dog: u, fish: c, horse: m, insect: h, lion: y, pet_name: p, rabbit: g, rodent: b, snake: C, type: S };
var k = _a;
var f = ["{{person.name}}", "{{company.name}}"];
var v = ["Redhold", "Treeflex", "Trippledex", "Kanlam", "Bigtax", "Daltfresh", "Toughjoyfax", "Mat Lam Tam", "Otcom", "Tres-Zap", "Y-Solowarm", "Tresom", "Voltsillam", "Biodex", "Greenlam", "Viva", "Matsoft", "Temp", "Zoolab", "Subin", "Rank", "Job", "Stringtough", "Tin", "It", "Home Ing", "Zamit", "Sonsing", "Konklab", "Alpha", "Latlux", "Voyatouch", "Alphazap", "Holdlamis", "Zaam-Dox", "Sub-Ex", "Quo Lux", "Bamity", "Ventosanzap", "Lotstring", "Hatity", "Tempsoft", "Overhold", "Fixflex", "Konklux", "Zontrax", "Tampflex", "Span", "Namfix", "Transcof", "Stim", "Fix San", "Sonair", "Stronghold", "Fintone", "Y-find", "Opela", "Lotlux", "Ronstring", "Zathin", "Duobam", "Keylex"];
var A = ["0.#.#", "0.##", "#.##", "#.#", "#.#.#"];
var Qa = { author: f, name: v, version: A };
var B = Qa;
var T = ["A.A. Milne", "Agatha Christie", "Alan Moore and Dave Gibbons", "Albert Camus", "Aldous Huxley", "Alexander Pope", "Alexandre Dumas", "Alice Walker", "Andrew Lang", "Anne Frank", "Anthony Burgess", "Anthony Trollope", "Antoine de Saint-Exup\xE9ry", "Anton Chekhov", "Anton Pavlovich Chekhov", "Arthur Conan Doyle", "Arthur Schopenhauer", "Aylmer Maude", "Ayn Rand", "Beatrix Potter", "Benjamin Disraeli", "Benjamin Jowett", "Bernard Shaw", "Bertrand Russell", "Bhagavanlal Indrajit", "Boris Pasternak", "Bram Stoker", "Brian Evenson", "C.E. Brock", "C.S. Lewis", "Carson McCallers", "Charles Dickens", "Charles E. Derbyshire", "Charlotte Bront\xEB", "Charlotte Perkins Gilman", "Chinua Achebe", "Clifford R. Adams", "Constance Garnett", "Cormac McCarthy", "D.H. Lawrence", "Dan Brown", "Daniel Defoe", "Dante Alighieri", "Dashiell Hammett", "David Widger", "David Wyllie", "Dean Koontz", "Don DeLillo", "E.M. Forster", "Edgar Allan Poe", "Edgar Rice Burroughs", "Elizabeth Cleghorn Gaskell", "Elizabeth Von Arnim", "Emily Bront\xEB", "Erich Remarque", "Ernest Hemingway", "Evelyn Waugh", "F. Scott Fitzgerald", "Ford Madox Ford", "Frances Hodgson Burnett", "Frank Herbert", "Frank T. Merrill", "Franz Kafka", "Friedrich Wilhelm Nietzsche", "Fyodor Dostoyevsky", "G.K. Chesterton", "Gabriel Garcia Marquez", "Geoffrey Chaucer", "George Eliot", "George Grossmith", "George Orwell", "George R. R. Martin", "George Saunders", "Grady Ward", "Graham Greene", "Gustave Dor\xE9", "Gustave Flaubert", "Guy de Maupassant", "G\xFCnter Grass", "H.G. Wells", "H.P. Lovecraft", "Harper Lee", "Harriet Beecher Stowe", "Haruki Murakami", "Henrik Ibsen", "Henry David Thoreau", "Henry Fielding", "Henry James", "Henry Miller", "Henry Morley", "Herman Melville", "Hermann Broch", "Homer", "Honor\xE9 de Balzac", "Ian McEwan", "Isabel Florence Hapgood", "Italo Calvino", "J.D. Salinger", "J.K. Rowling", "J.M. Barrie", "J.R.R. Tolkien", "Jack Kerouac", "Jack London", "Jacob Grimm", "Jacqueline Crooks", "James Baldwin", "James Dickey", "James Ellroy", "James Joyce", "James Patterson", "Jane Austen", "Johann Wolfgang von Goethe", "John Bunyan", "John Camden Hotten", "John Dos Passos", "John Green", "John Grisham", "John Kennedy Toole", "John Milton", "John Ormsby", "John Steinbeck", "John Updike", "Jonathan Franzen", "Jonathan Swift", "Joseph Conrad", "Joseph Heller", "Jos\xE9 Rizal", "Judy Blume", "Jules Verne", "Junot Diaz", "Karl Marx", "Kazuo Ishiguro", "Ken Follett", "Ken Kesey", "Kenneth Grahame", "Khaled Hosseini", "Kingsley Amis", "Kurt Vonnegut", "L. Frank Baum", "L.M. Montgomery", "Laurence Sterne", "Leo Tolstoy", "Lewis Carroll", "Louisa May Alcott", "Louise Maude", "Malcolm Lowry", "Marcel Proust", "Margaret Atwood", "Margaret Mitchell", "Marilynne Robinson", "Mark Twain", "Martin Amis", "Mary Shelley", "Michael Chabon", "Miguel de Cervantes", "Mikhail Bulgakov", "Muriel Spark", "Nancy Mitford", "Nathanael West", "Nathaniel Hawthorne", "Neil Gaiman", "Niccolo Machiavelli", "Norman Mailer", "Oscar Levy", "Oscar Wilde", "P.G. Wodehouse", "Paulo Coelho", "Peter Carey", "Philip Pullman", "Philip Roth", "Plato", "R.L. Stine", "Rachel Kushner", "Ralph Ellison", "Ray Bradbury", "Raymond Chandler", "Richard Wagner", "Richard Wright", "Richard Yates", "Roald Dahl", "Robert Graves", "Robert Louis Stevenson", "Robert Penn Warren", "Rudyard Kipling", "Salman Rushdie", "Samuel Beckett", "Samuel Butler", "Samuel Richardson", "Saul Bellow", "Shivaram Parashuram Bhide", "Sir Arthur Conan Doyle", "Sir Richard Francis Burton", "Stendhal", "Stephen Hawking", "Stephen King", "Sun Tzu", "Suzanne Collins", "T. Smollett", "T.S. Eliot", "Theodore Alois Buckley", "Theodore Dreiser", "Thomas Hardy", "Thomas Love Peacock", "Thomas Mann", "Toni Morrison", "Truman Capote", "V.S. Naipaul", "Vance Packard", "Vatsyayana", "Victor Hugo", "Virgil", "Virginia Woolf", "Vladimir Nabokov", "Voltaire", "W.G. Sebald", "W.K. Marriott", "Walker Percy", "Walt Whitman", "Walter Scott", "Wilhelm Grimm", "Wilkie Collins", "William Faulkner", "William Gibson", "William Golding", "William Makepeace Thackeray", "William Shakespeare", "Zadie Smith"];
var M = ["Audiobook", "Ebook", "Hardcover", "Paperback"];
var w = ["Adventure", "Biography", "Business", "Children's Literature", "Classic", "Comedy", "Comic", "Detective", "Drama", "Fantasy", "Graphic Novel", "Historical Fiction", "Horror", "Memoir", "Mystery", "Mythology", "Philosophy", "Poetry", "Psychology", "Religion", "Romance", "Science Fiction", "Thriller", "Western", "Young Adult"];
var L = ["Academic Press", "Ace Books", "Addison-Wesley", "Adis International", "Airiti Press", "Allen Ltd", "Andrews McMeel Publishing", "Anova Books", "Anvil Press Poetry", "Applewood Books", "Apress", "Athabasca University Press", "Atheneum Books", "Atheneum Publishers", "Atlantic Books", "Atlas Press", "BBC Books", "Ballantine Books", "Banner of Truth Trust", "Bantam Books", "Bantam Spectra", "Barrie & Jenkins", "Basic Books", "Belknap Press", "Bella Books", "Bellevue Literary Press", "Berg Publishers", "Berkley Books", "Bison Books", "Black Dog Publishing", "Black Library", "Black Sparrow Books", "Blackie and Son Limited", "Blackstaff Press", "Blackwell Publishing", "Bloodaxe Books", "Bloomsbury Publishing Plc", "Blue Ribbon Books", "Book League of America", "Book Works", "Booktrope", "Borgo Press", "Bowes & Bowes", "Boydell & Brewer", "Breslov Research Institute", "Brill", "Brimstone Press", "Broadview Press", "Burns & Oates", "Butterworth-Heinemann", "Caister Academic Press", "Cambridge University Press", "Candlewick Press", "Canongate Books", "Carcanet Press", "Carlton Books", "Carlton Publishing Group", "Carnegie Mellon University Press", "Casemate Publishers", "Cengage Learning", "Central European University Press", "Chambers Harrap", "Charles Scribner's Sons", "Chatto and Windus", "Chick Publications", "Chronicle Books", "Churchill Livingstone", "Cisco Press", "City Lights Publishers", "Cloverdale Corporation", "D. Appleton & Company", "D. Reidel", "DAW Books", "Da Capo Press", "Daedalus Publishing", "Dalkey Archive Press", "Darakwon Press", "David & Charles", "Dedalus Books", "Del Rey Books", "E. P. Dutton", "ECW Press", "Earthscan", "Edupedia Publications", "Eel Pie Publishing", "Eerdmans Publishing", "Ellora's Cave", "Elsevier", "Emerald Group Publishing", "Etruscan Press", "FabJob", "Faber and Faber", "Fairview Press", "Farrar, Straus & Giroux", "Fearless Books", "Felony & Mayhem Press", "Firebrand Books", "Flame Tree Publishing", "Focal Press", "G-Unit Books", "G. P. Putnam's Sons", "Gaspereau Press", "Gay Men's Press", "Gefen Publishing House", "George H. Doran Company", "George Newnes", "George Routledge & Sons", "Godwit Press", "Golden Cockerel Press", "HMSO", "Hachette Book Group USA", "Hackett Publishing Company", "Hamish Hamilton", "Happy House", "Harcourt Assessment", "Harcourt Trade Publishers", "Harlequin Enterprises Ltd", "Harper & Brothers", "Harper & Row", "HarperCollins", "HarperPrism", "HarperTrophy", "Harry N. Abrams, Inc.", "Harvard University Press", "Harvest House", "Harvill Press at Random House", "Hawthorne Books", "Hay House", "Haynes Manuals", "Heyday Books", "Hodder & Stoughton", "Hodder Headline", "Hogarth Press", "Holland Park Press", "Holt McDougal", "Horizon Scientific Press", "Ian Allan Publishing", "Ignatius Press", "Imperial War Museum", "Indiana University Press", "J. M. Dent", "Jaico Publishing House", "Jarrolds Publishing", "John Blake Publishing", "Karadi Tales", "Kensington Books", "Kessinger Publishing", "Kodansha", "Kogan Page", "Koren Publishers Jerusalem", "Ladybird Books", "Leaf Books", "Leafwood Publishers", "Left Book Club", "Legend Books", "Lethe Press", "Libertas Academica", "Liberty Fund", "Library of America", "Lion Hudson", "Macmillan Publishers", "Mainstream Publishing", "Manchester University Press", "Mandrake Press", "Mandrake of Oxford", "Manning Publications", "Manor House Publishing", "Mapin Publishing", "Marion Boyars Publishers", "Mark Batty Publisher", "Marshall Cavendish", "Marshall Pickering", "Martinus Nijhoff Publishers", "Mascot Books", "Matthias Media", "McClelland and Stewart", "McFarland & Company", "McGraw Hill Financial", "McGraw-Hill Education", "Medknow Publications", "Naiad Press", "Nauka", "NavPress", "New Directions Publishing", "New English Library", "New Holland Publishers", "New Village Press", "Newnes", "No Starch Press", "Nonesuch Press", "O'Reilly Media", "Oberon Books", "Open Court Publishing Company", "Open University Press", "Orchard Books", "Orion Books", "Packt Publishing", "Palgrave Macmillan", "Pan Books", "Pantheon Books at Random House", "Papadakis Publisher", "Parachute Publishing", "Parragon", "Pathfinder Press", "Paulist Press", "Pavilion Books", "Peace Hill Press", "Pecan Grove Press", "Pen and Sword Books", "Penguin Books", "Random House", "Reed Elsevier", "Reed Publishing", "SAGE Publications", "Salt Publishing", "Sams Publishing", "Schocken Books", "Scholastic Press", "Seagull Books", "Secker & Warburg", "Shambhala Publications", "Shire Books", "Shoemaker & Hoard Publishers", "Shuter & Shooter Publishers", "Sidgwick & Jackson", "Signet Books", "Simon & Schuster", "St. Martin's Press", "T & T Clark", "Tachyon Publications", "Tammi", "Target Books", "Tarpaulin Sky Press", "Tartarus Press", "Tate Publishing & Enterprises", "Taunton Press", "Taylor & Francis", "Ten Speed Press", "UCL Press", "Unfinished Monument Press", "United States Government Publishing Office", "University of Akron Press", "University of Alaska Press", "University of California Press", "University of Chicago Press", "University of Michigan Press", "University of Minnesota Press", "University of Nebraska Press", "Velazquez Press", "Verso Books", "Victor Gollancz Ltd", "Viking Press", "Vintage Books", "Vintage Books at Random House", "Virago Press", "Virgin Publishing", "Voyager Books", "Zed Books", "Ziff Davis Media", "Zondervan"];
var D = ["A Song of Ice and Fire", "Anna Karenina", "Colonel Race", "Discworld", "Dune", "Harry Potter", "Hercule Poirot", "His Dark Materials", "Jane Austen Murder Mysteries", "Little Women", "Outlander", "Percy Jackson", "Sherlock Holmes", "The Arc of a Scythe", "The Bartimaeus Trilogy", "The Border Trilogy", "The Chronicles of Narnia", "The Dark Tower", "The Dresden Files", "The Eighth Life", "The Foundation Series", "The Hitchhiker's Guide to the Galaxy", "The Hunger Games", "The Infinity Cycle", "The Inheritance Cycle", "The Lord of the Rings", "The Maze Runner", "The Prison Healer", "The Red Rising Saga", "The Southern Reach", "The Wheel of Time", "Thursday Next Series", "Twilight", "War and Peace"];
var R = ["1984", "20,000 Leagues Under the Sea", "A Bend in the River", "A Brief History of Time", "A Clockwork Orange", "A Confederacy of Dunces", "A Doll's House", "A Handful of Dust", "A Modest Proposal", "A Passage to India", "A Portrait of the Artist as a Young Man", "A Room with a View", "A Study in Scarlet", "A Tale of Two Cities", "A Wrinkle in Time", "Absalom, Absalom!", "Adventures of Huckleberry Finn", "Alice's Adventures in Wonderland", "All Quiet on the Western Front", "All the King's Men", "American Pastoral", "An American Tragedy", "And Then There Were None", "Animal Farm", "Anna Karenina", "Anne of Green Gables", "Are You There God? It's Me, Margaret", "As I Lay Dying", "Atlas Shrugged", "Atonement", "Austerlitz", "Beloved", "Beyond Good and Evil", "Bible", "Bleak House", "Blood Meridian", "Brave New World", "Brideshead Revisited", "Candide", "Carmilla", "Catch-22", "Charlie and the Chocolate Factory", "Charlotte's Web", "Clarissa", "Cranford", "Crime and Punishment", "Dao De Jing: A Minimalist Translation", "David Copperfield", "Deliverance", "Don Quixote", "Dora", "Dr. Zhivago", "Dracula", "Dubliners", "Dune", "East of Eden", "Emma", "Fahrenheit 451", "Faust", "For Whom the Bell Tolls", "Frankenstein", "Freakonomics", "Go Tell It on the Mountain", "Gone with the Wind", "Great Expectations", "Grimms' Fairy Tales", "Gulliver's Travels", "Hamlet", "Harry Potter and the Sorcerer's Stone", "Heart of Darkness", "Herzog", "His Dark Materials", "Hitting the line", "Housekeeping", "I, Claudius", "If on a Winter's Night a Traveler", "In Cold Blood", "In Search of Lost Time", "Invisible Man", "It", "Jane Eyre", "Josefine Mutzenbacher", "Jude the Obscure", "L.A. Confidential", "Leaves of Grass", "Les Miserables", "Life of Pi", "Little Women", "Lolita", "Long Walk to Freedom", "Lord Jim", "Lord of the Flies", "Lucky Jim", "Madame Bovary", "Malone Dies", "Meditations", "Men Without Women", "Metamorphosis", "Middlemarch", "Midnight's Children", "Moby Dick", "Money", "Mrs. Dalloway", "My Bondage and My Freedom", "My Life", "Native Son", "Neuromancer", "Never Let Me Go", "Nightmare Abbey", "Nineteen Eighty Four", "Nostromo", "Notes from the Underground", "Of Mice and Men", "Oliver Twist", "On the Duty of Civil Disobedience", "On the Road", "One Flew Over the Cuckoo's Nest", "One Hundred Years of Solitude", "One Thousand and One Nights", "Oscar and Lucinda", "Pale Fire", "Paradise Lost", "Peter Pan", "Portnoy's Complaint", "Pride and Prejudice", "Rabbit, Run", "Republic", "Revolutionary Road", "Robinson Crusoe", "Romeo and Juliet", "Ruth Fielding in Alaska", "Scoop", "Second Treatise of Government", "Slaughterhouse Five", "Stories of Anton Chekhov", "Sybil", "Tess of the d'Urbervilles", "The Adventures of Augie March", "The Adventures of Huckleberry Finn", "The Adventures of Sherlock Holmes", "The Adventures of Tom Sawyer", "The Aeneid", "The Alchemist", "The Ambassadors", "The Art of War", "The Big Sleep", "The Black Sheep", "The Blue Castle", "The Brief Wondrous Life of Oscar Wao", "The Brothers Karamazov", "The Call of the Wild", "The Canterbury Tales", "The Catcher in the Rye", "The Color Purple", "The Complete Works of Edgar Allen Poe", "The Corrections", "The Count of Monte Cristo", "The Day of the Locust", "The Diary of a Nobody", "The Diary of a Young Girl", "The Divine Comedy", "The Enchanted April", "The Fountainhead", "The Golden Bowl", "The Golden Notebook", "The Good Soldier", "The Grapes of Wrath", "The Great Gatsby", "The Handmaid's Tale", "The Heart is a Lonely Hunter", "The Heart of the Matter", "The Hobbit", "The Hound of the Baskervilles", "The Idiot", "The Iliad", "The King in Yellow", "The Kite Runner", "The Lion, the Witch, and the Wardrobe", "The Little Prince", "The Lord of the Rings", "The Magic Mountain", "The Maltese Falcon", "The Master and Margarita", "The Moviegoer", "The Naked and the Dead", "The Odyssey", "The Old Man and the Sea", "The Pickwick Papers", "The Picture of Dorian Gray", "The Pilgrim's Progress", "The Pillars of the Earth", "The Plague", "The Portrait of a Lady", "The Prime of Miss Jean Brodie", "The Prince", "The Problems of Philosophy", "The Prophet", "The Pursuit of Love", "The Rainbow", "The Red and the Black", "The Remains of the Day", "The Republic", "The Scarlet Letter", "The Sleepwalkers", "The Sound and the Fury", "The Stand", "The Strange Case of Dr. Jekyll and Mr. Hyde", "The Stranger", "The Sun Also Rises", "The Thirty-Nine Steps", "The Three Musketeers", "The Time Machine", "The Tin Drum", "The Trial", "The War of the Worlds", "The Waste Land", "The Way We Live Now", "The Wind in the Willows", "The Woman in White", "The Wonderful Wizard of Oz", "The Works of Edgar Allan Poe", "The Yellow Wallpaper", "Things Fall Apart", "Tinker, Tailor, Soldier, Spy", "To Kill a Mockingbird", "To the Lighthouse", "Tom Jones", "Treasure Island", "Tristram Shandy", "Tropic of Cancer", "U.S.A. Trilogy", "Ulysses", "Uncle Tom's Cabin", "Under the Volcano", "Underworld", "Vanity Fair", "Walden", "War and Peace", "Watchmen", "Winnie-the-Pooh", "Wuthering Heights"];
var Xa = { author: T, format: M, genre: w, publisher: L, series: D, title: R };
var P = Xa;
var H = ["###-###-####", "(###) ###-####", "1-###-###-####", "###.###.####"];
var $a = { formats: H };
var W = $a;
var G = ["azure", "black", "blue", "cyan", "fuchsia", "gold", "green", "grey", "indigo", "ivory", "lavender", "lime", "magenta", "maroon", "mint green", "olive", "orange", "orchid", "pink", "plum", "purple", "red", "salmon", "silver", "sky blue", "tan", "teal", "turquoise", "violet", "white", "yellow"];
var er = { human: G };
var F = er;
var N = ["Automotive", "Baby", "Beauty", "Books", "Clothing", "Computers", "Electronics", "Games", "Garden", "Grocery", "Health", "Home", "Industrial", "Jewelry", "Kids", "Movies", "Music", "Outdoors", "Shoes", "Sports", "Tools", "Toys"];
var E = ["Discover the {{animal.type}}-like agility of our {{commerce.product}}, perfect for {{word.adjective}} users", "Discover the {{word.adjective}} new {{commerce.product}} with an exciting mix of {{commerce.productMaterial}} ingredients", "Ergonomic {{commerce.product}} made with {{commerce.productMaterial}} for all-day {{word.adjective}} support", "Experience the {{color.human}} brilliance of our {{commerce.product}}, perfect for {{word.adjective}} environments", "Featuring {{science.chemical_element.name}}-enhanced technology, our {{commerce.product}} offers unparalleled {{word.adjective}} performance", "Innovative {{commerce.product}} featuring {{word.adjective}} technology and {{commerce.productMaterial}} construction", "Introducing the {{location.country}}-inspired {{commerce.product}}, blending {{word.adjective}} style with local craftsmanship", "New {{color.human}} {{commerce.product}} with ergonomic design for {{word.adjective}} comfort", 'New {{commerce.product}} model with {{number.int({"min": 1, "max": 100})}} GB RAM, {{number.int({"min": 1, "max": 1000})}} GB storage, and {{word.adjective}} features', "Our {{animal.type}}-friendly {{commerce.product}} ensures {{word.adjective}} comfort for your pets", "Our {{food.adjective}}-inspired {{commerce.product}} brings a taste of luxury to your {{word.adjective}} lifestyle", "Professional-grade {{commerce.product}} perfect for {{word.adjective}} training and recreational use", "Savor the {{food.adjective}} essence in our {{commerce.product}}, designed for {{word.adjective}} culinary adventures", "Stylish {{commerce.product}} designed to make you stand out with {{word.adjective}} looks", "The sleek and {{word.adjective}} {{commerce.product}} comes with {{color.human}} LED lighting for smart functionality", "The {{color.human}} {{commerce.product}} combines {{location.country}} aesthetics with {{science.chemical_element.name}}-based durability", "The {{company.catchPhrase}} {{commerce.product}} offers reliable performance and {{word.adjective}} design", "The {{person.firstName}} {{commerce.product}} is the latest in a series of {{word.adjective}} products from {{company.name}}", "{{commerce.productAdjective}} {{commerce.product}} designed with {{commerce.productMaterial}} for {{word.adjective}} performance", "{{company.name}}'s most advanced {{commerce.product}} technology increases {{word.adjective}} capabilities"];
var J = { adjective: ["Awesome", "Bespoke", "Electronic", "Elegant", "Ergonomic", "Fantastic", "Fresh", "Frozen", "Generic", "Gorgeous", "Handcrafted", "Handmade", "Incredible", "Intelligent", "Licensed", "Luxurious", "Modern", "Oriental", "Practical", "Recycled", "Refined", "Rustic", "Sleek", "Small", "Soft", "Tasty", "Unbranded"], material: ["Aluminum", "Bamboo", "Bronze", "Ceramic", "Concrete", "Cotton", "Gold", "Granite", "Marble", "Metal", "Plastic", "Rubber", "Silk", "Steel", "Wooden"], product: ["Bacon", "Ball", "Bike", "Car", "Chair", "Cheese", "Chicken", "Chips", "Computer", "Fish", "Gloves", "Hat", "Keyboard", "Mouse", "Pants", "Pizza", "Salad", "Sausages", "Shirt", "Shoes", "Soap", "Table", "Towels", "Tuna"] };
var ar = { department: N, product_description: E, product_name: J };
var I = ar;
var K = ["AI-driven", "Adaptive", "Advanced", "Automated", "Balanced", "Business-focused", "Centralized", "Compatible", "Configurable", "Cross-platform", "Customer-focused", "Customizable", "Decentralized", "Devolved", "Digitized", "Distributed", "Diverse", "Enhanced", "Ergonomic", "Exclusive", "Expanded", "Extended", "Face to face", "Focused", "Front-line", "Fully-configurable", "Fundamental", "Future-proofed", "Grass-roots", "Horizontal", "Immersive", "Implemented", "Innovative", "Integrated", "Intuitive", "Managed", "Monitored", "Multi-tiered", "Networked", "Open-architected", "Open-source", "Operative", "Optimized", "Optional", "Organic", "Organized", "Persevering", "Persistent", "Phased", "Polarised", "Proactive", "Profit-focused", "Profound", "Programmable", "Progressive", "Public-key", "Quality-focused", "Reactive", "Realigned", "Reduced", "Reverse-engineered", "Robust", "Seamless", "Secured", "Self-enabling", "Sharable", "Smart", "Stand-alone", "Streamlined", "Sustainable", "Synchronised", "Team-oriented", "Total", "Triple-buffered", "Universal", "Upgradable", "User-centric", "User-friendly", "Versatile", "Virtual", "Visionary"];
var O = ["24/7", "AI-driven", "B2B", "B2C", "back-end", "best-of-breed", "bleeding-edge", "collaborative", "compelling", "cross-media", "cross-platform", "customized", "cutting-edge", "decentralized", "distributed", "dynamic", "efficient", "end-to-end", "enterprise", "extensible", "frictionless", "front-end", "generative", "global", "granular", "holistic", "immersive", "impactful", "innovative", "integrated", "interactive", "intuitive", "killer", "leading-edge", "magnetic", "mission-critical", "next-generation", "one-to-one", "open-source", "out-of-the-box", "plug-and-play", "proactive", "quantum", "real-time", "revolutionary", "rich", "robust", "scalable", "seamless", "smart", "sticky", "strategic", "sustainable", "synergistic", "transparent", "turn-key", "ubiquitous", "user-centric", "value-added", "vertical", "viral", "virtual", "visionary", "world-class"];
var x = ["AI", "ROI", "applications", "architectures", "blockchains", "channels", "communities", "content", "convergence", "deliverables", "e-commerce", "experiences", "functionalities", "infrastructures", "initiatives", "interfaces", "large language models", "lifetime value", "markets", "methodologies", "metrics", "mindshare", "models", "networks", "niches", "paradigms", "partnerships", "platforms", "relationships", "schemas", "smart contracts", "solutions", "supply-chains", "synergies", "systems", "technologies", "users", "web services"];
var z = ["aggregate", "architect", "benchmark", "brand", "collaborate", "cultivate", "deliver", "deploy", "disintermediate", "drive", "embrace", "empower", "enable", "engage", "engineer", "enhance", "evolve", "expedite", "exploit", "extend", "facilitate", "gamify", "generate", "grow", "harness", "implement", "incentivize", "incubate", "innovate", "integrate", "iterate", "leverage", "maximize", "mesh", "monetize", "optimize", "orchestrate", "productize", "redefine", "reinvent", "repurpose", "revolutionize", "scale", "seize", "simplify", "strategize", "streamline", "syndicate", "synthesize", "target", "transform", "transition", "unleash", "utilize", "visualize", "whiteboard"];
var V = ["24 hour", "24/7", "AI-powered", "actuating", "analyzing", "asymmetric", "asynchronous", "attitude-oriented", "bifurcated", "bottom-line", "clear-thinking", "client-driven", "client-server", "cloud-native", "coherent", "cohesive", "composite", "content-based", "context-sensitive", "contextually-based", "data-driven", "dedicated", "demand-driven", "directional", "discrete", "disintermediate", "dynamic", "eco-centric", "empowering", "encompassing", "executive", "explicit", "exuding", "fault-tolerant", "fresh-thinking", "full-range", "global", "heuristic", "high-level", "holistic", "homogeneous", "human-resource", "hybrid", "immersive", "impactful", "incremental", "intangible", "interactive", "intermediate", "leading edge", "local", "logistical", "maximized", "methodical", "mission-critical", "mobile", "modular", "motivating", "national", "needs-based", "neutral", "next generation", "optimal", "optimizing", "radical", "real-time", "reciprocal", "regional", "resilient", "responsive", "scalable", "secondary", "stable", "static", "sustainable", "system-worthy", "systematic", "systemic", "tangible", "tertiary", "transitional", "uniform", "user-facing", "value-added", "well-modulated", "zero administration", "zero defect", "zero tolerance", "zero trust"];
var Y = ["Group", "Inc", "LLC", "and Sons"];
var j = ["{{person.last_name.generic}} - {{person.last_name.generic}}", "{{person.last_name.generic}} {{company.legal_entity_type}}", "{{person.last_name.generic}}, {{person.last_name.generic}} and {{person.last_name.generic}}"];
var q = ["ability", "access", "adapter", "algorithm", "alliance", "analyzer", "application", "approach", "architecture", "archive", "array", "artificial intelligence", "attitude", "benchmark", "budgetary management", "capability", "capacity", "challenge", "circuit", "collaboration", "complexity", "concept", "conglomeration", "contingency", "core", "customer loyalty", "data-warehouse", "database", "definition", "emulation", "encoding", "encryption", "firmware", "flexibility", "focus group", "forecast", "frame", "framework", "function", "functionalities", "generative AI", "hardware", "help-desk", "hierarchy", "hub", "implementation", "infrastructure", "initiative", "installation", "instruction set", "interface", "internet solution", "intranet", "knowledge base", "knowledge user", "leverage", "local area network", "matrices", "matrix", "methodology", "microservice", "middleware", "migration", "model", "moderator", "monitoring", "moratorium", "neural-net", "open architecture", "orchestration", "paradigm", "parallelism", "policy", "portal", "pricing structure", "process improvement", "product", "productivity", "project", "projection", "protocol", "service-desk", "software", "solution", "standardization", "strategy", "structure", "success", "support", "synergy", "system engine", "task-force", "throughput", "time-frame", "toolset", "utilisation", "website", "workforce"];
var rr = { adjective: K, buzz_adjective: O, buzz_noun: x, buzz_verb: z, descriptor: V, legal_entity_type: Y, name_pattern: j, noun: q };
var U = rr;
var Z = ["avatar", "category", "comment", "createdAt", "email", "group", "id", "name", "password", "phone", "status", "title", "token", "updatedAt"];
var or = { column: Z };
var _ = or;
var Q = { wide: ["April", "August", "December", "February", "January", "July", "June", "March", "May", "November", "October", "September"], abbr: ["Apr", "Aug", "Dec", "Feb", "Jan", "Jul", "Jun", "Mar", "May", "Nov", "Oct", "Sep"] };
var X = { wide: ["Friday", "Monday", "Saturday", "Sunday", "Thursday", "Tuesday", "Wednesday"], abbr: ["Fri", "Mon", "Sat", "Sun", "Thu", "Tue", "Wed"] };
var nr = { month: Q, weekday: X };
var $ = nr;
var ee = ["Auto Loan", "Checking", "Credit Card", "Home Loan", "Investment", "Money Market", "Personal Loan", "Savings"];
var ae = ["34##-######-####L", "37##-######-####L"];
var re = ["30[0-5]#-######-###L", "36##-######-###L", "54##-####-####-###L"];
var oe = ["6011-####-####-###L", "64[4-9]#-####-####-###L", "65##-####-####-###L"];
var ne = ["3528-####-####-###L", "3529-####-####-###L", "35[3-8]#-####-####-###L"];
var ie = ["2[221-720]-####-####-###L", "5[1-5]##-####-####-###L"];
var te = ["4###########L", "4###-####-####-###L"];
var ir = { american_express: ae, diners_club: re, discover: oe, jcb: ne, mastercard: ie, visa: te };
var le = ir;
var se = [{ name: "UAE Dirham", code: "AED", symbol: "", numericCode: "784" }, { name: "Afghani", code: "AFN", symbol: "\u060B", numericCode: "971" }, { name: "Lek", code: "ALL", symbol: "Lek", numericCode: "008" }, { name: "Armenian Dram", code: "AMD", symbol: "", numericCode: "051" }, { name: "Netherlands Antillian Guilder", code: "ANG", symbol: "\u0192", numericCode: "532" }, { name: "Kwanza", code: "AOA", symbol: "", numericCode: "973" }, { name: "Argentine Peso", code: "ARS", symbol: "$", numericCode: "032" }, { name: "Australian Dollar", code: "AUD", symbol: "$", numericCode: "036" }, { name: "Aruban Guilder", code: "AWG", symbol: "\u0192", numericCode: "533" }, { name: "Azerbaijanian Manat", code: "AZN", symbol: "\u043C\u0430\u043D", numericCode: "944" }, { name: "Convertible Marks", code: "BAM", symbol: "KM", numericCode: "977" }, { name: "Barbados Dollar", code: "BBD", symbol: "$", numericCode: "052" }, { name: "Taka", code: "BDT", symbol: "", numericCode: "050" }, { name: "Bulgarian Lev", code: "BGN", symbol: "\u043B\u0432", numericCode: "975" }, { name: "Bahraini Dinar", code: "BHD", symbol: "", numericCode: "048" }, { name: "Burundi Franc", code: "BIF", symbol: "", numericCode: "108" }, { name: "Bermudian Dollar (customarily known as Bermuda Dollar)", code: "BMD", symbol: "$", numericCode: "060" }, { name: "Brunei Dollar", code: "BND", symbol: "$", numericCode: "096" }, { name: "Boliviano boliviano", code: "BOB", symbol: "Bs", numericCode: "068" }, { name: "Brazilian Real", code: "BRL", symbol: "R$", numericCode: "986" }, { name: "Bahamian Dollar", code: "BSD", symbol: "$", numericCode: "044" }, { name: "Pula", code: "BWP", symbol: "P", numericCode: "072" }, { name: "Belarusian Ruble", code: "BYN", symbol: "Rbl", numericCode: "933" }, { name: "Belize Dollar", code: "BZD", symbol: "BZ$", numericCode: "084" }, { name: "Canadian Dollar", code: "CAD", symbol: "$", numericCode: "124" }, { name: "Congolese Franc", code: "CDF", symbol: "", numericCode: "976" }, { name: "Swiss Franc", code: "CHF", symbol: "CHF", numericCode: "756" }, { name: "Chilean Peso", code: "CLP", symbol: "$", numericCode: "152" }, { name: "Yuan Renminbi", code: "CNY", symbol: "\xA5", numericCode: "156" }, { name: "Colombian Peso", code: "COP", symbol: "$", numericCode: "170" }, { name: "Costa Rican Colon", code: "CRC", symbol: "\u20A1", numericCode: "188" }, { name: "Cuban Peso", code: "CUP", symbol: "\u20B1", numericCode: "192" }, { name: "Cape Verde Escudo", code: "CVE", symbol: "", numericCode: "132" }, { name: "Czech Koruna", code: "CZK", symbol: "K\u010D", numericCode: "203" }, { name: "Djibouti Franc", code: "DJF", symbol: "", numericCode: "262" }, { name: "Danish Krone", code: "DKK", symbol: "kr", numericCode: "208" }, { name: "Dominican Peso", code: "DOP", symbol: "RD$", numericCode: "214" }, { name: "Algerian Dinar", code: "DZD", symbol: "", numericCode: "012" }, { name: "Egyptian Pound", code: "EGP", symbol: "\xA3", numericCode: "818" }, { name: "Nakfa", code: "ERN", symbol: "", numericCode: "232" }, { name: "Ethiopian Birr", code: "ETB", symbol: "", numericCode: "230" }, { name: "Euro", code: "EUR", symbol: "\u20AC", numericCode: "978" }, { name: "Fiji Dollar", code: "FJD", symbol: "$", numericCode: "242" }, { name: "Falkland Islands Pound", code: "FKP", symbol: "\xA3", numericCode: "238" }, { name: "Pound Sterling", code: "GBP", symbol: "\xA3", numericCode: "826" }, { name: "Lari", code: "GEL", symbol: "", numericCode: "981" }, { name: "Cedi", code: "GHS", symbol: "", numericCode: "936" }, { name: "Gibraltar Pound", code: "GIP", symbol: "\xA3", numericCode: "292" }, { name: "Dalasi", code: "GMD", symbol: "", numericCode: "270" }, { name: "Guinea Franc", code: "GNF", symbol: "", numericCode: "324" }, { name: "Quetzal", code: "GTQ", symbol: "Q", numericCode: "320" }, { name: "Guyana Dollar", code: "GYD", symbol: "$", numericCode: "328" }, { name: "Hong Kong Dollar", code: "HKD", symbol: "$", numericCode: "344" }, { name: "Lempira", code: "HNL", symbol: "L", numericCode: "340" }, { name: "Gourde", code: "HTG", symbol: "", numericCode: "332" }, { name: "Forint", code: "HUF", symbol: "Ft", numericCode: "348" }, { name: "Rupiah", code: "IDR", symbol: "Rp", numericCode: "360" }, { name: "New Israeli Sheqel", code: "ILS", symbol: "\u20AA", numericCode: "376" }, { name: "Bhutanese Ngultrum", code: "BTN", symbol: "Nu", numericCode: "064" }, { name: "Indian Rupee", code: "INR", symbol: "\u20B9", numericCode: "356" }, { name: "Iraqi Dinar", code: "IQD", symbol: "", numericCode: "368" }, { name: "Iranian Rial", code: "IRR", symbol: "\uFDFC", numericCode: "364" }, { name: "Iceland Krona", code: "ISK", symbol: "kr", numericCode: "352" }, { name: "Jamaican Dollar", code: "JMD", symbol: "J$", numericCode: "388" }, { name: "Jordanian Dinar", code: "JOD", symbol: "", numericCode: "400" }, { name: "Yen", code: "JPY", symbol: "\xA5", numericCode: "392" }, { name: "Kenyan Shilling", code: "KES", symbol: "", numericCode: "404" }, { name: "Som", code: "KGS", symbol: "\u043B\u0432", numericCode: "417" }, { name: "Riel", code: "KHR", symbol: "\u17DB", numericCode: "116" }, { name: "Comoro Franc", code: "KMF", symbol: "", numericCode: "174" }, { name: "North Korean Won", code: "KPW", symbol: "\u20A9", numericCode: "408" }, { name: "Won", code: "KRW", symbol: "\u20A9", numericCode: "410" }, { name: "Kuwaiti Dinar", code: "KWD", symbol: "", numericCode: "414" }, { name: "Cayman Islands Dollar", code: "KYD", symbol: "$", numericCode: "136" }, { name: "Tenge", code: "KZT", symbol: "\u043B\u0432", numericCode: "398" }, { name: "Kip", code: "LAK", symbol: "\u20AD", numericCode: "418" }, { name: "Lebanese Pound", code: "LBP", symbol: "\xA3", numericCode: "422" }, { name: "Sri Lanka Rupee", code: "LKR", symbol: "\u20A8", numericCode: "144" }, { name: "Liberian Dollar", code: "LRD", symbol: "$", numericCode: "430" }, { name: "Libyan Dinar", code: "LYD", symbol: "", numericCode: "434" }, { name: "Moroccan Dirham", code: "MAD", symbol: "", numericCode: "504" }, { name: "Moldovan Leu", code: "MDL", symbol: "", numericCode: "498" }, { name: "Malagasy Ariary", code: "MGA", symbol: "", numericCode: "969" }, { name: "Denar", code: "MKD", symbol: "\u0434\u0435\u043D", numericCode: "807" }, { name: "Kyat", code: "MMK", symbol: "", numericCode: "104" }, { name: "Tugrik", code: "MNT", symbol: "\u20AE", numericCode: "496" }, { name: "Pataca", code: "MOP", symbol: "", numericCode: "446" }, { name: "Ouguiya", code: "MRU", symbol: "", numericCode: "929" }, { name: "Mauritius Rupee", code: "MUR", symbol: "\u20A8", numericCode: "480" }, { name: "Rufiyaa", code: "MVR", symbol: "", numericCode: "462" }, { name: "Kwacha", code: "MWK", symbol: "", numericCode: "454" }, { name: "Mexican Peso", code: "MXN", symbol: "$", numericCode: "484" }, { name: "Malaysian Ringgit", code: "MYR", symbol: "RM", numericCode: "458" }, { name: "Metical", code: "MZN", symbol: "MT", numericCode: "943" }, { name: "Naira", code: "NGN", symbol: "\u20A6", numericCode: "566" }, { name: "Cordoba Oro", code: "NIO", symbol: "C$", numericCode: "558" }, { name: "Norwegian Krone", code: "NOK", symbol: "kr", numericCode: "578" }, { name: "Nepalese Rupee", code: "NPR", symbol: "\u20A8", numericCode: "524" }, { name: "New Zealand Dollar", code: "NZD", symbol: "$", numericCode: "554" }, { name: "Rial Omani", code: "OMR", symbol: "\uFDFC", numericCode: "512" }, { name: "Balboa", code: "PAB", symbol: "B/.", numericCode: "590" }, { name: "Nuevo Sol", code: "PEN", symbol: "S/.", numericCode: "604" }, { name: "Kina", code: "PGK", symbol: "", numericCode: "598" }, { name: "Philippine Peso", code: "PHP", symbol: "Php", numericCode: "608" }, { name: "Pakistan Rupee", code: "PKR", symbol: "\u20A8", numericCode: "586" }, { name: "Zloty", code: "PLN", symbol: "z\u0142", numericCode: "985" }, { name: "Guarani", code: "PYG", symbol: "Gs", numericCode: "600" }, { name: "Qatari Rial", code: "QAR", symbol: "\uFDFC", numericCode: "634" }, { name: "New Leu", code: "RON", symbol: "lei", numericCode: "946" }, { name: "Serbian Dinar", code: "RSD", symbol: "\u0414\u0438\u043D.", numericCode: "941" }, { name: "Russian Ruble", code: "RUB", symbol: "\u0440\u0443\u0431", numericCode: "643" }, { name: "Rwanda Franc", code: "RWF", symbol: "", numericCode: "646" }, { name: "Saudi Riyal", code: "SAR", symbol: "\uFDFC", numericCode: "682" }, { name: "Solomon Islands Dollar", code: "SBD", symbol: "$", numericCode: "090" }, { name: "Seychelles Rupee", code: "SCR", symbol: "\u20A8", numericCode: "690" }, { name: "Sudanese Pound", code: "SDG", symbol: "", numericCode: "938" }, { name: "Swedish Krona", code: "SEK", symbol: "kr", numericCode: "752" }, { name: "Singapore Dollar", code: "SGD", symbol: "$", numericCode: "702" }, { name: "Saint Helena Pound", code: "SHP", symbol: "\xA3", numericCode: "654" }, { name: "Leone", code: "SLE", symbol: "", numericCode: "925" }, { name: "Somali Shilling", code: "SOS", symbol: "S", numericCode: "706" }, { name: "Surinam Dollar", code: "SRD", symbol: "$", numericCode: "968" }, { name: "South Sudanese pound", code: "SSP", symbol: "", numericCode: "728" }, { name: "Dobra", code: "STN", symbol: "Db", numericCode: "930" }, { name: "Syrian Pound", code: "SYP", symbol: "\xA3", numericCode: "760" }, { name: "Lilangeni", code: "SZL", symbol: "", numericCode: "748" }, { name: "Baht", code: "THB", symbol: "\u0E3F", numericCode: "764" }, { name: "Somoni", code: "TJS", symbol: "", numericCode: "972" }, { name: "Manat", code: "TMT", symbol: "", numericCode: "934" }, { name: "Tunisian Dinar", code: "TND", symbol: "", numericCode: "788" }, { name: "Pa'anga", code: "TOP", symbol: "", numericCode: "776" }, { name: "Turkish Lira", code: "TRY", symbol: "\u20BA", numericCode: "949" }, { name: "Trinidad and Tobago Dollar", code: "TTD", symbol: "TT$", numericCode: "780" }, { name: "New Taiwan Dollar", code: "TWD", symbol: "NT$", numericCode: "901" }, { name: "Tanzanian Shilling", code: "TZS", symbol: "", numericCode: "834" }, { name: "Hryvnia", code: "UAH", symbol: "\u20B4", numericCode: "980" }, { name: "Uganda Shilling", code: "UGX", symbol: "", numericCode: "800" }, { name: "US Dollar", code: "USD", symbol: "$", numericCode: "840" }, { name: "Peso Uruguayo", code: "UYU", symbol: "$U", numericCode: "858" }, { name: "Uzbekistan Sum", code: "UZS", symbol: "\u043B\u0432", numericCode: "860" }, { name: "Venezuelan bol\xEDvar", code: "VES", symbol: "Bs", numericCode: "928" }, { name: "Dong", code: "VND", symbol: "\u20AB", numericCode: "704" }, { name: "Vatu", code: "VUV", symbol: "", numericCode: "548" }, { name: "Tala", code: "WST", symbol: "", numericCode: "882" }, { name: "CFA Franc BEAC", code: "XAF", symbol: "", numericCode: "950" }, { name: "East Caribbean Dollar", code: "XCD", symbol: "$", numericCode: "951" }, { name: "CFA Franc BCEAO", code: "XOF", symbol: "", numericCode: "952" }, { name: "CFP Franc", code: "XPF", symbol: "", numericCode: "953" }, { name: "Yemeni Rial", code: "YER", symbol: "\uFDFC", numericCode: "886" }, { name: "Rand", code: "ZAR", symbol: "R", numericCode: "710" }, { name: "Lesotho Loti", code: "LSL", symbol: "", numericCode: "426" }, { name: "Namibia Dollar", code: "NAD", symbol: "N$", numericCode: "516" }, { name: "Zambian Kwacha", code: "ZMW", symbol: "K", numericCode: "967" }, { name: "Zimbabwe Dollar", code: "ZWL", symbol: "", numericCode: "932" }];
var de = ["A {{finance.transactionType}} for {{finance.currencyCode}} {{finance.amount}} was made at {{company.name}} via card ending ****{{string.numeric(4)}} on account ***{{string.numeric(4)}}.", "A {{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} occurred at {{company.name}} using a card ending in ****{{string.numeric(4)}} for account ***{{string.numeric(4)}}.", "Payment of {{finance.currencyCode}} {{finance.amount}} for {{finance.transactionType}} at {{company.name}}, processed with card ending ****{{string.numeric(4)}} linked to account ***{{string.numeric(4)}}.", "Transaction alert: {{finance.transactionType}} at {{company.name}} using card ending ****{{string.numeric(4)}} for an amount of {{finance.currencyCode}} {{finance.amount}} on account ***{{string.numeric(4)}}.", "You made a {{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} at {{company.name}} using card ending in ****{{string.numeric(4)}} from account ***{{string.numeric(4)}}.", "Your {{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} at {{company.name}} was successful. Charged via card ****{{string.numeric(4)}} to account ***{{string.numeric(4)}}.", "{{finance.transactionType}} at {{company.name}} with a card ending in ****{{string.numeric(4)}} for {{finance.currencyCode}} {{finance.amount}} from account ***{{string.numeric(4)}}.", "{{finance.transactionType}} confirmed at {{company.name}} for {{finance.currencyCode}} {{finance.amount}}, card ending in ****{{string.numeric(4)}} associated with account ***{{string.numeric(4)}}.", "{{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} at {{company.name}} charged to account ending in {{string.numeric(4)}} using card ending in ****{{string.numeric(4)}}.", "{{finance.transactionType}} processed at {{company.name}} for {{finance.currencyCode}} {{finance.amount}}, using card ending ****{{string.numeric(4)}}. Account: ***{{string.numeric(4)}}.", "{{finance.transactionType}} transaction at {{company.name}} using card ending with ****{{string.numeric(4)}} for {{finance.currencyCode}} {{finance.amount}} in account ***{{string.numeric(4)}}."];
var ue = ["deposit", "invoice", "payment", "withdrawal"];
var tr = { account_type: ee, credit_card: le, currency: se, transaction_description_pattern: de, transaction_type: ue };
var ce = tr;
var me = ["bitter", "creamy", "crispy", "crunchy", "delicious", "fluffy", "fresh", "golden", "juicy", "moist", "rich", "salty", "savory", "smoky", "sour", "spicy", "sweet", "tangy", "tender", "zesty"];
var he = ["A classic pie filled with delicious {{food.meat}} and {{food.adjective}} {{food.ingredient}}, baked in a {{food.adjective}} pastry crust and topped with a golden-brown lattice.", "A delightful tart combining {{food.adjective}} {{food.vegetable}} and sweet {{food.fruit}}, set in a buttery pastry shell and finished with a hint of {{food.spice}}.", "A heartwarming {{food.ethnic_category}} soup, featuring fresh {{food.ingredient}} and an aromatic blend of traditional spices.", "A robust {{food.adjective}} stew featuring {{food.ethnic_category}} flavors, loaded with {{food.adjective}} meat, {{food.adjective}} vegetables, and a {{food.adjective}}, {{food.adjective}} broth.", "A simple {{food.fruit}} pie. No fancy stuff. Just pie.", "A slow-roasted {{animal.bird}} with a {{food.adjective}}, {{food.adjective}} exterior. Stuffed with {{food.fruit}} and covered in {{food.fruit}} sauce. Sides with {{food.vegetable}} puree and wild {{food.vegetable}}.", "A special {{color.human}} {{food.ingredient}} from {{location.country}}. To support the strong flavor it is sided with a tablespoon of {{food.spice}}.", "A succulent {{food.meat}} steak, encased in a {{food.adjective}} {{food.spice}} crust, served with a side of {{food.spice}} mashed {{food.vegetable}}.", "An exquisite {{food.meat}} roast, infused with the essence of {{food.fruit}}, slow-roasted to bring out its natural flavors and served with a side of creamy {{food.vegetable}}", "Baked {{food.ingredient}}-stuffed {{food.meat}}, seasoned with {{food.spice}} and {{food.adjective}} herbs, accompanied by roasted {{food.vegetable}} medley.", "Crispy fried {{food.meat}} bites, seasoned with {{food.spice}} and served with a tangy {{food.fruit}} dipping sauce.", "Fresh mixed greens tossed with {{food.spice}}-rubbed {{food.meat}}, {{food.vegetable}}, and a light dressing.", "Fresh {{food.ingredient}} with a pinch of {{food.spice}}, topped by a caramelized {{food.fruit}} with whipped cream", "Grilled {{food.meat}} kebabs, marinated in {{food.ethnic_category}} spices and served with a fresh {{food.vegetable}} and {{food.fruit}} salad.", "Hearty {{food.ingredient}} and {{food.meat}} stew, slow-cooked with {{food.spice}} and {{food.vegetable}} for a comforting, flavorful meal.", "Juicy {{food.meat}}, grilled to your liking and drizzled with a bold {{food.spice}} sauce, served alongside roasted {{food.vegetable}}.", "Our {{food.adjective}} {{food.meat}}, slow-cooked to perfection, accompanied by steamed {{food.vegetable}} and a rich, savory gravy.", "Tender {{food.meat}} skewers, glazed with a sweet and tangy {{food.fruit}} sauce, served over a bed of fragrant jasmine rice.", "Tenderly braised {{food.meat}} in a rich {{food.spice}} and {{food.vegetable}} sauce, served with a side of creamy {{food.vegetable}}.", "Three {{food.ingredient}} with {{food.vegetable}}, {{food.vegetable}}, {{food.vegetable}}, {{food.vegetable}} and {{food.ingredient}}. With a side of baked {{food.fruit}}, and your choice of {{food.ingredient}} or {{food.ingredient}}.", '{{number.int({"min":1, "max":99})}}-day aged {{food.meat}} steak, with choice of {{number.int({"min":2, "max":4})}} sides.'];
var ye = ["California maki", "Peking duck", "Philadelphia maki", "arepas", "barbecue ribs", "bruschette with tomato", "bunny chow", "caesar salad", "caprese salad", "cauliflower penne", "cheeseburger", "chicken fajitas", "chicken milanese", "chicken parm", "chicken wings", "chilli con carne", "ebiten maki", "fettuccine alfredo", "fish and chips", "french fries with sausages", "french toast", "hummus", "katsu curry", "kebab", "lasagne", "linguine with clams", "massaman curry", "meatballs with sauce", "mushroom risotto", "pappardelle alla bolognese", "pasta and beans", "pasta carbonara", "pasta with tomato and basil", "pho", "pierogi", "pizza", "poke", "pork belly buns", "pork sausage roll", "poutine", "ricotta stuffed ravioli", "risotto with seafood", "salmon nigiri", "scotch eggs", "seafood paella", "som tam", "souvlaki", "stinky tofu", "sushi", "tacos", "teriyaki chicken donburi", "tiramis\xF9", "tuna sashimi", "vegetable soup"];
var pe = ["{{food.adjective}} {{food.ethnic_category}} stew", "{{food.adjective}} {{food.meat}} with {{food.vegetable}}", "{{food.ethnic_category}} {{food.ingredient}} soup", "{{food.fruit}} and {{food.fruit}} tart", "{{food.fruit}} pie", "{{food.fruit}}-glazed {{food.meat}} skewers", "{{food.fruit}}-infused {{food.meat}} roast", "{{food.ingredient}} and {{food.meat}} pie", "{{food.ingredient}}-infused {{food.meat}}", "{{food.meat}} steak", "{{food.meat}} with {{food.fruit}} sauce", "{{food.spice}}-crusted {{food.meat}}", "{{food.spice}}-rubbed {{food.meat}} salad", "{{food.vegetable}} salad", "{{person.first_name.generic}}'s special {{food.ingredient}}"];
var ge = ["Ainu", "Albanian", "American", "Andhra", "Anglo-Indian", "Arab", "Argentine", "Armenian", "Assyrian", "Awadhi", "Azerbaijani", "Balochi", "Bangladeshi", "Bashkir", "Belarusian", "Bengali", "Berber", "Brazilian", "British", "Buddhist", "Bulgarian", "Cajun", "Cantonese", "Caribbean", "Chechen", "Chinese", "Chinese Islamic", "Circassian", "Crimean Tatar", "Cypriot", "Czech", "Danish", "Egyptian", "English", "Eritrean", "Estonian", "Ethiopian", "Filipino", "French", "Georgian", "German", "Goan", "Goan Catholic", "Greek", "Gujarati", "Hyderabad", "Indian", "Indian Chinese", "Indian Singaporean", "Indonesian", "Inuit", "Irish", "Italian", "Italian-American", "Jamaican", "Japanese", "Jewish - Israeli", "Karnataka", "Kazakh", "Keralite", "Korean", "Kurdish", "Laotian", "Latvian", "Lebanese", "Lithuanian", "Louisiana Creole", "Maharashtrian", "Malay", "Malaysian Chinese", "Malaysian Indian", "Mangalorean", "Mediterranean", "Mennonite", "Mexican", "Mordovian", "Mughal", "Native American", "Nepalese", "New Mexican", "Odia", "Pakistani", "Parsi", "Pashtun", "Pennsylvania Dutch", "Peranakan", "Persian", "Peruvian", "Polish", "Portuguese", "Punjabi", "Qu\xE9b\xE9cois", "Rajasthani", "Romani", "Romanian", "Russian", "Sami", "Serbian", "Sindhi", "Slovak", "Slovenian", "Somali", "South Indian", "Soviet", "Spanish", "Sri Lankan", "Taiwanese", "Tamil", "Tatar", "Texan", "Thai", "Turkish", "Udupi", "Ukrainian", "Vietnamese", "Yamal", "Zambian", "Zanzibari"];
var be = ["apple", "apricot", "aubergine", "avocado", "banana", "berry", "blackberry", "blood orange", "blueberry", "bush tomato", "butternut pumpkin", "cantaloupe", "cavalo", "cherry", "corella pear", "cranberry", "cumquat", "currant", "custard apple", "custard apples daikon", "date", "dragonfruit", "dried apricot", "elderberry", "feijoa", "fig", "fingerlime", "goji berry", "grape", "grapefruit", "guava", "honeydew melon", "incaberry", "jarrahdale pumpkin", "juniper berry", "kiwi fruit", "kiwiberry", "lemon", "lime", "longan", "loquat", "lychee", "mandarin", "mango", "mangosteen", "melon", "mulberry", "nashi pear", "nectarine", "olive", "orange", "papaw", "papaya", "passionfruit", "peach", "pear", "pineapple", "plum", "pomegranate", "prune", "rockmelon", "snowpea", "sprout", "starfruit", "strawberry", "sultana", "tangelo", "tomato", "watermelon"];
var Ce = ["achacha", "adzuki beans", "agar", "agave syrup", "ajowan seed", "albacore tuna", "alfalfa", "allspice", "almond oil", "almonds", "amaranth", "amchur", "anchovies", "aniseed", "annatto seed", "apple cider vinegar", "apple juice", "apple juice concentrate", "apples", "apricots", "arborio rice", "arrowroot", "artichoke", "arugula", "asafoetida", "asian greens", "asian noodles", "asparagus", "aubergine", "avocado", "avocado oil", "avocado spread", "bacon", "baking powder", "baking soda", "balsamic vinegar", "bamboo shoots", "banana", "barberry", "barley", "barramundi", "basil basmati rice", "bay leaves", "bean shoots", "bean sprouts", "beans", "beef", "beef stock", "beetroot", "berries", "besan", "black eyed beans", "blackberries", "blood oranges", "blue cheese", "blue eye trevalla", "blue swimmer crab", "blueberries", "bocconcini", "bok choy", "bonito flakes", "bonza", "borlotti beans", "bran", "brazil nut", "bread", "brie", "broccoli", "broccolini", "brown flour", "brown mushrooms", "brown rice", "brown rice vinegar", "brussels sprouts", "buckwheat", "buckwheat flour", "buckwheat noodles", "bulghur", "bush tomato", "butter", "butter beans", "buttermilk", "butternut lettuce", "butternut pumpkin", "cabbage", "cacao", "cake", "calamari", "camellia tea oil", "camembert", "camomile", "candle nut", "cannellini beans", "canola oil", "cantaloupe", "capers", "capsicum", "caraway seed", "cardamom", "carob carrot", "carrot", "cashews", "cassia bark", "cauliflower", "cavalo", "cayenne", "celery", "celery seed", "cheddar", "cherries", "chestnut", "chia seeds", "chicken", "chicken stock", "chickory", "chickpea", "chilli pepper", "chinese cabbage", "chinese five spice", "chives", "choy sum", "cinnamon", "clams", "cloves", "cocoa powder", "coconut", "coconut oil", "coconut water", "coffee", "common cultivated mushrooms", "corella pear", "coriander leaves", "coriander seed", "corn oil", "corn syrup", "corn tortilla", "cornichons", "cornmeal", "cos lettuce", "cottage cheese", "cous cous", "crabs", "cranberry", "cream", "cream cheese", "cucumber", "cumin", "cumquat", "currants", "curry leaves", "curry powder", "custard apples", "dandelion", "dark chocolate", "dashi", "dates", "dill", "dragonfruit", "dried apricots", "dried chinese broccoli", "duck", "edam", "edamame", "eggplant", "eggs", "elderberry", "endive", "english spinach", "enoki mushrooms", "extra virgin olive oil", "farmed prawns", "feijoa", "fennel", "fennel seeds", "fenugreek", "feta", "figs", "file powder", "fingerlime", "fish sauce", "fish stock", "flat mushrooms", "flathead", "flaxseed", "flaxseed oil", "flounder", "flour", "freekeh", "french eschallots", "fresh chillies", "fromage blanc", "fruit", "galangal", "garam masala", "garlic", "goat cheese", "goat milk", "goji berry", "grape seed oil", "grapefruit", "grapes", "green beans", "green pepper", "green tea", "green tea noodles", "greenwheat freekeh", "gruyere", "guava", "gula melaka", "haloumi", "ham", "haricot beans", "harissa", "hazelnut", "hijiki", "hiramasa kingfish", "hokkien noodles", "honey", "honeydew melon", "horseradish", "hot smoked salmon", "hummus", "iceberg lettuce", "incaberries", "jarrahdale pumpkin", "jasmine rice", "jelly", "jerusalem artichoke", "jewfish", "jicama", "juniper berries", "kale", "kangaroo", "kecap manis", "kenchur", "kidney beans", "kidneys", "kiwi berries", "kiwi fruit", "kohlrabi", "kokam", "kombu", "koshihikari rice", "kudzu", "kumera", "lamb", "lavender flowers", "leeks", "lemon", "lemongrass", "lentils", "lettuce", "licorice", "lime leaves", "limes", "liver", "lobster", "longan", "loquats", "lotus root", "lychees", "macadamia nut", "macadamia oil", "mace", "mackerel", "mahi mahi", "mahlab", "malt vinegar", "mandarins", "mango", "mangosteens", "maple syrup", "margarine", "marigold", "marjoram", "mastic", "melon", "milk", "milk chocolate", "mint", "miso", "molasses", "monkfish", "morwong", "mountain bread", "mozzarella", "muesli", "mulberries", "mullet", "mung beans", "mussels", "mustard", "mustard seed", "nashi pear", "nasturtium", "nectarines", "nori", "nutmeg", "nutritional yeast", "nuts", "oat flour", "oatmeal", "oats", "octopus", "okra", "olive oil", "olives", "omega spread", "onion", "oranges", "oregano", "oyster mushrooms", "oyster sauce", "oysters", "pandanus leaves", "papaw", "papaya", "paprik", "parmesan cheese", "parrotfish", "parsley", "parsnip", "passionfruit", "pasta", "peaches", "peanuts", "pear", "pear juice", "pears", "peas", "pecan nut", "pecorino", "pepitas", "peppercorns", "peppermint", "peppers", "persimmon", "pine nut", "pineapple", "pinto beans", "pistachio nut", "plums", "polenta", "pomegranate", "poppy seed", "porcini mushrooms", "pork", "potato flour", "potatoes", "provolone", "prunes", "pumpkin", "pumpkin seed", "purple carrot", "purple rice", "quark", "quince", "quinoa", "radicchio", "radish", "raisin", "raspberry", "red cabbage", "red lentils", "red pepper", "red wine", "red wine vinegar", "redfish", "rhubarb", "rice flour", "rice noodles", "rice paper", "rice syrup", "ricemilk", "ricotta", "rockmelon", "rose water", "rosemary", "rye", "rye bread", "safflower oil", "saffron", "sage", "sake", "salmon", "sardines", "sausages", "scallops", "sea salt", "semolina", "sesame oil", "sesame seeds", "shark", "shiitake mushrooms", "silverbeet", "slivered almonds", "smoked trout", "snapper", "snowpea sprouts", "snowpeas", "soba", "sour dough bread", "soy", "soy beans", "soy flour", "soy milk", "soy sauce", "soymilk", "spearmint", "spelt", "spelt bread", "spinach", "spring onions", "sprouts", "squash", "squid", "star anise", "star fruit", "starfruit", "stevia", "strawberries", "sugar", "sultanas", "sun-dried tomatoes", "sunflower oil", "sunflower seeds", "sweet chilli sauce", "sweet potato", "swiss chard", "swordfish", "szechuan pepperberry", "tabasco", "tahini", "taleggio cheese", "tamari", "tamarillo", "tangelo", "tapioca", "tapioca flour", "tarragon", "tea", "tea oil", "tempeh", "thyme", "tinned", "tofu", "tom yum", "tomatoes", "trout", "tuna", "turkey", "turmeric", "turnips", "unbleached flour", "vanilla beans", "vegetable oil", "vegetable spaghetti", "vegetable stock", "vermicelli noodles", "vinegar", "wakame", "walnut", "warehou", "wasabi", "water", "watercress", "watermelon", "wattleseed", "wheat", "wheatgrass juice", "white bread", "white flour", "white rice", "white wine", "white wine vinegar", "whiting wild rice", "wholegrain bread", "wholemeal", "wholewheat flour", "william pear", "yeast", "yellow papaw", "yellowtail kingfish", "yoghurt", "yogurt", "zucchini"];
var Se = ["beef", "chicken", "crocodile", "duck", "emu", "goose", "kangaroo", "lamb", "ostrich", "pigeon", "pork", "quail", "rabbit", "salmon", "turkey", "venison"];
var ke = ["achiote seed", "ajwain seed", "ajwan seed", "allspice", "amchoor", "anise", "anise star", "aniseed", "annatto seed", "arrowroot", "asafoetida", "baharat", "balti masala", "balti stir fry mix", "basil", "bay leaves", "bbq", "caraway seed", "cardamom", "cassia", "cayenne pepper", "celery", "chamomile", "chervil", "chilli", "chilli pepper", "chillies", "china star", "chives", "cinnamon", "cloves", "colombo", "coriander", "cumin", "curly leaf parsley", "curry", "dhansak", "dill", "fennel seed", "fenugreek", "fines herbes", "five spice", "french lavender", "galangal", "garam masala", "garlic", "german chamomile", "ginger", "green cardamom", "herbes de provence", "jalfrezi", "jerk", "kaffir leaves", "korma", "lavender", "lemon grass", "lemon pepper", "lime leaves", "liquorice root", "mace", "mango", "marjoram", "methi", "mint", "mustard", "nutmeg", "onion seed", "orange zest", "oregano", "paprika", "parsley", "pepper", "peppercorns", "pimento", "piri piri", "poppy seed", "pot marjoram", "poudre de colombo", "ras-el-hanout", "rice paper", "rogan josh", "rose baie", "rosemary", "saffron", "sage", "sesame seed", "spearmint", "sumac", "sweet basil", "sweet laurel", "tagine", "tandoori masala", "tarragon", "thyme", "tikka masala", "turmeric", "vanilla", "zahtar"];
var fe = ["artichoke", "arugula", "asian greens", "asparagus", "bean shoots", "bean sprouts", "beans", "beetroot", "bok choy", "broccoli", "broccolini", "brussels sprouts", "butternut lettuce", "cabbage", "capers", "carob carrot", "carrot", "cauliflower", "celery", "chilli pepper", "chinese cabbage", "chives", "cornichons", "cos lettuce", "cucumber", "dried chinese broccoli", "eggplant", "endive", "english spinach", "french eschallots", "fresh chillies", "garlic", "green beans", "green pepper", "hijiki", "iceberg lettuce", "jerusalem artichoke", "jicama", "kale", "kohlrabi", "leeks", "lettuce", "okra", "onion", "parsnip", "peas", "peppers", "potatoes", "pumpkin", "purple carrot", "radicchio", "radish", "raspberry", "red cabbage", "red pepper", "rhubarb", "snowpea sprouts", "spinach", "squash", "sun dried tomatoes", "sweet potato", "swiss chard", "turnips", "zucchini"];
var lr = { adjective: me, description_pattern: he, dish: ye, dish_pattern: pe, ethnic_category: ge, fruit: be, ingredient: Ce, meat: Se, spice: ke, vegetable: fe };
var ve = lr;
var Ae = ["1080p", "auxiliary", "back-end", "bluetooth", "cross-platform", "digital", "haptic", "mobile", "multi-byte", "neural", "online", "open-source", "optical", "primary", "redundant", "solid state", "virtual", "wireless"];
var Be = ["backing up", "bypassing", "calculating", "compressing", "connecting", "copying", "generating", "hacking", "indexing", "navigating", "overriding", "parsing", "programming", "quantifying", "synthesizing", "transmitting"];
var Te = ["alarm", "application", "array", "bandwidth", "bus", "capacitor", "card", "circuit", "driver", "feed", "firewall", "hard drive", "interface", "matrix", "microchip", "monitor", "panel", "pixel", "port", "program", "protocol", "sensor", "system", "transmitter"];
var Me = ["I'll {{verb}} the {{adjective}} {{abbreviation}} {{noun}}, that should {{noun}} the {{abbreviation}} {{noun}}!", "If we {{verb}} the {{noun}}, we can get to the {{abbreviation}} {{noun}} through the {{adjective}} {{abbreviation}} {{noun}}!", "The {{abbreviation}} {{noun}} is down, {{verb}} the {{adjective}} {{noun}} so we can {{verb}} the {{abbreviation}} {{noun}}!", "Try to {{verb}} the {{abbreviation}} {{noun}}, maybe it will {{verb}} the {{adjective}} {{noun}}!", "Use the {{adjective}} {{abbreviation}} {{noun}}, then you can {{verb}} the {{adjective}} {{noun}}!", "We need to {{verb}} the {{adjective}} {{abbreviation}} {{noun}}!", "You can't {{verb}} the {{noun}} without {{ingverb}} the {{adjective}} {{abbreviation}} {{noun}}!", "{{ingverb}} the {{noun}} won't do anything, we need to {{verb}} the {{adjective}} {{abbreviation}} {{noun}}!"];
var we = ["back up", "bypass", "calculate", "compress", "connect", "copy", "generate", "hack", "index", "input", "navigate", "override", "parse", "program", "quantify", "reboot", "synthesize", "transmit"];
var sr = { adjective: Ae, ingverb: Be, noun: Te, phrase: Me, verb: we };
var Le = sr;
var De = ["com", "biz", "info", "name", "net", "org"];
var Re = ["example.org", "example.com", "example.net"];
var Pe = ["gmail.com", "yahoo.com", "hotmail.com"];
var dr = { domain_suffix: De, example_email: Re, free_email: Pe };
var He = dr;
var We = ["#####", "####", "###"];
var Ge = ["Abilene", "Akron", "Alafaya", "Alameda", "Albany", "Albuquerque", "Alexandria", "Alhambra", "Aliso Viejo", "Allen", "Allentown", "Aloha", "Alpharetta", "Altadena", "Altamonte Springs", "Altoona", "Amarillo", "Ames", "Anaheim", "Anchorage", "Anderson", "Ankeny", "Ann Arbor", "Annandale", "Antelope", "Antioch", "Apex", "Apopka", "Apple Valley", "Appleton", "Arcadia", "Arden-Arcade", "Arecibo", "Arlington", "Arlington Heights", "Arvada", "Ashburn", "Asheville", "Aspen Hill", "Atascocita", "Athens-Clarke County", "Atlanta", "Attleboro", "Auburn", "Augusta-Richmond County", "Aurora", "Austin", "Avondale", "Azusa", "Bakersfield", "Baldwin Park", "Baltimore", "Barnstable Town", "Bartlett", "Baton Rouge", "Battle Creek", "Bayamon", "Bayonne", "Baytown", "Beaumont", "Beavercreek", "Beaverton", "Bedford", "Bel Air South", "Bell Gardens", "Belleville", "Bellevue", "Bellflower", "Bellingham", "Bend", "Bentonville", "Berkeley", "Berwyn", "Bethesda", "Bethlehem", "Billings", "Biloxi", "Binghamton", "Birmingham", "Bismarck", "Blacksburg", "Blaine", "Bloomington", "Blue Springs", "Boca Raton", "Boise City", "Bolingbrook", "Bonita Springs", "Bossier City", "Boston", "Bothell", "Boulder", "Bountiful", "Bowie", "Bowling Green", "Boynton Beach", "Bozeman", "Bradenton", "Brandon", "Brentwood", "Bridgeport", "Bristol", "Brockton", "Broken Arrow", "Brookhaven", "Brookline", "Brooklyn Park", "Broomfield", "Brownsville", "Bryan", "Buckeye", "Buena Park", "Buffalo", "Buffalo Grove", "Burbank", "Burien", "Burke", "Burleson", "Burlington", "Burnsville", "Caguas", "Caldwell", "Camarillo", "Cambridge", "Camden", "Canton", "Cape Coral", "Carlsbad", "Carmel", "Carmichael", "Carolina", "Carrollton", "Carson", "Carson City", "Cary", "Casa Grande", "Casas Adobes", "Casper", "Castle Rock", "Castro Valley", "Catalina Foothills", "Cathedral City", "Catonsville", "Cedar Hill", "Cedar Park", "Cedar Rapids", "Centennial", "Centreville", "Ceres", "Cerritos", "Champaign", "Chandler", "Chapel Hill", "Charleston", "Charlotte", "Charlottesville", "Chattanooga", "Cheektowaga", "Chesapeake", "Chesterfield", "Cheyenne", "Chicago", "Chico", "Chicopee", "Chino", "Chino Hills", "Chula Vista", "Cicero", "Cincinnati", "Citrus Heights", "Clarksville", "Clearwater", "Cleveland", "Cleveland Heights", "Clifton", "Clovis", "Coachella", "Coconut Creek", "Coeur d'Alene", "College Station", "Collierville", "Colorado Springs", "Colton", "Columbia", "Columbus", "Commerce City", "Compton", "Concord", "Conroe", "Conway", "Coon Rapids", "Coral Gables", "Coral Springs", "Corona", "Corpus Christi", "Corvallis", "Costa Mesa", "Council Bluffs", "Country Club", "Covina", "Cranston", "Cupertino", "Cutler Bay", "Cuyahoga Falls", "Cypress", "Dale City", "Dallas", "Daly City", "Danbury", "Danville", "Davenport", "Davie", "Davis", "Dayton", "Daytona Beach", "DeKalb", "DeSoto", "Dearborn", "Dearborn Heights", "Decatur", "Deerfield Beach", "Delano", "Delray Beach", "Deltona", "Denton", "Denver", "Des Moines", "Des Plaines", "Detroit", "Diamond Bar", "Doral", "Dothan", "Downers Grove", "Downey", "Draper", "Dublin", "Dubuque", "Duluth", "Dundalk", "Dunwoody", "Durham", "Eagan", "East Hartford", "East Honolulu", "East Lansing", "East Los Angeles", "East Orange", "East Providence", "Eastvale", "Eau Claire", "Eden Prairie", "Edina", "Edinburg", "Edmond", "El Cajon", "El Centro", "El Dorado Hills", "El Monte", "El Paso", "Elgin", "Elizabeth", "Elk Grove", "Elkhart", "Ellicott City", "Elmhurst", "Elyria", "Encinitas", "Enid", "Enterprise", "Erie", "Escondido", "Euclid", "Eugene", "Euless", "Evanston", "Evansville", "Everett", "Fairfield", "Fall River", "Fargo", "Farmington", "Farmington Hills", "Fayetteville", "Federal Way", "Findlay", "Fishers", "Flagstaff", "Flint", "Florence-Graham", "Florin", "Florissant", "Flower Mound", "Folsom", "Fond du Lac", "Fontana", "Fort Collins", "Fort Lauderdale", "Fort Myers", "Fort Pierce", "Fort Smith", "Fort Wayne", "Fort Worth", "Fountain Valley", "Fountainebleau", "Framingham", "Franklin", "Frederick", "Freeport", "Fremont", "Fresno", "Frisco", "Fullerton", "Gainesville", "Gaithersburg", "Galveston", "Garden Grove", "Gardena", "Garland", "Gary", "Gastonia", "Georgetown", "Germantown", "Gilbert", "Gilroy", "Glen Burnie", "Glendale", "Glendora", "Glenview", "Goodyear", "Grand Forks", "Grand Island", "Grand Junction", "Grand Prairie", "Grand Rapids", "Grapevine", "Great Falls", "Greeley", "Green Bay", "Greensboro", "Greenville", "Greenwood", "Gresham", "Guaynabo", "Gulfport", "Hacienda Heights", "Hackensack", "Haltom City", "Hamilton", "Hammond", "Hampton", "Hanford", "Harlingen", "Harrisburg", "Harrisonburg", "Hartford", "Hattiesburg", "Haverhill", "Hawthorne", "Hayward", "Hemet", "Hempstead", "Henderson", "Hendersonville", "Hesperia", "Hialeah", "Hicksville", "High Point", "Highland", "Highlands Ranch", "Hillsboro", "Hilo", "Hoboken", "Hoffman Estates", "Hollywood", "Homestead", "Honolulu", "Hoover", "Houston", "Huntersville", "Huntington", "Huntington Beach", "Huntington Park", "Huntsville", "Hutchinson", "Idaho Falls", "Independence", "Indianapolis", "Indio", "Inglewood", "Iowa City", "Irondequoit", "Irvine", "Irving", "Jackson", "Jacksonville", "Janesville", "Jefferson City", "Jeffersonville", "Jersey City", "Johns Creek", "Johnson City", "Joliet", "Jonesboro", "Joplin", "Jupiter", "Jurupa Valley", "Kalamazoo", "Kannapolis", "Kansas City", "Kearny", "Keller", "Kendale Lakes", "Kendall", "Kenner", "Kennewick", "Kenosha", "Kent", "Kentwood", "Kettering", "Killeen", "Kingsport", "Kirkland", "Kissimmee", "Knoxville", "Kokomo", "La Crosse", "La Habra", "La Mesa", "La Mirada", "Lacey", "Lafayette", "Laguna Niguel", "Lake Charles", "Lake Elsinore", "Lake Forest", "Lake Havasu City", "Lake Ridge", "Lakeland", "Lakeville", "Lakewood", "Lancaster", "Lansing", "Laredo", "Largo", "Las Cruces", "Las Vegas", "Lauderhill", "Lawrence", "Lawton", "Layton", "League City", "Lee's Summit", "Leesburg", "Lehi", "Lehigh Acres", "Lenexa", "Levittown", "Lewisville", "Lexington-Fayette", "Lincoln", "Linden", "Little Rock", "Littleton", "Livermore", "Livonia", "Lodi", "Logan", "Lombard", "Lompoc", "Long Beach", "Longmont", "Longview", "Lorain", "Los Angeles", "Louisville/Jefferson County", "Loveland", "Lowell", "Lubbock", "Lynchburg", "Lynn", "Lynwood", "Macon-Bibb County", "Madera", "Madison", "Malden", "Manchester", "Manhattan", "Mansfield", "Manteca", "Maple Grove", "Margate", "Maricopa", "Marietta", "Marysville", "Mayaguez", "McAllen", "McKinney", "McLean", "Medford", "Melbourne", "Memphis", "Menifee", "Mentor", "Merced", "Meriden", "Meridian", "Mesa", "Mesquite", "Metairie", "Methuen Town", "Miami", "Miami Beach", "Miami Gardens", "Middletown", "Midland", "Midwest City", "Milford", "Millcreek", "Milpitas", "Milwaukee", "Minneapolis", "Minnetonka", "Minot", "Miramar", "Mishawaka", "Mission", "Mission Viejo", "Missoula", "Missouri City", "Mobile", "Modesto", "Moline", "Monroe", "Montebello", "Monterey Park", "Montgomery", "Moore", "Moreno Valley", "Morgan Hill", "Mount Pleasant", "Mount Prospect", "Mount Vernon", "Mountain View", "Muncie", "Murfreesboro", "Murray", "Murrieta", "Nampa", "Napa", "Naperville", "Nashua", "Nashville-Davidson", "National City", "New Bedford", "New Braunfels", "New Britain", "New Brunswick", "New Haven", "New Orleans", "New Rochelle", "New York", "Newark", "Newport Beach", "Newport News", "Newton", "Niagara Falls", "Noblesville", "Norfolk", "Normal", "Norman", "North Bethesda", "North Charleston", "North Highlands", "North Las Vegas", "North Lauderdale", "North Little Rock", "North Miami", "North Miami Beach", "North Port", "North Richland Hills", "Norwalk", "Novato", "Novi", "O'Fallon", "Oak Lawn", "Oak Park", "Oakland", "Oakland Park", "Ocala", "Oceanside", "Odessa", "Ogden", "Oklahoma City", "Olathe", "Olympia", "Omaha", "Ontario", "Orange", "Orem", "Orland Park", "Orlando", "Oro Valley", "Oshkosh", "Overland Park", "Owensboro", "Oxnard", "Palatine", "Palm Bay", "Palm Beach Gardens", "Palm Coast", "Palm Desert", "Palm Harbor", "Palm Springs", "Palmdale", "Palo Alto", "Paradise", "Paramount", "Parker", "Parma", "Pasadena", "Pasco", "Passaic", "Paterson", "Pawtucket", "Peabody", "Pearl City", "Pearland", "Pembroke Pines", "Pensacola", "Peoria", "Perris", "Perth Amboy", "Petaluma", "Pflugerville", "Pharr", "Philadelphia", "Phoenix", "Pico Rivera", "Pine Bluff", "Pine Hills", "Pinellas Park", "Pittsburg", "Pittsburgh", "Pittsfield", "Placentia", "Plainfield", "Plano", "Plantation", "Pleasanton", "Plymouth", "Pocatello", "Poinciana", "Pomona", "Pompano Beach", "Ponce", "Pontiac", "Port Arthur", "Port Charlotte", "Port Orange", "Port St. Lucie", "Portage", "Porterville", "Portland", "Portsmouth", "Potomac", "Poway", "Providence", "Provo", "Pueblo", "Quincy", "Racine", "Raleigh", "Rancho Cordova", "Rancho Cucamonga", "Rancho Palos Verdes", "Rancho Santa Margarita", "Rapid City", "Reading", "Redding", "Redlands", "Redmond", "Redondo Beach", "Redwood City", "Reno", "Renton", "Reston", "Revere", "Rialto", "Richardson", "Richland", "Richmond", "Rio Rancho", "Riverside", "Riverton", "Riverview", "Roanoke", "Rochester", "Rochester Hills", "Rock Hill", "Rockford", "Rocklin", "Rockville", "Rockwall", "Rocky Mount", "Rogers", "Rohnert Park", "Rosemead", "Roseville", "Roswell", "Round Rock", "Rowland Heights", "Rowlett", "Royal Oak", "Sacramento", "Saginaw", "Salem", "Salina", "Salinas", "Salt Lake City", "Sammamish", "San Angelo", "San Antonio", "San Bernardino", "San Bruno", "San Buenaventura (Ventura)", "San Clemente", "San Diego", "San Francisco", "San Jacinto", "San Jose", "San Juan", "San Leandro", "San Luis Obispo", "San Marcos", "San Mateo", "San Rafael", "San Ramon", "San Tan Valley", "Sandy", "Sandy Springs", "Sanford", "Santa Ana", "Santa Barbara", "Santa Clara", "Santa Clarita", "Santa Cruz", "Santa Fe", "Santa Maria", "Santa Monica", "Santa Rosa", "Santee", "Sarasota", "Savannah", "Sayreville", "Schaumburg", "Schenectady", "Scottsdale", "Scranton", "Seattle", "Severn", "Shawnee", "Sheboygan", "Shoreline", "Shreveport", "Sierra Vista", "Silver Spring", "Simi Valley", "Sioux City", "Sioux Falls", "Skokie", "Smyrna", "Somerville", "South Bend", "South Gate", "South Hill", "South Jordan", "South San Francisco", "South Valley", "South Whittier", "Southaven", "Southfield", "Sparks", "Spokane", "Spokane Valley", "Spring", "Spring Hill", "Spring Valley", "Springdale", "Springfield", "St. Charles", "St. Clair Shores", "St. Cloud", "St. George", "St. Joseph", "St. Louis", "St. Louis Park", "St. Paul", "St. Peters", "St. Petersburg", "Stamford", "State College", "Sterling Heights", "Stillwater", "Stockton", "Stratford", "Strongsville", "Suffolk", "Sugar Land", "Summerville", "Sunnyvale", "Sunrise", "Sunrise Manor", "Surprise", "Syracuse", "Tacoma", "Tallahassee", "Tamarac", "Tamiami", "Tampa", "Taunton", "Taylor", "Taylorsville", "Temecula", "Tempe", "Temple", "Terre Haute", "Texas City", "The Hammocks", "The Villages", "The Woodlands", "Thornton", "Thousand Oaks", "Tigard", "Tinley Park", "Titusville", "Toledo", "Toms River", "Tonawanda", "Topeka", "Torrance", "Town 'n' Country", "Towson", "Tracy", "Trenton", "Troy", "Trujillo Alto", "Tuckahoe", "Tucson", "Tulare", "Tulsa", "Turlock", "Tuscaloosa", "Tustin", "Twin Falls", "Tyler", "Union City", "University", "Upland", "Urbana", "Urbandale", "Utica", "Vacaville", "Valdosta", "Vallejo", "Vancouver", "Victoria", "Victorville", "Vineland", "Virginia Beach", "Visalia", "Vista", "Waco", "Waipahu", "Waldorf", "Walnut Creek", "Waltham", "Warner Robins", "Warren", "Warwick", "Washington", "Waterbury", "Waterloo", "Watsonville", "Waukegan", "Waukesha", "Wauwatosa", "Wellington", "Wesley Chapel", "West Allis", "West Babylon", "West Covina", "West Des Moines", "West Hartford", "West Haven", "West Jordan", "West Lafayette", "West New York", "West Palm Beach", "West Sacramento", "West Seneca", "West Valley City", "Westfield", "Westland", "Westminster", "Weston", "Weymouth Town", "Wheaton", "White Plains", "Whittier", "Wichita", "Wichita Falls", "Wilmington", "Wilson", "Winston-Salem", "Woodbury", "Woodland", "Worcester", "Wylie", "Wyoming", "Yakima", "Yonkers", "Yorba Linda", "York", "Youngstown", "Yuba City", "Yucaipa", "Yuma"];
var Fe = ["{{location.city_prefix}} {{person.first_name.generic}}{{location.city_suffix}}", "{{location.city_prefix}} {{person.first_name.generic}}", "{{person.first_name.generic}}{{location.city_suffix}}", "{{person.last_name.generic}}{{location.city_suffix}}", "{{location.city_name}}"];
var Ne = ["North", "East", "West", "South", "New", "Lake", "Port", "Fort"];
var Ee = ["town", "ton", "land", "ville", "berg", "burgh", "boro", "borough", "bury", "view", "port", "mouth", "stad", "stead", "furt", "chester", "cester", "fort", "field", "haven", "side", "shire", "worth"];
var Je = ["Africa", "Antarctica", "Asia", "Australia", "Europe", "North America", "South America"];
var Ie = ["Afghanistan", "Aland Islands", "Albania", "Algeria", "American Samoa", "Andorra", "Angola", "Anguilla", "Antarctica", "Antigua and Barbuda", "Argentina", "Armenia", "Aruba", "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium", "Belize", "Benin", "Bermuda", "Bhutan", "Bolivia", "Bonaire, Sint Eustatius and Saba", "Bosnia and Herzegovina", "Botswana", "Bouvet Island", "Brazil", "British Indian Ocean Territory (Chagos Archipelago)", "Brunei Darussalam", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", "Cameroon", "Canada", "Cape Verde", "Cayman Islands", "Central African Republic", "Chad", "Chile", "China", "Christmas Island", "Cocos (Keeling) Islands", "Colombia", "Comoros", "Congo", "Cook Islands", "Costa Rica", "Cote d'Ivoire", "Croatia", "Cuba", "Curacao", "Cyprus", "Czechia", "Democratic Republic of the Congo", "Denmark", "Djibouti", "Dominica", "Dominican Republic", "Ecuador", "Egypt", "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Eswatini", "Ethiopia", "Faroe Islands", "Falkland Islands (Malvinas)", "Fiji", "Finland", "France", "French Guiana", "French Polynesia", "French Southern Territories", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", "Gibraltar", "Greece", "Greenland", "Grenada", "Guadeloupe", "Guam", "Guatemala", "Guernsey", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", "Heard Island and McDonald Islands", "Holy See (Vatican City State)", "Honduras", "Hong Kong", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq", "Ireland", "Isle of Man", "Israel", "Italy", "Jamaica", "Japan", "Jersey", "Jordan", "Kazakhstan", "Kenya", "Kiribati", "Democratic People's Republic of Korea", "Republic of Korea", "Kuwait", "Kyrgyz Republic", "Lao People's Democratic Republic", "Latvia", "Lebanon", "Lesotho", "Liberia", "Libyan Arab Jamahiriya", "Liechtenstein", "Lithuania", "Luxembourg", "Macao", "Madagascar", "Malawi", "Malaysia", "Maldives", "Mali", "Malta", "Marshall Islands", "Martinique", "Mauritania", "Mauritius", "Mayotte", "Mexico", "Micronesia", "Moldova", "Monaco", "Mongolia", "Montenegro", "Montserrat", "Morocco", "Mozambique", "Myanmar", "Namibia", "Nauru", "Nepal", "Netherlands", "New Caledonia", "New Zealand", "Nicaragua", "Niger", "Nigeria", "Niue", "Norfolk Island", "North Macedonia", "Northern Mariana Islands", "Norway", "Oman", "Pakistan", "Palau", "Palestine", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Pitcairn Islands", "Poland", "Portugal", "Puerto Rico", "Qatar", "Reunion", "Romania", "Russian Federation", "Rwanda", "Saint Barthelemy", "Saint Helena", "Saint Kitts and Nevis", "Saint Lucia", "Saint Martin", "Saint Pierre and Miquelon", "Saint Vincent and the Grenadines", "Samoa", "San Marino", "Sao Tome and Principe", "Saudi Arabia", "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Sint Maarten", "Slovakia", "Slovenia", "Solomon Islands", "Somalia", "South Africa", "South Georgia and the South Sandwich Islands", "South Sudan", "Spain", "Sri Lanka", "Sudan", "Suriname", "Svalbard & Jan Mayen Islands", "Sweden", "Switzerland", "Syrian Arab Republic", "Taiwan", "Tajikistan", "Tanzania", "Thailand", "Timor-Leste", "Togo", "Tokelau", "Tonga", "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan", "Turks and Caicos Islands", "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States of America", "United States Minor Outlying Islands", "Uruguay", "Uzbekistan", "Vanuatu", "Venezuela", "Vietnam", "Virgin Islands, British", "Virgin Islands, U.S.", "Wallis and Futuna", "Western Sahara", "Yemen", "Zambia", "Zimbabwe"];
var Ke = ["Adams County", "Calhoun County", "Carroll County", "Clark County", "Clay County", "Crawford County", "Douglas County", "Fayette County", "Franklin County", "Grant County", "Greene County", "Hamilton County", "Hancock County", "Henry County", "Jackson County", "Jefferson County", "Johnson County", "Lake County", "Lawrence County", "Lee County", "Lincoln County", "Logan County", "Madison County", "Marion County", "Marshall County", "Monroe County", "Montgomery County", "Morgan County", "Perry County", "Pike County", "Polk County", "Scott County", "Union County", "Warren County", "Washington County", "Wayne County", "Avon", "Bedfordshire", "Berkshire", "Borders", "Buckinghamshire", "Cambridgeshire", "Central", "Cheshire", "Cleveland", "Clwyd", "Cornwall", "County Antrim", "County Armagh", "County Down", "County Fermanagh", "County Londonderry", "County Tyrone", "Cumbria", "Derbyshire", "Devon", "Dorset", "Dumfries and Galloway", "Durham", "Dyfed", "East Sussex", "Essex", "Fife", "Gloucestershire", "Grampian", "Greater Manchester", "Gwent", "Gwynedd County", "Hampshire", "Herefordshire", "Hertfordshire", "Highlands and Islands", "Humberside", "Isle of Wight", "Kent", "Lancashire", "Leicestershire", "Lincolnshire", "Lothian", "Merseyside", "Mid Glamorgan", "Norfolk", "North Yorkshire", "Northamptonshire", "Northumberland", "Nottinghamshire", "Oxfordshire", "Powys", "Rutland", "Shropshire", "Somerset", "South Glamorgan", "South Yorkshire", "Staffordshire", "Strathclyde", "Suffolk", "Surrey", "Tayside", "Tyne and Wear", "Warwickshire", "West Glamorgan", "West Midlands", "West Sussex", "West Yorkshire", "Wiltshire", "Worcestershire"];
var Oe = { cardinal: ["North", "East", "South", "West"], cardinal_abbr: ["N", "E", "S", "W"], ordinal: ["Northeast", "Northwest", "Southeast", "Southwest"], ordinal_abbr: ["NE", "NW", "SE", "SW"] };
var xe = [{ name: "Afrikaans", alpha2: "af", alpha3: "afr" }, { name: "Azerbaijani", alpha2: "az", alpha3: "aze" }, { name: "Maldivian", alpha2: "dv", alpha3: "div" }, { name: "Farsi/Persian", alpha2: "fa", alpha3: "fas" }, { name: "Latvian", alpha2: "lv", alpha3: "lav" }, { name: "Indonesian", alpha2: "id", alpha3: "ind" }, { name: "Nepali", alpha2: "ne", alpha3: "nep" }, { name: "Thai", alpha2: "th", alpha3: "tha" }, { name: "Uzbek", alpha2: "uz", alpha3: "uzb" }, { name: "Yoruba", alpha2: "yo", alpha3: "yor" }, { name: "Pashto", alpha2: "ps", alpha3: "pus" }, { name: "English", alpha2: "en", alpha3: "eng" }, { name: "Urdu", alpha2: "ur", alpha3: "urd" }, { name: "German", alpha2: "de", alpha3: "deu" }, { name: "French", alpha2: "fr", alpha3: "fra" }, { name: "Spanish", alpha2: "es", alpha3: "spa" }, { name: "Italian", alpha2: "it", alpha3: "ita" }, { name: "Dutch", alpha2: "nl", alpha3: "nld" }, { name: "Russian", alpha2: "ru", alpha3: "rus" }, { name: "Portuguese", alpha2: "pt", alpha3: "por" }, { name: "Polish", alpha2: "pl", alpha3: "pol" }, { name: "Arabic", alpha2: "ar", alpha3: "ara" }, { name: "Japanese", alpha2: "ja", alpha3: "jpn" }, { name: "Chinese", alpha2: "zh", alpha3: "zho" }, { name: "Hindi", alpha2: "hi", alpha3: "hin" }, { name: "Bengali", alpha2: "bn", alpha3: "ben" }, { name: "Gujarati", alpha2: "gu", alpha3: "guj" }, { name: "Tamil", alpha2: "ta", alpha3: "tam" }, { name: "Telugu", alpha2: "te", alpha3: "tel" }, { name: "Punjabi", alpha2: "pa", alpha3: "pan" }, { name: "Vietnamese", alpha2: "vi", alpha3: "vie" }, { name: "Korean", alpha2: "ko", alpha3: "kor" }, { name: "Turkish", alpha2: "tr", alpha3: "tur" }, { name: "Swedish", alpha2: "sv", alpha3: "swe" }, { name: "Greek", alpha2: "el", alpha3: "ell" }, { name: "Czech", alpha2: "cs", alpha3: "ces" }, { name: "Hungarian", alpha2: "hu", alpha3: "hun" }, { name: "Romanian", alpha2: "ro", alpha3: "ron" }, { name: "Ukrainian", alpha2: "uk", alpha3: "ukr" }, { name: "Norwegian", alpha2: "no", alpha3: "nor" }, { name: "Serbian", alpha2: "sr", alpha3: "srp" }, { name: "Croatian", alpha2: "hr", alpha3: "hrv" }, { name: "Slovak", alpha2: "sk", alpha3: "slk" }, { name: "Slovenian", alpha2: "sl", alpha3: "slv" }, { name: "Icelandic", alpha2: "is", alpha3: "isl" }, { name: "Finnish", alpha2: "fi", alpha3: "fin" }, { name: "Danish", alpha2: "da", alpha3: "dan" }, { name: "Swahili", alpha2: "sw", alpha3: "swa" }, { name: "Bashkir", alpha2: "ba", alpha3: "bak" }, { name: "Basque", alpha2: "eu", alpha3: "eus" }, { name: "Catalan", alpha2: "ca", alpha3: "cat" }, { name: "Galician", alpha2: "gl", alpha3: "glg" }, { name: "Esperanto", alpha2: "eo", alpha3: "epo" }, { name: "Fijian", alpha2: "fj", alpha3: "fij" }, { name: "Malagasy", alpha2: "mg", alpha3: "mlg" }, { name: "Maltese", alpha2: "mt", alpha3: "mlt" }, { name: "Albanian", alpha2: "sq", alpha3: "sqi" }, { name: "Armenian", alpha2: "hy", alpha3: "hye" }, { name: "Georgian", alpha2: "ka", alpha3: "kat" }, { name: "Macedonian", alpha2: "mk", alpha3: "mkd" }, { name: "Kazakh", alpha2: "kk", alpha3: "kaz" }, { name: "Haitian Creole", alpha2: "ht", alpha3: "hat" }, { name: "Mongolian", alpha2: "mn", alpha3: "mon" }, { name: "Kyrgyz", alpha2: "ky", alpha3: "kir" }, { name: "Finnish", alpha2: "fi", alpha3: "fin" }, { name: "Tagalog", alpha2: "tl", alpha3: "tgl" }, { name: "Malay", alpha2: "ms", alpha3: "msa" }, { name: "Tajik", alpha2: "tg", alpha3: "tgk" }, { name: "Swati", alpha2: "ss", alpha3: "ssw" }, { name: "Tatar", alpha2: "tt", alpha3: "tat" }, { name: "Zulu", alpha2: "zu", alpha3: "zul" }];
var ze = ["#####", "#####-####"];
var Ve = ["Apt. ###", "Suite ###"];
var Ye = ["Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut", "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey", "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", "South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "West Virginia", "Wisconsin", "Wyoming"];
var je = ["AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY"];
var qe = { normal: "{{location.buildingNumber}} {{location.street}}", full: "{{location.buildingNumber}} {{location.street}} {{location.secondaryAddress}}" };
var Ue = ["10th Street", "11th Street", "12th Street", "13th Street", "14th Street", "15th Street", "16th Street", "1st Avenue", "1st Street", "2nd Avenue", "2nd Street", "3rd Avenue", "3rd Street", "4th Avenue", "4th Street", "5th Avenue", "5th Street", "6th Avenue", "6th Street", "7th Avenue", "7th Street", "8th Avenue", "8th Street", "9th Street", "A Street", "Abbey Road", "Adams Avenue", "Adams Street", "Airport Road", "Albany Road", "Albert Road", "Albion Street", "Alexandra Road", "Alfred Street", "Alma Street", "Ash Close", "Ash Grove", "Ash Road", "Ash Street", "Aspen Close", "Atlantic Avenue", "Avenue Road", "Back Lane", "Baker Street", "Balmoral Road", "Barn Close", "Barton Road", "Bath Road", "Bath Street", "Bay Street", "Beach Road", "Bedford Road", "Beech Close", "Beech Drive", "Beech Grove", "Beech Road", "Beechwood Avenue", "Bell Lane", "Belmont Road", "Birch Avenue", "Birch Close", "Birch Grove", "Birch Road", "Blind Lane", "Bluebell Close", "Boundary Road", "Bramble Close", "Bramley Close", "Bridge Road", "Bridge Street", "Broad Lane", "Broad Street", "Broadway", "Broadway Avenue", "Broadway Street", "Brook Lane", "Brook Road", "Brook Street", "Brookside", "Buckingham Road", "Cambridge Street", "Canal Street", "Castle Close", "Castle Lane", "Castle Road", "Castle Street", "Cavendish Road", "Cedar Avenue", "Cedar Close", "Cedar Grove", "Cedar Road", "Cedar Street", "Cemetery Road", "Center Avenue", "Center Road", "Center Street", "Central Avenue", "Central Street", "Chapel Close", "Chapel Hill", "Chapel Road", "Chapel Street", "Charles Street", "Cherry Close", "Cherry Street", "Cherry Tree Close", "Chester Road", "Chestnut Close", "Chestnut Drive", "Chestnut Grove", "Chestnut Street", "Church Avenue", "Church Close", "Church Hill", "Church Lane", "Church Path", "Church Road", "Church Street", "Church View", "Church Walk", "Claremont Road", "Clarence Road", "Clarence Street", "Clarendon Road", "Clark Street", "Clay Lane", "Cleveland Street", "Cliff Road", "Clifton Road", "Clinton Street", "College Avenue", "College Street", "Columbia Avenue", "Commerce Street", "Commercial Road", "Commercial Street", "Common Lane", "Coronation Avenue", "Coronation Road", "County Line Road", "County Road", "Court Street", "Cow Lane", "Crescent Road", "Cromwell Road", "Cross Lane", "Cross Street", "Crown Street", "Cumberland Street", "Dale Street", "Dark Lane", "Davis Street", "Depot Street", "Derby Road", "Derwent Close", "Devonshire Road", "Division Street", "Douglas Road", "Duke Street", "E 10th Street", "E 11th Street", "E 12th Street", "E 14th Street", "E 1st Street", "E 2nd Street", "E 3rd Street", "E 4th Avenue", "E 4th Street", "E 5th Street", "E 6th Avenue", "E 6th Street", "E 7th Street", "E 8th Street", "E 9th Street", "E Bridge Street", "E Broad Street", "E Broadway", "E Broadway Street", "E Cedar Street", "E Center Street", "E Central Avenue", "E Church Street", "E Elm Street", "E Franklin Street", "E Front Street", "E Grand Avenue", "E High Street", "E Jackson Street", "E Jefferson Street", "E Main", "E Main Street", "E Maple Street", "E Market Street", "E North Street", "E Oak Street", "E Park Avenue", "E Pine Street", "E River Road", "E South Street", "E State Street", "E Union Street", "E Walnut Street", "E Washington Avenue", "E Washington Street", "E Water Street", "East Avenue", "East Road", "East Street", "Edward Street", "Elm Close", "Elm Grove", "Elm Road", "Elm Street", "Euclid Avenue", "Fairfield Road", "Farm Close", "Ferry Road", "Field Close", "Field Lane", "First Avenue", "First Street", "Fore Street", "Forest Avenue", "Forest Road", "Fourth Avenue", "Franklin Avenue", "Franklin Road", "Franklin Street", "Front Street", "Frontage Road", "Garden Close", "Garden Street", "George Street", "Gladstone Road", "Glebe Close", "Gloucester Road", "Gordon Road", "Gordon Street", "Grand Avenue", "Grange Avenue", "Grange Close", "Grange Road", "Grant Street", "Green Close", "Green Lane", "Green Street", "Greenville Road", "Greenway", "Greenwood Road", "Grove Lane", "Grove Road", "Grove Street", "Hall Lane", "Hall Street", "Harrison Avenue", "Harrison Street", "Hawthorn Avenue", "Hawthorn Close", "Hazel Close", "Hazel Grove", "Heath Road", "Heather Close", "Henry Street", "Heron Close", "Hickory Street", "High Road", "High Street", "Highfield Avenue", "Highfield Close", "Highfield Road", "Highland Avenue", "Hill Road", "Hill Street", "Hillside", "Hillside Avenue", "Hillside Close", "Hillside Road", "Holly Close", "Honeysuckle Close", "Howard Road", "Howard Street", "Jackson Avenue", "Jackson Street", "James Street", "Jefferson Avenue", "Jefferson Street", "Johnson Street", "Jubilee Close", "Juniper Close", "Kent Road", "Kestrel Close", "King Street", "King's Road", "Kingfisher Close", "Kings Highway", "Kingsway", "Laburnum Grove", "Lafayette Street", "Lake Avenue", "Lake Drive", "Lake Road", "Lake Street", "Lancaster Road", "Lansdowne Road", "Larch Close", "Laurel Close", "Lawrence Street", "Lee Street", "Liberty Street", "Lime Grove", "Lincoln Avenue", "Lincoln Highway", "Lincoln Road", "Lincoln Street", "Locust Street", "Lodge Close", "Lodge Lane", "London Road", "Long Lane", "Low Road", "Madison Avenue", "Madison Street", "Main", "Main Avenue", "Main Road", "Main Street", "Main Street E", "Main Street N", "Main Street S", "Main Street W", "Manchester Road", "Manor Close", "Manor Drive", "Manor Gardens", "Manor Road", "Manor Way", "Maple Avenue", "Maple Close", "Maple Drive", "Maple Road", "Maple Street", "Market Place", "Market Square", "Market Street", "Marlborough Road", "Marsh Lane", "Martin Luther King Boulevard", "Martin Luther King Drive", "Martin Luther King Jr Boulevard", "Mary Street", "Mayfield Road", "Meadow Close", "Meadow Drive", "Meadow Lane", "Meadow View", "Meadow Way", "Memorial Drive", "Middle Street", "Mill Close", "Mill Lane", "Mill Road", "Mill Street", "Milton Road", "Milton Street", "Monroe Street", "Moor Lane", "Moss Lane", "Mount Pleasant", "Mount Street", "Mulberry Street", "N 1st Street", "N 2nd Street", "N 3rd Street", "N 4th Street", "N 5th Street", "N 6th Street", "N 7th Street", "N 8th Street", "N 9th Street", "N Bridge Street", "N Broad Street", "N Broadway", "N Broadway Street", "N Cedar Street", "N Center Street", "N Central Avenue", "N Chestnut Street", "N Church Street", "N College Street", "N Court Street", "N Division Street", "N East Street", "N Elm Street", "N Franklin Street", "N Front Street", "N Harrison Street", "N High Street", "N Jackson Street", "N Jefferson Street", "N Lincoln Street", "N Locust Street", "N Main", "N Main Avenue", "N Main Street", "N Maple Street", "N Market Street", "N Monroe Street", "N Oak Street", "N Park Street", "N Pearl Street", "N Pine Street", "N Poplar Street", "N Railroad Street", "N State Street", "N Union Street", "N Walnut Street", "N Washington Avenue", "N Washington Street", "N Water Street", "Nelson Road", "Nelson Street", "New Lane", "New Road", "New Street", "Newton Road", "Nightingale Close", "Norfolk Road", "North Avenue", "North Lane", "North Road", "North Street", "Northfield Road", "Oak Avenue", "Oak Drive", "Oak Lane", "Oak Road", "Oak Street", "Oakfield Road", "Oaklands", "Old Lane", "Old Military Road", "Old Road", "Old State Road", "Orchard Drive", "Orchard Lane", "Orchard Road", "Orchard Street", "Oxford Road", "Oxford Street", "Park Avenue", "Park Crescent", "Park Drive", "Park Lane", "Park Place", "Park Road", "Park Street", "Park View", "Parkside", "Pearl Street", "Pennsylvania Avenue", "Pine Close", "Pine Grove", "Pine Street", "Pinfold Lane", "Pleasant Street", "Poplar Avenue", "Poplar Close", "Poplar Road", "Poplar Street", "Post Road", "Pound Lane", "Princes Street", "Princess Street", "Priory Close", "Priory Road", "Prospect Avenue", "Prospect Place", "Prospect Road", "Prospect Street", "Quarry Lane", "Quarry Road", "Queen's Road", "Railroad Avenue", "Railroad Street", "Railway Street", "Rectory Close", "Rectory Lane", "Richmond Close", "Richmond Road", "Ridge Road", "River Road", "River Street", "Riverside", "Riverside Avenue", "Riverside Drive", "Roman Road", "Roman Way", "Rowan Close", "Russell Street", "S 10th Street", "S 14th Street", "S 1st Avenue", "S 1st Street", "S 2nd Street", "S 3rd Street", "S 4th Street", "S 5th Street", "S 6th Street", "S 7th Street", "S 8th Street", "S 9th Street", "S Bridge Street", "S Broad Street", "S Broadway", "S Broadway Street", "S Center Street", "S Central Avenue", "S Chestnut Street", "S Church Street", "S College Street", "S Division Street", "S East Street", "S Elm Street", "S Franklin Street", "S Front Street", "S Grand Avenue", "S High Street", "S Jackson Street", "S Jefferson Street", "S Lincoln Street", "S Main", "S Main Avenue", "S Main Street", "S Maple Street", "S Market Street", "S Mill Street", "S Monroe Street", "S Oak Street", "S Park Street", "S Pine Street", "S Railroad Street", "S State Street", "S Union Street", "S Walnut Street", "S Washington Avenue", "S Washington Street", "S Water Street", "S West Street", "Salisbury Road", "Sandringham Road", "Sandy Lane", "School Close", "School Lane", "School Road", "School Street", "Second Avenue", "Silver Street", "Skyline Drive", "Smith Street", "Somerset Road", "South Avenue", "South Drive", "South Road", "South Street", "South View", "Spring Gardens", "Spring Street", "Springfield Close", "Springfield Road", "Spruce Street", "St Andrew's Road", "St Andrews Close", "St George's Road", "St John's Road", "St Mary's Close", "St Mary's Road", "Stanley Road", "Stanley Street", "State Avenue", "State Line Road", "State Road", "State Street", "Station Road", "Station Street", "Stoney Lane", "Sycamore Avenue", "Sycamore Close", "Sycamore Drive", "Sycamore Street", "Talbot Road", "Tennyson Road", "The Avenue", "The Beeches", "The Causeway", "The Chase", "The Coppice", "The Copse", "The Crescent", "The Croft", "The Dell", "The Drive", "The Fairway", "The Glebe", "The Grange", "The Green", "The Grove", "The Hawthorns", "The Lane", "The Laurels", "The Limes", "The Maltings", "The Meadows", "The Mews", "The Mount", "The Oaks", "The Orchard", "The Oval", "The Paddock", "The Paddocks", "The Poplars", "The Ridgeway", "The Ridings", "The Rise", "The Sidings", "The Spinney", "The Square", "The Willows", "The Woodlands", "Third Avenue", "Third Street", "Tower Road", "Trinity Road", "Tudor Close", "Union Avenue", "Union Street", "University Avenue", "University Drive", "Valley Road", "Veterans Memorial Drive", "Veterans Memorial Highway", "Vicarage Close", "Vicarage Lane", "Vicarage Road", "Victoria Place", "Victoria Road", "Victoria Street", "Vine Street", "W 10th Street", "W 11th Street", "W 12th Street", "W 14th Street", "W 1st Street", "W 2nd Street", "W 3rd Street", "W 4th Avenue", "W 4th Street", "W 5th Street", "W 6th Avenue", "W 6th Street", "W 7th Street", "W 8th Street", "W 9th Street", "W Bridge Street", "W Broad Street", "W Broadway", "W Broadway Avenue", "W Broadway Street", "W Center Street", "W Central Avenue", "W Chestnut Street", "W Church Street", "W Division Street", "W Elm Street", "W Franklin Street", "W Front Street", "W Grand Avenue", "W High Street", "W Jackson Street", "W Jefferson Street", "W Lake Street", "W Main", "W Main Street", "W Maple Street", "W Market Street", "W Monroe Street", "W North Street", "W Oak Street", "W Park Street", "W Pine Street", "W River Road", "W South Street", "W State Street", "W Union Street", "W Walnut Street", "W Washington Avenue", "W Washington Street", "Walnut Close", "Walnut Street", "Warren Close", "Warren Road", "Washington Avenue", "Washington Boulevard", "Washington Road", "Washington Street", "Water Lane", "Water Street", "Waterloo Road", "Waterside", "Watery Lane", "Waverley Road", "Well Lane", "Wellington Road", "Wellington Street", "West Avenue", "West End", "West Lane", "West Road", "West Street", "West View", "Western Avenue", "Western Road", "Westfield Road", "Westgate", "William Street", "Willow Close", "Willow Drive", "Willow Grove", "Willow Road", "Willow Street", "Windermere Road", "Windmill Close", "Windmill Lane", "Windsor Avenue", "Windsor Close", "Windsor Drive", "Wood Lane", "Wood Street", "Woodland Close", "Woodland Road", "Woodlands", "Woodlands Avenue", "Woodlands Close", "Woodlands Road", "Woodside", "Woodside Road", "Wren Close", "Yew Tree Close", "York Road", "York Street"];
var Ze = ["{{person.first_name.generic}} {{location.street_suffix}}", "{{person.last_name.generic}} {{location.street_suffix}}", "{{location.street_name}}"];
var _e = ["Alley", "Avenue", "Branch", "Bridge", "Brook", "Brooks", "Burg", "Burgs", "Bypass", "Camp", "Canyon", "Cape", "Causeway", "Center", "Centers", "Circle", "Circles", "Cliff", "Cliffs", "Club", "Common", "Corner", "Corners", "Course", "Court", "Courts", "Cove", "Coves", "Creek", "Crescent", "Crest", "Crossing", "Crossroad", "Curve", "Dale", "Dam", "Divide", "Drive", "Drives", "Estate", "Estates", "Expressway", "Extension", "Extensions", "Fall", "Falls", "Ferry", "Field", "Fields", "Flat", "Flats", "Ford", "Fords", "Forest", "Forge", "Forges", "Fork", "Forks", "Fort", "Freeway", "Garden", "Gardens", "Gateway", "Glen", "Glens", "Green", "Greens", "Grove", "Groves", "Harbor", "Harbors", "Haven", "Heights", "Highway", "Hill", "Hills", "Hollow", "Inlet", "Island", "Islands", "Isle", "Junction", "Junctions", "Key", "Keys", "Knoll", "Knolls", "Lake", "Lakes", "Land", "Landing", "Lane", "Light", "Lights", "Loaf", "Lock", "Locks", "Lodge", "Loop", "Mall", "Manor", "Manors", "Meadow", "Meadows", "Mews", "Mill", "Mills", "Mission", "Motorway", "Mount", "Mountain", "Mountains", "Neck", "Orchard", "Oval", "Overpass", "Park", "Parks", "Parkway", "Parkways", "Pass", "Passage", "Path", "Pike", "Pine", "Pines", "Place", "Plain", "Plains", "Plaza", "Point", "Points", "Port", "Ports", "Prairie", "Radial", "Ramp", "Ranch", "Rapid", "Rapids", "Rest", "Ridge", "Ridges", "River", "Road", "Roads", "Route", "Row", "Rue", "Run", "Shoal", "Shoals", "Shore", "Shores", "Skyway", "Spring", "Springs", "Spur", "Spurs", "Square", "Squares", "Station", "Stravenue", "Stream", "Street", "Streets", "Summit", "Terrace", "Throughway", "Trace", "Track", "Trafficway", "Trail", "Tunnel", "Turnpike", "Underpass", "Union", "Unions", "Valley", "Valleys", "Via", "Viaduct", "View", "Views", "Village", "Villages", "Ville", "Vista", "Walk", "Walks", "Wall", "Way", "Ways", "Well", "Wells"];
var ur = { building_number: We, city_name: Ge, city_pattern: Fe, city_prefix: Ne, city_suffix: Ee, continent: Je, country: Ie, county: Ke, direction: Oe, language: xe, postcode: ze, secondary_address: Ve, state: Ye, state_abbr: je, street_address: qe, street_name: Ue, street_pattern: Ze, street_suffix: _e };
var Qe = ur;
var Xe = ["a", "ab", "abbas", "abduco", "abeo", "abscido", "absconditus", "absens", "absorbeo", "absque", "abstergo", "absum", "abundans", "abutor", "accedo", "accendo", "acceptus", "accommodo", "accusamus", "accusantium", "accusator", "acer", "acerbitas", "acervus", "acidus", "acies", "acquiro", "acsi", "ad", "adamo", "adaugeo", "addo", "adduco", "ademptio", "adeo", "adeptio", "adfectus", "adfero", "adficio", "adflicto", "adhaero", "adhuc", "adicio", "adimpleo", "adinventitias", "adipisci", "adipiscor", "adiuvo", "administratio", "admiratio", "admitto", "admoneo", "admoveo", "adnuo", "adopto", "adsidue", "adstringo", "adsuesco", "adsum", "adulatio", "adulescens", "aduro", "advenio", "adversus", "advoco", "aedificium", "aeger", "aegre", "aegrotatio", "aegrus", "aeneus", "aequitas", "aequus", "aer", "aestas", "aestivus", "aestus", "aetas", "aeternus", "ager", "aggero", "aggredior", "agnitio", "agnosco", "ago", "ait", "aiunt", "alias", "alienus", "alii", "alioqui", "aliqua", "aliquam", "aliquid", "alius", "allatus", "alo", "alter", "altus", "alveus", "amaritudo", "ambitus", "ambulo", "amet", "amicitia", "amiculum", "amissio", "amita", "amitto", "amo", "amor", "amoveo", "amplexus", "amplitudo", "amplus", "ancilla", "angelus", "angulus", "angustus", "animadverto", "animi", "animus", "annus", "anser", "ante", "antea", "antepono", "antiquus", "aperiam", "aperio", "aperte", "apostolus", "apparatus", "appello", "appono", "appositus", "approbo", "apto", "aptus", "apud", "aqua", "ara", "aranea", "arbitro", "arbor", "arbustum", "arca", "arceo", "arcesso", "architecto", "arcus", "argentum", "argumentum", "arguo", "arma", "armarium", "aro", "ars", "articulus", "artificiose", "arto", "arx", "ascisco", "ascit", "asper", "asperiores", "aspernatur", "aspicio", "asporto", "assentator", "assumenda", "astrum", "at", "atavus", "ater", "atque", "atqui", "atrocitas", "atrox", "attero", "attollo", "attonbitus", "auctor", "auctus", "audacia", "audax", "audentia", "audeo", "audio", "auditor", "aufero", "aureus", "aurum", "aut", "autem", "autus", "auxilium", "avaritia", "avarus", "aveho", "averto", "baiulus", "balbus", "barba", "bardus", "basium", "beatae", "beatus", "bellicus", "bellum", "bene", "beneficium", "benevolentia", "benigne", "bestia", "bibo", "bis", "blandior", "blanditiis", "bonus", "bos", "brevis", "cado", "caecus", "caelestis", "caelum", "calamitas", "calcar", "calco", "calculus", "callide", "campana", "candidus", "canis", "canonicus", "canto", "capillus", "capio", "capitulus", "capto", "caput", "carbo", "carcer", "careo", "caries", "cariosus", "caritas", "carmen", "carpo", "carus", "casso", "caste", "casus", "catena", "caterva", "cattus", "cauda", "causa", "caute", "caveo", "cavus", "cedo", "celebrer", "celer", "celo", "cena", "cenaculum", "ceno", "censura", "centum", "cerno", "cernuus", "certe", "certus", "cervus", "cetera", "charisma", "chirographum", "cibo", "cibus", "cicuta", "cilicium", "cimentarius", "ciminatio", "cinis", "circumvenio", "cito", "civis", "civitas", "clam", "clamo", "claro", "clarus", "claudeo", "claustrum", "clementia", "clibanus", "coadunatio", "coaegresco", "coepi", "coerceo", "cogito", "cognatus", "cognomen", "cogo", "cohaero", "cohibeo", "cohors", "colligo", "collum", "colo", "color", "coma", "combibo", "comburo", "comedo", "comes", "cometes", "comis", "comitatus", "commemoro", "comminor", "commodi", "commodo", "communis", "comparo", "compello", "complectus", "compono", "comprehendo", "comptus", "conatus", "concedo", "concido", "conculco", "condico", "conduco", "confero", "confido", "conforto", "confugo", "congregatio", "conicio", "coniecto", "conitor", "coniuratio", "conor", "conqueror", "conscendo", "consectetur", "consequatur", "consequuntur", "conservo", "considero", "conspergo", "constans", "consuasor", "contabesco", "contego", "contigo", "contra", "conturbo", "conventus", "convoco", "copia", "copiose", "cornu", "corona", "corporis", "corpus", "correptius", "corrigo", "corroboro", "corrumpo", "corrupti", "coruscus", "cotidie", "crapula", "cras", "crastinus", "creator", "creber", "crebro", "credo", "creo", "creptio", "crepusculum", "cresco", "creta", "cribro", "crinis", "cruciamentum", "crudelis", "cruentus", "crur", "crustulum", "crux", "cubicularis", "cubitum", "cubo", "cui", "cuius", "culpa", "culpo", "cultellus", "cultura", "cum", "cumque", "cunabula", "cunae", "cunctatio", "cupiditas", "cupiditate", "cupio", "cuppedia", "cupressus", "cur", "cura", "curatio", "curia", "curiositas", "curis", "curo", "curriculum", "currus", "cursim", "curso", "cursus", "curto", "curtus", "curvo", "custodia", "damnatio", "damno", "dapifer", "debeo", "debilito", "debitis", "decens", "decerno", "decet", "decimus", "decipio", "decor", "decretum", "decumbo", "dedecor", "dedico", "deduco", "defaeco", "defendo", "defero", "defessus", "defetiscor", "deficio", "defleo", "defluo", "defungo", "degenero", "degero", "degusto", "deinde", "delectatio", "delectus", "delego", "deleniti", "deleo", "delibero", "delicate", "delinquo", "deludo", "demens", "demergo", "demitto", "demo", "demonstro", "demoror", "demulceo", "demum", "denego", "denique", "dens", "denuncio", "denuo", "deorsum", "depereo", "depono", "depopulo", "deporto", "depraedor", "deprecator", "deprimo", "depromo", "depulso", "deputo", "derelinquo", "derideo", "deripio", "deserunt", "desidero", "desino", "desipio", "desolo", "desparatus", "despecto", "dicta", "dignissimos", "distinctio", "dolor", "dolore", "dolorem", "doloremque", "dolores", "doloribus", "dolorum", "ducimus", "ea", "eaque", "earum", "eius", "eligendi", "enim", "eos", "error", "esse", "est", "et", "eum", "eveniet", "ex", "excepturi", "exercitationem", "expedita", "explicabo", "facere", "facilis", "fuga", "fugiat", "fugit", "harum", "hic", "id", "illo", "illum", "impedit", "in", "incidunt", "infit", "inflammatio", "inventore", "ipsa", "ipsam", "ipsum", "iste", "itaque", "iure", "iusto", "labore", "laboriosam", "laborum", "laudantium", "libero", "magnam", "magni", "maiores", "maxime", "minima", "minus", "modi", "molestiae", "molestias", "mollitia", "nam", "natus", "necessitatibus", "nemo", "neque", "nesciunt", "nihil", "nisi", "nobis", "non", "nostrum", "nulla", "numquam", "occaecati", "ocer", "odio", "odit", "officia", "officiis", "omnis", "optio", "paens", "pariatur", "patior", "patria", "patrocinor", "patruus", "pauci", "paulatim", "pauper", "pax", "peccatus", "pecco", "pecto", "pectus", "pecus", "peior", "pel", "perferendis", "perspiciatis", "placeat", "porro", "possimus", "praesentium", "provident", "quae", "quaerat", "quam", "quas", "quasi", "qui", "quia", "quibusdam", "quidem", "quis", "quisquam", "quo", "quod", "quos", "ratione", "recusandae", "reiciendis", "rem", "repellat", "repellendus", "reprehenderit", "repudiandae", "rerum", "saepe", "sapiente", "sed", "sequi", "similique", "sint", "sit", "socius", "sodalitas", "sol", "soleo", "solio", "solitudo", "solium", "sollers", "sollicito", "solum", "solus", "soluta", "solutio", "solvo", "somniculosus", "somnus", "sonitus", "sono", "sophismata", "sopor", "sordeo", "sortitus", "spargo", "speciosus", "spectaculum", "speculum", "sperno", "spero", "spes", "spiculum", "spiritus", "spoliatio", "sponte", "stabilis", "statim", "statua", "stella", "stillicidium", "stipes", "stips", "sto", "strenuus", "strues", "studio", "stultus", "suadeo", "suasoria", "sub", "subito", "subiungo", "sublime", "subnecto", "subseco", "substantia", "subvenio", "succedo", "succurro", "sufficio", "suffoco", "suffragium", "suggero", "sui", "sulum", "sum", "summa", "summisse", "summopere", "sumo", "sumptus", "sunt", "supellex", "super", "suppellex", "supplanto", "suppono", "supra", "surculus", "surgo", "sursum", "suscipio", "suscipit", "suspendo", "sustineo", "suus", "synagoga", "tabella", "tabernus", "tabesco", "tabgo", "tabula", "taceo", "tactus", "taedium", "talio", "talis", "talus", "tam", "tamdiu", "tamen", "tametsi", "tamisium", "tamquam", "tandem", "tantillus", "tantum", "tardus", "tego", "temeritas", "temperantia", "templum", "tempora", "tempore", "temporibus", "temptatio", "tempus", "tenax", "tendo", "teneo", "tener", "tenetur", "tenuis", "tenus", "tepesco", "tepidus", "ter", "terebro", "teres", "terga", "tergeo", "tergiversatio", "tergo", "tergum", "termes", "terminatio", "tero", "terra", "terreo", "territo", "terror", "tersus", "tertius", "testimonium", "texo", "textilis", "textor", "textus", "thalassinus", "theatrum", "theca", "thema", "theologus", "thermae", "thesaurus", "thesis", "thorax", "thymbra", "thymum", "tibi", "timidus", "timor", "titulus", "tolero", "tollo", "tondeo", "tonsor", "torqueo", "torrens", "tot", "totam", "totidem", "toties", "totus", "tracto", "trado", "traho", "trans", "tredecim", "tremo", "trepide", "tres", "tribuo", "tricesimus", "triduana", "tripudio", "tristis", "triumphus", "trucido", "truculenter", "tubineus", "tui", "tum", "tumultus", "tunc", "turba", "turbo", "turpis", "tutamen", "tutis", "tyrannus", "uberrime", "ubi", "ulciscor", "ullam", "ullus", "ulterius", "ultio", "ultra", "umbra", "umerus", "umquam", "una", "unde", "undique", "universe", "unus", "urbanus", "urbs", "uredo", "usitas", "usque", "ustilo", "ustulo", "usus", "ut", "uter", "uterque", "utilis", "utique", "utor", "utpote", "utrimque", "utroque", "utrum", "uxor", "vaco", "vacuus", "vado", "vae", "valde", "valens", "valeo", "valetudo", "validus", "vallum", "vapulus", "varietas", "varius", "vehemens", "vel", "velit", "velociter", "velum", "velut", "venia", "veniam", "venio", "ventito", "ventosus", "ventus", "venustas", "ver", "verbera", "verbum", "vere", "verecundia", "vereor", "vergo", "veritas", "veritatis", "vero", "versus", "verto", "verumtamen", "verus", "vesco", "vesica", "vesper", "vespillo", "vester", "vestigium", "vestrum", "vetus", "via", "vicinus", "vicissitudo", "victoria", "victus", "videlicet", "video", "viduo", "vigilo", "vigor", "vilicus", "vilis", "vilitas", "villa", "vinco", "vinculum", "vindico", "vinitor", "vinum", "vir", "virga", "virgo", "viridis", "viriliter", "virtus", "vis", "viscus", "vita", "vitae", "vitiosus", "vitium", "vito", "vivo", "vix", "vobis", "vociferor", "voco", "volaticus", "volo", "volubilis", "voluntarius", "volup", "voluptas", "voluptate", "voluptatem", "voluptates", "voluptatibus", "voluptatum", "volutabrum", "volva", "vomer", "vomica", "vomito", "vorago", "vorax", "voro", "vos", "votum", "voveo", "vox", "vulariter", "vulgaris", "vulgivagus", "vulgo", "vulgus", "vulnero", "vulnus", "vulpes", "vulticulus", "xiphias"];
var cr = { word: Xe };
var $e = cr;
var mr = { title: "English", code: "en", language: "en", endonym: "English", dir: "ltr", script: "Latn" };
var ea = mr;
var aa = ['"Awaken, My Love!"', "(What's The Story) Morning Glory?", "- Tragedy +", "13 Reasons Why (Season 3)", "21st Century Breakdown", "30 De Febrero", "432 Hz Deep Healing", "5-Star", "528 Hz Meditation Music", "54+1", "8 Mile", "808s & Heartbreak", "9 To 5 And Odd Jobs", "A Beautiful Lie", "A Day At The Races", "A Day Without Rain", "A Fever You Can't Sweat Out", "A Gangsta's Pain", "A Gift & A Curse", "A Hard Day's Night", "A Head Full Of Dreams", "A Kind Of Magic", "A Million Ways To Murder", "A Moment Apart", "A Song For Every Moon", "A Thousand Suns", "A Winter Romance", "ABBA", "AI YoungBoy", "AJ Tracey", "Act One", "After Hours", "Agent Provocateur", "All About You", "All I Know So Far: Setlist", "All Or Nothing", "All Out", "All Over The Place", "All Stand Together", "All The Lost Souls", "All The Things I Never Said", "All Things Must Pass", "Alleen", "Alright, Still", "Alta Suciedad", "America", "American Heartbreak", "American Teen", "And Justice For None", "Animal Songs", "Another Friday Night", "Anything Goes", "Ao Vivo Em S\xE3o Paulo", "Ao Vivo No Ibirapuera", "Apricot Princess", "Aqui E Agora (Ao Vivo)", "Arcane League Of Legends", "Ardipithecus", "Aretha Now", "Around The Fur", "Arrival", "Artist 2.0", "As She Pleases", "Ascend", "Ashlyn", "Astro Lounge", "At Night, Alone.", "At. Long. Last. ASAP", "Atlas", "Audioslave", "Aura", "Austin", "Awake", "Away From The Sun", "Ayayay!", "Baby On Baby", "Back For Everything", "Back From The Edge", "Back In Black", "Back To Black", "Back To The Game", "Bad", "Bah\xEDa Ducati", "Baila", "Barbie The Album", "Battleground", "Bayou Country", "Bcos U Will Never B Free", "Be", "Be Here Now", "Beautiful Mind", "Beautiful Thugger Girls", "Beautiful Trauma", "Beauty And The Beast", "Beggars Banquet", "Being Funny In A Foreign Language", "Berlin Lebt", "Berry Is On Top", "Best White Noise For Baby Sleep - Loopable With No Fade", "Big Baby DRAM", "Bigger, Better, Faster, More!", "Billy Talent II", "Black Star Elephant", "Blackout", "Blank Face LP", "Bleach", "Blizzard Of Ozz", "Blonde", "Blood Sugar Sex Magik", "Bloom", "Blowin' Your Mind!", "Blu Celeste", "Blue", "Blue Banisters", "Blue Hawaii", "Blue Neighbourhood", "Bluebird Days", "Bobby Tarantino", "Bobby Tarantino II", "Bon Iver", "Born Pink", "Born To Run", "Brand New Eyes", "Break The Cycle", "Breakfast In America", "Breakthrough", "Brett Young", "Bridge Over Troubled Water", "Bright: The Album", "Brol", "Buds", "Buena Vista Social Club", "Built On Glass", "Bury Me At Makeout Creek", "Busyhead", "By The Way", "CB6", "CNCO", "California Sunrise", "Californication", "Call Me Irresponsible", "Calm", "Camino Palmero", "Camp", "Caracal", "Carbon Fiber Hits", "Carnival", "Carry On", "Cartel De Santa", "Certified Lover Boy", "Chaaama", "Chama Meu Nome", "Chapter 1: Snake Oil", "Chapter 2: Swamp Savant", "Chapter One", "Charlie's Angels", "Cherry Bomb", "Chief", "Chocolate Factory", "Chosen", "Chris Brown", "Christina Aguilera", "Chromatica", "Church", "City Of Evil", "Clandestino", "Clouds", "Coco", "Collision Course", "Colour Vision", "Combat Rock", "Come Around Sundown", "Come Away With Me", "Come Home The Kids Miss You", "Come What(ever) May", "Commando", "Common Sense", "Communion", "Conditions", "Confident", "Confrontation", "Control The Streets, Volume 2", "Corinne Bailey Rae", "Costello Music", "Cottonwood", "Covers, Vol. 2", "Cozy Tapes Vol. 2: Too Cozy", "Crash Talk", "Crazy Love", "Crazysexycool", "Crowded House", "Cruisin' With Junior H", "Culture", "Current Mood", "DS2", "Dale", "Danger Days: The True Lives Of The Fabulous Killjoys", "Dangerous Woman", "Dangerous: The Double Album", "Dark Horse", "Day69", "Daydream", "De Fiesta", "De Viaje", "DeAnn", "Death Race For Love", "Delirium", "Delta", "Demidevil", "Depression Cherry", "Descendants", "Desgenerados Mixtape", "Destin", "Destiny Fulfilled", "Desvelado", "Detroit 2", "Dex Meets Dexter", "Dharma", "Die A Legend", "Different World", "Dig Your Roots", "Digital Druglord", "Dirt", "Disclaimer I / II", "Discovery", "Disraeli Gears", "Disumano", "Dizzy Up The Girl", "Don't Play That Song", "Donda", "Donde Quiero Estar", "Doo-Wops & Hooligans", "Down The Way", "Dr. Feelgood", "Dream Your Life Away", "Dreaming Out Loud", "Drip Harder", "Drive", "Drones", "Dropped Outta College", "Drowning", "Dua Warna Cinta", "Dulce Beat", "Dusty In Memphis", "Dutty Rock", "Dying To Live", "ENR", "East Atlanta Love Letter", "Editorial", "Edna", "El Abayarde", "El Amor En Los Tiempos Del Perreo", "El Camino", "El Comienzo", "El Dorado", "El Karma", "El Mal Querer", "El Malo", "El Trabajo Es La Suerte", "El Viaje De Copperpot", "Electric Ladyland", "Emotion", "En Tus Planes", "Endless Summer Vacation", "Enter The Wu-Tang (36 Chambers)", "Equals (=)", "Estrella", "Euphoria", "Europop", "Evermore", "Every Kingdom", "Everyday Life", "Evolve", "Expectations", "Face Yourself", "Facelift", "Fallin'", "Fancy You", "Fantas\xEDa", "Favourite Worst Nightmare", "Fear Of The Dark", "Fearless", "Feel Something", "Feels Like Home", "Femme Fatale", "Ferxxocalipsis", "Fifty Shades Darker", "Fifty Shades Freed", "Fifty Shades Of Grey", "Final (Vol.1)", "Finding Beauty In Negative Spaces", "Fine Line", "First Impressions Of Earth", "First Steps", "Five Seconds Flat", "Folklore", "For Emma, Forever Ago", "Forajido EP 1", "Forever", "Forever Young", "Formula Of Love: O+T=<3", "Free 6lack", "Freudian", "Frozen II", "Full Moon Fever", "Funhouse", "Funk Wav Bounces Vol.1", "Future History", "FutureSex/LoveSounds", "Fuzzybrain", "Gallery", "Gangsta's Paradise", "Gemini", "Gemini Rights", "Generationwhy", "Get A Grip", "Get Up", "Gettin' Old", "Girl", "Gladiator", "Glisten", "Globalization", "Gloria", "Glory Days", "God's Project", "Gold Skies", "Golden", "Good Evening", "Good Thing", "Goodbye Yellow Brick Road", "Gossip Columns", "Got Your Six", "Graceland", "Graduation", "Grand Champ", "Grandson, Vol. 1", "Green River", "Guerra", "Ha*Ash Primera Fila - Hecho Realidad", "Haiz", "Hamilton", "Happy Endings", "Harry Styles", "Hasta La Ra\xEDz", "Hatful Of Hollow", "Head In The Clouds", "Heard It In A Past Life", "Heart Shaped World", "Heartbeat City", "Heartbreak On A Full Moon / Cuffing Season - 12 Days Of Christmas", "Heaven Or Hell", "Heaven knows", "Hellbilly Deluxe", "Hellboy", "Help!", "Her Loss", "Here Comes The Cowboy", "Hey World", "High School Musical", "High Tide In The Snake's Nest", "Historias De Un Capricornio", "Hndrxx", "Hombres G (Devu\xE9lveme A Mi Chica)", "Homerun", "Homework", "Hot Fuss", "Hot Pink", "Hot Sauce / Hello Future", "Hot Space", "Hotel Diablo", "Houses Of The Holy", "How Big, How Blue, How Beautiful", "How I'm Feeling", "How To Be Human", "How To Save A Life", "How To: Friend, Love, Freefall", "Hozier", "Human", "Huncho Jack, Jack Huncho", "Hunter Hayes", "Hysteria", "I Am...Sasha Fierce", "I Can't Handle Change", "I Met You When I Was 18. (The Playlist)", "I Never Liked You", "I Never Loved A Man The Way I Love You", "I See You", "I Think You Think Too Much Of Me", "I Used To Know Her", "I Used To Think I Could Fly", "I'm Comin' Over", "Ich & Keine Maske", "If You Can Believe Your Eyes & Ears", "Il Ballo Della Vita", "Ill Communication", "Imagination & The Misfit Kid", "Imagine", "Immortalized", "In A Perfect World...", "In Colour", "In My Own Words", "In Rainbows", "In Return", "In The Lonely Hour", "Infest", "Innuendo", "Inter Shibuya - La Mafia", "Interstellar", "Is This It", "It Was Written", "It's Not Me, It's You", "It's Only Me", "Ivory", "JackBoys", "Jamie", "Jazz", "Jibrail & Iblis", "Jordi", "Jordin Sparks", "Jose", "Just As I Am", "Just Cause Y'all Waited 2", "Just Like You", "Justified", "K-12 / After School", "K.I.D.S.", "K.O.", "K.O.B. Live", "KG0516", "KOD", "Kane Brown", "Kid A", "Kid Krow", "Kids See Ghosts", "Kids in Love", "Kinks (You Really Got Me)", "Know-It-All", "Konvicted", "Kring", "LANY", "LM5", "La Criatura", "La Flaca", "La Melodia De La Calle", "La Revolucion", "Lady Lady", "Lady Wood", "Langit Mong Bughaw", "Las Que No Iban A Salir", "Last Day Of Summer", "Last Year Was Complicated", "Layers", "Layover", "Lazarus", "Led Zeppelin", "Left Of The Middle", "Leftoverture", "Legends Never Die", "Let's Skip To The Wedding", "Let's Talk About Love", "Licensed To Ill", "Life In Cartoon Motion", "Life Thru A Lens", "Lifelines", "Like..?", "Lil Big Pac", "Lil Boat", "Lil Boat 2", "Lil Boat 3.5", "Lil Kiwi", "Lil Pump", "Limon Y Sal", "Listen Without Prejudice", "Little Voice", "Live On Red Barn Radio I & II", "Lo Que And\xE1bamos Buscando", "Lofi Fruits Music 2021", "London Calling", "Los Campeones Del Pueblo", "Los Extraterrestres", "Los Favoritos 2", "Lost", "Lost In Love", "Loud", "Love Sick", "Love Story", "Love Stuff", "Love Yourself: Tear", "Lover", "Luca Brasi 2: Gangsta Grillz", "Lust For Life", "Luv Is Rage", "M!ssundaztood", "Ma Fleur", "Made In Lagos", "Mafia Bidness", "Magazines Or Novels", "Mainstream Sellout", "Majestic", "Make It Big", "Make Yourself", "Making Mirrors", "Mamma Mia! Here We Go Again", "Man Of The Woods", "Manic", "Me And My Gang", "Meduza", "Meet The Orphans", "Meet The Woo", "Melim", "Mellon Collie And The Infinite Sadness", "Melly vs. Melvin", "Memories...Do Not Open", "Menagerie", "Midnights", "Minecraft - Volume Alpha", "Minutes To Midnight", "Mix Pa Llorar En Tu Cuarto", "Modo Avi\xF3n", "Monkey Business", "Mono.", "Montana", "Montevallo", "Moosetape", "Morning View", "Motivan2", "Moving Pictures", "Mr. Davis", "Mr. Misunderstood", "Mulan", "Mura Masa", "Music From The Edge Of Heaven", "Music Of The Sun", "My House", "My Kinda Party", "My Krazy Life", "My Liver Will Handle What My Heart Can't", "My Moment", "My Own Lane", "My Turn", "My Worlds", "Na Praia (Ao Vivo)", "Nakamura", "Nation Of Two", "Navegando", "Need You Now", "Neon Future III", "Neotheater", "Never Trust A Happy Song", "New English", "News Of The World", "Nicole", "Night & Day", "Nimmerland", "Nimrod", "Nine Track Mind", "No Angel", "No Me Pidas Perd\xF3n", "No More Drama", "No Protection", "No Strings Attached", "No Time To Die", "Nobody Is Listening", "Non Stop Erotic Cabaret", "Non-Fiction", "Northsbest", "Nostalgia", "Nostalgia, Ultra", "Notes On A Conditional Form", "Now Or Never", "O Embaixador (Ao Vivo)", "O My Heart", "OK Computer", "Ocean", "Ocean Avenue", "Ocean Eyes", "Odisea", "Oh My My", "Oh, What A Life", "On The 6", "One In A Million", "One More Light", "One Of These Nights", "Open Up And Say...Ahh!", "Ordinary Man", "Origins", "Out Of The Blue", "Over It", "OzuTochi", "PTSD", "Pa Las Baby's Y Belikeada", "Pa Que Hablen", "Pa' Luego Es Tarde", "Pa' Otro La 'O", "Pablo Honey", "Pain Is Love", "Pain Is Temporary", "Painting Pictures", "Palmen Aus Plastik 2", "Para Mi Ex", "Para Siempre", "Partners In Crime", "Pawn Shop", "Pegasus / Neon Shark VS Pegasus", "Pet Sounds", "Piece By Piece", "Pier Pressure", "Pineapple Sunrise", "Piseiro 2020 Ao Vivo", "Planet Pit", "Plans", "Play Deep", "Playa Saturno", "Por Primera Vez", "Por Vida", "Positions", "Post Human: Survival Horror", "Poster Girl", "Prazer, Eu Sou Ferrugem (Ao Vivo)", "Pretty Girls Like Trap Music", "Pretty. Odd.", "Prince Royce", "Prisma", "Prometo", "Providence", "Puberty 2", "Punisher", "Purgatory", "Purple Rain", "Que Bendici\xF3n", "Queen Of The Clouds", "Quiero Volver", "R&G (Rhythm & Gangsta): The Masterpiece", "Raise!", "Ransom 2", "Rapunzel", "Rare", "Re Mida", "Ready To Die", "Realer", "Rebelde", "Reclassified", "Recovery", "Recuerden Mi Estilo", "Reggatta De Blanc", "Regulate\u2026 G Funk Era", "Reik", "Reise, Reise", "Relapse", "Relaxing Piano Lullabies And Natural Sleep Aid For Baby Sleep Music", "Religiously. The Album.", "Replay", "Results May Vary", "Revenge", "Revolve", "Revolver", "Ricky Martin", "Rien 100 Rien", "Ripcord", "Rise And Fall, Rage And Grace", "Rise Of An Empire", "Robin Hood: Prince Of Thieves", "Rock N Roll Jesus", "Romance", "Romances", "Ronan", "Royal Blood", "Rumours", "Sad Boyz 4 Life II", "San Lucas", "Santana World", "Saturation III", "Sauce Boyz", "Savage Mode", "Saxobeats", "Scarlet", "Schwarzes Herz", "Seal The Deal & Let's Boogie", "Section.80", "Segundo Romance", "Sehnsucht", "Shake The Snow Globe", "Shang-Chi And The Legend Of The Ten Rings: The Album", "Sheer Heart Attack", "Shiesty Season", "Shock Value", "Shoot For The Stars, Aim For The Moon", "Signed Sealed And Delivered", "Signos", "Silent Alarm", "Simplemente Gracias", "Sin Bandera", "Sing Me A Lullaby, My Sweet Temptation", "Sinner", "Sirio", "Sit Still, Look Pretty", "Skin", "Slowhand", "Smash", "Smithereens", "Snow Cougar", "Social Cues", "Some Girls", "Song Hits From Holiday Inn", "Songs For Dads", "Songs For The Deaf", "Songs For You, Truths For Me", "Songs In The Key Of Life", "Souled Out", "Sounds Of Silence", "Soy Como Quiero Ser", "Speak Now", "Speak Your Mind", "Speakerboxxx/The Love Below", "Spider-Man: Into The Spider-Verse", "Split Decision", "Square Up", "SremmLife", "Starboy", "Stay +", "Stay Dangerous", "Staying At Tamara's", "Steppenwolf", "Stick Season", "Still Bill", "Straight Outta Compton", "Strange Trails", "Stronger", "Suavemente", "Sublime", "Suck It and See", "Sucker", "Sue\xF1os", "Sugar", "Summer Forever", "Summer,", "Sunset Season", "Sunshine On Leith", "Surfer Rosa", "Sweet Talker", "SweetSexySavage", "System Of A Down", "TA13OO", "Talk That Talk", "Talking Heads: 77", "Tangled Up", "Tango In The Night", "Taxi Driver", "Taylor Swift", "Tell Me It's Real", "Ten", "Ten Summoner's Tales", "Terra Sem Cep (Ao Vivo)", "Terral", "Testing", "Tha Carter III", "Thank Me Later", "That's Christmas To Me", "The Academy", "The Adventures Of Bobby Ray", "The Album", "The Andy Williams Christmas Album", "The Aviary", "The Balcony", "The Battle Of Los Angeles", "The Beatles (White Album)", "The Beginning", "The Better Life", "The Big Day", "The Book", "The Breakfast Club", "The Cars", "The Colour And The Shape", "The Death Of Peace Of Mind", "The Diary Of Alicia Keys", "The Documentary", "The Emancipation Of Mimi", "The Eminem Show", "The End Of Everything", "The Final Countdown", "The Forever Story", "The Foundation", "The Goat", "The Golden Child", "The Good Parts", "The Greatest Showman: Reimagined", "The Green Trip", "The Hardest Love", "The Head And The Heart", "The Human Condition", "The Infamous", "The Lady Killer", "The Last Don II", "The Lion King", "The Lockdown Sessions", "The London Sessions", "The Lord Of The Rings: The Fellowship Of The Ring", "The Lost Boy", "The Magic Of Christmas / The Christmas Song", "The Marshall Mathers LP", "The Martin Garrix Collection", "The Melodic Blue", "The Mockingbird & The Crow", "The Pains Of Growing", "The Papercut Chronicles", "The Perfect Luv Tape", "The Pinkprint", "The Predator", "The Queen Is Dead", "The ReVe Festival: Finale", "The Rise And Fall Of Ziggy Stardust And The Spiders From Mars", "The Rising Tied", "The River", "The Stone Roses", "The Story Of Us", "The Stranger", "The Sufferer & The Witness", "The Sun's Tirade", "The Temptations Sing Smokey", "The Time Of Our Lives", "The Way It Is", "The Wonderful World Of Sam Cooke", "The Writing's On The Wall", "The Young And The Hopeless", "Therapy", "Therapy Session", "There Is More (Live)", "There Is Nothing Left To Lose", "These Things Happen", "Third Eye Blind", "This Is Me...Then", "This Unruly Mess I've Made", "Threat to Survival", "Thrill Of The Chase", "Time", "Timelezz", "To Let A Good Thing Die", "To Pimp A Butterfly", "Toast To Our Differences", "Todos Os Cantos, Vol. 1 (Ao Vivo)", "Too Hard", "Torches X", "Total Xanarchy", "Toto IV", "Toulouse Street", "Tourist History", "Toxicity", "Tragic Kingdom", "Tranquility Base Hotel & Casino", "Traumazine", "Traveler", "Tres Hombres", "Trip At Knight", "Tron: Legacy", "True Blue", "True Colors", "Trustfall", "Tu Veneno Mortal", "Tudo Em Paz", "Ubuntu", "Ugly Is Beautiful", "Ultra 2021", "Una Mattina", "Unbroken", "Uncovered", "Under Pressure", "Unsponsored Content", "Unstoppable", "Unwritten", "Urban Flora", "Urban Hymns", "Use Your Illusion I", "Veneer", "Versions Of Me", "Vibes", "Vice Versa", "Vices & Virtues", "Victory", "Vida", "Viejo Marihuano", "Visual\xEDzate", "Walk Away", "Walk Me Home...", "Watch The Throne", "Wave", "We Broke The Rules", "We Love You Tecca", "We Love You Tecca 2", "Weezer (Green Album)", "Welcome To The Madhouse", "Westlife", "What A Time To Be Alive", "What Do You Think About The Car?", "What Is Love?", "What Makes You Country", "What Separates Me From You", "What You See Is What You Get / What You See Ain't Always What You Get", "When It's Dark Out", "When We All Fall Asleep, Where Do We Go?", "Where The Light Is", "While The World Was Burning", "White Pony", "Whitney", "Who Really Cares", "Who You Are", "Who's Next", "Wide Open", "Wilder Mind", "Wildfire", "Willy And The Poor Boys", "Wings / You Never Walk Alone", "Wish", "Wish You Were Here", "Without Warning", "Wonder", "X&Y", "XOXO", "Y Que Quede Claro", "YBN: The Mixtape", "Yo Creo", "You Will Regret", "Youngblood", "Younger Now", "Youth"];
var ra = ["$NOT", "$uicideboy$", "(G)I-DLE", "*NSYNC", "2 Chainz", "21 Savage", "6LACK", "? & The Mysterians", "A Boogie Wit da Hoodie", "A Taste of Honey", "A Tribe Called Quest", "A-Ha", "ABBA", "AC/DC", "AJ Tracey", "ATEEZ", "Ace of Base", "Adele", "Ado", "Aerosmith", "Agust D", "Aitana", "Al Dexter & his Troopers", "Al Green", "Al Jolson", "Al Martino", "Alan Jackson", "Alannah Myles", "Alec Benjamin", "Alejandro Sanz", "Alesso", "Alfredo Olivas", "Ali Gatie", "Alice In Chains", "Alina Baraz", "All Time Low", "All-4-One", "All-American Rejects", "Alok", "America", "American Quartet", "Amii Stewart", "Amitabh Bhattacharya", "Ana Castela", "Anderson .Paak", "Andy Grammer", "Angus & Julia Stone", "Anirudh Ravichander", "Anita Ward", "Anitta", "Anton Karas", "Anuel AA", "Arcade Fire", "Archie Bell & The Drells", "Archies", "Aretha Franklin", "Arizona Zervas", "Armin van Buuren", "Arthur Conley", "Artie Shaw", "Asake", "Asees Kaur", "Association", "Atif Aslam", "Audioslave", "Aventura", "Avril Lavigne", "Aya Nakamura", "B J Thomas", "B.o.B", "BLACKPINK", "BONES", "BROCKHAMPTON", "BTS", "Baby Keem", "Bachman-Turner Overdrive", "Backstreet Boys", "Bad Bunny", "Badshah", "Bailey Zimmerman", "Banda El Recodo", "Barbra Streisand", "Barry White", "Bazzi", "Bebe Rexha", "Becky G", "Becky Hill", "Bee Gees", "Ben Bernie", "Ben Howard", "Ben Selvin", "Berlin", "Bessie Smith", "Bethel Music", "Bette Midler", "Beyonce", "Bibi Blocksberg", "Bibi und Tina", "BigXthaPlug", "Bill Doggett", "Bill Haley & his Comets", "Bill Withers", "Billy Davis Jr", "Billy Joel", "Billy Paul", "Billy Preston", "Billy Swan", "Birdy", "Bizarrap", "Blake Shelton", "Blur", "Bob Marley & The Wailers", "Bob Seger", "Bobby Darin", "Bobby Lewis", "Bobby McFerrin", "Bobby Vinton", "Boney M.", "Bonez MC", "Bonnie Tyler", "Booba", "Boston", "BoyWithUke", "Boyce Avenue", "Bradley Cooper", "Bread", "Brent Faiyaz", "Brett Young", "Bring Me The Horizon", "Britney Spears", "Brooks & Dunn", "Bruce Channel", "Bruno & Marrone", "Bryan Adams", "Bryce Vine", "Buddy Holly", "Burna Boy", "C. Tangana", "CKay", "CRO", "Camilo", "Capital Bra", "Captain & Tennille", "Cardi B", "Carin Leon", "Carlos Vives", "Carly Simon", "Carpenters", "Cavetown", "Celine Dion", "Central Cee", "Chaka Khan", "Champs", "Charlie Rich", "Chayanne", "Cheat Codes", "Cher", "Chic", "Chicago", "Chris Brown", "Chris Isaak", "Chris Young", "Christina Aguilera", "Christina Perri", "Christopher Cross", "Chuck Berry", "Ciara", "Cigarettes After Sex", "Cliff Edwards (Ukelele Ike)", "Cody Johnson", "Colbie Caillat", "Colby O'Donis", "Cole Swindell", "Coleman Hawkins", "Contours", "Coolio", "Count Basie", "Cris Mj", "Culture Club", "Cyndi Lauper", "D-Block Europe", "DAY6", "DJ Khaled", "DJ Luian", "DJ Nelson", "DMX", "DNCE", "DaVido", "Dadju", "Daft Punk", "Dan + Shay", "Daniel Powter", "Danny Ocean", "Darius Rucker", "Dave", "David Bowie", "David Guetta", "Daya", "Dean Martin", "Deee-Lite", "Deep Purple", "Deftones", "Demi Lovato", "Dennis Lloyd", "Denzel Curry", "Dermot Kennedy", "Desiigner", "Devo", "Dewa 19", "Dexys Midnight Runners", "Diddy", "Dido", "Die drei !!!", "Diego & Victor Hugo", "Diljit Dosanjh", "Dimitri Vegas & Like Mike", "Dinah Shore", "Dionne Warwick", "Dire Straits", "Disclosure", "Dixie Cups", "Doja Cat", "Dolly Parton", "Don Diablo", "Don Henley", "Don McLean", "Don Omar", "Donna Summer", "Donovan", "Dr. Dre", "Drake", "Dreamville", "Dua Lipa", "EMF", "ENHYPEN", "Earth, Wind & Fire", "Ed Sheeran", "Eddie Cantor", "Eddie Cochran", "Eddy Howard", "Edgar Winter Group", "Edwin Hawkins Singers", "Edwin Starr", "El Alfa", "Eladio Carrion", "Electric Light Orchestra", "Elevation Worship", "Ella Henderson", "Ellie Goulding", "Elton John", "Elvis Presley", "Empire of the Sun", "En Vogue", "Enrique Iglesias", "Eslabon Armado", "Ethel Waters", "Etta James", "Evanescence", "Exile", "Extreme", "Faith Hill", "Fall Out Boy", "Fanny Brice", "Farruko", "Fats Domino", "Fats Waller", "Feid", "Felix Jaehn", "Fergie", "Fetty Wap", "Fiersa Besari", "Fifth Harmony", "Fine Young Cannibals", "Five Finger Death Punch", "Fleetwood Mac", "Flo-Rida", "Florence + The Machine", "Flume", "Foo Fighters", "Foreigner", "Foster The People", "Four Aces", "Frank Ocean", "Frank Sinatra", "Frankie Avalon", "Frankie Valli", "Fred Astaire", "Freda Payne", "Freddie Dredd", "Freddy Fender", "French Montana", "Fuerza Regida", "Fujii Kaze", "Future", "G-Eazy", "Garfunkel and Oates", "Gary Lewis & The Playboys", "Gary Numan", "Gene Autry", "Gene Chandler", "Gene Vincent", "George Michael", "George Strait", "Gera MX", "Ghost", "Ghostemane", "Gigi D'Agostino", "Gladys Knight & The Pips", "Glass Animals", "Glee Cast", "Gloria Gaynor", "Godsmack", "Gorillaz", "Gotye", "Grand Funk Railroad", "Green Day", "Grouplove", "Grupo Firme", "Grupo Marca Registrada", "Gryffin", "Gucci Mane", "Guess Who", "Gunna", "Gusttavo Lima", "Guy Mitchell", "Gwen Stefani", "Gzuz", "H.E.R.", "HARDY", "Hailee Steinfeld", "Halsey", "Hans Zimmer", "Harris Jayaraj", "Harry Chapin", "Harry James", "Harry Nilsson", "Harry Styles", "Hayley Williams", "Herb Alpert", "Herman's Hermits", "Hillsong UNITED", "Hillsong Worship", "Hollywood Undead", "Honey Cone", "Hoobastank", "Hues Corporation", "I Prevail", "ITZY", "IVE", "Ice Cube", "Ice Spice", "Iggy Azalea", "Imagine Dragons", "Incubus", "Internet Money", "Isaac Hayes", "J Geils Band", "J. Cole", "JAY-Z", "JJ Lin", "JP Saxe", "JVKE", "Jack Harlow", "Jack Johnson", "Jackie Wilson", "Jacquees", "James Arthur", "James Brown", "James TW", "James Taylor", "Jamie Foxx", "Janet Jackson", "Janis Joplin", "Jason Aldean", "Jason Mraz", "Jay Chou", "Jay Sean", "Jay Wheeler", "Jaymes Young", "Jean Knight", "Jeezy", "Jennifer Lopez", "Jennifer Warnes", "Jeremih", "Jeremy Zucker", "Jerry Lee Lewis", "Jerry Murad's Harmonicats", "Jess Glynne", "Jessie J", "Jewel", "Jimi Hendrix", "Jimin", "Jimmie Rodgers", "Jimmy Dean", "Jo Stafford", "Joan Jett & The Blackhearts", "Joao Gilberto", "Joel Corry", "John Fred & The Playboy Band", "John Legend", "John Mayer", "John Williams", "Johnnie Ray", "Johnnie Taylor", "Johnny Cash", "Johnny Horton", "Johnny Mathis", "Johnny Mercer", "Johnny Nash", "Joji", "Jon Bellion", "Jonas Blue", "Jonas Brothers", "Joni James", "Jorja Smith", "Juan Gabriel", "Juan Luis Guerra 4.40", "Juanes", "Juice Newton", "Julia Michaels", "Justin Bieber", "Justin Quiles", "KALEO", "KAROL G", "KAYTRANADA", "KK", "KSI", "KYLE", "Kacey Musgraves", "Kane Brown", "Kanye West", "Karan Aujla", "Kate Smith", "Katy Perry", "Kay Kyser", "Ke$ha", "Kehlani", "Kelly Clarkson", "Kenny Chesney", "Kenny Loggins", "Kenny Rogers", "Kenshi Yonezu", "Kenya Grace", "Kevin Gates", "Key Glock", "Khalid", "Kim Carnes", "Kim Petras", "Kimbra", "Kina", "King Gnu", "Kings of Leon", "Kingsmen", "Kitty Kallen", "Kodak Black", "Kodaline", "Kollegah", "Kool & The Gang", "Kungs", "Kygo", "Kylie Minogue", "LE SSERAFIM", "LISA", "LMFAO", "LUDMILLA", "La Adictiva Banda San Jos\xE9 de Mesillas", "La Oreja de Van Gogh", "Labrinth", "Lady Antebellum", "Lady GaGa", "Lainey Wilson", "Lana Del Rey", "Latto", "Lauryn Hill", "Lauv", "League of Legends", "Lee Brice", "Leon Bridges", "Leona Lewis", "Lesley Gore", "Leslie Odom Jr.", "Liam Payne", "Lifehouse", "Lil Baby", "Lil Dicky", "Lil Durk", "Lil Mosey", "Lil Nas X", "Lil Pump", "Lil Skies", "Lil Tjay", "Lil Uzi Vert", "Lil Yachty", "Lil' Kim", "Lil' Wayne", "Lin-Manuel Miranda", "Linkin Park", "Lionel Richie", "Lipps Inc", "Lisa Loeb", "Little Peggy March", "Little Richard", "Lofi Fruits Music", "Lord Huron", "Los Del Rio", "Los Dos Carnales", "Los Lobos", "Los Temerarios", "Los Tigres Del Norte", "Los Tucanes De Tijuana", "Lou Reed", "Loud Luxury", "Louis Jordan", "Louis Tomlinson", "Love Unlimited", "Lovin' Spoonful", "Luan Santana", "Luciano", "Luis Miguel", "Luis R Conriquez", "Lulu", "Lunay", "Lupe Fiasco", "M", "MAX", "MC Hammer", "MC Ryan SP", "MKTO", "Mabel", "Machine Gun Kelly", "Madison Beer", "Madonna", "Mahalini", "Major Lazer", "Mambo Kingz", "Maneskin", "Marco Antonio Sol\xEDs", "Margaret Whiting", "Maria Becerra", "Mario", "Mario Lanza", "Mark Ronson", "Maroon 5", "Marshmello", "Martin Garrix", "Mary Ford", "Mary J Blige", "Mary J. Blige", "Mary Wells", "Matoma", "Mau y Ricky", "Meek Mill", "Megadeth", "Melanie", "Melanie Martinez", "Melendi", "Men At Work", "Metro Boomin", "Michael Bubl\xE9", "Michael Jackson", "Michael McDonald", "Michael Sembello", "Miguel", "Mike Posner", "Miley Cyrus", "Milky Chance", "Minnie Riperton", "Miracle Tones", "Miranda Lambert", "Mohit Chauhan", "Mon Laferte", "Moneybagg Yo", "Monsta X", "Mora", "Morad", "Morat", "Mother Mother", "Motley Crue", "Ms. Lauryn Hill", "Mumford & Sons", "Muse", "Mya", "Myke Towers", "NCT 127", "NCT DREAM", "NEFFEX", "Nadin Amizah", "Nancy Sinatra", "Nat King Cole", "Nate Smith", "Natti Natasha", "Nayer", "Neil Diamond", "Neil Sedaka", "Nekfeu", "Nelly", "New Vaudeville Band", "Next", "Nickelback", "Nicki Minaj", "Nicki Nicole", "Nicky Jam", "Nina Simone", "Ninho", "Nipsey Hussle", "Nirvana", "Niska", "No Doubt", "Norah Jones", "Normani", "OMI", "ONE OK ROCK", "Oasis", "Official HIGE DANdism", "Offset", "Old Dominion", "Oliver Heldens", "Olivia Rodrigo", "Omah Lay", "One Direction", "Otis Redding", "OutKast", "Owl City", "P Diddy", "P!nk", "PLK", "PNL", "Pamungkas", "Passenger", "Pat Boone", "Patsy Cline", "Patti LaBelle", "Patti Page", "Paul & Paula", "Paul Revere & the Raiders", "Paul Robeson", "Paul Russell", "Paul Whiteman", "Paula Abdul", "Peaches & Herb", "Pearl Jam", "Pee Wee Hunt", "Pee Wee King", "Pentatonix", "Percy Faith", "Percy Sledge", "Peso Pluma", "Peter Cetera", "Peter Gabriel", "Peter, Paul & Mary", "Pharrell Williams", "Pierce The Veil", "Pineapple StormTv", "Pink Floyd", "Pink Sweat$", "Piso 21", "Pitbull", "Plan B", "Player", "Polo G", "Pop Smoke", "Portugal. The Man", "Pouya", "Prince", "Prince Royce", "Pusha T", "Quality Control", "Queen", "Quinn XCII", "R. Kelly", "RAF Camora", "RAYE", "REM", "REO Speedwagon", "Radiohead", "Rag'n'Bone Man", "Rage Against The Machine", "Rahat Fateh Ali Khan", "Rainbow Kitten Surprise", "Rammstein", "Rauw Alejandro", "Ray Charles", "Ray Parker Jr", "Ray Stevens", "Red Foley", "Red Hot Chili Peppers", "Red Velvet", "Regard", "Regina Belle", "Reik", "Rels B", "Rema", "Ricardo Arjona", "Rich The Kid", "Rick Astley", "Rick Dees & his Cast of Idiots", "Rick Ross", "Rick Springfield", "Ricky Martin", "Ricky Nelson", "Rihanna", "Rita Ora", "Ritchie Valens", "Rizky Febian", "Rob Thomas", "Roberta Flack", "Robin Schulz", "Robin Thicke", "Rod Stewart", "Rod Wave", "Roddy Ricch", "Roger Miller", "Romeo Santos", "Rosemary Clooney", "Roxette", "Roy Acuff", "Roy Orbison", "Rudimental", "Ruel", "Ruth B.", "Ryan Lewis", "SCH", "SEVENTEEN", "SWV", "Sabaton", "Sabrina Carpenter", "Sachet Tandon", "Sachin-Jigar", "Sade", "Sam Cooke", "Sam Feldt", "Sam Hunt", "Sam Smith", "Sam The Sham & The Pharaohs", "Sammy Davis Jr", "Sammy Kaye", "Santana", "Sasha Alex Sloan", "Savage Garden", "Saweetie", "Scorpions", "Sean Kingston", "Sean Paul", "Sebastian Yatra", "Sech", "Seeb", "Sezen Aksu", "Sfera Ebbasta", "Shaggy", "Shania Twain", "Shawn Mendes", "Sheena Easton", "Shinedown", "Shubh", "Sia", "Sid Sriram", "Sidhu Moose Wala", "Silk", "Silver Convention", "Simon & Garfunkel", "Sinead O'Connor", "Sir Mix-a-Lot", "Sister Sledge", "Ski Mask The Slump God", "Skillet", "Skrillex", "Sleeping At Last", "Smokey Robinson", "Snoop Dogg", "Snow Patrol", "Soda Stereo", "Sonu Nigam", "Sophie Ellis-Bextor", "Spencer Davis Group", "Spice Girls", "Stan Getz", "Starland Vocal Band", "Stephen Sanchez", "Steve Aoki", "Steve Lacy", "Steve Winwood", "Stevie B", "Sting", "Stormzy", "Strawberry Alarm Clock", "Stray Kids", "Stromae", "Sublime", "Sum 41", "Summer Walker", "Supertramp", "Survivor", "Swedish House Mafia", "System Of A Down", "T-Pain", "T.I.", "TAEYEON", "TKKG", "TLC", "TOMORROW X TOGETHER", "TOTO", "TWICE", "Tag Team", "Tainy", "Tammi Terrell", "Tanishk Bagchi", "Tate McRae", "Taylor Swift", "Tears For Fears", "Tems", "Tennessee Ernie Ford", "Terence Trent D'Arby", "Teresa Brewer", "Terry Jacks", "The Ames Brothers", "The Animals", "The B52s", "The Bangles", "The Beatles", "The Black Eyed Peas", "The Black Keys", "The Box Tops", "The Chainsmokers", "The Chiffons", "The Chordettes", "The Clash", "The Coasters", "The Commodores", "The Cowsills", "The Cranberries", "The Crew-Cuts", "The Cure", "The Detroit Spinners", "The Diamonds", "The Doobie Brothers", "The Doors", "The Drifters", "The Emotions", "The Eurythmics", "The Fireballs", "The Flamingos", "The Foundations", "The Four Seasons", "The Fray", "The Game", "The Go Gos", "The Goo Goo Dolls", "The Head And The Heart", "The Hollies", "The Ink Spots", "The Isley Brothers", "The Jackson 5", "The Kid LAROI", "The Killers", "The Kingston Trio", "The Kooks", "The Lemon Pipers", "The Living Tombstone", "The Lumineers", "The Mamas & The Papas", "The Marvelettes", "The McCoys", "The Mills Brothers", "The Miracles", "The Monkees", "The Moody Blues", "The National", "The Neighbourhood", "The Notorious B.I.G.", "The O'Jays", "The Offspring", "The Osmonds", "The Partridge Family", "The Penguins", "The Pet Shop Boys", "The Platters", "The Righteous Brothers", "The Rolling Stones", "The Ronettes", "The Score", "The Script", "The Seekers", "The Shangri-Las", "The Smashing Pumpkins", "The Staple Singers", "The Strokes", "The Supremes", "The Temptations", "The Turtles", "The Vamps", "The Verve", "The Village People", "The Weavers", "The White Stripes", "The Young Rascals", "The Zombies", "Thelma Houston", "Thomas Rhett", "Three Days Grace", "Three Dog Night", "Three Man Down", "Timbaland", "Timmy Trumpet", "Toby Keith", "Tom Jones", "Tom Petty and the Heartbreakers", "Tommy Dorsey", "Tommy Edwards", "Tommy James & the Shondells", "Tone Loc", "Toni Braxton", "Topic", "Tory Lanez", "Tove Lo", "Trevor Daniel", "Trey Songz", "Trippie Redd", "Trueno", "Tulsi Kumar", "Tulus", "Twenty One Pilots", "Two Feet", "Ty Dolla $ign", "Tyga", "Tyler Hubbard", "U2", "UB40", "UZI", "Ufo361", "Upchurch", "V", "Vampire Weekend", "Van McCoy", "Van Morrison", "Vance Joy", "Vanessa Carlton", "Vanessa Williams", "Vera Lynn", "Vernon Dalhart", "Vicente Fernandez", "Vishal-Shekhar", "Volbeat", "WILLOW", "Wale", "Wallows", "Weezer", "Wham!", "Whitney Houston", "Why Don't We", "Wilbert Harrison", "Wilson Phillips", "Wiz Khalifa", "Woody Guthrie", "Wyclef Jean", "XXXTENTACION", "Xavi", "YG", "YNW Melly", "YOASOBI", "Yandel", "Years & Years", "Yeat", "Yo Gotti", "Young Dolph", "Young Miko", "Young Thug", "YoungBoy Never Broke Again", "Yung Gravy", "Yuuri", "Yuvan Shankar Raja", "ZAYN", "ZZ Top", "Zac Brown Band", "Zach Bryan", "Zara Larsson", "aespa", "benny blanco", "blink-182", "d4vd", "deadmau5", "girl in red", "gnash", "iann dior", "will.i.am"];
var oa = ["Acid House", "Acid Jazz", "Acid Rock", "Acoustic", "Acoustic Blues", "Afro-Pop", "Afrobeat", "Alt-Rock", "Alternative", "Ambient", "American Trad Rock", "Americana", "Anime", "Arena Rock", "Art-Rock", "Avant-Garde", "Avant-Punk", "Baladas y Boleros", "Barbershop", "Baroque", "Bebop", "Big Band", "Black Metal", "Blue Note", "Bluegrass", "Blues", "Boogaloo", "Bop", "Bossa Nova", "Bounce", "Brazilian Funk", "Breakbeat", "Britpop", "CCM", "Cajun", "Cantopop", "Celtic", "Celtic Folk", "Chamber Music", "Chant", "Chanukah", "Chicago Blues", "Chicago House", "Chicano", "Children\u2019s Music", "Chill", "Choral", "Christian", "Christmas", "Classical", "Club", "College Rock", "Conjunto", "Cool Jazz", "Country", "Crunk", "Dance", "Dancehall", "Death Metal", "Deep House", "Delta Blues", "Detroit Techno", "Dirty South", "Disco", "Disney", "Dixieland", "Doo-wop", "Downtempo", "Dream Pop", "Drill", "Drinking Songs", "Drone", "Drum'n'bass", "Dub", "Dubstep", "EDM", "Early Music", "East Coast Rap", "Easter", "Easy Listening", "Eclectic", "Electric Blues", "Electro", "Electronic", "Electronica", "Emo", "Enka", "Environmental", "Ethio-jazz", "Experimental", "Experimental Rock", "Flamenco", "Folk", "Folk-Rock", "Forro", "French Pop", "Funk", "Fusion", "Gangsta Rap", "Garage", "German Folk", "German Pop", "Glam Rock", "Gospel", "Goth", "Grime", "Grindcore", "Groove", "Grunge", "Hair Metal", "Halloween", "Happy", "Hard Bop", "Hard Dance", "Hard Rock", "Hardcore", "Hardcore Punk", "Hardcore Rap", "Hardstyle", "Healing", "Heavy Metal", "High Classical", "Hip Hop", "Holiday", "Honky Tonk", "House", "IDM", "Impressionist", "Indie", "Industrial", "Instrumental", "J-Dance", "J-Idol", "J-Pop", "J-Punk", "J-Rock", "J-Ska", "J-Synth", "Jackin House", "Jam Bands", "Japanese Pop", "Jazz", "Jungle", "K-Pop", "Karaoke", "Kayokyoku", "Kids", "Kitsch", "Klezmer", "Krautrock", "Latin", "Latin Jazz", "Latin Rap", "Local", "Lounge", "Lullabies", "MPB", "Mainstream Jazz", "Malay", "Mandopop", "March", "Mariachi", "Mawwal", "Medieval", "Meditation", "Metal", "Metalcore", "Minimal Techno", "Minimalism", "Modern", "Motown", "Mugham", "Musicals", "Musique Concr\xE8te", "Nature", "Neo-Soul", "Nerdcore", "New Acoustic", "New Age", "New Mex", "New Wave", "No Wave", "Noise", "Nordic", "Novelty", "OPM", "Oi!", "Old School Rap", "Opera", "Orchestral", "Original Score", "Outlaw Country", "Pagode", "Party", "Piano", "Polka", "Pop", "Pop Film", "Pop Latino", "Post Dubstep", "Power Pop", "Praise & Worship", "Progressive House", "Progressive Rock", "Proto-punk", "Psych Rock", "Psychedelic", "Punk", "Punk Rock", "Qawwali", "Quiet Storm", "R&B", "Ragtime", "Rainy Day", "Rap", "Reggae", "Reggaeton", "Regional Mexicano", "Relaxation", "Renaissance", "Retro", "Rock", "Rockabilly", "Rocksteady", "Romance", "Romantic", "Roots Reggae", "Roots Rock", "SKA", "Sad", "Salsa", "Samba", "Second Line", "Sertanejo", "Shaabi", "Shoegaze", "Sleep", "Smooth Jazz", "Soft Rock", "Soul", "Soundtrack", "Southern Gospel", "Southern Rock", "Space Rock", "Stage And Screen", "Steampunk", "Summer", "Surf", "Swamp Pop", "Swing", "Synth Pop", "Tango", "Techno", "Teen Pop", "Tejano", "Tex-Mex", "Thanksgiving", "Traditional", "Trance", "Trip Hop", "Tropical", "Underground Rap", "Urban", "Urban Cowboy", "West Coast Rap", "Western Swing", "World", "Worldbeat", "Zydeco"];
var na = ["(Everything I Do) I Do it For You", "(Ghost) Riders in the Sky", "(I Can't Get No) Satisfaction", "(I've Got a Gal In) Kalamazoo", "(I've Had) the Time of My Life", "(It's No) Sin", "(Just Like) Starting Over", "(Let Me Be Your) Teddy Bear", "(Put Another Nickel In) Music! Music! Music!", "(Sexual) Healing", "(Sittin' On) the Dock of the Bay", "(They Long to Be) Close to You", "(You Keep Me) Hangin' On", "(You're My) Soul & Inspiration", "(Your Love Keeps Lifting Me) Higher & Higher", "12th Street Rag", "1999", "19th Nervous Breakdown", "50 Ways to Leave Your Lover", "9 to 5", "96 Tears", "A Boy Named Sue", "A Hard Day's Night", "A String of Pearls", "A Thousand Miles", "A Tree in the Meadow", "A Whiter Shade of Pale", "A Whole New World (Aladdin's Theme)", "A Woman in Love", "A-Tisket A-Tasket", "ABC", "Abracadabra", "Ac-cent-tchu-ate the Positive", "Addicted to Love", "After You've Gone", "Afternoon Delight", "Again", "Against All Odds (Take a Look At Me Now)", "Ain't Misbehavin'", "Ain't No Mountain High Enough", "Ain't No Sunshine", "Ain't That a Shame", "Airplanes", "All Along the Watchtower", "All I Have to Do is Dream", "All I Wanna Do", "All My Lovin' (You're Never Gonna Get It)", "All Night Long (All Night)", "All Out of Love", "All Shook Up", "All You Need is Love", "Alone", "Alone Again (Naturally)", "Always On My Mind", "American Pie", "American Woman", "Angie", "Another Brick in the Wall (part 2)", "Another Day in Paradise", "Another Night", "Another One Bites the Dust", "Apologize", "April Showers", "Aquarius/Let The Sunshine In", "Are You Lonesome Tonight?", "Arthur's Theme (Best That You Can Do)", "As Time Goes By", "At Last", "At the Hop", "Auf Wiederseh'n Sweetheart", "Baby Baby", "Baby Come Back", "Baby Got Back", "Baby Love", "Baby One More Time", "Bad Day", "Bad Girls", "Bad Moon Rising", "Bad Romance", "Bad, Bad Leroy Brown", "Baker Street", "Ball of Confusion (That's What the World is Today)", "Ballad of the Green Berets", "Ballerina", "Band On the Run", "Band of Gold", "Battle of New Orleans", "Be Bop a Lula", "Be My Baby", "Be My Love", "Beat It", "Beautiful Day", "Beauty & the Beast", "Because I Love You (The Postman Song)", "Because You Loved Me", "Because of You", "Before The Next Teardrop Falls", "Begin the Beguine", "Behind Closed Doors", "Being With You", "Believe", "Ben", "Bennie & the Jets", "Besame Mucho", "Best of My Love", "Bette Davis Eyes", "Big Bad John", "Big Girls Don't Cry", "Billie Jean", "Bitter Sweet Symphony", "Black Or White", "Black Velvet", "Blaze of Glory", "Bleeding Love", "Blue Suede Shoes", "Blue Tango", "Blueberry Hill", "Blurred Lines", "Body & Soul", "Bohemian Rhapsody", "Boogie Oogie Oogie", "Boogie Woogie Bugle Boy", "Boom Boom Pow", "Born in the USA", "Born to Be Wild", "Born to Run", "Boulevard of Broken Dreams", "Brand New Key", "Brandy (You're A Fine Girl)", "Breaking Up is Hard to Do", "Breathe", "Bridge Over Troubled Water", "Brother Louie", "Brother, Can You Spare a Dime?", "Brown Eyed Girl", "Brown Sugar", "Build Me Up Buttercup", "Burn", "Buttons & Bows", "Bye Bye Love", "Bye Bye, Blackbird", "Bye, Bye, Bye", "Caldonia Boogie (What Makes Your Big Head So Hard)", "California Dreamin'", "California Girls", "Call Me", "Call Me Maybe", "Can You Feel the Love Tonight", "Can't Buy Me Love", "Can't Get Enough of Your Love, Babe", "Can't Help Falling in Love", "Candle in the Wind '97", "Candy Man", "Car Wash", "Careless Whisper", "Cars", "Cat's in the Cradle", "Cathy's Clown", "Celebration", "Centerfold", "Chain of Fools", "Chances Are", "Change the World", "Chapel of Love", "Chattanooga Choo Choo", "Chattanoogie Shoe-Shine Boy", "Check On It", "Cheek to Cheek", "Cherish", "Cherry Pink & Apple Blossom White", "Cold, Cold Heart", "Colors of the Wind", "Come On Eileen", "Come On-a My House", "Come Together", "Coming Up", "Cracklin' Rosie", "Crazy", "Crazy For You", "Crazy Little Thing Called Love", "Crazy in Love", "Creep", "Crimson & Clover", "Crocodile Rock", "Cry", "Cry Like a Baby", "Crying", "Da Doo Ron Ron (When He Walked Me Home)", "Dance to the Music", "Dancing Queen", "Dancing in the Dark", "Dancing in the Street", "Dardanella", "Daydream Believer", "December 1963 (Oh What a Night)", "Delicado", "Dilemma", "Disco Duck", "Disco Lady", "Disturbia", "Dizzy", "Do That to Me One More Time", "Do Wah Diddy Diddy", "Do Ya Think I'm Sexy?", "Do You Love Me?", "Don't Be Cruel", "Don't Fence Me In", "Don't Go Breaking My Heart", "Don't Leave Me This Way", "Don't Let the Stars Get in Your Eyes", "Don't Let the Sun Go Down On Me", "Don't Speak", "Don't Stop 'Til You Get Enough", "Don't Worry Be Happy", "Don't You (Forget About Me)", "Don't You Want Me", "Doo Wop (That Thing)", "Down", "Down Hearted Blues", "Down Under", "Downtown", "Dreamlover", "Dreams", "Drop it Like It's Hot", "Drops of Jupiter (Tell Me)", "Duke of Earl", "E.T.", "Earth Angel", "Ebony & Ivory", "Eight Days a Week", "Empire State Of Mind", "End of the Road", "Endless Love", "Escape (The Pina Colada Song)", "Eve of Destruction", "Every Breath You Take", "Every Little Thing She Does is Magic", "Everybody Loves Somebody", "Everybody Wants to Rule the World", "Everyday People", "Eye of the Tiger", "Faith", "Fallin'", "Fame", "Family Affair", "Fantasy", "Fast Car", "Feel Good Inc", "Feel Like Making Love", "Fire & Rain", "Firework", "Flashdance. What a Feeling", "Fly Robin Fly", "Foolish Games", "Footloose", "For What It's Worth (Stop, Hey What's That Sound)", "Fortunate Son", "Frankenstein", "Freak Me", "Freebird", "Frenesi", "Funkytown", "Gangsta's Paradise", "Georgia On My Mind", "Georgy Girl", "Get Back", "Get Down Tonight", "Get Off of My Cloud", "Ghostbusters", "Gimme Some Lovin'", "Girls Just Wanna Have Fun", "Give Me Everything", "Gives You Hell", "Glamorous", "Glory of Love", "Go Your Own Way", "God Bless America", "God Bless the Child", "Gold Digger", "Gonna Make You Sweat (Everybody Dance Now)", "Good Lovin'", "Good Times", "Good Vibrations", "Goodbye Yellow Brick Road", "Goodnight, Irene", "Got to Give it Up", "Grease", "Great Balls of Fire", "Greatest Love of All", "Green Onions", "Green River", "Green Tambourine", "Grenade", "Groove is in the Heart", "Groovin'", "Gypsies, Tramps & Thieves", "Hair", "Hang On Sloopy", "Hanging by a Moment", "Hanky Panky", "Happy Days Are Here Again", "Happy Together", "Harbour Lights", "Hard to Say I'm Sorry", "Harper Valley PTA", "Have You Ever Really Loved a Woman?", "He'll Have to Go", "He's So Fine", "He's a Rebel", "Heart of Glass", "Heart of Gold", "Heartbreak Hotel", "Hello Dolly", "Hello, I Love You, Won't You Tell Me Your Name?", "Help Me, Rhonda", "Help!", "Here Without You", "Here in My Heart", "Hero", "Hey Baby", "Hey Jude", "Hey Paula", "Hey There", "Hey There Delilah", "Hey Ya!", "Higher Love", "Hips don't lie", "Hit the Road, Jack", "Hold On", "Hollaback Girl", "Honey", "Honky Tonk", "Honky Tonk Woman", "Horse With No Name", "Hot Child In The City", "Hot Stuff", "Hotel California", "Hound Dog", "House of the Rising Sun", "How Deep is Your Love?", "How Do I Live?", "How Do You Mend a Broken Heart", "How High the Moon", "How Much is That Doggy in the Window?", "How Will I Know", "How You Remind Me", "How to Save a Life", "Hungry Heart", "Hurt So Good", "I Believe I Can Fly", "I Can Dream, Can't I?", "I Can Help", "I Can See Clearly Now", "I Can't Get Next to You", "I Can't Get Started", "I Can't Go For That (No Can Do)", "I Can't Help Myself (Sugar Pie, Honey Bunch)", "I Can't Stop Loving You", "I Don't Want to Miss a Thing", "I Fall to Pieces", "I Feel Fine", "I Feel For You", "I Feel Love", "I Get Around", "I Got You (I Feel Good)", "I Got You Babe", "I Gotta Feeling", "I Heard it Through the Grapevine", "I Honestly Love You", "I Just Called to Say I Love You", "I Just Wanna Be Your Everything", "I Kissed A Girl", "I Love Rock 'n' Roll", "I Need You Now", "I Only Have Eyes For You", "I Shot the Sheriff", "I Still Haven't Found What I'm Looking For", "I Swear", "I Think I Love You", "I Walk the Line", "I Wanna Dance With Somebody (Who Loves Me)", "I Wanna Love You", "I Want You Back", "I Want to Hold Your Hand", "I Want to Know What Love Is", "I Went to Your Wedding", "I Will Always Love You", "I Will Follow Him", "I Will Survive", "I Write the Songs", "I'll Be Missing You", "I'll Be There", "I'll Make Love to You", "I'll Never Smile Again", "I'll Take You There", "I'll Walk Alone", "I'll be seeing you", "I'm Looking Over a Four Leaf Clover", "I'm So Lonesome I Could Cry", "I'm Sorry", "I'm Walking Behind You", "I'm Your Boogie Man", "I'm Yours", "I'm a Believer", "I've Heard That Song Before", "If (They Made Me a King)", "If I Didn't Care", "If You Don't Know Me By Now", "If You Leave Me Now", "Imagine", "In Da Club", "In the End", "In the Ghetto", "In the Mood", "In the Summertime", "In the Year 2525 (Exordium & Terminus)", "Incense & Peppermints", "Indian Reservation (The Lament Of The Cherokee Reservation Indian)", "Instant Karma", "Iris", "Ironic", "Irreplaceable", "It Had to Be You", "It's All in the Game", "It's My Party", "It's Now Or Never", "It's Still Rock 'n' Roll to Me", "It's Too Late", "Jack & Diane", "Jailhouse Rock", "Jessie's Girl", "Jive Talkin'", "Johnny B Goode", "Joy to the World", "Judy in Disguise (With Glasses)", "Jump", "Jumpin' Jack Flash", "Just Dance", "Just My Imagination (Running Away With Me)", "Just the Way You Are", "Kansas City", "Karma Chameleon", "Keep On Loving You", "Killing Me Softly With His Song", "King of the Road", "Kiss", "Kiss & Say Goodbye", "Kiss From a Rose", "Kiss Me", "Kiss On My List", "Kiss You All Over", "Knock On Wood", "Knock Three Times", "Kokomo", "Kryptonite", "Kung Fu Fighting", "La Bamba", "Lady", "Lady Marmalade (Voulez-Vous Coucher Aver Moi Ce Soir?)", "Last Train to Clarksville", "Layla", "Le Freak", "Leader of the Pack", "Lean On Me", "Leaving, on a Jet Plane", "Let Me Call You Sweetheart", "Let Me Love You", "Let it Be", "Let it Snow! Let it Snow! Let it Snow!", "Let's Dance", "Let's Get it On", "Let's Groove", "Let's Hear it For the Boy", "Let's Stay Together", "Light My Fire", "Lights", "Like a Prayer", "Like a Rolling Stone", "Like a Virgin", "Little Darlin'", "Little Things Mean a Lot", "Live & Let Die", "Livin' La Vida Loca", "Livin' On a Prayer", "Living For the City", "Locked Out Of Heaven", "Lola", "Lonely Boy", "Long Cool Woman in a Black Dress", "Long Tall Sally", "Look Away", "Lookin' Out My Back Door", "Lose Yourself", "Losing My Religion", "Louie Louie", "Love Child", "Love Hangover", "Love In This Club", "Love Is Blue (L'Amour Est Bleu)", "Love Letters in the Sand", "Love Me Do", "Love Me Tender", "Love Shack", "Love Theme From 'A Star is Born' (Evergreen)", "Love Train", "Love Will Keep Us Together", "Love is a Many Splendoured Thing", "Love to Love You Baby", "Love's Theme", "Loving You", "Low", "Macarena", "Mack the Knife", "Maggie May", "Magic", "Magic Carpet Ride", "Make Love to Me", "Make it With You", "Makin' Whoopee", "Mama Told Me Not to Come", "Man in the Mirror", "Manana (Is Soon Enough For Me)", "Maneater", "Maniac", "Maybellene", "Me & Bobby McGee", "Me & Mrs Jones", "Memories Are Made of This", "Mercy Mercy Me (The Ecology)", "Mickey", "Midnight Train to Georgia", "Minnie the Moocher", "Miss You", "Miss You Much", "Mister Sandman", "Mmmbop", "Mona Lisa", "Monday Monday", "Money For Nothing", "Mony Mony", "Mood Indigo", "Moonlight Cocktail", "Moonlight Serenade", "More Than Words", "More Than a Feeling", "Morning Train (Nine to Five)", "Mr Big Stuff", "Mr Brightside", "Mr Tambourine Man", "Mrs Brown You've Got a Lovely Daughter", "Mrs Robinson", "Mule Train", "Music", "My Blue Heaven", "My Boyfriend's Back", "My Eyes Adored You", "My Girl", "My Guy", "My Heart Will Go On", "My Life", "My Love", "My Man", "My Prayer", "My Sharona", "My Sweet Lord", "Na Na Hey Hey (Kiss Him Goodbye)", "Nature Boy", "Near You", "Need You Now", "Need You Tonight", "Never Gonna Give You Up", "Night & Day", "Night Fever", "Nights in White Satin", "No One", "No Scrubs", "Nobody Does it Better", "Nothin' on You", "Nothing Compares 2 U", "Nothing's Gonna Stop Us Now", "Ode To Billie Joe", "Oh Happy Day", "Oh My Papa (O Mein Papa)", "Oh, Pretty Woman", "Ol' Man River", "Ole Buttermilk Sky", "On Bended Knee", "On My Own", "On the Atchison, Topeka & the Santa Fe", "One", "One Bad Apple", "One More Try", "One O'Clock Jump", "One Sweet Day", "One of These Nights", "One of Us", "Only The Lonely (Know The Way I Feel)", "Only You (And You Alone)", "Open Arms", "Over There", "Over the Rainbow", "Paint it Black", "Papa Don't Preach", "Papa Was a Rolling Stone", "Papa's Got a Brand New Bag", "Paper Doll", "Paper Planes", "Paperback Writer", "Party Rock Anthem", "Peg o' My Heart", "Peggy Sue", "Pennies From Heaven", "Penny Lane", "People", "People Got to Be Free", "Personality", "Philadelphia Freedom", "Physical", "Piano Man", "Pick Up the Pieces", "Pistol Packin' Mama", "Play That Funky Music", "Please Mr Postman", "Poker Face", "Pon De Replay", "Pony Time", "Pop Muzik", "Prisoner of Love", "Private Eyes", "Promiscuous", "Proud Mary", "Purple Haze", "Purple Rain", "Puttin' on the Ritz", "Que sera sera (Whatever will be will be)", "Queen of Hearts", "Rag Doll", "Rag Mop", "Rags to Riches", "Raindrops Keep Falling On My Head", "Rapture", "Ray of Light", "Reach Out (I'll Be There)", "Red Red Wine", "Rehab", "Respect", "Return to Sender", "Reunited", "Revolution", "Rhapsody in Blue", "Rhinestone Cowboy", "Rich Girl", "Riders On the Storm", "Right Back Where We Started From", "Ring My Bell", "Ring of Fire", "Rock Around the Clock", "Rock With You", "Rock Your Baby", "Rock the Boat", "Rock the Casbah", "Roll Over Beethoven", "Roll With It", "Rolling In The Deep", "Rosanna", "Roses Are Red", "Royals", "Ruby Tuesday", "Rudolph, the Red-Nosed Reindeer", "Rum & Coca-Cola", "Runaround Sue", "Runaway", "Running Scared", "Rush Rush", "Sailing", "Save the Best For Last", "Save the Last Dance For Me", "Say It Right", "Say My Name", "Say Say Say", "Say You, Say Me", "School's Out", "Seasons in the Sun", "Secret Love", "Sentimental Journey", "Sexyback", "Sh-Boom (Life Could Be a Dream)", "Shadow Dancing", "Shake Down", "Shake You Down", "She Drives Me Crazy", "She Loves You", "She's a Lady", "Shining Star", "Shop Around", "Shout", "Silly Love Songs", "Since U Been Gone", "Sing, Sing, Sing (With A Swing)", "Singing The Blues", "Single Ladies (Put A Ring On It)", "Sir Duke", "Sixteen Tons", "Sledgehammer", "Sleep Walk", "Sleepy Lagoon", "Slow Poke", "Smells Like Teen Spirit", "Smoke Gets in Your Eyes", "Smoke On the Water", "Smoke! Smoke! Smoke! (That Cigarette)", "Smooth", "So Much in Love", "Soldier Boy", "Some Enchanted Evening", "Some of These Days", "Somebody That I Used to Know", "Somebody to Love", "Someday", "Somethin' Stupid", "Something", "Soul Man", "Spanish Harlem", "Spill the Wine", "Spinning Wheel", "Spirit in the Sky", "St George & the Dragonette", "St Louis Blues", "Stagger Lee", "Stairway to Heaven", "Stand By Me", "Stardust", "Stars & Stripes Forever", "Stay (I Missed You)", "Stayin' Alive", "Stop! in the Name of Love", "Stormy Weather (Keeps Rainin' All the Time)", "Straight Up", "Strange Fruit", "Stranger On the Shore", "Strangers in the Night", "Strawberry Fields Forever", "Streets of Philadelphia", "Stronger", "Stuck On You", "Sugar Shack", "Sugar Sugar", "Summer in the City", "Summertime Blues", "Sunday, Monday or Always", "Sunshine Superman", "Sunshine of Your Love", "Superstar", "Superstition", "Surfin' USA", "Suspicious Minds", "Swanee", "Sweet Caroline (Good Times Never Seemed So Good)", "Sweet Child O' Mine", "Sweet Dreams (Are Made of This)", "Sweet Georgia Brown", "Sweet Home Alabama", "Sweet Soul Music", "Swinging On a Star", "T For Texas (Blue Yodel No 1)", "TSOP (The Sound of Philadelphia)", "Take Me Home, Country Roads", "Take My Breath Away", "Take On Me", "Take The 'A' Train", "Take a Bow", "Tammy", "Tangerine", "Tears in Heaven", "Tears of a Clown", "Temperature", "Tennessee Waltz", "Tequila", "Tha Crossroads", "Thank You (Falettinme be Mice Elf Again)", "That Lucky Old Sun (Just Rolls Around Heaven All Day)", "That Old Black Magic", "That'll Be the Day", "That's Amore", "That's What Friends Are For", "That's the Way (I Like It)", "That's the Way Love Goes", "The Boy is Mine", "The Boys of Summer", "The Christmas Song (Chestnuts Roasting On An Open Fire)", "The End of the World", "The First Time Ever I Saw Your Face", "The Girl From Ipanema", "The Glow-Worm", "The Great Pretender", "The Gypsy", "The Hustle", "The Joker", "The Last Dance", "The Letter", "The Loco-Motion", "The Long & Winding Road", "The Love You Save", "The Morning After", "The Power of Love", "The Prisoner's Song", "The Reason", "The Rose", "The Sign", "The Song From Moulin Rouge (Where Is Your Heart)", "The Sounds of Silence", "The Streak", "The Sweet Escape", "The Thing", "The Tide is High", "The Tracks of My Tears", "The Twist", "The Wanderer", "The Way We Were", "The Way You Look Tonight", "The Way You Move", "Theme From 'A Summer Place'", "Theme From 'Greatest American Hero' (Believe It Or Not)", "Theme From 'Shaft'", "There goes my baby", "These Boots Are Made For Walking", "Third Man Theme", "This Diamond Ring", "This Guy's in Love With You", "This Land is Your Land", "This Love", "This Ole House", "This Used to Be My Playground", "Three Coins in the Fountain", "Three Times a Lady", "Thrift Shop", "Thriller", "Ticket to Ride", "Tie a Yellow Ribbon 'round the Old Oak Tree", "Tiger Rag", "Tighten Up", "Tik-Toc", "Till I Waltz Again With You", "Till The End of Time", "Time After Time", "Time of the Season", "To Sir, with Love", "Tom Dooley", "Tonight's the Night (Gonna Be Alright)", "Too Close", "Too Young", "Tossing & Turning", "Total Eclipse of the Heart", "Touch Me", "Toxic", "Travellin' Band", "Travellin' Man", "Truly Madly Deeply", "Turn! Turn! Turn! (To Everything There is a Season)", "Tutti Frutti", "Twist & Shout", "Two Hearts", "U Can't Touch This", "U Got it Bad", "Umbrella", "Un-Break My Heart", "Unbelievable", "Unchained Melody", "Uncle Albert (Admiral Halsey)", "Under the Boardwalk", "Under the Bridge", "Unforgettable", "Up Around the Bend", "Up Up & Away", "Up Where We Belong", "Upside Down", "Use Somebody", "Vaya Con Dios (may God Be With You)", "Venus", "Vision of Love", "Viva La Vida", "Vogue", "Volare", "Wabash Cannonball", "Waiting For a Girl Like You", "Wake Me Up Before You Go Go", "Wake Up Little Susie", "Walk Don't Run", "Walk Like a Man", "Walk Like an Egyptian", "Walk On By", "Walk On the Wild Side", "Walk This Way", "Wannabe", "Want Ads", "Wanted", "War", "Waterfalls", "Wayward Wind", "We Are Family", "We Are Young", "We Are the Champions", "We Are the World", "We Belong Together", "We Built This City", "We Can Work it Out", "We Didn't Start the Fire", "We Found Love", "We Got The Beat", "We Will Rock You", "We've Only Just Begun", "Weak", "Wedding Bell Blues", "West End Blues", "West End Girls", "What Goes Around Comes Around", "What a Fool Believes", "What'd I Say", "What's Going On?", "What's Love Got to Do With It?", "Whatcha Say", "Wheel of Fortune", "When Doves Cry", "When You Wish Upon a Star", "When a Man Loves a Woman", "Where Did Our Love Go", "Where is the Love?", "Whip It", "Whispering", "White Christmas", "White Rabbit", "Whole Lotta Love", "Whole Lotta Shakin' Goin' On", "Whoomp! (There it Is)", "Why Do Fools Fall in Love?", "Why Don't You Believe Me?", "Wichita Lineman", "Wicked Game", "Wild Thing", "Wild Wild West", "Will It Go Round In Circles", "Will You Love Me Tomorrow", "Winchester Cathedral", "Wind Beneath My Wings", "Wipe Out", "Wishing Well", "With Or Without You", "Without Me", "Without You", "Woman", "Won't Get Fooled Again", "Wooly Bully", "Working My Way Back to You", "YMCA", "Yakety Yak", "Yeah!", "Yellow Rose of Texas", "Yesterday", "You Ain't Seen Nothin' Yet", "You Always Hurt the One You Love", "You Are the Sunshine of My Life", "You Belong With Me", "You Belong to Me", "You Can't Hurry Love", "You Don't Bring Me Flowers", "You Don't Have to Be a Star (To Be in My Show)", "You Light Up My Life", "You Make Me Feel Brand New", "You Make Me Feel Like Dancing", "You Really Got Me", "You Send Me", "You Sexy Thing", "You Were Meant for Me", "You make Me Wanna", "You'll Never Know", "You're Beautiful", "You're So Vain", "You're Still the One", "You're the One That I Want", "You've Got a Friend", "You've Lost That Lovin' Feelin'", "Your Cheatin' Heart", "Your Song"];
var hr = { album: aa, artist: ra, genre: oa, song_name: na };
var ia = hr;
var ta = ["activist", "artist", "author", "blogger", "business owner", "coach", "creator", "designer", "developer", "dreamer", "educator", "engineer", "entrepreneur", "environmentalist", "film lover", "filmmaker", "foodie", "founder", "friend", "gamer", "geek", "grad", "inventor", "leader", "model", "musician", "nerd", "parent", "patriot", "person", "philosopher", "photographer", "public speaker", "scientist", "singer", "streamer", "student", "teacher", "traveler", "veteran", "writer"];
var la = ["{{person.bio_part}}", "{{person.bio_part}}, {{person.bio_part}}", "{{person.bio_part}}, {{person.bio_part}}, {{person.bio_part}}", "{{person.bio_part}}, {{person.bio_part}}, {{person.bio_part}} {{internet.emoji}}", "{{word.noun}} {{person.bio_supporter}}", "{{word.noun}} {{person.bio_supporter}}  {{internet.emoji}}", "{{word.noun}} {{person.bio_supporter}}, {{person.bio_part}}", "{{word.noun}} {{person.bio_supporter}}, {{person.bio_part}} {{internet.emoji}}"];
var sa = ["advocate", "devotee", "enthusiast", "fan", "junkie", "lover", "supporter"];
var da = { generic: ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aimee", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "D'angelo", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gayle", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"], female: ["Ada", "Adrienne", "Agnes", "Alberta", "Alexandra", "Alexis", "Alice", "Alicia", "Alison", "Allison", "Alma", "Alyssa", "Amanda", "Amber", "Amelia", "Amy", "Ana", "Andrea", "Angel", "Angela", "Angelica", "Angelina", "Angie", "Anita", "Ann", "Anna", "Anne", "Annette", "Annie", "Antoinette", "Antonia", "April", "Arlene", "Ashley", "Audrey", "Barbara", "Beatrice", "Becky", "Belinda", "Bernadette", "Bernice", "Bertha", "Bessie", "Beth", "Bethany", "Betsy", "Betty", "Beulah", "Beverly", "Billie", "Blanca", "Blanche", "Bobbie", "Bonnie", "Brandi", "Brandy", "Brenda", "Bridget", "Brittany", "Brooke", "Camille", "Candace", "Candice", "Carla", "Carmen", "Carol", "Carole", "Caroline", "Carolyn", "Carrie", "Casey", "Cassandra", "Catherine", "Cathy", "Cecelia", "Cecilia", "Celia", "Charlene", "Charlotte", "Chelsea", "Cheryl", "Christie", "Christina", "Christine", "Christy", "Cindy", "Claire", "Clara", "Claudia", "Colleen", "Connie", "Constance", "Cora", "Courtney", "Cristina", "Crystal", "Cynthia", "Daisy", "Dana", "Danielle", "Darla", "Darlene", "Dawn", "Deanna", "Debbie", "Deborah", "Debra", "Delia", "Della", "Delores", "Denise", "Desiree", "Diana", "Diane", "Dianna", "Dianne", "Dixie", "Dolores", "Donna", "Dora", "Doreen", "Doris", "Dorothy", "Ebony", "Edith", "Edna", "Eileen", "Elaine", "Eleanor", "Elena", "Elisa", "Elizabeth", "Ella", "Ellen", "Eloise", "Elsa", "Elsie", "Elvira", "Emily", "Emma", "Erica", "Erika", "Erin", "Erma", "Ernestine", "Essie", "Estelle", "Esther", "Ethel", "Eula", "Eunice", "Eva", "Evelyn", "Faith", "Fannie", "Faye", "Felicia", "Flora", "Florence", "Frances", "Francis", "Freda", "Gail", "Gayle", "Geneva", "Genevieve", "Georgia", "Geraldine", "Gertrude", "Gina", "Ginger", "Gladys", "Glenda", "Gloria", "Grace", "Gretchen", "Guadalupe", "Gwen", "Gwendolyn", "Hannah", "Harriet", "Hattie", "Hazel", "Heather", "Heidi", "Helen", "Henrietta", "Hilda", "Holly", "Hope", "Ida", "Inez", "Irene", "Iris", "Irma", "Isabel", "Jackie", "Jacqueline", "Jacquelyn", "Jaime", "Jamie", "Jan", "Jana", "Jane", "Janet", "Janice", "Janie", "Janis", "Jasmine", "Jean", "Jeanette", "Jeanne", "Jeannette", "Jeannie", "Jenna", "Jennie", "Jennifer", "Jenny", "Jessica", "Jessie", "Jill", "Jo", "Joan", "Joann", "Joanna", "Joanne", "Jodi", "Jody", "Johanna", "Johnnie", "Josefina", "Josephine", "Joy", "Joyce", "Juana", "Juanita", "Judith", "Judy", "Julia", "Julie", "June", "Kara", "Karen", "Kari", "Karla", "Kate", "Katherine", "Kathleen", "Kathryn", "Kathy", "Katie", "Katrina", "Kay", "Kayla", "Kelley", "Kelli", "Kellie", "Kelly", "Kendra", "Kerry", "Kim", "Kimberly", "Krista", "Kristen", "Kristi", "Kristie", "Kristin", "Kristina", "Kristine", "Kristy", "Krystal", "Lana", "Latoya", "Laura", "Lauren", "Laurie", "Laverne", "Leah", "Lee", "Leigh", "Lela", "Lena", "Leona", "Leslie", "Leticia", "Lila", "Lillian", "Lillie", "Linda", "Lindsay", "Lindsey", "Lisa", "Lois", "Lola", "Lora", "Lorena", "Lorene", "Loretta", "Lori", "Lorraine", "Louise", "Lucia", "Lucille", "Lucy", "Lula", "Luz", "Lydia", "Lynda", "Lynette", "Lynn", "Lynne", "Mabel", "Mable", "Madeline", "Mae", "Maggie", "Mamie", "Mandy", "Marcella", "Marcia", "Margaret", "Margarita", "Margie", "Marguerite", "Maria", "Marian", "Marianne", "Marie", "Marilyn", "Marion", "Marjorie", "Marlene", "Marsha", "Marta", "Martha", "Mary", "Maryann", "Mattie", "Maureen", "Maxine", "May", "Megan", "Meghan", "Melanie", "Melba", "Melinda", "Melissa", "Melody", "Mercedes", "Meredith", "Michele", "Michelle", "Mildred", "Mindy", "Minnie", "Miranda", "Miriam", "Misty", "Molly", "Mona", "Monica", "Monique", "Muriel", "Myra", "Myrtle", "Nadine", "Nancy", "Naomi", "Natalie", "Natasha", "Nellie", "Nettie", "Nichole", "Nicole", "Nina", "Nora", "Norma", "Olga", "Olive", "Olivia", "Ollie", "Opal", "Ora", "Pam", "Pamela", "Pat", "Patricia", "Patsy", "Patti", "Patty", "Paula", "Paulette", "Pauline", "Pearl", "Peggy", "Penny", "Phyllis", "Priscilla", "Rachael", "Rachel", "Ramona", "Raquel", "Rebecca", "Regina", "Renee", "Rhonda", "Rita", "Roberta", "Robin", "Robyn", "Rochelle", "Rosa", "Rosalie", "Rose", "Rosemarie", "Rosemary", "Rosie", "Roxanne", "Ruby", "Ruth", "Sabrina", "Sadie", "Sally", "Samantha", "Sandra", "Sandy", "Sara", "Sarah", "Shannon", "Shari", "Sharon", "Shawna", "Sheila", "Shelia", "Shelley", "Shelly", "Sheri", "Sherri", "Sherry", "Sheryl", "Shirley", "Silvia", "Sonia", "Sonja", "Sonya", "Sophia", "Sophie", "Stacey", "Stacy", "Stella", "Stephanie", "Sue", "Susan", "Susie", "Suzanne", "Sylvia", "Tabitha", "Tamara", "Tami", "Tammy", "Tanya", "Tara", "Tasha", "Teresa", "Teri", "Terri", "Terry", "Thelma", "Theresa", "Tiffany", "Tina", "Toni", "Tonya", "Tracey", "Traci", "Tracy", "Tricia", "Valerie", "Vanessa", "Velma", "Vera", "Verna", "Veronica", "Vicki", "Vickie", "Vicky", "Victoria", "Viola", "Violet", "Virginia", "Vivian", "Wanda", "Wendy", "Whitney", "Willie", "Wilma", "Winifred", "Yolanda", "Yvette", "Yvonne"], male: ["Aaron", "Abel", "Abraham", "Adam", "Adrian", "Al", "Alan", "Albert", "Alberto", "Alejandro", "Alex", "Alexander", "Alfonso", "Alfred", "Alfredo", "Allan", "Allen", "Alonzo", "Alton", "Alvin", "Amos", "Andre", "Andres", "Andrew", "Andy", "Angel", "Angelo", "Anthony", "Antonio", "Archie", "Armando", "Arnold", "Arthur", "Arturo", "Aubrey", "Austin", "Barry", "Ben", "Benjamin", "Bennie", "Benny", "Bernard", "Bert", "Bill", "Billy", "Blake", "Bob", "Bobby", "Boyd", "Brad", "Bradford", "Bradley", "Brandon", "Brendan", "Brent", "Brett", "Brian", "Bruce", "Bryan", "Bryant", "Byron", "Caleb", "Calvin", "Cameron", "Carl", "Carlos", "Carlton", "Carroll", "Cary", "Casey", "Cecil", "Cedric", "Cesar", "Chad", "Charles", "Charlie", "Chester", "Chris", "Christian", "Christopher", "Clarence", "Clark", "Claude", "Clay", "Clayton", "Clifford", "Clifton", "Clint", "Clinton", "Clyde", "Cody", "Colin", "Conrad", "Corey", "Cornelius", "Cory", "Courtney", "Craig", "Curtis", "Dale", "Dallas", "Damon", "Dan", "Dana", "Daniel", "Danny", "Darin", "Darnell", "Darrel", "Darrell", "Darren", "Darrin", "Darryl", "Daryl", "Dave", "David", "Dean", "Delbert", "Dennis", "Derek", "Derrick", "Devin", "Dewey", "Dexter", "Domingo", "Dominic", "Dominick", "Don", "Donald", "Donnie", "Doug", "Douglas", "Doyle", "Drew", "Duane", "Dustin", "Dwayne", "Dwight", "Earl", "Earnest", "Ed", "Eddie", "Edgar", "Edmond", "Edmund", "Eduardo", "Edward", "Edwin", "Elbert", "Elias", "Elijah", "Ellis", "Elmer", "Emanuel", "Emilio", "Emmett", "Enrique", "Eric", "Erick", "Erik", "Ernest", "Ernesto", "Ervin", "Eugene", "Evan", "Everett", "Felipe", "Felix", "Fernando", "Floyd", "Forrest", "Francis", "Francisco", "Frank", "Frankie", "Franklin", "Fred", "Freddie", "Frederick", "Fredrick", "Gabriel", "Garrett", "Garry", "Gary", "Gene", "Geoffrey", "George", "Gerald", "Gerard", "Gerardo", "Gilbert", "Gilberto", "Glen", "Glenn", "Gordon", "Grady", "Grant", "Greg", "Gregg", "Gregory", "Guadalupe", "Guillermo", "Gustavo", "Guy", "Harold", "Harry", "Harvey", "Hector", "Henry", "Herbert", "Herman", "Homer", "Horace", "Howard", "Hubert", "Hugh", "Hugo", "Ian", "Ignacio", "Ira", "Irvin", "Irving", "Isaac", "Ismael", "Israel", "Ivan", "Jack", "Jackie", "Jacob", "Jaime", "Jake", "James", "Jamie", "Jan", "Jared", "Jason", "Javier", "Jay", "Jean", "Jeff", "Jeffery", "Jeffrey", "Jerald", "Jeremiah", "Jeremy", "Jermaine", "Jerome", "Jerry", "Jesse", "Jessie", "Jesus", "Jim", "Jimmie", "Jimmy", "Jody", "Joe", "Joel", "Joey", "John", "Johnathan", "Johnnie", "Johnny", "Jon", "Jonathan", "Jonathon", "Jordan", "Jorge", "Jose", "Joseph", "Josh", "Joshua", "Juan", "Julian", "Julio", "Julius", "Justin", "Karl", "Keith", "Kelly", "Kelvin", "Ken", "Kenneth", "Kenny", "Kent", "Kerry", "Kevin", "Kim", "Kirk", "Kristopher", "Kurt", "Kyle", "Lamar", "Lance", "Larry", "Laurence", "Lawrence", "Lee", "Leland", "Leo", "Leon", "Leonard", "Leroy", "Leslie", "Lester", "Levi", "Lewis", "Lionel", "Lloyd", "Lonnie", "Loren", "Lorenzo", "Louis", "Lowell", "Lucas", "Luis", "Luke", "Luther", "Lyle", "Lynn", "Mack", "Malcolm", "Manuel", "Marc", "Marco", "Marcos", "Marcus", "Mario", "Marion", "Mark", "Marlon", "Marshall", "Martin", "Marty", "Marvin", "Mathew", "Matt", "Matthew", "Maurice", "Max", "Melvin", "Merle", "Michael", "Micheal", "Miguel", "Mike", "Milton", "Mitchell", "Morris", "Moses", "Myron", "Nathan", "Nathaniel", "Neal", "Neil", "Nelson", "Nicholas", "Nick", "Nicolas", "Noah", "Noel", "Norman", "Oliver", "Omar", "Orlando", "Orville", "Oscar", "Otis", "Owen", "Pablo", "Pat", "Patrick", "Paul", "Pedro", "Percy", "Perry", "Pete", "Peter", "Phil", "Philip", "Phillip", "Preston", "Rafael", "Ralph", "Ramiro", "Ramon", "Randal", "Randall", "Randolph", "Randy", "Raul", "Ray", "Raymond", "Reginald", "Rene", "Rex", "Ricardo", "Richard", "Rick", "Rickey", "Ricky", "Robert", "Roberto", "Robin", "Roderick", "Rodney", "Rodolfo", "Rogelio", "Roger", "Roland", "Rolando", "Roman", "Ron", "Ronald", "Ronnie", "Roosevelt", "Ross", "Roy", "Ruben", "Rudolph", "Rudy", "Rufus", "Russell", "Ryan", "Salvador", "Salvatore", "Sam", "Sammy", "Samuel", "Santiago", "Santos", "Saul", "Scott", "Sean", "Sergio", "Seth", "Shane", "Shannon", "Shaun", "Shawn", "Sheldon", "Sherman", "Sidney", "Simon", "Spencer", "Stanley", "Stephen", "Steve", "Steven", "Stewart", "Stuart", "Sylvester", "Taylor", "Ted", "Terence", "Terrance", "Terrell", "Terrence", "Terry", "Theodore", "Thomas", "Tim", "Timmy", "Timothy", "Toby", "Todd", "Tom", "Tomas", "Tommie", "Tommy", "Tony", "Tracy", "Travis", "Trevor", "Troy", "Tyler", "Tyrone", "Van", "Vernon", "Victor", "Vincent", "Virgil", "Wade", "Wallace", "Walter", "Warren", "Wayne", "Wendell", "Wesley", "Wilbert", "Wilbur", "Wilfred", "Willard", "William", "Willie", "Willis", "Wilson", "Winston", "Wm", "Woodrow", "Zachary"] };
var ua = ["Agender", "Androgyne", "Androgynous", "Bigender", "Cis female", "Cis male", "Cis man", "Cis woman", "Cis", "Cisgender female", "Cisgender male", "Cisgender man", "Cisgender woman", "Cisgender", "Demi-boy", "Demi-girl", "Demi-man", "Demi-woman", "Demiflux", "Demigender", "F2M", "FTM", "Female to male trans man", "Female to male transgender man", "Female to male transsexual man", "Female to male", "Gender fluid", "Gender neutral", "Gender nonconforming", "Gender questioning", "Gender variant", "Genderflux", "Genderqueer", "Hermaphrodite", "Intersex man", "Intersex person", "Intersex woman", "Intersex", "M2F", "MTF", "Male to female trans woman", "Male to female transgender woman", "Male to female transsexual woman", "Male to female", "Man", "Multigender", "Neither", "Neutrois", "Non-binary", "Omnigender", "Other", "Pangender", "Polygender", "T* man", "T* woman", "Trans female", "Trans male", "Trans man", "Trans person", "Trans woman", "Trans", "Transsexual female", "Transsexual male", "Transsexual man", "Transsexual person", "Transsexual woman", "Transsexual", "Transgender female", "Transgender person", "Transmasculine", "Trigender", "Two* person", "Two-spirit person", "Two-spirit", "Woman", "Xenogender"];
var ca = ["Solutions", "Program", "Brand", "Security", "Research", "Marketing", "Directives", "Implementation", "Integration", "Functionality", "Response", "Paradigm", "Tactics", "Identity", "Markets", "Group", "Division", "Applications", "Optimization", "Operations", "Infrastructure", "Intranet", "Communications", "Web", "Branding", "Quality", "Assurance", "Mobility", "Accounts", "Data", "Creative", "Configuration", "Accountability", "Interactions", "Factors", "Usability", "Metrics"];
var ma = ["Lead", "Senior", "Direct", "Corporate", "Dynamic", "Future", "Product", "National", "Regional", "District", "Central", "Global", "Customer", "Investor", "International", "Legacy", "Forward", "Internal", "Human", "Chief", "Principal"];
var ha = ["{{person.jobDescriptor}} {{person.jobArea}} {{person.jobType}}"];
var ya = ["Supervisor", "Associate", "Executive", "Liaison", "Officer", "Manager", "Engineer", "Specialist", "Director", "Coordinator", "Administrator", "Architect", "Analyst", "Designer", "Planner", "Orchestrator", "Technician", "Developer", "Producer", "Consultant", "Assistant", "Facilitator", "Agent", "Representative", "Strategist"];
var pa = { generic: ["Abbott", "Abernathy", "Abshire", "Adams", "Altenwerth", "Anderson", "Ankunding", "Armstrong", "Auer", "Aufderhar", "Bahringer", "Bailey", "Balistreri", "Barrows", "Bartell", "Bartoletti", "Barton", "Bashirian", "Batz", "Bauch", "Baumbach", "Bayer", "Beahan", "Beatty", "Bechtelar", "Becker", "Bednar", "Beer", "Beier", "Berge", "Bergnaum", "Bergstrom", "Bernhard", "Bernier", "Bins", "Blanda", "Blick", "Block", "Bode", "Boehm", "Bogan", "Bogisich", "Borer", "Bosco", "Botsford", "Boyer", "Boyle", "Bradtke", "Brakus", "Braun", "Breitenberg", "Brekke", "Brown", "Bruen", "Buckridge", "Carroll", "Carter", "Cartwright", "Casper", "Cassin", "Champlin", "Christiansen", "Cole", "Collier", "Collins", "Conn", "Connelly", "Conroy", "Considine", "Corkery", "Cormier", "Corwin", "Cremin", "Crist", "Crona", "Cronin", "Crooks", "Cruickshank", "Cummerata", "Cummings", "D'Amore", "Dach", "Daniel", "Dare", "Daugherty", "Davis", "Deckow", "Denesik", "Dibbert", "Dickens", "Dicki", "Dickinson", "Dietrich", "Donnelly", "Dooley", "Douglas", "Doyle", "DuBuque", "Durgan", "Ebert", "Effertz", "Emard", "Emmerich", "Erdman", "Ernser", "Fadel", "Fahey", "Farrell", "Fay", "Feeney", "Feest", "Feil", "Ferry", "Fisher", "Flatley", "Frami", "Franecki", "Franey", "Friesen", "Fritsch", "Funk", "Gerhold", "Gerlach", "Gibson", "Gislason", "Gleason", "Gleichner", "Glover", "Goldner", "Goodwin", "Gorczany", "Gottlieb", "Goyette", "Grady", "Graham", "Grant", "Green", "Greenfelder", "Greenholt", "Grimes", "Gulgowski", "Gusikowski", "Gutkowski", "Gutmann", "Haag", "Hackett", "Hagenes", "Hahn", "Haley", "Halvorson", "Hamill", "Hammes", "Hand", "Hane", "Hansen", "Harber", "Harris", "Hartmann", "Harvey", "Hauck", "Hayes", "Heaney", "Heathcote", "Hegmann", "Heidenreich", "Heller", "Herman", "Hermann", "Hermiston", "Herzog", "Hessel", "Hettinger", "Hickle", "Hilll", "Hills", "Hilpert", "Hintz", "Hirthe", "Hodkiewicz", "Hoeger", "Homenick", "Hoppe", "Howe", "Howell", "Hudson", "Huel", "Huels", "Hyatt", "Jacobi", "Jacobs", "Jacobson", "Jakubowski", "Jaskolski", "Jast", "Jenkins", "Jerde", "Johns", "Johnson", "Johnston", "Jones", "Kassulke", "Kautzer", "Keebler", "Keeling", "Kemmer", "Kerluke", "Kertzmann", "Kessler", "Kiehn", "Kihn", "Kilback", "King", "Kirlin", "Klein", "Kling", "Klocko", "Koch", "Koelpin", "Koepp", "Kohler", "Konopelski", "Koss", "Kovacek", "Kozey", "Krajcik", "Kreiger", "Kris", "Kshlerin", "Kub", "Kuhic", "Kuhlman", "Kuhn", "Kulas", "Kunde", "Kunze", "Kuphal", "Kutch", "Kuvalis", "Labadie", "Lakin", "Lang", "Langosh", "Langworth", "Larkin", "Larson", "Leannon", "Lebsack", "Ledner", "Leffler", "Legros", "Lehner", "Lemke", "Lesch", "Leuschke", "Lind", "Lindgren", "Littel", "Little", "Lockman", "Lowe", "Lubowitz", "Lueilwitz", "Luettgen", "Lynch", "MacGyver", "Macejkovic", "Maggio", "Mann", "Mante", "Marks", "Marquardt", "Marvin", "Mayer", "Mayert", "McClure", "McCullough", "McDermott", "McGlynn", "McKenzie", "McLaughlin", "Medhurst", "Mertz", "Metz", "Miller", "Mills", "Mitchell", "Moen", "Mohr", "Monahan", "Moore", "Morar", "Morissette", "Mosciski", "Mraz", "Mueller", "Muller", "Murazik", "Murphy", "Murray", "Nader", "Nicolas", "Nienow", "Nikolaus", "Nitzsche", "Nolan", "O'Connell", "O'Conner", "O'Hara", "O'Keefe", "O'Kon", "O'Reilly", "Oberbrunner", "Okuneva", "Olson", "Ondricka", "Orn", "Ortiz", "Osinski", "Pacocha", "Padberg", "Pagac", "Parisian", "Parker", "Paucek", "Pfannerstill", "Pfeffer", "Pollich", "Pouros", "Powlowski", "Predovic", "Price", "Prohaska", "Prosacco", "Purdy", "Quigley", "Quitzon", "Rath", "Ratke", "Rau", "Raynor", "Reichel", "Reichert", "Reilly", "Reinger", "Rempel", "Renner", "Reynolds", "Rice", "Rippin", "Ritchie", "Robel", "Roberts", "Rodriguez", "Rogahn", "Rohan", "Rolfson", "Romaguera", "Roob", "Rosenbaum", "Rowe", "Ruecker", "Runolfsdottir", "Runolfsson", "Runte", "Russel", "Rutherford", "Ryan", "Sanford", "Satterfield", "Sauer", "Sawayn", "Schaden", "Schaefer", "Schamberger", "Schiller", "Schimmel", "Schinner", "Schmeler", "Schmidt", "Schmitt", "Schneider", "Schoen", "Schowalter", "Schroeder", "Schulist", "Schultz", "Schumm", "Schuppe", "Schuster", "Senger", "Shanahan", "Shields", "Simonis", "Sipes", "Skiles", "Smith", "Smitham", "Spencer", "Spinka", "Sporer", "Stamm", "Stanton", "Stark", "Stehr", "Steuber", "Stiedemann", "Stokes", "Stoltenberg", "Stracke", "Streich", "Stroman", "Strosin", "Swaniawski", "Swift", "Terry", "Thiel", "Thompson", "Tillman", "Torp", "Torphy", "Towne", "Toy", "Trantow", "Tremblay", "Treutel", "Tromp", "Turcotte", "Turner", "Ullrich", "Upton", "Vandervort", "Veum", "Volkman", "Von", "VonRueden", "Waelchi", "Walker", "Walsh", "Walter", "Ward", "Waters", "Watsica", "Weber", "Wehner", "Weimann", "Weissnat", "Welch", "West", "White", "Wiegand", "Wilderman", "Wilkinson", "Will", "Williamson", "Willms", "Windler", "Wintheiser", "Wisoky", "Wisozk", "Witting", "Wiza", "Wolf", "Wolff", "Wuckert", "Wunsch", "Wyman", "Yost", "Yundt", "Zboncak", "Zemlak", "Ziemann", "Zieme", "Zulauf"] };
var ga = { generic: [{ value: "{{person.last_name.generic}}", weight: 95 }, { value: "{{person.last_name.generic}}-{{person.last_name.generic}}", weight: 5 }] };
var ba = { generic: ["Addison", "Alex", "Anderson", "Angel", "Arden", "August", "Austin", "Avery", "Bailey", "Billie", "Blake", "Bowie", "Brooklyn", "Cameron", "Charlie", "Corey", "Dakota", "Drew", "Elliott", "Ellis", "Emerson", "Finley", "Gray", "Greer", "Harper", "Hayden", "Jaden", "James", "Jamie", "Jordan", "Jules", "Kai", "Kendall", "Kennedy", "Kyle", "Leslie", "Logan", "London", "Marlowe", "Micah", "Nico", "Noah", "North", "Parker", "Phoenix", "Quinn", "Reagan", "Reese", "Reign", "Riley", "River", "Robin", "Rory", "Rowan", "Ryan", "Sage", "Sasha", "Sawyer", "Shawn", "Shiloh", "Skyler", "Taylor"], female: ["Abigail", "Adele", "Alex", "Alice", "Alisha", "Amber", "Amelia", "Amora", "Ana\xEFs", "Angelou", "Anika", "Anise", "Annabel", "Anne", "Aphrodite", "Aretha", "Arya", "Ashton", "Aster", "Audrey", "Avery", "Bailee", "Bay", "Belle", "Beth", "Billie", "Blair", "Blaise", "Blake", "Blanche", "Blue", "Bree", "Brielle", "Brienne", "Brooke", "Caleen", "Candice", "Caprice", "Carelyn", "Caylen", "Celine", "Cerise", "Cia", "Claire", "Claudia", "Clementine", "Coral", "Coraline", "Dahlia", "Dakota", "Dawn", "Della", "Demi", "Denise", "Denver", "Devine", "Devon", "Diana", "Dylan", "Ebony", "Eden", "Eleanor", "Elein", "Elizabeth", "Ellen", "Elodie", "Eloise", "Ember", "Emma", "Erin", "Eyre", "Faith", "Farrah", "Fawn", "Fayre", "Fern", "France", "Francis", "Frida", "Genisis", "Georgia", "Grace", "Gwen", "Harley", "Harper", "Hazel", "Helen", "Hippolyta", "Holly", "Hope", "Imani", "Iowa", "Ireland", "Irene", "Iris", "Isa", "Isla", "Ivy", "Jade", "Jane", "Jazz", "Jean", "Jess", "Jett", "Jo", "Joan", "Jolie", "Jordan", "Josie", "Journey", "Joy", "Jules", "Julien", "Juliet", "Juniper", "Justice", "Kali", "Karma", "Kat", "Kate", "Kennedy", "Keva", "Kylie", "Lake", "Lane", "Lark", "Layla", "Lee", "Leigh", "Leona", "Lexi", "London", "Lou", "Louise", "Love", "Luna", "Lux", "Lynn", "Lyric", "Maddie", "Mae", "Marie", "Matilda", "Maude", "Maybel", "Meadow", "Medusa", "Mercy", "Michelle", "Mirabel", "Monroe", "Morgan", "Nalia", "Naomi", "Nova", "Olive", "Paige", "Parker", "Pax", "Pearl", "Penelope", "Phoenix", "Quinn", "Rae", "Rain", "Raven", "Ray", "Raye", "Rebel", "Reese", "Reeve", "Regan", "Riley", "River", "Robin", "Rory", "Rose", "Royal", "Ruth", "Rylie", "Sage", "Sam", "Saturn", "Scout", "Serena", "Sky", "Skylar", "Sofia", "Sophia", "Storm", "Sue", "Suzanne", "Sydney", "Taylen", "Taylor", "Teagan", "Tempest", "Tenley", "Thea", "Trinity", "Valerie", "Venus", "Vera", "Violet", "Willow", "Winter", "Xena", "Zaylee", "Zion", "Zoe"], male: ["Ace", "Aiden", "Alexander", "Ander", "Anthony", "Asher", "August", "Aziel", "Bear", "Beckham", "Benjamin", "Buddy", "Calvin", "Carter", "Charles", "Christopher", "Clyde", "Cooper", "Daniel", "David", "Dior", "Dylan", "Elijah", "Ellis", "Emerson", "Ethan", "Ezra", "Fletcher", "Flynn", "Gabriel", "Grayson", "Gus", "Hank", "Harrison", "Hendrix", "Henry", "Houston", "Hudson", "Hugh", "Isaac", "Jack", "Jackson", "Jacob", "Jakobe", "James", "Jaxon", "Jaxtyn", "Jayden", "John", "Joseph", "Josiah", "Jude", "Julian", "Karsyn", "Kenji", "Kobe", "Kylo", "Lennon", "Leo", "Levi", "Liam", "Lincoln", "Logan", "Louis", "Lucas", "Lucky", "Luke", "Mason", "Mateo", "Matthew", "Maverick", "Michael", "Monroe", "Nixon", "Ocean", "Oliver", "Otis", "Otto", "Owen", "Ozzy", "Parker", "Rocky", "Samuel", "Sebastian", "Sonny", "Teddy", "Theo", "Theodore", "Thomas", "Truett", "Walter", "Warren", "Watson", "William", "Wison", "Wyatt", "Ziggy", "Zyair"] };
var Ca = [{ value: "{{person.firstName}} {{person.lastName}}", weight: 49 }, { value: "{{person.prefix}} {{person.firstName}} {{person.lastName}}", weight: 7 }, { value: "{{person.firstName}} {{person.lastName}} {{person.suffix}}", weight: 7 }, { value: "{{person.prefix}} {{person.firstName}} {{person.lastName}} {{person.suffix}}", weight: 1 }];
var Sa = { generic: ["Dr.", "Miss", "Mr.", "Mrs.", "Ms."], female: ["Dr.", "Miss", "Mrs.", "Ms."], male: ["Dr.", "Mr."] };
var ka = ["female", "male"];
var fa = ["Jr.", "Sr.", "I", "II", "III", "IV", "V", "MD", "DDS", "PhD", "DVM"];
var va = ["Aquarius", "Pisces", "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn"];
var yr = { bio_part: ta, bio_pattern: la, bio_supporter: sa, first_name: da, gender: ua, job_area: ca, job_descriptor: ma, job_title_pattern: ha, job_type: ya, last_name: pa, last_name_pattern: ga, middle_name: ba, name: Ca, prefix: Sa, sex: ka, suffix: fa, western_zodiac_sign: va };
var Aa = yr;
var Ba = ["!##-!##-####", "(!##) !##-####", "1-!##-!##-####", "!##.!##.####", "!##-!##-#### x###", "(!##) !##-#### x###", "1-!##-!##-#### x###", "!##.!##.#### x###", "!##-!##-#### x####", "(!##) !##-#### x####", "1-!##-!##-#### x####", "!##.!##.#### x####", "!##-!##-#### x#####", "(!##) !##-#### x#####", "1-!##-!##-#### x#####", "!##.!##.#### x#####"];
var Ta = ["+1!##!######"];
var Ma = ["(!##) !##-####"];
var pr = { human: Ba, international: Ta, national: Ma };
var wa = pr;
var gr = { format: wa };
var La = gr;
var Da = [{ symbol: "H", name: "Hydrogen", atomicNumber: 1 }, { symbol: "He", name: "Helium", atomicNumber: 2 }, { symbol: "Li", name: "Lithium", atomicNumber: 3 }, { symbol: "Be", name: "Beryllium", atomicNumber: 4 }, { symbol: "B", name: "Boron", atomicNumber: 5 }, { symbol: "C", name: "Carbon", atomicNumber: 6 }, { symbol: "N", name: "Nitrogen", atomicNumber: 7 }, { symbol: "O", name: "Oxygen", atomicNumber: 8 }, { symbol: "F", name: "Fluorine", atomicNumber: 9 }, { symbol: "Ne", name: "Neon", atomicNumber: 10 }, { symbol: "Na", name: "Sodium", atomicNumber: 11 }, { symbol: "Mg", name: "Magnesium", atomicNumber: 12 }, { symbol: "Al", name: "Aluminium", atomicNumber: 13 }, { symbol: "Si", name: "Silicon", atomicNumber: 14 }, { symbol: "P", name: "Phosphorus", atomicNumber: 15 }, { symbol: "S", name: "Sulfur", atomicNumber: 16 }, { symbol: "Cl", name: "Chlorine", atomicNumber: 17 }, { symbol: "Ar", name: "Argon", atomicNumber: 18 }, { symbol: "K", name: "Potassium", atomicNumber: 19 }, { symbol: "Ca", name: "Calcium", atomicNumber: 20 }, { symbol: "Sc", name: "Scandium", atomicNumber: 21 }, { symbol: "Ti", name: "Titanium", atomicNumber: 22 }, { symbol: "V", name: "Vanadium", atomicNumber: 23 }, { symbol: "Cr", name: "Chromium", atomicNumber: 24 }, { symbol: "Mn", name: "Manganese", atomicNumber: 25 }, { symbol: "Fe", name: "Iron", atomicNumber: 26 }, { symbol: "Co", name: "Cobalt", atomicNumber: 27 }, { symbol: "Ni", name: "Nickel", atomicNumber: 28 }, { symbol: "Cu", name: "Copper", atomicNumber: 29 }, { symbol: "Zn", name: "Zinc", atomicNumber: 30 }, { symbol: "Ga", name: "Gallium", atomicNumber: 31 }, { symbol: "Ge", name: "Germanium", atomicNumber: 32 }, { symbol: "As", name: "Arsenic", atomicNumber: 33 }, { symbol: "Se", name: "Selenium", atomicNumber: 34 }, { symbol: "Br", name: "Bromine", atomicNumber: 35 }, { symbol: "Kr", name: "Krypton", atomicNumber: 36 }, { symbol: "Rb", name: "Rubidium", atomicNumber: 37 }, { symbol: "Sr", name: "Strontium", atomicNumber: 38 }, { symbol: "Y", name: "Yttrium", atomicNumber: 39 }, { symbol: "Zr", name: "Zirconium", atomicNumber: 40 }, { symbol: "Nb", name: "Niobium", atomicNumber: 41 }, { symbol: "Mo", name: "Molybdenum", atomicNumber: 42 }, { symbol: "Tc", name: "Technetium", atomicNumber: 43 }, { symbol: "Ru", name: "Ruthenium", atomicNumber: 44 }, { symbol: "Rh", name: "Rhodium", atomicNumber: 45 }, { symbol: "Pd", name: "Palladium", atomicNumber: 46 }, { symbol: "Ag", name: "Silver", atomicNumber: 47 }, { symbol: "Cd", name: "Cadmium", atomicNumber: 48 }, { symbol: "In", name: "Indium", atomicNumber: 49 }, { symbol: "Sn", name: "Tin", atomicNumber: 50 }, { symbol: "Sb", name: "Antimony", atomicNumber: 51 }, { symbol: "Te", name: "Tellurium", atomicNumber: 52 }, { symbol: "I", name: "Iodine", atomicNumber: 53 }, { symbol: "Xe", name: "Xenon", atomicNumber: 54 }, { symbol: "Cs", name: "Caesium", atomicNumber: 55 }, { symbol: "Ba", name: "Barium", atomicNumber: 56 }, { symbol: "La", name: "Lanthanum", atomicNumber: 57 }, { symbol: "Ce", name: "Cerium", atomicNumber: 58 }, { symbol: "Pr", name: "Praseodymium", atomicNumber: 59 }, { symbol: "Nd", name: "Neodymium", atomicNumber: 60 }, { symbol: "Pm", name: "Promethium", atomicNumber: 61 }, { symbol: "Sm", name: "Samarium", atomicNumber: 62 }, { symbol: "Eu", name: "Europium", atomicNumber: 63 }, { symbol: "Gd", name: "Gadolinium", atomicNumber: 64 }, { symbol: "Tb", name: "Terbium", atomicNumber: 65 }, { symbol: "Dy", name: "Dysprosium", atomicNumber: 66 }, { symbol: "Ho", name: "Holmium", atomicNumber: 67 }, { symbol: "Er", name: "Erbium", atomicNumber: 68 }, { symbol: "Tm", name: "Thulium", atomicNumber: 69 }, { symbol: "Yb", name: "Ytterbium", atomicNumber: 70 }, { symbol: "Lu", name: "Lutetium", atomicNumber: 71 }, { symbol: "Hf", name: "Hafnium", atomicNumber: 72 }, { symbol: "Ta", name: "Tantalum", atomicNumber: 73 }, { symbol: "W", name: "Tungsten", atomicNumber: 74 }, { symbol: "Re", name: "Rhenium", atomicNumber: 75 }, { symbol: "Os", name: "Osmium", atomicNumber: 76 }, { symbol: "Ir", name: "Iridium", atomicNumber: 77 }, { symbol: "Pt", name: "Platinum", atomicNumber: 78 }, { symbol: "Au", name: "Gold", atomicNumber: 79 }, { symbol: "Hg", name: "Mercury", atomicNumber: 80 }, { symbol: "Tl", name: "Thallium", atomicNumber: 81 }, { symbol: "Pb", name: "Lead", atomicNumber: 82 }, { symbol: "Bi", name: "Bismuth", atomicNumber: 83 }, { symbol: "Po", name: "Polonium", atomicNumber: 84 }, { symbol: "At", name: "Astatine", atomicNumber: 85 }, { symbol: "Rn", name: "Radon", atomicNumber: 86 }, { symbol: "Fr", name: "Francium", atomicNumber: 87 }, { symbol: "Ra", name: "Radium", atomicNumber: 88 }, { symbol: "Ac", name: "Actinium", atomicNumber: 89 }, { symbol: "Th", name: "Thorium", atomicNumber: 90 }, { symbol: "Pa", name: "Protactinium", atomicNumber: 91 }, { symbol: "U", name: "Uranium", atomicNumber: 92 }, { symbol: "Np", name: "Neptunium", atomicNumber: 93 }, { symbol: "Pu", name: "Plutonium", atomicNumber: 94 }, { symbol: "Am", name: "Americium", atomicNumber: 95 }, { symbol: "Cm", name: "Curium", atomicNumber: 96 }, { symbol: "Bk", name: "Berkelium", atomicNumber: 97 }, { symbol: "Cf", name: "Californium", atomicNumber: 98 }, { symbol: "Es", name: "Einsteinium", atomicNumber: 99 }, { symbol: "Fm", name: "Fermium", atomicNumber: 100 }, { symbol: "Md", name: "Mendelevium", atomicNumber: 101 }, { symbol: "No", name: "Nobelium", atomicNumber: 102 }, { symbol: "Lr", name: "Lawrencium", atomicNumber: 103 }, { symbol: "Rf", name: "Rutherfordium", atomicNumber: 104 }, { symbol: "Db", name: "Dubnium", atomicNumber: 105 }, { symbol: "Sg", name: "Seaborgium", atomicNumber: 106 }, { symbol: "Bh", name: "Bohrium", atomicNumber: 107 }, { symbol: "Hs", name: "Hassium", atomicNumber: 108 }, { symbol: "Mt", name: "Meitnerium", atomicNumber: 109 }, { symbol: "Ds", name: "Darmstadtium", atomicNumber: 110 }, { symbol: "Rg", name: "Roentgenium", atomicNumber: 111 }, { symbol: "Cn", name: "Copernicium", atomicNumber: 112 }, { symbol: "Nh", name: "Nihonium", atomicNumber: 113 }, { symbol: "Fl", name: "Flerovium", atomicNumber: 114 }, { symbol: "Mc", name: "Moscovium", atomicNumber: 115 }, { symbol: "Lv", name: "Livermorium", atomicNumber: 116 }, { symbol: "Ts", name: "Tennessine", atomicNumber: 117 }, { symbol: "Og", name: "Oganesson", atomicNumber: 118 }];
var Ra = [{ name: "meter", symbol: "m" }, { name: "second", symbol: "s" }, { name: "mole", symbol: "mol" }, { name: "ampere", symbol: "A" }, { name: "kelvin", symbol: "K" }, { name: "candela", symbol: "cd" }, { name: "kilogram", symbol: "kg" }, { name: "radian", symbol: "rad" }, { name: "hertz", symbol: "Hz" }, { name: "newton", symbol: "N" }, { name: "pascal", symbol: "Pa" }, { name: "joule", symbol: "J" }, { name: "watt", symbol: "W" }, { name: "coulomb", symbol: "C" }, { name: "volt", symbol: "V" }, { name: "ohm", symbol: "\u03A9" }, { name: "tesla", symbol: "T" }, { name: "degree Celsius", symbol: "\xB0C" }, { name: "lumen", symbol: "lm" }, { name: "becquerel", symbol: "Bq" }, { name: "gray", symbol: "Gy" }, { name: "sievert", symbol: "Sv" }, { name: "steradian", symbol: "sr" }, { name: "farad", symbol: "F" }, { name: "siemens", symbol: "S" }, { name: "weber", symbol: "Wb" }, { name: "henry", symbol: "H" }, { name: "lux", symbol: "lx" }, { name: "katal", symbol: "kat" }];
var br = { chemical_element: Da, unit: Ra };
var Pa = br;
var Ha = ["ants", "bats", "bears", "bees", "birds", "buffalo", "cats", "chickens", "cattle", "dogs", "dolphins", "ducks", "elephants", "fishes", "foxes", "frogs", "geese", "goats", "horses", "kangaroos", "lions", "monkeys", "owls", "oxen", "penguins", "people", "pigs", "rabbits", "sheep", "tigers", "whales", "wolves", "zebras", "banshees", "crows", "black cats", "chimeras", "ghosts", "conspirators", "dragons", "dwarves", "elves", "enchanters", "exorcists", "sons", "foes", "giants", "gnomes", "goblins", "gooses", "griffins", "lycanthropes", "nemesis", "ogres", "oracles", "prophets", "sorcerors", "spiders", "spirits", "vampires", "warlocks", "vixens", "werewolves", "witches", "worshipers", "zombies", "druids"];
var Wa = ["{{location.state}} {{team.creature}}"];
var Cr = { creature: Ha, name: Wa };
var Ga = Cr;
var Fa = ["Adventure Road Bicycle", "BMX Bicycle", "City Bicycle", "Cruiser Bicycle", "Cyclocross Bicycle", "Dual-Sport Bicycle", "Fitness Bicycle", "Flat-Foot Comfort Bicycle", "Folding Bicycle", "Hybrid Bicycle", "Mountain Bicycle", "Recumbent Bicycle", "Road Bicycle", "Tandem Bicycle", "Touring Bicycle", "Track/Fixed-Gear Bicycle", "Triathlon/Time Trial Bicycle", "Tricycle"];
var Na = ["Diesel", "Electric", "Gasoline", "Hybrid"];
var Ea = ["Aston Martin", "Audi", "BMW", "BYD", "Bentley", "Bugatti", "Cadillac", "Chevrolet", "Chrysler", "Citro\xEBn", "Dodge", "Ferrari", "Fiat", "Ford", "Honda", "Hyundai", "Jaguar", "Jeep", "Kia", "Lamborghini", "Land Rover", "MG", "Mahindra & Mahindra", "Maruti", "Maserati", "Mazda", "Mercedes Benz", "Mini", "Mitsubishi", "NIO", "Nissan", "Peugeot", "Polestar", "Porsche", "Renault", "Rivian", "Rolls Royce", "Skoda", "Smart", "Subaru", "Suzuki", "Tata", "Tesla", "Toyota", "Vauxhall", "Volkswagen", "Volvo"];
var Ja = ["1", "2", "911", "A4", "A8", "ATS", "Accord", "Alpine", "Altima", "Aventador", "Beetle", "CTS", "CX-9", "Camaro", "Camry", "Challenger", "Charger", "Civic", "Colorado", "Corvette", "Countach", "Cruze", "Durango", "El Camino", "Element", "Escalade", "Expedition", "Explorer", "F-150", "Fiesta", "Focus", "Fortwo", "Golf", "Grand Caravan", "Grand Cherokee", "Impala", "Jetta", "Land Cruiser", "LeBaron", "Malibu", "Mercielago", "Model 3", "Model S", "Model T", "Model X", "Model Y", "Mustang", "PT Cruiser", "Prius", "Ranchero", "Roadster", "Sentra", "Silverado", "Spyder", "Taurus", "V90", "Volt", "Wrangler", "XC90", "XTS"];
var Ia = ["Cargo Van", "Convertible", "Coupe", "Crew Cab Pickup", "Extended Cab Pickup", "Hatchback", "Minivan", "Passenger Van", "SUV", "Sedan", "Wagon"];
var Sr = { bicycle_type: Fa, fuel: Na, manufacturer: Ea, model: Ja, type: Ia };
var Ka = Sr;
var Oa = ["abandoned", "able", "acceptable", "acclaimed", "accomplished", "accurate", "aching", "acidic", "actual", "admired", "adolescent", "advanced", "affectionate", "afraid", "aged", "aggravating", "aggressive", "agile", "agitated", "agreeable", "ajar", "alarmed", "alert", "alienated", "alive", "all", "altruistic", "amazing", "ambitious", "ample", "amused", "angelic", "anguished", "animated", "annual", "another", "antique", "any", "apprehensive", "appropriate", "apt", "arid", "artistic", "ashamed", "assured", "astonishing", "athletic", "austere", "authentic", "authorized", "avaricious", "average", "aware", "awesome", "awful", "babyish", "back", "bad", "baggy", "bare", "basic", "beloved", "beneficial", "best", "better", "big", "biodegradable", "bitter", "black", "black-and-white", "blank", "blaring", "bleak", "blind", "blond", "blue", "blushing", "bogus", "boiling", "bony", "boring", "bossy", "both", "bouncy", "bowed", "brave", "breakable", "bright", "brilliant", "brisk", "broken", "brown", "bruised", "bulky", "burdensome", "burly", "bustling", "busy", "buttery", "buzzing", "calculating", "candid", "carefree", "careless", "caring", "cautious", "cavernous", "celebrated", "charming", "cheap", "cheerful", "chilly", "chubby", "circular", "classic", "clean", "clear", "clear-cut", "close", "closed", "cloudy", "clueless", "clumsy", "cluttered", "coarse", "colorful", "colorless", "colossal", "comfortable", "common", "compassionate", "competent", "complete", "complicated", "concerned", "concrete", "confused", "considerate", "content", "cool", "cooperative", "coordinated", "corny", "corrupt", "courageous", "courteous", "crafty", "crazy", "creamy", "creative", "criminal", "critical", "crooked", "crowded", "cruel", "crushing", "cuddly", "cultivated", "cumbersome", "curly", "cute", "damaged", "damp", "dapper", "dark", "darling", "dazzling", "dead", "deadly", "deafening", "dearest", "decent", "decisive", "deep", "defenseless", "defensive", "deficient", "definite", "definitive", "delectable", "delicious", "delirious", "dense", "dental", "dependable", "dependent", "descriptive", "deserted", "determined", "devoted", "different", "difficult", "digital", "diligent", "dim", "direct", "dirty", "discrete", "disloyal", "dismal", "distant", "distinct", "distorted", "doting", "downright", "drab", "dramatic", "dreary", "dual", "dull", "dutiful", "each", "early", "earnest", "easy", "ecstatic", "edible", "educated", "elastic", "elderly", "electric", "elegant", "elementary", "elliptical", "eminent", "emotional", "empty", "enchanted", "enchanting", "energetic", "enlightened", "enraged", "entire", "equatorial", "essential", "esteemed", "ethical", "everlasting", "every", "evil", "exalted", "excellent", "excitable", "excited", "exhausted", "exotic", "expensive", "experienced", "expert", "extra-large", "extroverted", "failing", "faint", "fair", "fake", "familiar", "fantastic", "far", "far-flung", "far-off", "faraway", "fat", "fatal", "fatherly", "favorable", "favorite", "fearless", "feline", "filthy", "fine", "finished", "firm", "first", "firsthand", "fixed", "flashy", "flawed", "flawless", "flickering", "flimsy", "flowery", "fluffy", "flustered", "focused", "fond", "foolhardy", "foolish", "forceful", "formal", "forsaken", "fortunate", "fragrant", "frail", "frank", "free", "french", "frequent", "friendly", "frightened", "frilly", "frivolous", "frizzy", "front", "frozen", "frugal", "fruitful", "functional", "funny", "fussy", "fuzzy", "gaseous", "general", "gentle", "genuine", "gifted", "gigantic", "giving", "glaring", "glass", "gleaming", "glittering", "gloomy", "glorious", "glossy", "glum", "golden", "good", "good-natured", "gorgeous", "graceful", "gracious", "grandiose", "granular", "grave", "gray", "great", "greedy", "grim", "grimy", "gripping", "grizzled", "grouchy", "grounded", "growing", "grown", "grubby", "gruesome", "grumpy", "guilty", "gullible", "gummy", "hairy", "handsome", "handy", "happy", "happy-go-lucky", "hard-to-find", "harmful", "hasty", "hateful", "haunting", "heartfelt", "heavenly", "heavy", "hefty", "helpful", "helpless", "hidden", "hoarse", "hollow", "homely", "honorable", "honored", "hopeful", "hospitable", "hot", "huge", "humble", "humiliating", "hungry", "hurtful", "husky", "icy", "ideal", "idealistic", "idolized", "ignorant", "ill", "ill-fated", "illiterate", "illustrious", "imaginary", "imaginative", "immaculate", "immediate", "immense", "impartial", "impassioned", "impeccable", "impish", "impolite", "important", "impossible", "impractical", "impressionable", "impressive", "improbable", "impure", "inborn", "incomparable", "incomplete", "inconsequential", "indelible", "indolent", "inexperienced", "infamous", "infatuated", "inferior", "infinite", "informal", "innocent", "insecure", "insidious", "insignificant", "insistent", "instructive", "intelligent", "intent", "interesting", "internal", "international", "intrepid", "ironclad", "irresponsible", "jagged", "jam-packed", "jaunty", "jealous", "jittery", "joyful", "joyous", "jubilant", "judicious", "juicy", "jumbo", "junior", "juvenile", "kaleidoscopic", "key", "knotty", "knowledgeable", "known", "kooky", "kosher", "lanky", "last", "lasting", "late", "lavish", "lawful", "lazy", "leading", "lean", "left", "legal", "light", "lighthearted", "likable", "likely", "limited", "limp", "limping", "linear", "lined", "liquid", "little", "live", "lively", "livid", "lone", "lonely", "long", "long-term", "lost", "lovable", "lovely", "low", "lucky", "lumbering", "lumpy", "lustrous", "mad", "made-up", "magnificent", "majestic", "major", "male", "mammoth", "married", "marvelous", "massive", "mature", "meager", "mealy", "mean", "measly", "meaty", "mediocre", "medium", "memorable", "menacing", "merry", "messy", "metallic", "mild", "milky", "mindless", "minor", "minty", "miserable", "miserly", "misguided", "mixed", "moist", "monstrous", "monthly", "monumental", "moral", "motionless", "muddy", "muffled", "multicolored", "mundane", "murky", "mushy", "musty", "muted", "mysterious", "narrow", "natural", "naughty", "nautical", "near", "neat", "necessary", "needy", "negative", "neglected", "negligible", "neighboring", "nervous", "new", "next", "nice", "nifty", "nimble", "nippy", "nocturnal", "normal", "noted", "noteworthy", "noxious", "numb", "nutritious", "obedient", "oblong", "obvious", "odd", "oddball", "official", "oily", "old", "old-fashioned", "only", "optimal", "optimistic", "orange", "orderly", "ordinary", "ornate", "ornery", "other", "our", "outgoing", "outlandish", "outlying", "outrageous", "outstanding", "oval", "overcooked", "overdue", "palatable", "pale", "paltry", "parallel", "parched", "partial", "passionate", "pastel", "peaceful", "peppery", "perfumed", "perky", "personal", "pertinent", "pessimistic", "petty", "phony", "physical", "pink", "pitiful", "plain", "pleasant", "pleased", "pleasing", "plump", "pointed", "pointless", "polished", "polite", "political", "poor", "portly", "posh", "possible", "potable", "powerful", "powerless", "practical", "precious", "present", "prestigious", "pretty", "pricey", "prickly", "primary", "prime", "private", "probable", "productive", "profitable", "profuse", "proper", "proud", "prudent", "punctual", "puny", "pure", "purple", "pushy", "putrid", "puzzled", "qualified", "quarrelsome", "quarterly", "queasy", "querulous", "questionable", "quick", "quick-witted", "quiet", "quintessential", "quixotic", "radiant", "ragged", "rapid", "rare", "raw", "realistic", "reasonable", "recent", "reckless", "rectangular", "red", "reflecting", "regal", "regular", "remarkable", "remorseful", "repentant", "respectful", "responsible", "rewarding", "rich", "right", "rigid", "ripe", "roasted", "robust", "rosy", "rotating", "rotten", "rough", "round", "rowdy", "royal", "rubbery", "ruddy", "rundown", "runny", "rural", "rusty", "sad", "salty", "same", "sandy", "sarcastic", "sardonic", "scaly", "scared", "scary", "scented", "scientific", "scornful", "scratchy", "second", "second-hand", "secondary", "secret", "self-assured", "self-reliant", "selfish", "sentimental", "separate", "serene", "serpentine", "severe", "shabby", "shadowy", "shady", "shallow", "shameful", "shameless", "shimmering", "shiny", "shocked", "shoddy", "short", "short-term", "showy", "shrill", "shy", "sick", "silent", "silky", "silver", "similar", "simple", "simplistic", "sinful", "sizzling", "skeletal", "sleepy", "slight", "slimy", "slow", "slushy", "small", "smart", "smoggy", "smooth", "smug", "snappy", "snarling", "sneaky", "sniveling", "snoopy", "sociable", "soft", "soggy", "somber", "some", "sophisticated", "sore", "sorrowful", "soulful", "soupy", "sour", "spanish", "sparkling", "sparse", "specific", "speedy", "spherical", "spiffy", "spirited", "spiteful", "splendid", "spotless", "square", "squeaky", "squiggly", "stable", "staid", "stained", "stale", "standard", "stark", "steel", "steep", "sticky", "stiff", "stingy", "stormy", "straight", "strange", "strict", "strident", "striking", "strong", "stunning", "stupendous", "sturdy", "stylish", "subdued", "submissive", "substantial", "subtle", "suburban", "sudden", "sugary", "sunny", "super", "superb", "superficial", "superior", "supportive", "sure-footed", "surprised", "svelte", "sweet", "swift", "talkative", "tall", "tame", "tangible", "tasty", "tattered", "taut", "tedious", "teeming", "tempting", "tender", "tense", "tepid", "terrible", "that", "these", "thick", "thin", "thorny", "thorough", "those", "thrifty", "tidy", "tight", "timely", "tinted", "tiny", "tired", "torn", "total", "tough", "tragic", "trained", "triangular", "tricky", "trim", "trivial", "troubled", "true", "trusting", "trustworthy", "trusty", "turbulent", "twin", "ugly", "ultimate", "unaware", "uncomfortable", "uncommon", "unconscious", "understated", "uneven", "unfinished", "unfit", "unfortunate", "unhappy", "unhealthy", "uniform", "unimportant", "unique", "unkempt", "unknown", "unlawful", "unlined", "unlucky", "unpleasant", "unrealistic", "unripe", "unruly", "unselfish", "unsightly", "unsteady", "unsung", "untidy", "untimely", "untried", "untrue", "unused", "unusual", "unwelcome", "unwieldy", "unwilling", "unwritten", "upbeat", "upright", "upset", "urban", "usable", "useless", "utilized", "utter", "vague", "vain", "valuable", "variable", "vast", "velvety", "vengeful", "vibrant", "victorious", "violent", "vivacious", "vivid", "voluminous", "warlike", "warm", "warmhearted", "warped", "wasteful", "waterlogged", "watery", "wavy", "wealthy", "weary", "webbed", "wee", "weekly", "weighty", "weird", "well-documented", "well-groomed", "well-lit", "well-made", "well-off", "well-to-do", "well-worn", "which", "whimsical", "whirlwind", "whispered", "white", "whole", "whopping", "wicked", "wide", "wide-eyed", "wiggly", "willing", "wilted", "winding", "windy", "winged", "wise", "witty", "wobbly", "woeful", "wonderful", "wordy", "worldly", "worse", "worst", "worthless", "worthwhile", "worthy", "wrathful", "wretched", "writhing", "wrong", "wry", "yearly", "yellow", "yellowish", "young", "youthful", "yummy", "zany", "zealous", "zesty"];
var xa = ["abnormally", "absentmindedly", "accidentally", "acidly", "actually", "adventurously", "afterwards", "almost", "always", "angrily", "annually", "anxiously", "arrogantly", "awkwardly", "badly", "bashfully", "beautifully", "bitterly", "bleakly", "blindly", "blissfully", "boastfully", "boldly", "bravely", "briefly", "brightly", "briskly", "broadly", "busily", "calmly", "carefully", "carelessly", "cautiously", "certainly", "cheerfully", "clearly", "cleverly", "closely", "coaxingly", "colorfully", "commonly", "continually", "coolly", "correctly", "courageously", "crossly", "cruelly", "curiously", "daily", "daintily", "dearly", "deceivingly", "deeply", "defiantly", "deliberately", "delightfully", "diligently", "dimly", "doubtfully", "dreamily", "easily", "elegantly", "energetically", "enormously", "enthusiastically", "equally", "especially", "even", "evenly", "eventually", "exactly", "excitedly", "extremely", "fairly", "faithfully", "famously", "far", "fast", "fatally", "ferociously", "fervently", "fiercely", "fondly", "foolishly", "fortunately", "frankly", "frantically", "freely", "frenetically", "frightfully", "fully", "furiously", "generally", "generously", "gently", "gladly", "gleefully", "gracefully", "gratefully", "greatly", "greedily", "happily", "hastily", "healthily", "heavily", "helpfully", "helplessly", "highly", "honestly", "hopelessly", "hourly", "hungrily", "immediately", "innocently", "inquisitively", "instantly", "intensely", "intently", "interestingly", "inwardly", "irritably", "jaggedly", "jealously", "joshingly", "jovially", "joyfully", "joyously", "jubilantly", "judgementally", "justly", "keenly", "kiddingly", "kindheartedly", "kindly", "kissingly", "knavishly", "knottily", "knowingly", "knowledgeably", "kookily", "lazily", "less", "lightly", "likely", "limply", "lively", "loftily", "longingly", "loosely", "loudly", "lovingly", "loyally", "madly", "majestically", "meaningfully", "mechanically", "merrily", "miserably", "mockingly", "monthly", "more", "mortally", "mostly", "mysteriously", "naturally", "nearly", "neatly", "needily", "nervously", "never", "nicely", "noisily", "not", "obediently", "obnoxiously", "oddly", "offensively", "officially", "often", "only", "openly", "optimistically", "overconfidently", "owlishly", "painfully", "partially", "patiently", "perfectly", "physically", "playfully", "politely", "poorly", "positively", "potentially", "powerfully", "promptly", "properly", "punctually", "quaintly", "quarrelsomely", "queasily", "questionably", "questioningly", "quicker", "quickly", "quietly", "quirkily", "quizzically", "rapidly", "rarely", "readily", "really", "reassuringly", "recklessly", "regularly", "reluctantly", "repeatedly", "reproachfully", "restfully", "righteously", "rightfully", "rigidly", "roughly", "rudely", "sadly", "safely", "scarcely", "scarily", "searchingly", "sedately", "seemingly", "seldom", "selfishly", "separately", "seriously", "shakily", "sharply", "sheepishly", "shrilly", "shyly", "silently", "sleepily", "slowly", "smoothly", "softly", "solemnly", "solidly", "sometimes", "soon", "speedily", "stealthily", "sternly", "strictly", "successfully", "suddenly", "surprisingly", "suspiciously", "sweetly", "swiftly", "sympathetically", "tenderly", "tensely", "terribly", "thankfully", "thoroughly", "thoughtfully", "tightly", "tomorrow", "too", "tremendously", "triumphantly", "truly", "truthfully", "ultimately", "unabashedly", "unaccountably", "unbearably", "unethically", "unexpectedly", "unfortunately", "unimpressively", "unnaturally", "unnecessarily", "upbeat", "upliftingly", "upright", "upside-down", "upward", "upwardly", "urgently", "usefully", "uselessly", "usually", "utterly", "vacantly", "vaguely", "vainly", "valiantly", "vastly", "verbally", "very", "viciously", "victoriously", "violently", "vivaciously", "voluntarily", "warmly", "weakly", "wearily", "well", "wetly", "wholly", "wildly", "willfully", "wisely", "woefully", "wonderfully", "worriedly", "wrongly", "yawningly", "yearly", "yearningly", "yesterday", "yieldingly", "youthfully"];
var za = ["after", "although", "and", "as", "because", "before", "but", "consequently", "even", "finally", "for", "furthermore", "hence", "how", "however", "if", "inasmuch", "incidentally", "indeed", "instead", "lest", "likewise", "meanwhile", "nor", "now", "once", "or", "provided", "since", "so", "supposing", "than", "that", "though", "till", "unless", "until", "what", "when", "whenever", "where", "whereas", "wherever", "whether", "which", "while", "who", "whoever", "whose", "why", "yet"];
var Va = ["yuck", "oh", "phooey", "blah", "boo", "whoa", "yowza", "huzzah", "boohoo", "fooey", "geez", "pfft", "ew", "ah", "yum", "brr", "hm", "yahoo", "aha", "woot", "drat", "gah", "meh", "psst", "aw", "ugh", "yippee", "eek", "gee", "bah", "gadzooks", "duh", "ha", "mmm", "ouch", "phew", "ack", "uh-huh", "gosh", "hmph", "pish", "zowie", "er", "ick", "oof", "um"];
var Ya = ["CD", "SUV", "abacus", "academics", "accelerator", "accompanist", "account", "accountability", "acquaintance", "ad", "adaptation", "address", "adrenalin", "adult", "advancement", "advertisement", "adviser", "affect", "affiliate", "aftermath", "agreement", "airbus", "aircraft", "airline", "airmail", "airman", "airport", "alb", "alert", "allegation", "alliance", "alligator", "allocation", "almighty", "amendment", "amnesty", "analogy", "angle", "annual", "antelope", "anticodon", "apparatus", "appliance", "approach", "apricot", "arcade", "archaeology", "armchair", "armoire", "asset", "assist", "atrium", "attraction", "availability", "avalanche", "awareness", "babushka", "backbone", "backburn", "bakeware", "bandwidth", "bar", "barge", "baritone", "barracks", "baseboard", "basket", "bathhouse", "bathrobe", "battle", "begonia", "behest", "bell", "bench", "bend", "beret", "best-seller", "bid", "bidet", "bin", "birdbath", "birdcage", "birth", "blight", "blossom", "blowgun", "bob", "bog", "bonfire", "bonnet", "bookcase", "bookend", "boulevard", "bourgeoisie", "bowler", "bowling", "boyfriend", "brace", "bracelet", "bran", "breastplate", "brief", "brochure", "brook", "brush", "bug", "bump", "bungalow", "cafe", "cake", "calculus", "cannon", "cantaloupe", "cap", "cappelletti", "captain", "caption", "carboxyl", "cardboard", "carnival", "case", "casement", "cash", "casket", "cassava", "castanet", "catalyst", "cauliflower", "cellar", "celsius", "cemetery", "ceramic", "ceramics", "certification", "chainstay", "chairperson", "challenge", "championship", "chap", "chapel", "character", "characterization", "charlatan", "charm", "chasuble", "cheese", "cheetah", "chiffonier", "chops", "chow", "cinder", "cinema", "circumference", "citizen", "clamp", "clavicle", "cleaner", "climb", "co-producer", "coal", "coast", "cod", "coil", "coin", "coliseum", "collaboration", "collectivization", "colon", "colonialism", "comestible", "commercial", "commodity", "community", "comparison", "completion", "complication", "compromise", "concentration", "configuration", "confusion", "conservation", "conservative", "consistency", "contractor", "contrail", "convection", "conversation", "cook", "coordination", "cop-out", "cope", "cork", "cornet", "corporation", "corral", "cosset", "costume", "couch", "council", "councilman", "countess", "courtroom", "cow", "creator", "creature", "crest", "cricket", "crocodile", "cross-contamination", "cruelty", "cuckoo", "curl", "custody", "custom", "cutlet", "cutover", "cycle", "daddy", "dandelion", "dash", "daughter", "dead", "decision", "deck", "declaration", "decongestant", "decryption", "deduction", "deed", "deer", "defendant", "density", "department", "dependency", "deployment", "depot", "derby", "descendant", "descent", "design", "designation", "desk", "detective", "devastation", "developing", "developmental", "devil", "diagram", "digestive", "digit", "dime", "director", "disadvantage", "disappointment", "disclosure", "disconnection", "discourse", "dish", "disk", "disposer", "distinction", "diver", "diversity", "dividend", "divine", "doing", "doorpost", "doubter", "draft", "draw", "dream", "dredger", "dress", "drive", "drug", "duffel", "dulcimer", "dusk", "duster", "dwell", "e-mail", "earth", "ecliptic", "ectoderm", "edge", "editor", "effector", "eggplant", "electronics", "elevation", "elevator", "elver", "embarrassment", "embossing", "emergent", "encouragement", "entry", "epic", "equal", "essence", "eternity", "ethyl", "euphonium", "event", "exasperation", "excess", "executor", "exhaust", "expansion", "expense", "experience", "exploration", "extension", "extent", "exterior", "eyebrow", "eyeliner", "farm", "farmer", "fat", "fax", "feather", "fedora", "fellow", "fen", "fencing", "ferret", "festival", "fibre", "filter", "final", "finding", "finer", "finger", "fireplace", "fisherman", "fishery", "fit", "flame", "flat", "fledgling", "flight", "flint", "flood", "flu", "fog", "fold", "folklore", "follower", "following", "foodstuffs", "footrest", "forage", "forager", "forgery", "fork", "formamide", "formation", "formula", "fort", "fowl", "fraudster", "freckle", "freezing", "freight", "fuel", "fun", "fund", "fundraising", "futon", "gallery", "galoshes", "gastropod", "gazebo", "gerbil", "ghost", "giant", "gift", "giggle", "glider", "gloom", "goat", "godfather", "godparent", "going", "goodwill", "governance", "government", "gown", "gradient", "graffiti", "grandpa", "grandson", "granny", "grass", "gray", "gripper", "grouper", "guacamole", "guard", "guidance", "guide", "gym", "gymnast", "habit", "haircut", "halt", "hamburger", "hammock", "handful", "handle", "handover", "harp", "haversack", "hawk", "heartache", "heartbeat", "heating", "hello", "help", "hepatitis", "heroine", "hexagon", "hierarchy", "hippodrome", "honesty", "hoof", "hope", "horde", "hornet", "horst", "hose", "hospitalization", "hovel", "hovercraft", "hubris", "humidity", "humor", "hundred", "hunger", "hunt", "husband", "hutch", "hydrant", "hydrocarbon", "hydrolyse", "hydrolyze", "hyena", "hygienic", "hyphenation", "ice-cream", "icebreaker", "igloo", "ignorance", "illusion", "impact", "import", "importance", "impostor", "in-joke", "incandescence", "independence", "individual", "information", "injunction", "innovation", "insolence", "inspection", "instance", "institute", "instruction", "instructor", "integer", "intellect", "intent", "interchange", "interior", "intervention", "interviewer", "invite", "iridescence", "issue", "jacket", "jazz", "jellyfish", "jet", "jogging", "joy", "juggernaut", "jump", "jungle", "junior", "jury", "kettledrum", "kick", "kielbasa", "kinase", "king", "kiss", "kit", "knickers", "knight", "knitting", "knuckle", "label", "labourer", "lace", "lady", "lamp", "language", "larva", "lashes", "laughter", "lava", "lawmaker", "lay", "leading", "league", "legend", "legging", "legislature", "lender", "license", "lid", "lieu", "lifestyle", "lift", "linseed", "litter", "loaf", "lobster", "longboat", "lotion", "lounge", "louse", "lox", "loyalty", "luck", "lyre", "maestro", "mainstream", "maintainer", "majority", "makeover", "making", "mallard", "management", "manner", "mantua", "marathon", "march", "marimba", "marketplace", "marksman", "markup", "marten", "massage", "masterpiece", "mathematics", "meadow", "meal", "meander", "meatloaf", "mechanic", "median", "membership", "mentor", "merit", "metabolite", "metal", "middle", "midwife", "milestone", "millet", "minion", "minister", "minor", "minority", "mixture", "mobility", "molasses", "mom", "moment", "monasticism", "monocle", "monster", "morbidity", "morning", "mortise", "mountain", "mouser", "mousse", "mozzarella", "muscat", "mythology", "napkin", "necklace", "nectarine", "negotiation", "nephew", "nerve", "netsuke", "newsletter", "newsprint", "newsstand", "nightlife", "noon", "nougat", "nucleotidase", "nudge", "numeracy", "numeric", "nun", "obedience", "obesity", "object", "obligation", "ocelot", "octave", "offset", "oil", "omelet", "onset", "opera", "operating", "optimal", "orchid", "order", "ostrich", "other", "outlaw", "outrun", "outset", "overcoat", "overheard", "overload", "ownership", "pacemaker", "packaging", "paintwork", "palate", "pants", "pantyhose", "papa", "parade", "parsnip", "partridge", "passport", "pasta", "patroller", "pear", "pearl", "pecan", "pendant", "peninsula", "pension", "peony", "pepper", "perfection", "permafrost", "perp", "petal", "petticoat", "pharmacopoeia", "phrase", "pick", "piglet", "pigpen", "pigsty", "pile", "pillbox", "pillow", "pilot", "pine", "pinstripe", "place", "plain", "planula", "plastic", "platter", "platypus", "pleasure", "pliers", "plugin", "plumber", "pneumonia", "pocket-watch", "poetry", "polarisation", "polyester", "pomelo", "pop", "poppy", "popularity", "populist", "porter", "possession", "postbox", "precedent", "premeditation", "premier", "premise", "premium", "pressure", "presume", "priesthood", "printer", "privilege", "procurement", "produce", "programme", "prohibition", "promise", "pronoun", "providence", "provider", "provision", "publication", "publicity", "pulse", "punctuation", "pupil", "puppet", "puritan", "quart", "quinoa", "quit", "railway", "range", "rationale", "ravioli", "rawhide", "reach", "reasoning", "reboot", "receptor", "recommendation", "reconsideration", "recovery", "redesign", "relative", "release", "remark", "reorganisation", "repeat", "replacement", "reporter", "representation", "republican", "request", "requirement", "reservation", "resolve", "resource", "responsibility", "restaurant", "retention", "retrospectivity", "reward", "ribbon", "rim", "riser", "roadway", "role", "rosemary", "roundabout", "rubric", "ruin", "rule", "runway", "rust", "safe", "sailor", "saloon", "sand", "sandbar", "sanity", "sarong", "sauerkraut", "saw", "scaffold", "scale", "scarification", "scenario", "schedule", "schnitzel", "scholarship", "scorn", "scorpion", "scout", "scrap", "scratch", "seafood", "seagull", "seal", "season", "secrecy", "secret", "section", "sediment", "self-confidence", "sermon", "sesame", "settler", "shadowbox", "shark", "shipper", "shore", "shoulder", "sideboard", "siege", "sightseeing", "signature", "silk", "simple", "singing", "skean", "skeleton", "skyline", "skyscraper", "slide", "slime", "slipper", "smog", "smoke", "sock", "soliloquy", "solution", "solvency", "someplace", "sonar", "sonata", "sonnet", "soup", "soybean", "space", "spear", "spirit", "spork", "sport", "spring", "sprinkles", "squid", "stall", "starboard", "statue", "status", "stay", "steak", "steeple", "step", "step-mother", "sticker", "stir-fry", "stitcher", "stock", "stool", "story", "strait", "stranger", "strategy", "straw", "stump", "subexpression", "submitter", "subsidy", "substitution", "suitcase", "summary", "summer", "sunbeam", "sundae", "supplier", "surface", "sushi", "suspension", "sustenance", "swanling", "swath", "sweatshop", "swim", "swine", "swing", "switch", "switchboard", "swordfish", "synergy", "t-shirt", "tabletop", "tackle", "tail", "tapioca", "taro", "tarragon", "taxicab", "teammate", "technician", "technologist", "tectonics", "tenant", "tenement", "tennis", "tentacle", "teriyaki", "term", "testimonial", "testing", "thigh", "thongs", "thorn", "thread", "thunderbolt", "thyme", "tinderbox", "toaster", "tomatillo", "tomb", "tomography", "tool", "tooth", "toothbrush", "toothpick", "topsail", "traditionalism", "traffic", "translation", "transom", "transparency", "trash", "travel", "tray", "trench", "tribe", "tributary", "trick", "trolley", "tuba", "tuber", "tune-up", "turret", "tusk", "tuxedo", "typeface", "typewriter", "unblinking", "underneath", "underpants", "understanding", "unibody", "unique", "unit", "utilization", "valentine", "validity", "valley", "valuable", "vanadyl", "vein", "velocity", "venom", "version", "verve", "vestment", "veto", "viability", "vibraphone", "vibration", "vicinity", "video", "violin", "vision", "vista", "vol", "volleyball", "wafer", "waist", "wallaby", "warming", "wasabi", "waterspout", "wear", "wedding", "whack", "whale", "wheel", "widow", "wilderness", "willow", "window", "wombat", "word", "worth", "wriggler", "yak", "yarmulke", "yeast", "yin", "yogurt", "zebra", "zen"];
var ja = ["a", "abaft", "aboard", "about", "above", "absent", "across", "afore", "after", "against", "along", "alongside", "amid", "amidst", "among", "amongst", "an", "anenst", "anti", "apropos", "apud", "around", "as", "aside", "astride", "at", "athwart", "atop", "barring", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "but", "by", "circa", "concerning", "considering", "despite", "down", "during", "except", "excepting", "excluding", "failing", "following", "for", "forenenst", "from", "given", "in", "including", "inside", "into", "lest", "like", "mid", "midst", "minus", "modulo", "near", "next", "notwithstanding", "of", "off", "on", "onto", "opposite", "out", "outside", "over", "pace", "past", "per", "plus", "pro", "qua", "regarding", "round", "sans", "save", "since", "than", "the", "through", "throughout", "till", "times", "to", "toward", "towards", "under", "underneath", "unlike", "until", "unto", "up", "upon", "versus", "via", "vice", "with", "within", "without", "worth"];
var qa = ["abnegate", "abscond", "abseil", "absolve", "accentuate", "accept", "access", "accessorise", "accompany", "account", "accredit", "achieve", "acknowledge", "acquire", "adjourn", "adjudge", "admonish", "adumbrate", "advocate", "afford", "airbrush", "ameliorate", "amend", "amount", "anaesthetise", "analyse", "anesthetize", "anneal", "annex", "antagonize", "ape", "apologise", "apostrophize", "appertain", "appreciate", "appropriate", "approximate", "arbitrate", "archive", "arraign", "arrange", "ascertain", "ascribe", "assail", "atomize", "attend", "attest", "attribute", "augment", "avow", "axe", "baa", "banish", "bank", "baptise", "battle", "beard", "beep", "behold", "belabor", "bemuse", "besmirch", "bestride", "better", "bewail", "bicycle", "bide", "bind", "biodegrade", "blacken", "blaspheme", "bleach", "blend", "blink", "bliss", "bloom", "bludgeon", "bobble", "boggle", "bolster", "book", "boom", "bootleg", "border", "bore", "boss", "braid", "brand", "brandish", "break", "breed", "broadcast", "broadside", "brood", "browse", "buck", "burgeon", "bus", "butter", "buzzing", "camouflage", "cannibalise", "canter", "cap", "capitalise", "capitalize", "capsize", "card", "carouse", "carp", "carpool", "catalog", "catalyze", "catch", "categorise", "cease", "celebrate", "censor", "certify", "char", "charter", "chase", "chatter", "chime", "chip", "christen", "chromakey", "chunder", "chunter", "cinch", "circle", "circulate", "circumnavigate", "clamor", "clamour", "claw", "cleave", "clinch", "clinking", "clone", "clonk", "coagulate", "coexist", "coincide", "collaborate", "colligate", "colorize", "colour", "comb", "come", "commandeer", "commemorate", "communicate", "compete", "conceal", "conceptualize", "conclude", "concrete", "condense", "cone", "confide", "confirm", "confiscate", "confound", "confute", "congregate", "conjecture", "connect", "consign", "construe", "contradict", "contrast", "contravene", "controvert", "convalesce", "converse", "convince", "convoke", "coop", "cop", "corner", "covenant", "cow", "crackle", "cram", "crank", "creak", "creaking", "cripple", "croon", "cross", "crumble", "crystallize", "culminate", "culture", "curry", "curse", "customise", "cycle", "dally", "dampen", "darn", "debit", "debut", "decide", "decode", "decouple", "decriminalize", "deduce", "deduct", "deflate", "deflect", "deform", "defrag", "degenerate", "degrease", "delete", "delight", "deliquesce", "demob", "demobilise", "democratize", "demonstrate", "denitrify", "deny", "depart", "depend", "deplore", "deploy", "deprave", "depute", "dereference", "describe", "desecrate", "deselect", "destock", "detain", "develop", "devise", "dial", "dicker", "digitize", "dilate", "disapprove", "disarm", "disbar", "discontinue", "disgorge", "dishearten", "dishonor", "disinherit", "dislocate", "dispense", "display", "dispose", "disrespect", "dissemble", "ditch", "divert", "dock", "doodle", "downchange", "downshift", "dowse", "draft", "drag", "drain", "dramatize", "drowse", "drum", "dwell", "economise", "edge", "efface", "egg", "eke", "electrify", "embalm", "embed", "embody", "emboss", "emerge", "emphasise", "emphasize", "emulsify", "encode", "endow", "enfold", "engage", "engender", "enhance", "enlist", "enrage", "enrich", "enroll", "entice", "entomb", "entrench", "entwine", "equate", "essay", "etch", "eulogise", "even", "evince", "exacerbate", "exaggerate", "exalt", "exempt", "exonerate", "expatiate", "explode", "expostulate", "extract", "extricate", "eyeglasses", "fabricate", "facilitate", "factorise", "factorize", "fail", "fall", "familiarize", "fashion", "father", "fathom", "fax", "federate", "feminize", "fence", "fess", "fictionalize", "fiddle", "fidget", "fill", "flash", "fleck", "flight", "floodlight", "floss", "fluctuate", "fluff", "fly", "focalise", "foot", "forearm", "forecast", "foretell", "forgather", "forgo", "fork", "form", "forswear", "founder", "fraternise", "fray", "frizz", "fumigate", "function", "furlough", "fuss", "gad", "gallivant", "galvanize", "gape", "garage", "garrote", "gasp", "gestate", "give", "glimmer", "glisten", "gloat", "gloss", "glow", "gnash", "gnaw", "goose", "govern", "grade", "graduate", "graft", "grok", "guest", "guilt", "gulp", "gum", "gurn", "gust", "gut", "guzzle", "ham", "harangue", "harvest", "hassle", "haul", "haze", "headline", "hearten", "heighten", "highlight", "hoick", "hold", "hole", "hollow", "holster", "home", "homeschool", "hoot", "horn", "horse", "hotfoot", "house", "hover", "howl", "huddle", "huff", "hunger", "hunt", "husk", "hype", "hypothesise", "hypothesize", "idle", "ignite", "imagineer", "impact", "impanel", "implode", "incinerate", "incline", "inculcate", "industrialize", "ingratiate", "inhibit", "inject", "innovate", "inscribe", "insert", "insist", "inspect", "institute", "institutionalize", "intend", "intermarry", "intermesh", "intermix", "internalise", "internalize", "internationalize", "intrigue", "inure", "inveigle", "inventory", "investigate", "irk", "iterate", "jaywalk", "jell", "jeopardise", "jiggle", "jive", "joint", "jot", "jut", "keel", "knife", "knit", "know", "kowtow", "lack", "lampoon", "large", "leap", "lecture", "legitimize", "lend", "libel", "liberalize", "license", "ligate", "list", "lobotomise", "lock", "log", "loose", "low", "lowball", "machine", "magnetize", "major", "make", "malfunction", "manage", "manipulate", "maroon", "masculinize", "mash", "mask", "masquerade", "massage", "masticate", "materialise", "matter", "maul", "memorise", "merge", "mesh", "metabolise", "microblog", "microchip", "micromanage", "militate", "mill", "minister", "minor", "misappropriate", "miscalculate", "misfire", "misjudge", "miskey", "mismatch", "mispronounce", "misread", "misreport", "misspend", "mob", "mobilise", "mobilize", "moisten", "mooch", "moor", "moralise", "mortar", "mosh", "mothball", "motivate", "motor", "mould", "mount", "muddy", "mummify", "mutate", "mystify", "nab", "narrate", "narrowcast", "nasalise", "nauseate", "navigate", "neaten", "neck", "neglect", "norm", "notarize", "object", "obscure", "observe", "obsess", "obstruct", "obtrude", "offend", "offset", "option", "orchestrate", "orient", "orientate", "outbid", "outdo", "outfit", "outflank", "outfox", "outnumber", "outrank", "outrun", "outsource", "overburden", "overcharge", "overcook", "overdub", "overfeed", "overload", "overplay", "overproduce", "overreact", "override", "overspend", "overstay", "overtrain", "overvalue", "overwork", "own", "oxidise", "oxidize", "oxygenate", "pace", "pack", "pale", "pant", "paralyse", "parody", "part", "pause", "pave", "penalise", "persecute", "personalise", "perspire", "pertain", "peter", "pike", "pillory", "pinion", "pip", "pity", "pivot", "pixellate", "plagiarise", "plait", "plan", "please", "pluck", "ponder", "popularize", "portray", "prance", "preclude", "preheat", "prejudge", "preregister", "presell", "preside", "pretend", "print", "prioritize", "probate", "probe", "proceed", "procrastinate", "profane", "progress", "proliferate", "proofread", "propound", "proselytise", "provision", "pry", "publicize", "puff", "pull", "pulp", "pulverize", "purse", "put", "putrefy", "quadruple", "quaff", "quantify", "quarrel", "quash", "quaver", "question", "quiet", "quintuple", "quip", "quit", "rag", "rally", "ramp", "randomize", "rationalise", "rationalize", "ravage", "ravel", "react", "readies", "readjust", "readmit", "ready", "reapply", "rear", "reassemble", "rebel", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuke", "recede", "reckon", "reclassify", "recompense", "reconstitute", "record", "recount", "redact", "redevelop", "redound", "redraw", "redress", "reel", "refer", "reference", "refine", "reflate", "refute", "regulate", "reiterate", "rejigger", "rejoin", "rekindle", "relaunch", "relieve", "remand", "remark", "reopen", "reorient", "replicate", "repossess", "represent", "reprimand", "reproach", "reprove", "repurpose", "requite", "reschedule", "resort", "respray", "restructure", "retool", "retract", "revere", "revitalise", "revoke", "reword", "rewrite", "ride", "ridge", "rim", "ring", "rise", "rival", "roger", "rosin", "rot", "rout", "row", "rue", "rule", "safeguard", "sashay", "sate", "satirise", "satirize", "satisfy", "saturate", "savour", "scale", "scamper", "scar", "scare", "scarper", "scent", "schematise", "scheme", "schlep", "scoff", "scoop", "scope", "scotch", "scowl", "scrabble", "scram", "scramble", "scrape", "screw", "scruple", "scrutinise", "scuffle", "scuttle", "search", "secularize", "see", "segregate", "sell", "sense", "sensitize", "sequester", "serenade", "serialize", "serve", "service", "settle", "sew", "shaft", "sham", "shampoo", "shanghai", "shear", "sheathe", "shell", "shinny", "shirk", "shoot", "shoulder", "shout", "shovel", "showboat", "shred", "shrill", "shudder", "shush", "sidetrack", "sign", "silt", "sin", "singe", "sit", "sizzle", "skateboard", "ski", "slake", "slap", "slather", "sleet", "slink", "slip", "slope", "slump", "smarten", "smuggle", "snack", "sneak", "sniff", "snoop", "snow", "snowplow", "snuggle", "soap", "solace", "solder", "solicit", "source", "spark", "spattering", "spectacles", "spectate", "spellcheck", "spew", "spice", "spirit", "splash", "splay", "split", "splosh", "splurge", "spook", "square", "squirm", "stabilise", "stable", "stack", "stage", "stake", "starch", "state", "statement", "stiffen", "stigmatize", "sting", "stint", "stoop", "store", "storyboard", "stratify", "structure", "stuff", "stunt", "substantiate", "subtract", "suckle", "suffice", "suffocate", "summarise", "sun", "sunbathe", "sunder", "sup", "surge", "surprise", "swat", "swathe", "sway", "swear", "swelter", "swerve", "swill", "swing", "symbolise", "synthesise", "syringe", "table", "tabulate", "tag", "tame", "tank", "tankful", "tarry", "task", "taxicab", "team", "telescope", "tenant", "terraform", "terrorise", "testify", "think", "throbbing", "thump", "tighten", "toady", "toe", "tough", "tousle", "traduce", "train", "transcend", "transplant", "trash", "treasure", "treble", "trek", "trial", "tromp", "trouser", "trust", "tune", "tut", "twine", "twist", "typify", "unbalance", "uncork", "uncover", "underachieve", "undergo", "underplay", "unearth", "unfreeze", "unfurl", "unlearn", "unscramble", "unzip", "uproot", "upsell", "usher", "vacation", "vamoose", "vanish", "vary", "veg", "venture", "verify", "vet", "veto", "volunteer", "vulgarise", "waft", "wallop", "waltz", "warp", "wash", "waver", "weary", "weatherize", "wedge", "weep", "weight", "welcome", "westernise", "westernize", "while", "whine", "whisper", "whistle", "whitewash", "whup", "wilt", "wing", "wire", "wisecrack", "wolf", "wound", "wring", "writ", "yak", "yawn", "yearn", "yuppify"];
var kr = { adjective: Oa, adverb: xa, conjunction: za, interjection: Va, noun: Ya, preposition: ja, verb: qa };
var Ua = kr;
var fr = { airline: o, animal: k, app: B, book: P, cell_phone: W, color: F, commerce: I, company: U, database: _, date: $, finance: ce, food: ve, hacker: Le, internet: He, location: Qe, lorem: $e, metadata: ea, music: ia, person: Aa, phone_number: La, science: Pa, team: Ga, vehicle: Ka, word: Ua };
var ys = fr;

// ../../node_modules/@faker-js/faker/dist/chunk-2O3P3S23.js
var m2 = class extends Error {
};
function Ce2(i2) {
  let e2 = Object.getPrototypeOf(i2);
  do {
    for (let r2 of Object.getOwnPropertyNames(e2)) typeof i2[r2] == "function" && r2 !== "constructor" && (i2[r2] = i2[r2].bind(i2));
    e2 = Object.getPrototypeOf(e2);
  } while (e2 !== Object.prototype);
}
var x2 = class {
  constructor(e2) {
    this.faker = e2;
    Ce2(this);
  }
};
var p2 = class extends x2 {
  constructor(r2) {
    super(r2);
    this.faker = r2;
  }
};
var Ne2 = ((t2) => (t2.Narrowbody = "narrowbody", t2.Regional = "regional", t2.Widebody = "widebody", t2))(Ne2 || {});
var kr2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var xr = ["0", "O", "1", "I", "L"];
var Ar = { regional: 20, narrowbody: 35, widebody: 60 };
var Er = { regional: ["A", "B", "C", "D"], narrowbody: ["A", "B", "C", "D", "E", "F"], widebody: ["A", "B", "C", "D", "E", "F", "G", "H", "J", "K"] };
var F2 = class extends p2 {
  airport() {
    return this.faker.helpers.arrayElement(this.faker.definitions.airline.airport);
  }
  airline() {
    return this.faker.helpers.arrayElement(this.faker.definitions.airline.airline);
  }
  airplane() {
    return this.faker.helpers.arrayElement(this.faker.definitions.airline.airplane);
  }
  recordLocator(e2 = {}) {
    let { allowNumerics: r2 = false, allowVisuallySimilarCharacters: t2 = false } = e2, a2 = [];
    return r2 || a2.push(...kr2), t2 || a2.push(...xr), this.faker.string.alphanumeric({ length: 6, casing: "upper", exclude: a2 });
  }
  seat(e2 = {}) {
    let { aircraftType: r2 = "narrowbody" } = e2, t2 = Ar[r2], a2 = Er[r2], n2 = this.faker.number.int({ min: 1, max: t2 }), o2 = this.faker.helpers.arrayElement(a2);
    return `${n2}${o2}`;
  }
  aircraftType() {
    return this.faker.helpers.enumValue(Ne2);
  }
  flightNumber(e2 = {}) {
    let { length: r2 = { min: 1, max: 4 }, addLeadingZeros: t2 = false } = e2, a2 = this.faker.string.numeric({ length: r2, allowLeadingZeros: false });
    return t2 ? a2.padStart(4, "0") : a2;
  }
};
var De2 = ((n2) => (n2.SRGB = "sRGB", n2.DisplayP3 = "display-p3", n2.REC2020 = "rec2020", n2.A98RGB = "a98-rgb", n2.ProphotoRGB = "prophoto-rgb", n2))(De2 || {});
var Re2 = ((c2) => (c2.RGB = "rgb", c2.RGBA = "rgba", c2.HSL = "hsl", c2.HSLA = "hsla", c2.HWB = "hwb", c2.CMYK = "cmyk", c2.LAB = "lab", c2.LCH = "lch", c2.COLOR = "color", c2))(Re2 || {});
function wr(i2, e2) {
  let { prefix: r2, casing: t2 } = e2;
  switch (t2) {
    case "upper": {
      i2 = i2.toUpperCase();
      break;
    }
    case "lower": {
      i2 = i2.toLowerCase();
      break;
    }
    case "mixed":
  }
  return r2 && (i2 = r2 + i2), i2;
}
function Le2(i2) {
  return i2.map((r2) => {
    if (r2 % 1 !== 0) {
      let a2 = new ArrayBuffer(4);
      new DataView(a2).setFloat32(0, r2);
      let n2 = new Uint8Array(a2);
      return Le2([...n2]).replaceAll(" ", "");
    }
    return (r2 >>> 0).toString(2).padStart(8, "0");
  }).join(" ");
}
function A2(i2) {
  return Math.round(i2 * 100);
}
function Sr2(i2, e2 = "rgb", r2 = "sRGB") {
  switch (e2) {
    case "rgba":
      return `rgba(${i2[0]}, ${i2[1]}, ${i2[2]}, ${i2[3]})`;
    case "color":
      return `color(${r2} ${i2[0]} ${i2[1]} ${i2[2]})`;
    case "cmyk":
      return `cmyk(${A2(i2[0])}%, ${A2(i2[1])}%, ${A2(i2[2])}%, ${A2(i2[3])}%)`;
    case "hsl":
      return `hsl(${i2[0]}deg ${A2(i2[1])}% ${A2(i2[2])}%)`;
    case "hsla":
      return `hsl(${i2[0]}deg ${A2(i2[1])}% ${A2(i2[2])}% / ${A2(i2[3])})`;
    case "hwb":
      return `hwb(${i2[0]} ${A2(i2[1])}% ${A2(i2[2])}%)`;
    case "lab":
      return `lab(${A2(i2[0])}% ${i2[1]} ${i2[2]})`;
    case "lch":
      return `lch(${A2(i2[0])}% ${i2[1]} ${i2[2]})`;
    case "rgb":
      return `rgb(${i2[0]}, ${i2[1]}, ${i2[2]})`;
  }
}
function D2(i2, e2, r2 = "rgb", t2 = "sRGB") {
  switch (e2) {
    case "css":
      return Sr2(i2, r2, t2);
    case "binary":
      return Le2(i2);
    case "decimal":
      return i2;
  }
}
var G2 = class extends p2 {
  human() {
    return this.faker.helpers.arrayElement(this.faker.definitions.color.human);
  }
  space() {
    return this.faker.helpers.arrayElement(this.faker.definitions.color.space);
  }
  cssSupportedFunction() {
    return this.faker.helpers.enumValue(Re2);
  }
  cssSupportedSpace() {
    return this.faker.helpers.enumValue(De2);
  }
  rgb(e2 = {}) {
    let { format: r2 = "hex", includeAlpha: t2 = false, prefix: a2 = "#", casing: n2 = "lower" } = e2, o2, s2 = "rgb";
    return r2 === "hex" ? (o2 = this.faker.string.hexadecimal({ length: t2 ? 8 : 6, prefix: "" }), o2 = wr(o2, { prefix: a2, casing: n2 }), o2) : (o2 = Array.from({ length: 3 }, () => this.faker.number.int(255)), t2 && (o2.push(this.faker.number.float({ multipleOf: 0.01 })), s2 = "rgba"), D2(o2, r2, s2));
  }
  cmyk(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = Array.from({ length: 4 }, () => this.faker.number.float({ multipleOf: 0.01 }));
    return D2(t2, r2, "cmyk");
  }
  hsl(e2 = {}) {
    let { format: r2 = "decimal", includeAlpha: t2 = false } = e2, a2 = [this.faker.number.int(360)];
    for (let n2 = 0; n2 < (e2?.includeAlpha ? 3 : 2); n2++) a2.push(this.faker.number.float({ multipleOf: 0.01 }));
    return D2(a2, r2, t2 ? "hsla" : "hsl");
  }
  hwb(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = [this.faker.number.int(360)];
    for (let a2 = 0; a2 < 2; a2++) t2.push(this.faker.number.float({ multipleOf: 0.01 }));
    return D2(t2, r2, "hwb");
  }
  lab(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = [this.faker.number.float({ multipleOf: 1e-6 })];
    for (let a2 = 0; a2 < 2; a2++) t2.push(this.faker.number.float({ min: -100, max: 100, multipleOf: 1e-4 }));
    return D2(t2, r2, "lab");
  }
  lch(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = [this.faker.number.float({ multipleOf: 1e-6 })];
    for (let a2 = 0; a2 < 2; a2++) t2.push(this.faker.number.float({ max: 230, multipleOf: 0.1 }));
    return D2(t2, r2, "lch");
  }
  colorByCSSColorSpace(e2 = {}) {
    let { format: r2 = "decimal", space: t2 = "sRGB" } = e2, a2 = Array.from({ length: 3 }, () => this.faker.number.float({ multipleOf: 1e-4 }));
    return D2(a2, r2, "color", t2);
  }
};
var be2 = ((a2) => (a2.Legacy = "legacy", a2.Segwit = "segwit", a2.Bech32 = "bech32", a2.Taproot = "taproot", a2))(be2 || {});
var Pe2 = ((r2) => (r2.Mainnet = "mainnet", r2.Testnet = "testnet", r2))(Pe2 || {});
var Be2 = { legacy: { prefix: { mainnet: "1", testnet: "m" }, length: { min: 26, max: 34 }, casing: "mixed", exclude: "0OIl" }, segwit: { prefix: { mainnet: "3", testnet: "2" }, length: { min: 26, max: 34 }, casing: "mixed", exclude: "0OIl" }, bech32: { prefix: { mainnet: "bc1", testnet: "tb1" }, length: { min: 42, max: 42 }, casing: "lower", exclude: "1bBiIoO" }, taproot: { prefix: { mainnet: "bc1p", testnet: "tb1p" }, length: { min: 62, max: 62 }, casing: "lower", exclude: "1bBiIoO" } };
var de2 = typeof Buffer > "u" || !ve2("base64") ? (i2) => {
  let e2 = new TextEncoder().encode(i2), r2 = Array.from(e2, (t2) => String.fromCodePoint(t2)).join("");
  return btoa(r2);
} : (i2) => Buffer.from(i2).toString("base64");
var ge2 = typeof Buffer > "u" || !ve2("base64url") ? (i2) => de2(i2).replaceAll("+", "-").replaceAll("/", "_").replaceAll(/=+$/g, "") : (i2) => Buffer.from(i2).toString("base64url");
function ve2(i2) {
  try {
    return typeof Buffer.from("test").toString(i2) == "string";
  } catch {
    return false;
  }
}
function w2(i2) {
  let { deprecated: e2, since: r2, until: t2, proposed: a2 } = i2, n2 = `[@faker-js/faker]: ${e2} is deprecated`;
  r2 && (n2 += ` since v${r2}`), t2 && (n2 += ` and will be removed in v${t2}`), a2 && (n2 += `. Please use ${a2} instead`), console.warn(`${n2}.`);
}
var Mr = Object.fromEntries([["\u0410", "A"], ["\u0430", "a"], ["\u0411", "B"], ["\u0431", "b"], ["\u0412", "V"], ["\u0432", "v"], ["\u0413", "G"], ["\u0433", "g"], ["\u0414", "D"], ["\u0434", "d"], ["\u044A\u0435", "ye"], ["\u042A\u0435", "Ye"], ["\u044A\u0415", "yE"], ["\u042A\u0415", "YE"], ["\u0415", "E"], ["\u0435", "e"], ["\u0401", "Yo"], ["\u0451", "yo"], ["\u0416", "Zh"], ["\u0436", "zh"], ["\u0417", "Z"], ["\u0437", "z"], ["\u0418", "I"], ["\u0438", "i"], ["\u044B\u0439", "iy"], ["\u042B\u0439", "Iy"], ["\u042B\u0419", "IY"], ["\u044B\u0419", "iY"], ["\u0419", "Y"], ["\u0439", "y"], ["\u041A", "K"], ["\u043A", "k"], ["\u041B", "L"], ["\u043B", "l"], ["\u041C", "M"], ["\u043C", "m"], ["\u041D", "N"], ["\u043D", "n"], ["\u041E", "O"], ["\u043E", "o"], ["\u041F", "P"], ["\u043F", "p"], ["\u0420", "R"], ["\u0440", "r"], ["\u0421", "S"], ["\u0441", "s"], ["\u0422", "T"], ["\u0442", "t"], ["\u0423", "U"], ["\u0443", "u"], ["\u0424", "F"], ["\u0444", "f"], ["\u0425", "Kh"], ["\u0445", "kh"], ["\u0426", "Ts"], ["\u0446", "ts"], ["\u0427", "Ch"], ["\u0447", "ch"], ["\u0428", "Sh"], ["\u0448", "sh"], ["\u0429", "Sch"], ["\u0449", "sch"], ["\u042A", ""], ["\u044A", ""], ["\u042B", "Y"], ["\u044B", "y"], ["\u042C", ""], ["\u044C", ""], ["\u042D", "E"], ["\u044D", "e"], ["\u042E", "Yu"], ["\u044E", "yu"], ["\u042F", "Ya"], ["\u044F", "ya"]]);
var Tr = Object.fromEntries([["\u03B1", "a"], ["\u03B2", "v"], ["\u03B3", "g"], ["\u03B4", "d"], ["\u03B5", "e"], ["\u03B6", "z"], ["\u03B7", "i"], ["\u03B8", "th"], ["\u03B9", "i"], ["\u03BA", "k"], ["\u03BB", "l"], ["\u03BC", "m"], ["\u03BD", "n"], ["\u03BE", "ks"], ["\u03BF", "o"], ["\u03C0", "p"], ["\u03C1", "r"], ["\u03C3", "s"], ["\u03C4", "t"], ["\u03C5", "y"], ["\u03C6", "f"], ["\u03C7", "x"], ["\u03C8", "ps"], ["\u03C9", "o"], ["\u03AC", "a"], ["\u03AD", "e"], ["\u03AF", "i"], ["\u03CC", "o"], ["\u03CD", "y"], ["\u03AE", "i"], ["\u03CE", "o"], ["\u03C2", "s"], ["\u03CA", "i"], ["\u03B0", "y"], ["\u03CB", "y"], ["\u0390", "i"], ["\u0391", "A"], ["\u0392", "B"], ["\u0393", "G"], ["\u0394", "D"], ["\u0395", "E"], ["\u0396", "Z"], ["\u0397", "I"], ["\u0398", "TH"], ["\u0399", "I"], ["\u039A", "K"], ["\u039B", "L"], ["\u039C", "M"], ["\u039D", "N"], ["\u039E", "KS"], ["\u039F", "O"], ["\u03A0", "P"], ["\u03A1", "R"], ["\u03A3", "S"], ["\u03A4", "T"], ["\u03A5", "Y"], ["\u03A6", "F"], ["\u03A7", "X"], ["\u03A8", "PS"], ["\u03A9", "O"], ["\u0386", "A"], ["\u0388", "E"], ["\u038A", "I"], ["\u038C", "O"], ["\u038E", "Y"], ["\u0389", "I"], ["\u038F", "O"], ["\u03AA", "I"], ["\u03AB", "Y"]]);
var Cr2 = Object.fromEntries([["\u0621", "e"], ["\u0622", "a"], ["\u0623", "a"], ["\u0624", "w"], ["\u0625", "i"], ["\u0626", "y"], ["\u0627", "a"], ["\u0628", "b"], ["\u0629", "t"], ["\u062A", "t"], ["\u062B", "th"], ["\u062C", "j"], ["\u062D", "h"], ["\u062E", "kh"], ["\u062F", "d"], ["\u0630", "dh"], ["\u0631", "r"], ["\u0632", "z"], ["\u0633", "s"], ["\u0634", "sh"], ["\u0635", "s"], ["\u0636", "d"], ["\u0637", "t"], ["\u0638", "z"], ["\u0639", "e"], ["\u063A", "gh"], ["\u0640", "_"], ["\u0641", "f"], ["\u0642", "q"], ["\u0643", "k"], ["\u0644", "l"], ["\u0645", "m"], ["\u0646", "n"], ["\u0647", "h"], ["\u0648", "w"], ["\u0649", "a"], ["\u064A", "y"], ["\u064E\u200E", "a"], ["\u064F", "u"], ["\u0650\u200E", "i"]]);
var Nr = Object.fromEntries([["\u0561", "a"], ["\u0531", "A"], ["\u0562", "b"], ["\u0532", "B"], ["\u0563", "g"], ["\u0533", "G"], ["\u0564", "d"], ["\u0534", "D"], ["\u0565", "ye"], ["\u0535", "Ye"], ["\u0566", "z"], ["\u0536", "Z"], ["\u0567", "e"], ["\u0537", "E"], ["\u0568", "y"], ["\u0538", "Y"], ["\u0569", "t"], ["\u0539", "T"], ["\u056A", "zh"], ["\u053A", "Zh"], ["\u056B", "i"], ["\u053B", "I"], ["\u056C", "l"], ["\u053C", "L"], ["\u056D", "kh"], ["\u053D", "Kh"], ["\u056E", "ts"], ["\u053E", "Ts"], ["\u056F", "k"], ["\u053F", "K"], ["\u0570", "h"], ["\u0540", "H"], ["\u0571", "dz"], ["\u0541", "Dz"], ["\u0572", "gh"], ["\u0542", "Gh"], ["\u0573", "tch"], ["\u0543", "Tch"], ["\u0574", "m"], ["\u0544", "M"], ["\u0575", "y"], ["\u0545", "Y"], ["\u0576", "n"], ["\u0546", "N"], ["\u0577", "sh"], ["\u0547", "Sh"], ["\u0578", "vo"], ["\u0548", "Vo"], ["\u0579", "ch"], ["\u0549", "Ch"], ["\u057A", "p"], ["\u054A", "P"], ["\u057B", "j"], ["\u054B", "J"], ["\u057C", "r"], ["\u054C", "R"], ["\u057D", "s"], ["\u054D", "S"], ["\u057E", "v"], ["\u054E", "V"], ["\u057F", "t"], ["\u054F", "T"], ["\u0580", "r"], ["\u0550", "R"], ["\u0581", "c"], ["\u0551", "C"], ["\u0578\u0582", "u"], ["\u0548\u0552", "U"], ["\u0548\u0582", "U"], ["\u0583", "p"], ["\u0553", "P"], ["\u0584", "q"], ["\u0554", "Q"], ["\u0585", "o"], ["\u0555", "O"], ["\u0586", "f"], ["\u0556", "F"], ["\u0587", "yev"]]);
var Dr = Object.fromEntries([["\u0686", "ch"], ["\u06A9", "k"], ["\u06AF", "g"], ["\u067E", "p"], ["\u0698", "zh"], ["\u06CC", "y"]]);
var Rr = Object.fromEntries([["\u05D0", "a"], ["\u05D1", "b"], ["\u05D2", "g"], ["\u05D3", "d"], ["\u05D4", "h"], ["\u05D5", "v"], ["\u05D6", "z"], ["\u05D7", "ch"], ["\u05D8", "t"], ["\u05D9", "y"], ["\u05DB", "k"], ["\u05DA", "kh"], ["\u05DC", "l"], ["\u05DD", "m"], ["\u05DE", "m"], ["\u05DF", "n"], ["\u05E0", "n"], ["\u05E1", "s"], ["\u05E2", "a"], ["\u05E4", "f"], ["\u05E3", "ph"], ["\u05E6", "ts"], ["\u05E5", "ts"], ["\u05E7", "k"], ["\u05E8", "r"], ["\u05E9", "sh"], ["\u05EA", "t"], ["\u05D5", "v"]]);
var ye2 = { ...Mr, ...Tr, ...Cr2, ...Dr, ...Nr, ...Rr };
var Lr = ((u2) => (u2.Any = "any", u2.Loopback = "loopback", u2.PrivateA = "private-a", u2.PrivateB = "private-b", u2.PrivateC = "private-c", u2.TestNet1 = "test-net-1", u2.TestNet2 = "test-net-2", u2.TestNet3 = "test-net-3", u2.LinkLocal = "link-local", u2.Multicast = "multicast", u2))(Lr || {});
var Pr = { any: "0.0.0.0/0", loopback: "127.0.0.0/8", "private-a": "10.0.0.0/8", "private-b": "172.16.0.0/12", "private-c": "192.168.0.0/16", "test-net-1": "192.0.2.0/24", "test-net-2": "198.51.100.0/24", "test-net-3": "203.0.113.0/24", "link-local": "169.254.0.0/16", multicast: "224.0.0.0/4" };
function $e2(i2) {
  return /^[a-z][a-z-]*[a-z]$/i.exec(i2) !== null;
}
function Ie2(i2, e2) {
  let r2 = i2.helpers.slugify(e2);
  if ($e2(r2)) return r2;
  let t2 = i2.helpers.slugify(i2.lorem.word());
  return $e2(t2) ? t2 : i2.string.alpha({ casing: "lower", length: i2.number.int({ min: 4, max: 8 }) });
}
function ke2(i2, e2) {
  return Math.floor((i2.number.int(256) + e2) / 2).toString(16).padStart(2, "0");
}
var O2 = class extends p2 {
  email(e2 = {}) {
    let { firstName: r2, lastName: t2, provider: a2 = this.faker.helpers.arrayElement(this.faker.definitions.internet.free_email), allowSpecialCharacters: n2 = false } = e2, o2 = this.username({ firstName: r2, lastName: t2 });
    if (o2 = o2.replaceAll(/[^A-Za-z0-9._+-]+/g, ""), o2 = o2.substring(0, 50), n2) {
      let s2 = [..."._-"], l2 = [...".!#$%&'*+-/=?^_`{|}~"];
      o2 = o2.replace(this.faker.helpers.arrayElement(s2), this.faker.helpers.arrayElement(l2));
    }
    return o2 = o2.replaceAll(/\.{2,}/g, "."), o2 = o2.replace(/^\./, ""), o2 = o2.replace(/\.$/, ""), `${o2}@${a2}`;
  }
  exampleEmail(e2 = {}) {
    let { firstName: r2, lastName: t2, allowSpecialCharacters: a2 = false } = e2, n2 = this.faker.helpers.arrayElement(this.faker.definitions.internet.example_email);
    return this.email({ firstName: r2, lastName: t2, provider: n2, allowSpecialCharacters: a2 });
  }
  userName(e2 = {}) {
    return w2({ deprecated: "faker.internet.userName()", proposed: "faker.internet.username()", since: "9.1.0", until: "10.0.0" }), this.username(e2);
  }
  username(e2 = {}) {
    let { firstName: r2 = this.faker.person.firstName(), lastName: t2 = this.faker.person.lastName(), lastName: a2 } = e2, n2 = this.faker.helpers.arrayElement([".", "_"]), o2 = this.faker.number.int(99), s2 = [() => `${r2}${n2}${t2}${o2}`, () => `${r2}${n2}${t2}`];
    a2 || s2.push(() => `${r2}${o2}`);
    let l2 = this.faker.helpers.arrayElement(s2)();
    return l2 = l2.normalize("NFKD").replaceAll(/[\u0300-\u036F]/g, ""), l2 = [...l2].map((c2) => {
      if (ye2[c2]) return ye2[c2];
      let u2 = c2.codePointAt(0) ?? Number.NaN;
      return u2 < 128 ? c2 : u2.toString(36);
    }).join(""), l2 = l2.toString().replaceAll("'", ""), l2 = l2.replaceAll(" ", ""), l2;
  }
  displayName(e2 = {}) {
    let { firstName: r2 = this.faker.person.firstName(), lastName: t2 = this.faker.person.lastName() } = e2, a2 = this.faker.helpers.arrayElement([".", "_"]), n2 = this.faker.number.int(99), o2 = [() => `${r2}${n2}`, () => `${r2}${a2}${t2}`, () => `${r2}${a2}${t2}${n2}`], s2 = this.faker.helpers.arrayElement(o2)();
    return s2 = s2.toString().replaceAll("'", ""), s2 = s2.replaceAll(" ", ""), s2;
  }
  protocol() {
    let e2 = ["http", "https"];
    return this.faker.helpers.arrayElement(e2);
  }
  httpMethod() {
    let e2 = ["GET", "POST", "PUT", "DELETE", "PATCH"];
    return this.faker.helpers.arrayElement(e2);
  }
  httpStatusCode(e2 = {}) {
    let { types: r2 = Object.keys(this.faker.definitions.internet.http_status_code) } = e2, t2 = this.faker.helpers.arrayElement(r2);
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.http_status_code[t2]);
  }
  url(e2 = {}) {
    let { appendSlash: r2 = this.faker.datatype.boolean(), protocol: t2 = "https" } = e2;
    return `${t2}://${this.domainName()}${r2 ? "/" : ""}`;
  }
  domainName() {
    return `${this.domainWord()}.${this.domainSuffix()}`;
  }
  domainSuffix() {
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.domain_suffix);
  }
  domainWord() {
    let e2 = Ie2(this.faker, this.faker.word.adjective()), r2 = Ie2(this.faker, this.faker.word.noun());
    return `${e2}-${r2}`.toLowerCase();
  }
  ip() {
    return this.faker.datatype.boolean() ? this.ipv4() : this.ipv6();
  }
  ipv4(e2 = {}) {
    let { network: r2 = "any", cidrBlock: t2 = Pr[r2] } = e2;
    if (!/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2}$/.test(t2)) throw new m2(`Invalid CIDR block provided: ${t2}. Must be in the format x.x.x.x/y.`);
    let [a2, n2] = t2.split("/"), o2 = 4294967295 >>> Number.parseInt(n2), [s2, l2, c2, u2] = a2.split(".").map(Number), f3 = (s2 << 24 | l2 << 16 | c2 << 8 | u2) & ~o2, g2 = this.faker.number.int(o2), b2 = f3 | g2;
    return [b2 >>> 24 & 255, b2 >>> 16 & 255, b2 >>> 8 & 255, b2 & 255].join(".");
  }
  ipv6() {
    return Array.from({ length: 8 }, () => this.faker.string.hexadecimal({ length: 4, casing: "lower", prefix: "" })).join(":");
  }
  port() {
    return this.faker.number.int(65535);
  }
  userAgent() {
    return this.faker.helpers.fake(this.faker.definitions.internet.user_agent_pattern);
  }
  color(e2 = {}) {
    w2({ deprecated: "faker.internet.color()", proposed: "faker.color.rgb()", since: "9.6.0", until: "10.0.0" });
    let { redBase: r2 = 0, greenBase: t2 = 0, blueBase: a2 = 0 } = e2, n2 = ke2(this.faker, r2), o2 = ke2(this.faker, t2), s2 = ke2(this.faker, a2);
    return `#${n2}${o2}${s2}`;
  }
  mac(e2 = {}) {
    typeof e2 == "string" && (e2 = { separator: e2 });
    let { separator: r2 = ":" } = e2, t2, a2 = "";
    for ([":", "-", ""].includes(r2) || (r2 = ":"), t2 = 0; t2 < 12; t2++) a2 += this.faker.number.hex(15), t2 % 2 === 1 && t2 !== 11 && (a2 += r2);
    return a2;
  }
  password(e2 = {}) {
    let r2 = /[aeiouAEIOU]$/, t2 = /[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]$/, a2 = (c2, u2, h2, f3) => {
      if (f3.length >= c2) return f3;
      u2 && (h2 = t2.test(f3) ? r2 : t2);
      let g2 = this.faker.number.int(94) + 33, b2 = String.fromCodePoint(g2);
      return u2 && (b2 = b2.toLowerCase()), h2.test(b2) ? a2(c2, u2, h2, f3 + b2) : a2(c2, u2, h2, f3);
    }, { length: n2 = 15, memorable: o2 = false, pattern: s2 = /\w/, prefix: l2 = "" } = e2;
    return a2(n2, o2, s2, l2);
  }
  emoji(e2 = {}) {
    let { types: r2 = Object.keys(this.faker.definitions.internet.emoji) } = e2, t2 = this.faker.helpers.arrayElement(r2);
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.emoji[t2]);
  }
  jwtAlgorithm() {
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.jwt_algorithm);
  }
  jwt(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = this.faker.date.recent({ refDate: r2 }), { header: a2 = { alg: this.jwtAlgorithm(), typ: "JWT" }, payload: n2 = { iat: Math.round(t2.valueOf() / 1e3), exp: Math.round(this.faker.date.soon({ refDate: t2 }).valueOf() / 1e3), nbf: Math.round(this.faker.date.anytime({ refDate: r2 }).valueOf() / 1e3), iss: this.faker.company.name(), sub: this.faker.string.uuid(), aud: this.faker.string.uuid(), jti: this.faker.string.uuid() } } = e2, o2 = ge2(JSON.stringify(a2)), s2 = ge2(JSON.stringify(n2)), l2 = this.faker.string.alphanumeric(64);
    return `${o2}.${s2}.${l2}`;
  }
};
var _e2 = ((r2) => (r2.Female = "female", r2.Male = "male", r2))(_e2 || {});
function R2(i2, e2, r2) {
  let { generic: t2, female: a2, male: n2 } = r2;
  switch (e2) {
    case "female":
      return a2 ?? t2;
    case "male":
      return n2 ?? t2;
    default:
      return t2 ?? i2.helpers.arrayElement([a2, n2]) ?? [];
  }
}
var U2 = class extends p2 {
  firstName(e2) {
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.first_name));
  }
  lastName(e2) {
    if (this.faker.rawDefinitions.person?.last_name_pattern != null) {
      let r2 = this.faker.helpers.weightedArrayElement(R2(this.faker, e2, this.faker.rawDefinitions.person.last_name_pattern));
      return this.faker.helpers.fake(r2);
    }
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.last_name));
  }
  middleName(e2) {
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.middle_name));
  }
  fullName(e2 = {}) {
    let { sex: r2 = this.faker.helpers.arrayElement(["female", "male"]), firstName: t2 = this.firstName(r2), lastName: a2 = this.lastName(r2) } = e2, n2 = this.faker.helpers.weightedArrayElement(this.faker.definitions.person.name);
    return this.faker.helpers.mustache(n2, { "person.prefix": () => this.prefix(r2), "person.firstName": () => t2, "person.middleName": () => this.middleName(r2), "person.lastName": () => a2, "person.suffix": () => this.suffix() });
  }
  gender() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.gender);
  }
  sex() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.sex);
  }
  sexType() {
    return this.faker.helpers.enumValue(_e2);
  }
  bio() {
    let { bio_pattern: e2 } = this.faker.definitions.person;
    return this.faker.helpers.fake(e2);
  }
  prefix(e2) {
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.prefix));
  }
  suffix() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.suffix);
  }
  jobTitle() {
    return this.faker.helpers.fake(this.faker.definitions.person.job_title_pattern);
  }
  jobDescriptor() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.job_descriptor);
  }
  jobArea() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.job_area);
  }
  jobType() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.job_type);
  }
  zodiacSign() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.western_zodiac_sign);
  }
};
var Br = 23283064365386963e-26;
var vr = 1 / 9007199254740992;
var { imul: Ae2, trunc: Ee2 } = Math;
function Fe2(i2) {
  return typeof i2 == "number" ? Ge2(i2) : $r(i2);
}
function Ge2(i2) {
  let e2 = Array.from({ length: 624 });
  e2[0] = i2;
  for (let r2 = 1; r2 !== 624; ++r2) {
    let t2 = e2[r2 - 1] ^ e2[r2 - 1] >>> 30;
    e2[r2] = Ee2(Ae2(1812433253, t2) + r2);
  }
  return e2;
}
function $r(i2) {
  let e2 = Ge2(19650218), r2 = 1, t2 = 0;
  for (let a2 = Math.max(624, i2.length); a2 !== 0; --a2) {
    let n2 = e2[r2 - 1] ^ e2[r2 - 1] >>> 30;
    e2[r2] = Ee2((e2[r2] ^ Ae2(n2, 1664525)) + i2[t2] + t2), r2++, t2++, r2 >= 624 && (e2[0] = e2[623], r2 = 1), t2 >= i2.length && (t2 = 0);
  }
  for (let a2 = 623; a2 !== 0; a2--) e2[r2] = Ee2((e2[r2] ^ Ae2(e2[r2 - 1] ^ e2[r2 - 1] >>> 30, 1566083941)) - r2), r2++, r2 >= 624 && (e2[0] = e2[623], r2 = 1);
  return e2[0] = 2147483648, e2;
}
function xe2(i2) {
  for (let r2 = 0; r2 !== 227; ++r2) {
    let t2 = (i2[r2] & 2147483648) + (i2[r2 + 1] & 2147483647);
    i2[r2] = i2[r2 + 397] ^ t2 >>> 1 ^ -(t2 & 1) & 2567483615;
  }
  for (let r2 = 227; r2 !== 623; ++r2) {
    let t2 = (i2[r2] & 2147483648) + (i2[r2 + 1] & 2147483647);
    i2[r2] = i2[r2 + 397 - 624] ^ t2 >>> 1 ^ -(t2 & 1) & 2567483615;
  }
  let e2 = (i2[623] & 2147483648) + (i2[0] & 2147483647);
  return i2[623] = i2[396] ^ e2 >>> 1 ^ -(e2 & 1) & 2567483615, i2;
}
var L2 = class {
  constructor(e2 = Math.random() * Number.MAX_SAFE_INTEGER, r2 = xe2(Fe2(e2)), t2 = 0) {
    this.states = r2;
    this.index = t2;
  }
  nextU32() {
    let e2 = this.states[this.index];
    return e2 ^= this.states[this.index] >>> 11, e2 ^= e2 << 7 & 2636928640, e2 ^= e2 << 15 & 4022730752, e2 ^= e2 >>> 18, ++this.index >= 624 && (this.states = xe2(this.states), this.index = 0), e2 >>> 0;
  }
  nextF32() {
    return this.nextU32() * Br;
  }
  nextU53() {
    let e2 = this.nextU32() >>> 5, r2 = this.nextU32() >>> 6;
    return e2 * 67108864 + r2;
  }
  nextF53() {
    return this.nextU53() * vr;
  }
  seed(e2) {
    this.states = xe2(Fe2(e2)), this.index = 0;
  }
};
function P2() {
  return Math.ceil(Math.random() * Number.MAX_SAFE_INTEGER);
}
function Oe2(i2 = P2()) {
  let e2 = new L2(i2);
  return { next() {
    return e2.nextF53();
  }, seed(r2) {
    e2.seed(r2);
  } };
}
var K2 = class extends x2 {
  boolean(e2 = {}) {
    typeof e2 == "number" && (e2 = { probability: e2 });
    let { probability: r2 = 0.5 } = e2;
    return r2 <= 0 ? false : r2 >= 1 ? true : this.faker.number.float() < r2;
  }
};
function S2(i2, e2 = "refDate") {
  let r2 = new Date(i2);
  if (Number.isNaN(r2.valueOf())) throw new m2(`Invalid ${e2} date: ${i2.toString()}`);
  return r2;
}
var j2 = () => {
  throw new m2("You cannot edit the locale data on the faker instance");
};
function Ue2(i2) {
  let e2 = {};
  return new Proxy(i2, { has() {
    return true;
  }, get(r2, t2) {
    return typeof t2 == "symbol" || t2 === "nodeType" ? r2[t2] : t2 in e2 ? e2[t2] : e2[t2] = Ir(t2, r2[t2]);
  }, set: j2, deleteProperty: j2 });
}
function H2(i2, ...e2) {
  if (i2 === null) throw new m2(`The locale data for '${e2.join(".")}' aren't applicable to this locale.
  If you think this is a bug, please report it at: https://github.com/faker-js/faker`);
  if (i2 === void 0) throw new m2(`The locale data for '${e2.join(".")}' are missing in this locale.
  If this is a custom Faker instance, please make sure all required locales are used e.g. '[de_AT, de, en, base]'.
  Please contribute the missing data to the project or use a locale/Faker instance that has these data.
  For more information see https://fakerjs.dev/guide/localization.html`);
}
function Ir(i2, e2 = {}) {
  return new Proxy(e2, { has(r2, t2) {
    return r2[t2] != null;
  }, get(r2, t2) {
    let a2 = r2[t2];
    return typeof t2 == "symbol" || t2 === "nodeType" || H2(a2, i2, t2.toString()), a2;
  }, set: j2, deleteProperty: j2 });
}
var B2 = class extends x2 {
  anytime(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = S2(r2).getTime();
    return this.between({ from: t2 - 1e3 * 60 * 60 * 24 * 365, to: t2 + 1e3 * 60 * 60 * 24 * 365 });
  }
  past(e2 = {}) {
    let { years: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0) throw new m2("Years must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 - r2 * 365 * 24 * 3600 * 1e3, to: a2 - 1e3 });
  }
  future(e2 = {}) {
    let { years: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0) throw new m2("Years must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 + 1e3, to: a2 + r2 * 365 * 24 * 3600 * 1e3 });
  }
  between(e2) {
    if (e2 == null || e2.from == null || e2.to == null) throw new m2("Must pass an options object with `from` and `to` values.");
    let { from: r2, to: t2 } = e2, a2 = S2(r2, "from").getTime(), n2 = S2(t2, "to").getTime();
    if (a2 > n2) throw new m2("`from` date must be before `to` date.");
    return new Date(this.faker.number.int({ min: a2, max: n2 }));
  }
  betweens(e2) {
    if (e2 == null || e2.from == null || e2.to == null) throw new m2("Must pass an options object with `from` and `to` values.");
    let { from: r2, to: t2, count: a2 = 3 } = e2;
    return this.faker.helpers.multiple(() => this.between({ from: r2, to: t2 }), { count: a2 }).sort((n2, o2) => n2.getTime() - o2.getTime());
  }
  recent(e2 = {}) {
    let { days: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0) throw new m2("Days must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 - r2 * 24 * 3600 * 1e3, to: a2 - 1e3 });
  }
  soon(e2 = {}) {
    let { days: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0) throw new m2("Days must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 + 1e3, to: a2 + r2 * 24 * 3600 * 1e3 });
  }
  birthdate(e2 = {}) {
    let { mode: r2 = "age", min: t2 = 18, max: a2 = 80, refDate: n2 = this.faker.defaultRefDate(), mode: o2, min: s2, max: l2 } = e2;
    if ([s2, l2, o2].filter((f3) => f3 != null).length % 3 !== 0) throw new m2("The 'min', 'max', and 'mode' options must be set together.");
    let u2 = S2(n2), h2 = u2.getUTCFullYear();
    switch (r2) {
      case "age": {
        let g2 = new Date(u2).setUTCFullYear(h2 - a2 - 1) + 864e5, b2 = new Date(u2).setUTCFullYear(h2 - t2);
        if (g2 > b2) throw new m2(`Max age ${a2} should be greater than or equal to min age ${t2}.`);
        return this.between({ from: g2, to: b2 });
      }
      case "year": {
        let f3 = new Date(Date.UTC(0, 0, 2)).setUTCFullYear(t2), g2 = new Date(Date.UTC(0, 11, 30)).setUTCFullYear(a2);
        if (f3 > g2) throw new m2(`Max year ${a2} should be greater than or equal to min year ${t2}.`);
        return this.between({ from: f3, to: g2 });
      }
    }
  }
};
var V2 = class extends B2 {
  constructor(r2) {
    super(r2);
    this.faker = r2;
  }
  month(r2 = {}) {
    let { abbreviated: t2 = false, context: a2 = false } = r2, n2 = this.faker.definitions.date.month, o2;
    t2 ? o2 = a2 && n2.abbr_context != null ? "abbr_context" : "abbr" : o2 = a2 && n2.wide_context != null ? "wide_context" : "wide";
    let s2 = n2[o2];
    return H2(s2, "date.month", o2), this.faker.helpers.arrayElement(s2);
  }
  weekday(r2 = {}) {
    let { abbreviated: t2 = false, context: a2 = false } = r2, n2 = this.faker.definitions.date.weekday, o2;
    t2 ? o2 = a2 && n2.abbr_context != null ? "abbr_context" : "abbr" : o2 = a2 && n2.wide_context != null ? "wide_context" : "wide";
    let s2 = n2[o2];
    return H2(s2, "date.weekday", o2), this.faker.helpers.arrayElement(s2);
  }
  timeZone() {
    return this.faker.helpers.arrayElement(this.faker.definitions.date.time_zone);
  }
};
var _r = /\.|\(/;
function Ke2(i2, e2, r2 = [e2, e2.rawDefinitions]) {
  if (i2.length === 0) throw new m2("Eval expression cannot be empty.");
  if (r2.length === 0) throw new m2("Eval entrypoints cannot be empty.");
  let t2 = r2, a2 = i2;
  do {
    let o2;
    a2.startsWith("(") ? [o2, t2] = Fr(a2, t2, i2) : [o2, t2] = Or(a2, t2), a2 = a2.substring(o2), t2 = t2.filter((s2) => s2 != null).map((s2) => Array.isArray(s2) ? e2.helpers.arrayElement(s2) : s2);
  } while (a2.length > 0 && t2.length > 0);
  if (t2.length === 0) throw new m2(`Cannot resolve expression '${i2}'`);
  let n2 = t2[0];
  return typeof n2 == "function" ? n2() : n2;
}
function Fr(i2, e2, r2) {
  let [t2, a2] = Gr(i2), n2 = i2[t2 + 1];
  switch (n2) {
    case ".":
    case "(":
    case void 0:
      break;
    default:
      throw new m2(`Expected dot ('.'), open parenthesis ('('), or nothing after function call but got '${n2}'`);
  }
  return [t2 + (n2 === "." ? 2 : 1), e2.map((o2) => typeof o2 == "function" ? o2(...a2) : (console.warn(`[@faker-js/faker]: Invoking expressions which are not functions is deprecated since v9.0 and will be removed in v10.0.
Please remove the parentheses or replace the expression with an actual function.
${r2}
${" ".repeat(r2.length - i2.length)}^`), o2))];
}
function Gr(i2) {
  let e2 = i2.indexOf(")", 1);
  if (e2 === -1) throw new m2(`Missing closing parenthesis in '${i2}'`);
  for (; e2 !== -1; ) {
    let t2 = i2.substring(1, e2);
    try {
      return [e2, JSON.parse(`[${t2}]`)];
    } catch {
      if (!t2.includes("'") && !t2.includes('"')) try {
        return [e2, JSON.parse(`["${t2}"]`)];
      } catch {
      }
    }
    e2 = i2.indexOf(")", e2 + 1);
  }
  e2 = i2.lastIndexOf(")");
  let r2 = i2.substring(1, e2);
  return [e2, [r2]];
}
function Or(i2, e2) {
  let r2 = _r.exec(i2), t2 = (r2?.[0] ?? "") === ".", a2 = r2?.index ?? i2.length, n2 = i2.substring(0, a2);
  if (n2.length === 0) throw new m2(`Expression parts cannot be empty in '${i2}'`);
  let o2 = i2[a2 + 1];
  if (t2 && (o2 == null || o2 === "." || o2 === "(")) throw new m2(`Found dot without property name in '${i2}'`);
  return [a2 + (t2 ? 1 : 0), e2.map((s2) => Ur(s2, n2))];
}
function Ur(i2, e2) {
  switch (typeof i2) {
    case "function": {
      try {
        i2 = i2();
      } catch {
        return;
      }
      return i2?.[e2];
    }
    case "object":
      return i2?.[e2];
    default:
      return;
  }
}
function je2(i2) {
  let e2 = Kr(i2.replace(/L?$/, "0"));
  return e2 === 0 ? 0 : 10 - e2;
}
function Kr(i2) {
  i2 = i2.replaceAll(/[\s-]/g, "");
  let e2 = 0, r2 = false;
  for (let t2 = i2.length - 1; t2 >= 0; t2--) {
    let a2 = Number.parseInt(i2[t2]);
    r2 && (a2 *= 2, a2 > 9 && (a2 = a2 % 10 + 1)), e2 += a2, r2 = !r2;
  }
  return e2 % 10;
}
function He2(i2, e2, r2, t2) {
  let a2 = 1;
  if (e2) switch (e2) {
    case "?": {
      a2 = i2.datatype.boolean() ? 0 : 1;
      break;
    }
    case "*": {
      let n2 = 1;
      for (; i2.datatype.boolean(); ) n2 *= 2;
      a2 = i2.number.int({ min: 0, max: n2 });
      break;
    }
    case "+": {
      let n2 = 1;
      for (; i2.datatype.boolean(); ) n2 *= 2;
      a2 = i2.number.int({ min: 1, max: n2 });
      break;
    }
    default:
      throw new m2("Unknown quantifier symbol provided.");
  }
  else r2 != null && t2 != null ? a2 = i2.number.int({ min: Number.parseInt(r2), max: Number.parseInt(t2) }) : r2 != null && t2 == null && (a2 = Number.parseInt(r2));
  return a2;
}
function jr(i2, e2 = "") {
  let r2 = /(.)\{(\d+),(\d+)\}/, t2 = /(.)\{(\d+)\}/, a2 = /\[(\d+)-(\d+)\]/, n2, o2, s2, l2, c2 = r2.exec(e2);
  for (; c2 != null; ) n2 = Number.parseInt(c2[2]), o2 = Number.parseInt(c2[3]), n2 > o2 && (s2 = o2, o2 = n2, n2 = s2), l2 = i2.number.int({ min: n2, max: o2 }), e2 = e2.slice(0, c2.index) + c2[1].repeat(l2) + e2.slice(c2.index + c2[0].length), c2 = r2.exec(e2);
  for (c2 = t2.exec(e2); c2 != null; ) l2 = Number.parseInt(c2[2]), e2 = e2.slice(0, c2.index) + c2[1].repeat(l2) + e2.slice(c2.index + c2[0].length), c2 = t2.exec(e2);
  for (c2 = a2.exec(e2); c2 != null; ) n2 = Number.parseInt(c2[1]), o2 = Number.parseInt(c2[2]), n2 > o2 && (s2 = o2, o2 = n2, n2 = s2), e2 = e2.slice(0, c2.index) + i2.number.int({ min: n2, max: o2 }).toString() + e2.slice(c2.index + c2[0].length), c2 = a2.exec(e2);
  return e2;
}
function we2(i2, e2 = "", r2 = "#") {
  let t2 = "";
  for (let a2 = 0; a2 < e2.length; a2++) e2.charAt(a2) === r2 ? t2 += i2.number.int(9) : e2.charAt(a2) === "!" ? t2 += i2.number.int({ min: 2, max: 9 }) : t2 += e2.charAt(a2);
  return t2;
}
var v2 = class extends x2 {
  slugify(e2 = "") {
    return e2.normalize("NFKD").replaceAll(/[\u0300-\u036F]/g, "").replaceAll(" ", "-").replaceAll(/[^\w.-]+/g, "");
  }
  replaceSymbols(e2 = "") {
    let r2 = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], t2 = "";
    for (let a2 = 0; a2 < e2.length; a2++) e2.charAt(a2) === "#" ? t2 += this.faker.number.int(9) : e2.charAt(a2) === "?" ? t2 += this.arrayElement(r2) : e2.charAt(a2) === "*" ? t2 += this.faker.datatype.boolean() ? this.arrayElement(r2) : this.faker.number.int(9) : t2 += e2.charAt(a2);
    return t2;
  }
  replaceCreditCardSymbols(e2 = "6453-####-####-####-###L", r2 = "#") {
    e2 = jr(this.faker, e2), e2 = we2(this.faker, e2, r2);
    let t2 = je2(e2);
    return e2.replace("L", String(t2));
  }
  fromRegExp(e2) {
    let r2 = false;
    e2 instanceof RegExp && (r2 = e2.flags.includes("i"), e2 = e2.toString(), e2 = /\/(.+?)\//.exec(e2)?.[1] ?? "");
    let t2, a2, n2, o2 = /([.A-Za-z0-9])(?:\{(\d+)(?:,(\d+)|)\}|(\?|\*|\+))(?![^[]*]|[^{]*})/, s2 = o2.exec(e2);
    for (; s2 != null; ) {
      let f3 = s2[2], g2 = s2[3], b2 = s2[4];
      n2 = He2(this.faker, b2, f3, g2);
      let y2;
      s2[1] === "." ? y2 = this.faker.string.alphanumeric(n2) : r2 ? y2 = this.faker.string.fromCharacters([s2[1].toLowerCase(), s2[1].toUpperCase()], n2) : y2 = s2[1].repeat(n2), e2 = e2.slice(0, s2.index) + y2 + e2.slice(s2.index + s2[0].length), s2 = o2.exec(e2);
    }
    let l2 = /(\d-\d|\w-\w|\d|\w|[-!@#$&()`.+,/"])/, c2 = /\[(\^|)(-|)(.+?)\](?:\{(\d+)(?:,(\d+)|)\}|(\?|\*|\+)|)/;
    for (s2 = c2.exec(e2); s2 != null; ) {
      let f3 = s2[1] === "^", g2 = s2[2] === "-", b2 = s2[4], y2 = s2[5], N2 = s2[6], k2 = [], _2 = s2[3], C2 = l2.exec(_2);
      for (g2 && k2.push(45); C2 != null; ) {
        if (C2[0].includes("-")) {
          let E2 = C2[0].split("-").map((d2) => d2.codePointAt(0) ?? Number.NaN);
          if (t2 = E2[0], a2 = E2[1], t2 > a2) throw new m2("Character range provided is out of order.");
          for (let d2 = t2; d2 <= a2; d2++) if (r2 && Number.isNaN(Number(String.fromCodePoint(d2)))) {
            let Te2 = String.fromCodePoint(d2);
            k2.push(Te2.toUpperCase().codePointAt(0) ?? Number.NaN, Te2.toLowerCase().codePointAt(0) ?? Number.NaN);
          } else k2.push(d2);
        } else r2 && Number.isNaN(Number(C2[0])) ? k2.push(C2[0].toUpperCase().codePointAt(0) ?? Number.NaN, C2[0].toLowerCase().codePointAt(0) ?? Number.NaN) : k2.push(C2[0].codePointAt(0) ?? Number.NaN);
        _2 = _2.substring(C2[0].length), C2 = l2.exec(_2);
      }
      if (n2 = He2(this.faker, N2, b2, y2), f3) {
        let E2 = -1;
        for (let d2 = 48; d2 <= 57; d2++) {
          if (E2 = k2.indexOf(d2), E2 > -1) {
            k2.splice(E2, 1);
            continue;
          }
          k2.push(d2);
        }
        for (let d2 = 65; d2 <= 90; d2++) {
          if (E2 = k2.indexOf(d2), E2 > -1) {
            k2.splice(E2, 1);
            continue;
          }
          k2.push(d2);
        }
        for (let d2 = 97; d2 <= 122; d2++) {
          if (E2 = k2.indexOf(d2), E2 > -1) {
            k2.splice(E2, 1);
            continue;
          }
          k2.push(d2);
        }
      }
      let yr2 = this.multiple(() => String.fromCodePoint(this.arrayElement(k2)), { count: n2 }).join("");
      e2 = e2.slice(0, s2.index) + yr2 + e2.slice(s2.index + s2[0].length), s2 = c2.exec(e2);
    }
    let u2 = /(.)\{(\d+),(\d+)\}/;
    for (s2 = u2.exec(e2); s2 != null; ) {
      if (t2 = Number.parseInt(s2[2]), a2 = Number.parseInt(s2[3]), t2 > a2) throw new m2("Numbers out of order in {} quantifier.");
      n2 = this.faker.number.int({ min: t2, max: a2 }), e2 = e2.slice(0, s2.index) + s2[1].repeat(n2) + e2.slice(s2.index + s2[0].length), s2 = u2.exec(e2);
    }
    let h2 = /(.)\{(\d+)\}/;
    for (s2 = h2.exec(e2); s2 != null; ) n2 = Number.parseInt(s2[2]), e2 = e2.slice(0, s2.index) + s2[1].repeat(n2) + e2.slice(s2.index + s2[0].length), s2 = h2.exec(e2);
    return e2;
  }
  shuffle(e2, r2 = {}) {
    let { inplace: t2 = false } = r2;
    t2 || (e2 = [...e2]);
    for (let a2 = e2.length - 1; a2 > 0; --a2) {
      let n2 = this.faker.number.int(a2);
      [e2[a2], e2[n2]] = [e2[n2], e2[a2]];
    }
    return e2;
  }
  uniqueArray(e2, r2) {
    if (Array.isArray(e2)) {
      let n2 = [...new Set(e2)];
      return this.shuffle(n2).splice(0, r2);
    }
    let t2 = /* @__PURE__ */ new Set();
    try {
      if (typeof e2 == "function") {
        let a2 = 1e3 * r2, n2 = 0;
        for (; t2.size < r2 && n2 < a2; ) t2.add(e2()), n2++;
      }
    } catch {
    }
    return [...t2];
  }
  mustache(e2, r2) {
    if (e2 == null) return "";
    for (let t2 in r2) {
      let a2 = new RegExp(`{{${t2}}}`, "g"), n2 = r2[t2];
      typeof n2 == "string" && (n2 = n2.replaceAll("$", "$$$$")), e2 = e2.replace(a2, n2);
    }
    return e2;
  }
  maybe(e2, r2 = {}) {
    if (this.faker.datatype.boolean(r2)) return e2();
  }
  objectKey(e2) {
    let r2 = Object.keys(e2);
    return this.arrayElement(r2);
  }
  objectValue(e2) {
    let r2 = this.faker.helpers.objectKey(e2);
    return e2[r2];
  }
  objectEntry(e2) {
    let r2 = this.faker.helpers.objectKey(e2);
    return [r2, e2[r2]];
  }
  arrayElement(e2) {
    if (e2.length === 0) throw new m2("Cannot get value from empty dataset.");
    let r2 = e2.length > 1 ? this.faker.number.int({ max: e2.length - 1 }) : 0;
    return e2[r2];
  }
  weightedArrayElement(e2) {
    if (e2.length === 0) throw new m2("weightedArrayElement expects an array with at least one element");
    if (!e2.every((n2) => n2.weight > 0)) throw new m2("weightedArrayElement expects an array of { weight, value } objects where weight is a positive number");
    let r2 = e2.reduce((n2, { weight: o2 }) => n2 + o2, 0), t2 = this.faker.number.float({ min: 0, max: r2 }), a2 = 0;
    for (let { weight: n2, value: o2 } of e2) if (a2 += n2, t2 < a2) return o2;
    return e2.at(-1).value;
  }
  arrayElements(e2, r2) {
    if (e2.length === 0) return [];
    let t2 = this.rangeToNumber(r2 ?? { min: 1, max: e2.length });
    if (t2 >= e2.length) return this.shuffle(e2);
    if (t2 <= 0) return [];
    let a2 = [...e2], n2 = e2.length, o2 = n2 - t2, s2, l2;
    for (; n2-- > o2; ) l2 = this.faker.number.int(n2), s2 = a2[l2], a2[l2] = a2[n2], a2[n2] = s2;
    return a2.slice(o2);
  }
  enumValue(e2) {
    let r2 = Object.keys(e2).filter((a2) => Number.isNaN(Number(a2))), t2 = this.arrayElement(r2);
    return e2[t2];
  }
  rangeToNumber(e2) {
    return typeof e2 == "number" ? e2 : this.faker.number.int(e2);
  }
  multiple(e2, r2 = {}) {
    let t2 = this.rangeToNumber(r2.count ?? 3);
    return t2 <= 0 ? [] : Array.from({ length: t2 }, e2);
  }
};
var z2 = class extends v2 {
  constructor(r2) {
    super(r2);
    this.faker = r2;
  }
  fake(r2) {
    r2 = typeof r2 == "string" ? r2 : this.arrayElement(r2);
    let t2 = r2.search(/{{[a-z]/), a2 = r2.indexOf("}}", t2);
    if (t2 === -1 || a2 === -1) return r2;
    let o2 = r2.substring(t2 + 2, a2 + 2).replace("}}", "").replace("{{", ""), s2 = Ke2(o2, this.faker), l2 = String(s2), c2 = r2.substring(0, t2) + l2 + r2.substring(a2 + 2);
    return this.fake(c2);
  }
};
var W2 = class extends x2 {
  int(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = Number.MAX_SAFE_INTEGER, multipleOf: a2 = 1 } = e2;
    if (!Number.isInteger(a2)) throw new m2("multipleOf should be an integer.");
    if (a2 <= 0) throw new m2("multipleOf should be greater than 0.");
    let n2 = Math.ceil(r2 / a2), o2 = Math.floor(t2 / a2);
    if (n2 === o2) return n2 * a2;
    if (o2 < n2) throw t2 >= r2 ? new m2(`No suitable integer value between ${r2} and ${t2} found.`) : new m2(`Max ${t2} should be greater than min ${r2}.`);
    let l2 = this.faker._randomizer.next(), c2 = o2 - n2 + 1;
    return Math.floor(l2 * c2 + n2) * a2;
  }
  float(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 1, fractionDigits: a2, multipleOf: n2, multipleOf: o2 = a2 == null ? void 0 : 10 ** -a2 } = e2;
    if (t2 < r2) throw new m2(`Max ${t2} should be greater than min ${r2}.`);
    if (a2 != null) {
      if (n2 != null) throw new m2("multipleOf and fractionDigits cannot be set at the same time.");
      if (!Number.isInteger(a2)) throw new m2("fractionDigits should be an integer.");
      if (a2 < 0) throw new m2("fractionDigits should be greater than or equal to 0.");
    }
    if (o2 != null) {
      if (o2 <= 0) throw new m2("multipleOf should be greater than 0.");
      let c2 = Math.log10(o2), u2 = o2 < 1 && Number.isInteger(c2) ? 10 ** -c2 : 1 / o2;
      return this.int({ min: r2 * u2, max: t2 * u2 }) / u2;
    }
    return this.faker._randomizer.next() * (t2 - r2) + r2;
  }
  binary(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 1 } = e2;
    return this.int({ max: t2, min: r2 }).toString(2);
  }
  octal(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 7 } = e2;
    return this.int({ max: t2, min: r2 }).toString(8);
  }
  hex(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 15 } = e2;
    return this.int({ max: t2, min: r2 }).toString(16);
  }
  bigInt(e2 = {}) {
    (typeof e2 == "bigint" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "boolean") && (e2 = { max: e2 });
    let r2 = BigInt(e2.min ?? 0), t2 = BigInt(e2.max ?? r2 + BigInt(999999999999999)), a2 = BigInt(e2.multipleOf ?? 1);
    if (t2 < r2) throw new m2(`Max ${t2} should be larger than min ${r2}.`);
    if (a2 <= BigInt(0)) throw new m2("multipleOf should be greater than 0.");
    let n2 = r2 / a2 + (r2 % a2 > 0n ? 1n : 0n), o2 = t2 / a2 - (t2 % a2 < 0n ? 1n : 0n);
    if (n2 === o2) return n2 * a2;
    if (o2 < n2) throw new m2(`No suitable bigint value between ${r2} and ${t2} found.`);
    let s2 = o2 - n2 + 1n, l2 = BigInt(this.faker.string.numeric({ length: s2.toString(10).length, allowLeadingZeros: true })) % s2;
    return (n2 + l2) * a2;
  }
  romanNumeral(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: a2 = 1, max: n2 = 3999 } = e2;
    if (a2 < 1) throw new m2(`Min value ${a2} should be 1 or greater.`);
    if (n2 > 3999) throw new m2(`Max value ${n2} should be 3999 or less.`);
    let o2 = this.int({ min: a2, max: n2 }), s2 = [["M", 1e3], ["CM", 900], ["D", 500], ["CD", 400], ["C", 100], ["XC", 90], ["L", 50], ["XL", 40], ["X", 10], ["IX", 9], ["V", 5], ["IV", 4], ["I", 1]], l2 = "";
    for (let [c2, u2] of s2) l2 += c2.repeat(Math.floor(o2 / u2)), o2 %= u2;
    return l2;
  }
};
var Se2 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
function Ve2(i2) {
  let e2 = i2.valueOf(), r2 = "";
  for (let t2 = 10; t2 > 0; t2--) {
    let a2 = e2 % 32;
    r2 = Se2[a2] + r2, e2 = (e2 - a2) / 32;
  }
  return r2;
}
var Y2 = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZ"];
var Z2 = [..."abcdefghijklmnopqrstuvwxyz"];
var ze2 = [..."0123456789"];
var J2 = class extends x2 {
  fromCharacters(e2, r2 = 1) {
    if (r2 = this.faker.helpers.rangeToNumber(r2), r2 <= 0) return "";
    if (typeof e2 == "string" && (e2 = [...e2]), e2.length === 0) throw new m2("Unable to generate string: No characters to select from.");
    return this.faker.helpers.multiple(() => this.faker.helpers.arrayElement(e2), { count: r2 }).join("");
  }
  alpha(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let r2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (r2 <= 0) return "";
    let { casing: t2 = "mixed" } = e2, { exclude: a2 = [] } = e2;
    typeof a2 == "string" && (a2 = [...a2]);
    let n2;
    switch (t2) {
      case "upper": {
        n2 = [...Y2];
        break;
      }
      case "lower": {
        n2 = [...Z2];
        break;
      }
      case "mixed": {
        n2 = [...Z2, ...Y2];
        break;
      }
    }
    return n2 = n2.filter((o2) => !a2.includes(o2)), this.fromCharacters(n2, r2);
  }
  alphanumeric(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let r2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (r2 <= 0) return "";
    let { casing: t2 = "mixed" } = e2, { exclude: a2 = [] } = e2;
    typeof a2 == "string" && (a2 = [...a2]);
    let n2 = [...ze2];
    switch (t2) {
      case "upper": {
        n2.push(...Y2);
        break;
      }
      case "lower": {
        n2.push(...Z2);
        break;
      }
      case "mixed": {
        n2.push(...Z2, ...Y2);
        break;
      }
    }
    return n2 = n2.filter((o2) => !a2.includes(o2)), this.fromCharacters(n2, r2);
  }
  binary(e2 = {}) {
    let { prefix: r2 = "0b" } = e2, t2 = r2;
    return t2 += this.fromCharacters(["0", "1"], e2.length ?? 1), t2;
  }
  octal(e2 = {}) {
    let { prefix: r2 = "0o" } = e2, t2 = r2;
    return t2 += this.fromCharacters(["0", "1", "2", "3", "4", "5", "6", "7"], e2.length ?? 1), t2;
  }
  hexadecimal(e2 = {}) {
    let { casing: r2 = "mixed", prefix: t2 = "0x" } = e2, a2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (a2 <= 0) return t2;
    let n2 = this.fromCharacters(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"], a2);
    return r2 === "upper" ? n2 = n2.toUpperCase() : r2 === "lower" && (n2 = n2.toLowerCase()), `${t2}${n2}`;
  }
  numeric(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let r2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (r2 <= 0) return "";
    let { allowLeadingZeros: t2 = true } = e2, { exclude: a2 = [] } = e2;
    typeof a2 == "string" && (a2 = [...a2]);
    let n2 = ze2.filter((s2) => !a2.includes(s2));
    if (n2.length === 0 || n2.length === 1 && !t2 && n2[0] === "0") throw new m2("Unable to generate numeric string, because all possible digits are excluded.");
    let o2 = "";
    return !t2 && !a2.includes("0") && (o2 += this.faker.helpers.arrayElement(n2.filter((s2) => s2 !== "0"))), o2 += this.fromCharacters(n2, r2 - o2.length), o2;
  }
  sample(e2 = 10) {
    e2 = this.faker.helpers.rangeToNumber(e2);
    let r2 = { min: 33, max: 125 }, t2 = "";
    for (; t2.length < e2; ) t2 += String.fromCodePoint(this.faker.number.int(r2));
    return t2;
  }
  uuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replaceAll("x", () => this.faker.number.hex({ min: 0, max: 15 })).replaceAll("y", () => this.faker.number.hex({ min: 8, max: 11 }));
  }
  ulid(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = S2(r2);
    return Ve2(t2) + this.fromCharacters(Se2, 16);
  }
  nanoid(e2 = 21) {
    if (e2 = this.faker.helpers.rangeToNumber(e2), e2 <= 0) return "";
    let r2 = [{ value: () => this.alphanumeric(1), weight: 62 }, { value: () => this.faker.helpers.arrayElement(["_", "-"]), weight: 2 }], t2 = "";
    for (; t2.length < e2; ) {
      let a2 = this.faker.helpers.weightedArrayElement(r2);
      t2 += a2();
    }
    return t2;
  }
  symbol(e2 = 1) {
    return this.fromCharacters(["!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"], e2);
  }
};
var $2 = class {
  _defaultRefDate = () => /* @__PURE__ */ new Date();
  get defaultRefDate() {
    return this._defaultRefDate;
  }
  setDefaultRefDate(e2 = () => /* @__PURE__ */ new Date()) {
    typeof e2 == "function" ? this._defaultRefDate = e2 : this._defaultRefDate = () => new Date(e2);
  }
  _randomizer;
  datatype = new K2(this);
  date = new B2(this);
  helpers = new v2(this);
  number = new W2(this);
  string = new J2(this);
  constructor(e2 = {}) {
    let { randomizer: r2, seed: t2 } = e2;
    r2 != null && t2 != null && r2.seed(t2), this._randomizer = r2 ?? Oe2(t2);
  }
  seed(e2 = P2()) {
    return this._randomizer.seed(e2), e2;
  }
};
var fa2 = new $2();
function We2(i2) {
  let e2 = {};
  for (let r2 of i2) for (let t2 in r2) {
    let a2 = r2[t2];
    e2[t2] === void 0 ? e2[t2] = { ...a2 } : e2[t2] = { ...a2, ...e2[t2] };
  }
  return e2;
}
var X2 = class extends p2 {
  dog() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.dog);
  }
  cat() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.cat);
  }
  snake() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.snake);
  }
  bear() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.bear);
  }
  lion() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.lion);
  }
  cetacean() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.cetacean);
  }
  horse() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.horse);
  }
  bird() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.bird);
  }
  cow() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.cow);
  }
  fish() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.fish);
  }
  crocodilia() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.crocodilia);
  }
  insect() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.insect);
  }
  rabbit() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.rabbit);
  }
  rodent() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.rodent);
  }
  type() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.type);
  }
  petName() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.pet_name);
  }
};
var Q2 = class extends p2 {
  author() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.author);
  }
  format() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.format);
  }
  genre() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.genre);
  }
  publisher() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.publisher);
  }
  series() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.series);
  }
  title() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.title);
  }
};
var Hr = { 0: [[1999999, 2], [2279999, 3], [2289999, 4], [3689999, 3], [3699999, 4], [6389999, 3], [6397999, 4], [6399999, 7], [6449999, 3], [6459999, 7], [6479999, 3], [6489999, 7], [6549999, 3], [6559999, 4], [6999999, 3], [8499999, 4], [8999999, 5], [9499999, 6], [9999999, 7]], 1: [[99999, 3], [299999, 2], [349999, 3], [399999, 4], [499999, 3], [699999, 2], [999999, 4], [3979999, 3], [5499999, 4], [6499999, 5], [6799999, 4], [6859999, 5], [7139999, 4], [7169999, 3], [7319999, 4], [7399999, 7], [7749999, 5], [7753999, 7], [7763999, 5], [7764999, 7], [7769999, 5], [7782999, 7], [7899999, 5], [7999999, 4], [8004999, 5], [8049999, 5], [8379999, 5], [8384999, 7], [8671999, 5], [8675999, 4], [8697999, 5], [9159999, 6], [9165059, 7], [9168699, 6], [9169079, 7], [9195999, 6], [9196549, 7], [9729999, 6], [9877999, 4], [9911499, 6], [9911999, 7], [9989899, 6], [9999999, 7]] };
var q2 = class extends p2 {
  department() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.department);
  }
  productName() {
    return `${this.productAdjective()} ${this.productMaterial()} ${this.product()}`;
  }
  price(e2 = {}) {
    let { dec: r2 = 2, max: t2 = 1e3, min: a2 = 1, symbol: n2 = "" } = e2;
    if (a2 < 0 || t2 < 0) return `${n2}0`;
    if (a2 === t2) return `${n2}${a2.toFixed(r2)}`;
    let o2 = this.faker.number.float({ min: a2, max: t2, fractionDigits: r2 });
    if (r2 === 0) return `${n2}${o2.toFixed(r2)}`;
    let s2 = o2 * 10 ** r2 % 10, l2 = this.faker.helpers.weightedArrayElement([{ weight: 5, value: 9 }, { weight: 3, value: 5 }, { weight: 1, value: 0 }, { weight: 1, value: this.faker.number.int({ min: 0, max: 9 }) }]), c2 = (1 / 10) ** r2, u2 = s2 * c2, h2 = l2 * c2, f3 = o2 - u2 + h2;
    return a2 <= f3 && f3 <= t2 ? `${n2}${f3.toFixed(r2)}` : `${n2}${o2.toFixed(r2)}`;
  }
  productAdjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.product_name.adjective);
  }
  productMaterial() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.product_name.material);
  }
  product() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.product_name.product);
  }
  productDescription() {
    return this.faker.helpers.fake(this.faker.definitions.commerce.product_description);
  }
  isbn(e2 = {}) {
    typeof e2 == "number" && (e2 = { variant: e2 });
    let { variant: r2 = 13, separator: t2 = "-" } = e2, a2 = "978", [n2, o2] = this.faker.helpers.objectEntry(Hr), s2 = this.faker.string.numeric(8), l2 = Number.parseInt(s2.slice(0, -1)), c2 = o2.find(([y2]) => l2 <= y2)?.[1];
    if (!c2) throw new m2(`Unable to find a registrant length for the group ${n2}`);
    let u2 = s2.slice(0, c2), h2 = s2.slice(c2), f3 = [a2, n2, u2, h2];
    r2 === 10 && f3.shift();
    let g2 = f3.join(""), b2 = 0;
    for (let y2 = 0; y2 < r2 - 1; y2++) {
      let N2 = r2 === 10 ? y2 + 1 : y2 % 2 ? 3 : 1;
      b2 += N2 * Number.parseInt(g2[y2]);
    }
    return b2 = r2 === 10 ? b2 % 11 : (10 - b2 % 10) % 10, f3.push(b2 === 10 ? "X" : b2.toString()), f3.join(t2);
  }
};
var ee2 = class extends p2 {
  name() {
    return this.faker.helpers.fake(this.faker.definitions.company.name_pattern);
  }
  catchPhrase() {
    return [this.catchPhraseAdjective(), this.catchPhraseDescriptor(), this.catchPhraseNoun()].join(" ");
  }
  buzzPhrase() {
    return [this.buzzVerb(), this.buzzAdjective(), this.buzzNoun()].join(" ");
  }
  catchPhraseAdjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.adjective);
  }
  catchPhraseDescriptor() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.descriptor);
  }
  catchPhraseNoun() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.noun);
  }
  buzzAdjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.buzz_adjective);
  }
  buzzVerb() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.buzz_verb);
  }
  buzzNoun() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.buzz_noun);
  }
};
var re2 = class extends p2 {
  column() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.column);
  }
  type() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.type);
  }
  collation() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.collation);
  }
  engine() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.engine);
  }
  mongodbObjectId() {
    return this.faker.string.hexadecimal({ length: 24, casing: "lower", prefix: "" });
  }
};
var Vr = { alpha: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], formats: [{ country: "AL", total: 28, bban: [{ type: "n", count: 8 }, { type: "c", count: 16 }], format: "ALkk bbbs sssx cccc cccc cccc cccc" }, { country: "AD", total: 24, bban: [{ type: "n", count: 8 }, { type: "c", count: 12 }], format: "ADkk bbbb ssss cccc cccc cccc" }, { country: "AT", total: 20, bban: [{ type: "n", count: 5 }, { type: "n", count: 11 }], format: "ATkk bbbb bccc cccc cccc" }, { country: "AZ", total: 28, bban: [{ type: "a", count: 4 }, { type: "n", count: 20 }], format: "AZkk bbbb cccc cccc cccc cccc cccc" }, { country: "BH", total: 22, bban: [{ type: "a", count: 4 }, { type: "c", count: 14 }], format: "BHkk bbbb cccc cccc cccc cc" }, { country: "BE", total: 16, bban: [{ type: "n", count: 3 }, { type: "n", count: 9 }], format: "BEkk bbbc cccc ccxx" }, { country: "BA", total: 20, bban: [{ type: "n", count: 6 }, { type: "n", count: 10 }], format: "BAkk bbbs sscc cccc ccxx" }, { country: "BR", total: 29, bban: [{ type: "n", count: 13 }, { type: "n", count: 10 }, { type: "a", count: 1 }, { type: "c", count: 1 }], format: "BRkk bbbb bbbb ssss sccc cccc ccct n" }, { country: "BG", total: 22, bban: [{ type: "a", count: 4 }, { type: "n", count: 6 }, { type: "c", count: 8 }], format: "BGkk bbbb ssss ddcc cccc cc" }, { country: "CR", total: 22, bban: [{ type: "n", count: 1 }, { type: "n", count: 3 }, { type: "n", count: 14 }], format: "CRkk xbbb cccc cccc cccc cc" }, { country: "HR", total: 21, bban: [{ type: "n", count: 7 }, { type: "n", count: 10 }], format: "HRkk bbbb bbbc cccc cccc c" }, { country: "CY", total: 28, bban: [{ type: "n", count: 8 }, { type: "c", count: 16 }], format: "CYkk bbbs ssss cccc cccc cccc cccc" }, { country: "CZ", total: 24, bban: [{ type: "n", count: 10 }, { type: "n", count: 10 }], format: "CZkk bbbb ssss sscc cccc cccc" }, { country: "DK", total: 18, bban: [{ type: "n", count: 4 }, { type: "n", count: 10 }], format: "DKkk bbbb cccc cccc cc" }, { country: "DO", total: 28, bban: [{ type: "a", count: 4 }, { type: "n", count: 20 }], format: "DOkk bbbb cccc cccc cccc cccc cccc" }, { country: "TL", total: 23, bban: [{ type: "n", count: 3 }, { type: "n", count: 16 }], format: "TLkk bbbc cccc cccc cccc cxx" }, { country: "EE", total: 20, bban: [{ type: "n", count: 4 }, { type: "n", count: 12 }], format: "EEkk bbss cccc cccc cccx" }, { country: "FO", total: 18, bban: [{ type: "n", count: 4 }, { type: "n", count: 10 }], format: "FOkk bbbb cccc cccc cx" }, { country: "FI", total: 18, bban: [{ type: "n", count: 6 }, { type: "n", count: 8 }], format: "FIkk bbbb bbcc cccc cx" }, { country: "FR", total: 27, bban: [{ type: "n", count: 10 }, { type: "c", count: 11 }, { type: "n", count: 2 }], format: "FRkk bbbb bggg ggcc cccc cccc cxx" }, { country: "GE", total: 22, bban: [{ type: "a", count: 2 }, { type: "n", count: 16 }], format: "GEkk bbcc cccc cccc cccc cc" }, { country: "DE", total: 22, bban: [{ type: "n", count: 8 }, { type: "n", count: 10 }], format: "DEkk bbbb bbbb cccc cccc cc" }, { country: "GI", total: 23, bban: [{ type: "a", count: 4 }, { type: "c", count: 15 }], format: "GIkk bbbb cccc cccc cccc ccc" }, { country: "GR", total: 27, bban: [{ type: "n", count: 7 }, { type: "c", count: 16 }], format: "GRkk bbbs sssc cccc cccc cccc ccc" }, { country: "GL", total: 18, bban: [{ type: "n", count: 4 }, { type: "n", count: 10 }], format: "GLkk bbbb cccc cccc cc" }, { country: "GT", total: 28, bban: [{ type: "c", count: 4 }, { type: "c", count: 4 }, { type: "c", count: 16 }], format: "GTkk bbbb mmtt cccc cccc cccc cccc" }, { country: "HU", total: 28, bban: [{ type: "n", count: 8 }, { type: "n", count: 16 }], format: "HUkk bbbs sssk cccc cccc cccc cccx" }, { country: "IS", total: 26, bban: [{ type: "n", count: 6 }, { type: "n", count: 16 }], format: "ISkk bbbb sscc cccc iiii iiii ii" }, { country: "IE", total: 22, bban: [{ type: "a", count: 4 }, { type: "n", count: 6 }, { type: "n", count: 8 }], format: "IEkk aaaa bbbb bbcc cccc cc" }, { country: "IL", total: 23, bban: [{ type: "n", count: 6 }, { type: "n", count: 13 }], format: "ILkk bbbn nncc cccc cccc ccc" }, { country: "IT", total: 27, bban: [{ type: "a", count: 1 }, { type: "n", count: 10 }, { type: "c", count: 12 }], format: "ITkk xaaa aabb bbbc cccc cccc ccc" }, { country: "JO", total: 30, bban: [{ type: "a", count: 4 }, { type: "n", count: 4 }, { type: "n", count: 18 }], format: "JOkk bbbb nnnn cccc cccc cccc cccc cc" }, { country: "KZ", total: 20, bban: [{ type: "n", count: 3 }, { type: "c", count: 13 }], format: "KZkk bbbc cccc cccc cccc" }, { country: "XK", total: 20, bban: [{ type: "n", count: 4 }, { type: "n", count: 12 }], format: "XKkk bbbb cccc cccc cccc" }, { country: "KW", total: 30, bban: [{ type: "a", count: 4 }, { type: "c", count: 22 }], format: "KWkk bbbb cccc cccc cccc cccc cccc cc" }, { country: "LV", total: 21, bban: [{ type: "a", count: 4 }, { type: "c", count: 13 }], format: "LVkk bbbb cccc cccc cccc c" }, { country: "LB", total: 28, bban: [{ type: "n", count: 4 }, { type: "c", count: 20 }], format: "LBkk bbbb cccc cccc cccc cccc cccc" }, { country: "LI", total: 21, bban: [{ type: "n", count: 5 }, { type: "c", count: 12 }], format: "LIkk bbbb bccc cccc cccc c" }, { country: "LT", total: 20, bban: [{ type: "n", count: 5 }, { type: "n", count: 11 }], format: "LTkk bbbb bccc cccc cccc" }, { country: "LU", total: 20, bban: [{ type: "n", count: 3 }, { type: "c", count: 13 }], format: "LUkk bbbc cccc cccc cccc" }, { country: "MK", total: 19, bban: [{ type: "n", count: 3 }, { type: "c", count: 10 }, { type: "n", count: 2 }], format: "MKkk bbbc cccc cccc cxx" }, { country: "MT", total: 31, bban: [{ type: "a", count: 4 }, { type: "n", count: 5 }, { type: "c", count: 18 }], format: "MTkk bbbb ssss sccc cccc cccc cccc ccc" }, { country: "MR", total: 27, bban: [{ type: "n", count: 10 }, { type: "n", count: 13 }], format: "MRkk bbbb bsss sscc cccc cccc cxx" }, { country: "MU", total: 30, bban: [{ type: "a", count: 4 }, { type: "n", count: 4 }, { type: "n", count: 15 }, { type: "a", count: 3 }], format: "MUkk bbbb bbss cccc cccc cccc 000d dd" }, { country: "MC", total: 27, bban: [{ type: "n", count: 10 }, { type: "c", count: 11 }, { type: "n", count: 2 }], format: "MCkk bbbb bsss sscc cccc cccc cxx" }, { country: "MD", total: 24, bban: [{ type: "c", count: 2 }, { type: "c", count: 18 }], format: "MDkk bbcc cccc cccc cccc cccc" }, { country: "ME", total: 22, bban: [{ type: "n", count: 3 }, { type: "n", count: 15 }], format: "MEkk bbbc cccc cccc cccc xx" }, { country: "NL", total: 18, bban: [{ type: "a", count: 4 }, { type: "n", count: 10 }], format: "NLkk bbbb cccc cccc cc" }, { country: "NO", total: 15, bban: [{ type: "n", count: 4 }, { type: "n", count: 7 }], format: "NOkk bbbb cccc ccx" }, { country: "PK", total: 24, bban: [{ type: "a", count: 4 }, { type: "n", count: 16 }], format: "PKkk bbbb cccc cccc cccc cccc" }, { country: "PS", total: 29, bban: [{ type: "a", count: 4 }, { type: "n", count: 9 }, { type: "n", count: 12 }], format: "PSkk bbbb xxxx xxxx xccc cccc cccc c" }, { country: "PL", total: 28, bban: [{ type: "n", count: 8 }, { type: "n", count: 16 }], format: "PLkk bbbs sssx cccc cccc cccc cccc" }, { country: "PT", total: 25, bban: [{ type: "n", count: 8 }, { type: "n", count: 13 }], format: "PTkk bbbb ssss cccc cccc cccx x" }, { country: "QA", total: 29, bban: [{ type: "a", count: 4 }, { type: "c", count: 21 }], format: "QAkk bbbb cccc cccc cccc cccc cccc c" }, { country: "RO", total: 24, bban: [{ type: "a", count: 4 }, { type: "c", count: 16 }], format: "ROkk bbbb cccc cccc cccc cccc" }, { country: "SM", total: 27, bban: [{ type: "a", count: 1 }, { type: "n", count: 10 }, { type: "c", count: 12 }], format: "SMkk xaaa aabb bbbc cccc cccc ccc" }, { country: "SA", total: 24, bban: [{ type: "n", count: 2 }, { type: "c", count: 18 }], format: "SAkk bbcc cccc cccc cccc cccc" }, { country: "RS", total: 22, bban: [{ type: "n", count: 3 }, { type: "n", count: 15 }], format: "RSkk bbbc cccc cccc cccc xx" }, { country: "SK", total: 24, bban: [{ type: "n", count: 10 }, { type: "n", count: 10 }], format: "SKkk bbbb ssss sscc cccc cccc" }, { country: "SI", total: 19, bban: [{ type: "n", count: 5 }, { type: "n", count: 10 }], format: "SIkk bbss sccc cccc cxx" }, { country: "ES", total: 24, bban: [{ type: "n", count: 10 }, { type: "n", count: 10 }], format: "ESkk bbbb gggg xxcc cccc cccc" }, { country: "SE", total: 24, bban: [{ type: "n", count: 3 }, { type: "n", count: 17 }], format: "SEkk bbbc cccc cccc cccc cccc" }, { country: "CH", total: 21, bban: [{ type: "n", count: 5 }, { type: "c", count: 12 }], format: "CHkk bbbb bccc cccc cccc c" }, { country: "TN", total: 24, bban: [{ type: "n", count: 5 }, { type: "n", count: 15 }], format: "TNkk bbss sccc cccc cccc cccc" }, { country: "TR", total: 26, bban: [{ type: "n", count: 5 }, { type: "n", count: 1 }, { type: "n", count: 16 }], format: "TRkk bbbb bxcc cccc cccc cccc cc" }, { country: "AE", total: 23, bban: [{ type: "n", count: 3 }, { type: "n", count: 16 }], format: "AEkk bbbc cccc cccc cccc ccc" }, { country: "GB", total: 22, bban: [{ type: "a", count: 4 }, { type: "n", count: 6 }, { type: "n", count: 8 }], format: "GBkk bbbb ssss sscc cccc cc" }, { country: "VG", total: 24, bban: [{ type: "a", count: 4 }, { type: "n", count: 16 }], format: "VGkk bbbb cccc cccc cccc cccc" }], iso3166: ["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW"], mod97: (i2) => {
  let e2 = 0;
  for (let r2 of i2) e2 = (e2 * 10 + +r2) % 97;
  return e2;
}, pattern10: ["01", "02", "03", "04", "05", "06", "07", "08", "09"], pattern100: ["001", "002", "003", "004", "005", "006", "007", "008", "009"], toDigitString: (i2) => i2.replaceAll(/[A-Z]/gi, (e2) => String((e2.toUpperCase().codePointAt(0) ?? Number.NaN) - 55)) };
var M2 = Vr;
function zr(i2) {
  let e2 = "";
  for (let r2 = 0; r2 < i2.length; r2 += 4) e2 += `${i2.substring(r2, r2 + 4)} `;
  return e2.trimEnd();
}
var te2 = class extends p2 {
  accountNumber(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let { length: r2 = 8 } = e2;
    return this.faker.string.numeric({ length: r2, allowLeadingZeros: true });
  }
  accountName() {
    return [this.faker.helpers.arrayElement(this.faker.definitions.finance.account_type), "Account"].join(" ");
  }
  routingNumber() {
    let e2 = this.faker.string.numeric({ length: 8, allowLeadingZeros: true }), r2 = 0;
    for (let t2 = 0; t2 < e2.length; t2 += 3) r2 += Number(e2[t2]) * 3, r2 += Number(e2[t2 + 1]) * 7, r2 += Number(e2[t2 + 2]) || 0;
    return `${e2}${Math.ceil(r2 / 10) * 10 - r2}`;
  }
  maskedNumber(e2 = {}) {
    w2({ deprecated: "faker.finance.maskedNumber()", proposed: "faker.finance.iban().replace(/(?<=.{4})\\w(?=.{2})/g, '*') or a similar approach", since: "9.3.0", until: "10.0.0" }), typeof e2 == "number" && (e2 = { length: e2 });
    let { ellipsis: r2 = true, length: t2 = 4, parens: a2 = true } = e2, n2 = this.faker.string.numeric({ length: t2 });
    return r2 && (n2 = `...${n2}`), a2 && (n2 = `(${n2})`), n2;
  }
  amount(e2 = {}) {
    let { autoFormat: r2 = false, dec: t2 = 2, max: a2 = 1e3, min: n2 = 0, symbol: o2 = "" } = e2, s2 = this.faker.number.float({ max: a2, min: n2, fractionDigits: t2 }), l2 = r2 ? s2.toLocaleString(void 0, { minimumFractionDigits: t2 }) : s2.toFixed(t2);
    return o2 + l2;
  }
  transactionType() {
    return this.faker.helpers.arrayElement(this.faker.definitions.finance.transaction_type);
  }
  currency() {
    return this.faker.helpers.arrayElement(this.faker.definitions.finance.currency);
  }
  currencyCode() {
    return this.currency().code;
  }
  currencyName() {
    return this.currency().name;
  }
  currencySymbol() {
    let e2;
    do
      e2 = this.currency().symbol;
    while (e2.length === 0);
    return e2;
  }
  currencyNumericCode() {
    return this.currency().numericCode;
  }
  bitcoinAddress(e2 = {}) {
    let { type: r2 = this.faker.helpers.enumValue(be2), network: t2 = "mainnet" } = e2, a2 = Be2[r2], n2 = a2.prefix[t2], o2 = this.faker.number.int(a2.length), s2 = this.faker.string.alphanumeric({ length: o2 - n2.length, casing: a2.casing, exclude: a2.exclude });
    return n2 + s2;
  }
  litecoinAddress() {
    let e2 = this.faker.number.int({ min: 26, max: 33 });
    return this.faker.string.fromCharacters("LM3") + this.faker.string.fromCharacters("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", e2 - 1);
  }
  creditCardNumber(e2 = {}) {
    typeof e2 == "string" && (e2 = { issuer: e2 });
    let { issuer: r2 = "" } = e2, t2, a2 = this.faker.definitions.finance.credit_card, n2 = r2.toLowerCase();
    if (n2 in a2) t2 = this.faker.helpers.arrayElement(a2[n2]);
    else if (r2.includes("#")) t2 = r2;
    else {
      let o2 = this.faker.helpers.objectValue(a2);
      t2 = this.faker.helpers.arrayElement(o2);
    }
    return t2 = t2.replaceAll("/", ""), this.faker.helpers.replaceCreditCardSymbols(t2);
  }
  creditCardCVV() {
    return this.faker.string.numeric({ length: 3, allowLeadingZeros: true });
  }
  creditCardIssuer() {
    return this.faker.helpers.objectKey(this.faker.definitions.finance.credit_card);
  }
  pin(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let { length: r2 = 4 } = e2;
    if (r2 < 1) throw new m2("minimum length is 1");
    return this.faker.string.numeric({ length: r2, allowLeadingZeros: true });
  }
  ethereumAddress() {
    return this.faker.string.hexadecimal({ length: 40, casing: "lower" });
  }
  iban(e2 = {}) {
    let { countryCode: r2, formatted: t2 = false } = e2, a2 = r2 ? M2.formats.find((c2) => c2.country === r2) : this.faker.helpers.arrayElement(M2.formats);
    if (!a2) throw new m2(`Country code ${r2} not supported.`);
    let n2 = "", o2 = 0;
    for (let c2 of a2.bban) {
      let u2 = c2.count;
      for (o2 += c2.count; u2 > 0; ) c2.type === "a" ? n2 += this.faker.helpers.arrayElement(M2.alpha) : c2.type === "c" ? this.faker.datatype.boolean(0.8) ? n2 += this.faker.number.int(9) : n2 += this.faker.helpers.arrayElement(M2.alpha) : u2 >= 3 && this.faker.datatype.boolean(0.3) ? this.faker.datatype.boolean() ? (n2 += this.faker.helpers.arrayElement(M2.pattern100), u2 -= 2) : (n2 += this.faker.helpers.arrayElement(M2.pattern10), u2--) : n2 += this.faker.number.int(9), u2--;
      n2 = n2.substring(0, o2);
    }
    let s2 = 98 - M2.mod97(M2.toDigitString(`${n2}${a2.country}00`));
    s2 < 10 && (s2 = `0${s2}`);
    let l2 = `${a2.country}${s2}${n2}`;
    return t2 ? zr(l2) : l2;
  }
  bic(e2 = {}) {
    let { includeBranchCode: r2 = this.faker.datatype.boolean() } = e2, t2 = this.faker.string.alpha({ length: 4, casing: "upper" }), a2 = this.faker.helpers.arrayElement(M2.iso3166), n2 = this.faker.string.alphanumeric({ length: 2, casing: "upper" }), o2 = r2 ? this.faker.datatype.boolean() ? this.faker.string.alphanumeric({ length: 3, casing: "upper" }) : "XXX" : "";
    return `${t2}${a2}${n2}${o2}`;
  }
  transactionDescription() {
    return this.faker.helpers.fake(this.faker.definitions.finance.transaction_description_pattern);
  }
};
function Ye2(i2) {
  return i2.split(" ").map((e2) => e2.charAt(0).toUpperCase() + e2.slice(1)).join(" ");
}
var ae2 = class extends p2 {
  adjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.adjective);
  }
  description() {
    return this.faker.helpers.fake(this.faker.definitions.food.description_pattern);
  }
  dish() {
    return this.faker.datatype.boolean() ? Ye2(this.faker.helpers.fake(this.faker.definitions.food.dish_pattern)) : Ye2(this.faker.helpers.arrayElement(this.faker.definitions.food.dish));
  }
  ethnicCategory() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.ethnic_category);
  }
  fruit() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.fruit);
  }
  ingredient() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.ingredient);
  }
  meat() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.meat);
  }
  spice() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.spice);
  }
  vegetable() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.vegetable);
  }
};
var Wr = "\xA0";
var ne2 = class extends p2 {
  branch() {
    let e2 = this.faker.hacker.noun().replace(" ", "-"), r2 = this.faker.hacker.verb().replace(" ", "-");
    return `${e2}-${r2}`;
  }
  commitEntry(e2 = {}) {
    let { merge: r2 = this.faker.datatype.boolean({ probability: 0.2 }), eol: t2 = "CRLF", refDate: a2 } = e2, n2 = [`commit ${this.faker.git.commitSha()}`];
    r2 && n2.push(`Merge: ${this.commitSha({ length: 7 })} ${this.commitSha({ length: 7 })}`);
    let o2 = this.faker.person.firstName(), s2 = this.faker.person.lastName(), l2 = this.faker.person.fullName({ firstName: o2, lastName: s2 }), c2 = this.faker.internet.username({ firstName: o2, lastName: s2 }), u2 = this.faker.helpers.arrayElement([l2, c2]), h2 = this.faker.internet.email({ firstName: o2, lastName: s2 });
    u2 = u2.replaceAll(/^[.,:;"\\']|[<>\n]|[.,:;"\\']$/g, ""), n2.push(`Author: ${u2} <${h2}>`, `Date: ${this.commitDate({ refDate: a2 })}`, "", `${Wr.repeat(4)}${this.commitMessage()}`, "");
    let f3 = t2 === "CRLF" ? `\r
` : `
`;
    return n2.join(f3);
  }
  commitMessage() {
    return `${this.faker.hacker.verb()} ${this.faker.hacker.adjective()} ${this.faker.hacker.noun()}`;
  }
  commitDate(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], a2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], n2 = this.faker.date.recent({ days: 1, refDate: r2 }), o2 = t2[n2.getUTCDay()], s2 = a2[n2.getUTCMonth()], l2 = n2.getUTCDate(), c2 = n2.getUTCHours().toString().padStart(2, "0"), u2 = n2.getUTCMinutes().toString().padStart(2, "0"), h2 = n2.getUTCSeconds().toString().padStart(2, "0"), f3 = n2.getUTCFullYear(), g2 = this.faker.number.int({ min: -11, max: 12 }), b2 = Math.abs(g2).toString().padStart(2, "0"), y2 = "00", N2 = g2 >= 0 ? "+" : "-";
    return `${o2} ${s2} ${l2} ${c2}:${u2}:${h2} ${f3} ${N2}${b2}${y2}`;
  }
  commitSha(e2 = {}) {
    let { length: r2 = 40 } = e2;
    return this.faker.string.hexadecimal({ length: r2, casing: "lower", prefix: "" });
  }
};
var ie2 = class extends p2 {
  abbreviation() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.abbreviation);
  }
  adjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.adjective);
  }
  noun() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.noun);
  }
  verb() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.verb);
  }
  ingverb() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.ingverb);
  }
  phrase() {
    let e2 = { abbreviation: this.abbreviation, adjective: this.adjective, ingverb: this.ingverb, noun: this.noun, verb: this.verb }, r2 = this.faker.helpers.arrayElement(this.faker.definitions.hacker.phrase);
    return this.faker.helpers.mustache(r2, e2);
  }
};
var oe2 = class extends p2 {
  avatar() {
    return this.faker.helpers.arrayElement([this.personPortrait, this.avatarGitHub])();
  }
  avatarGitHub() {
    return `https://avatars.githubusercontent.com/u/${this.faker.number.int(1e8)}`;
  }
  personPortrait(e2 = {}) {
    let { sex: r2 = this.faker.person.sexType(), size: t2 = 512 } = e2;
    return `https://cdn.jsdelivr.net/gh/faker-js/assets-person-portrait/${r2}/${t2}/${this.faker.number.int({ min: 0, max: 99 })}.jpg`;
  }
  avatarLegacy() {
    return w2({ deprecated: "faker.image.avatarLegacy()", proposed: "faker.image.avatar() or faker.image.personPortrait()", since: "9.0.2", until: "10.0.0" }), `https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/${this.faker.number.int(1249)}.jpg`;
  }
  url(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }) } = e2;
    return this.faker.helpers.arrayElement([this.urlLoremFlickr, ({ width: n2, height: o2 }) => this.urlPicsumPhotos({ width: n2, height: o2, grayscale: false, blur: 0 })])({ width: r2, height: t2 });
  }
  urlLoremFlickr(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }), category: a2 } = e2;
    return `https://loremflickr.com/${r2}/${t2}${a2 == null ? "" : `/${a2}`}?lock=${this.faker.number.int()}`;
  }
  urlPicsumPhotos(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }), grayscale: a2 = this.faker.datatype.boolean(), blur: n2 = this.faker.number.int({ max: 10 }) } = e2, o2 = `https://picsum.photos/seed/${this.faker.string.alphanumeric({ length: { min: 5, max: 10 } })}/${r2}/${t2}`, s2 = typeof n2 == "number" && n2 >= 1 && n2 <= 10;
    return (a2 || s2) && (o2 += "?", a2 && (o2 += "grayscale"), a2 && s2 && (o2 += "&"), s2 && (o2 += `blur=${n2}`)), o2;
  }
  urlPlaceholder(e2 = {}) {
    w2({ deprecated: "faker.image.urlPlaceholder()", proposed: "faker.image.url() or faker.image.dataUri()", since: "9.4.0", until: "10.0.0" });
    let { width: r2 = this.faker.number.int({ min: 1, max: 3500 }), height: t2 = this.faker.number.int({ min: 1, max: 3500 }), backgroundColor: a2 = this.faker.color.rgb({ format: "hex", prefix: "" }), textColor: n2 = this.faker.color.rgb({ format: "hex", prefix: "" }), format: o2 = this.faker.helpers.arrayElement(["gif", "jpeg", "jpg", "png", "webp"]), text: s2 = this.faker.lorem.words() } = e2, l2 = "https://via.placeholder.com";
    return l2 += `/${r2}`, l2 += `x${t2}`, l2 += `/${a2}`, l2 += `/${n2}`, l2 += `.${o2}`, l2 += `?text=${encodeURIComponent(s2)}`, l2;
  }
  dataUri(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }), color: a2 = this.faker.color.rgb(), type: n2 = this.faker.helpers.arrayElement(["svg-uri", "svg-base64"]) } = e2, o2 = `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" baseProfile="full" width="${r2}" height="${t2}"><rect width="100%" height="100%" fill="${a2}"/><text x="${r2 / 2}" y="${t2 / 2}" font-size="20" alignment-baseline="middle" text-anchor="middle" fill="white">${r2}x${t2}</text></svg>`;
    return n2 === "svg-uri" ? `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(o2)}` : `data:image/svg+xml;base64,${de2(o2)}`;
  }
};
var se2 = class extends p2 {
  zipCode(e2 = {}) {
    typeof e2 == "string" && (e2 = { format: e2 });
    let { state: r2 } = e2;
    if (r2 != null) {
      let a2 = this.faker.definitions.location.postcode_by_state[r2];
      if (a2 == null) throw new m2(`No zip code definition found for state "${r2}"`);
      return this.faker.helpers.fake(a2);
    }
    let { format: t2 = this.faker.definitions.location.postcode } = e2;
    return typeof t2 == "string" && (t2 = [t2]), t2 = this.faker.helpers.arrayElement(t2), this.faker.helpers.replaceSymbols(t2);
  }
  city() {
    return this.faker.helpers.fake(this.faker.definitions.location.city_pattern);
  }
  buildingNumber() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.building_number).replaceAll(/#+/g, (e2) => this.faker.string.numeric({ length: e2.length, allowLeadingZeros: false }));
  }
  street() {
    return this.faker.helpers.fake(this.faker.definitions.location.street_pattern);
  }
  streetAddress(e2 = {}) {
    typeof e2 == "boolean" && (e2 = { useFullAddress: e2 });
    let { useFullAddress: r2 } = e2, a2 = this.faker.definitions.location.street_address[r2 ? "full" : "normal"];
    return this.faker.helpers.fake(a2);
  }
  secondaryAddress() {
    return this.faker.helpers.fake(this.faker.definitions.location.secondary_address).replaceAll(/#+/g, (e2) => this.faker.string.numeric({ length: e2.length, allowLeadingZeros: false }));
  }
  county() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.county);
  }
  country() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.country);
  }
  continent() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.continent);
  }
  countryCode(e2 = {}) {
    typeof e2 == "string" && (e2 = { variant: e2 });
    let { variant: r2 = "alpha-2" } = e2, t2 = (() => {
      switch (r2) {
        case "numeric":
          return "numeric";
        case "alpha-3":
          return "alpha3";
        case "alpha-2":
          return "alpha2";
      }
    })();
    return this.faker.helpers.arrayElement(this.faker.definitions.location.country_code)[t2];
  }
  state(e2 = {}) {
    let { abbreviated: r2 = false } = e2, t2 = r2 ? this.faker.definitions.location.state_abbr : this.faker.definitions.location.state;
    return this.faker.helpers.arrayElement(t2);
  }
  latitude(e2 = {}) {
    let { max: r2 = 90, min: t2 = -90, precision: a2 = 4 } = e2;
    return this.faker.number.float({ min: t2, max: r2, fractionDigits: a2 });
  }
  longitude(e2 = {}) {
    let { max: r2 = 180, min: t2 = -180, precision: a2 = 4 } = e2;
    return this.faker.number.float({ max: r2, min: t2, fractionDigits: a2 });
  }
  direction(e2 = {}) {
    let { abbreviated: r2 = false } = e2;
    return r2 ? this.faker.helpers.arrayElement([...this.faker.definitions.location.direction.cardinal_abbr, ...this.faker.definitions.location.direction.ordinal_abbr]) : this.faker.helpers.arrayElement([...this.faker.definitions.location.direction.cardinal, ...this.faker.definitions.location.direction.ordinal]);
  }
  cardinalDirection(e2 = {}) {
    let { abbreviated: r2 = false } = e2;
    return r2 ? this.faker.helpers.arrayElement(this.faker.definitions.location.direction.cardinal_abbr) : this.faker.helpers.arrayElement(this.faker.definitions.location.direction.cardinal);
  }
  ordinalDirection(e2 = {}) {
    let { abbreviated: r2 = false } = e2;
    return r2 ? this.faker.helpers.arrayElement(this.faker.definitions.location.direction.ordinal_abbr) : this.faker.helpers.arrayElement(this.faker.definitions.location.direction.ordinal);
  }
  nearbyGPSCoordinate(e2 = {}) {
    let { origin: r2, radius: t2 = 10, isMetric: a2 = false } = e2;
    if (r2 == null) return [this.latitude(), this.longitude()];
    let n2 = this.faker.number.float({ max: 2 * Math.PI, fractionDigits: 5 }), o2 = a2 ? t2 : t2 * 1.60934, l2 = this.faker.number.float({ max: o2, fractionDigits: 3 }) * 0.995, c2 = 4e4 / 360, u2 = l2 / c2, h2 = [r2[0] + Math.sin(n2) * u2, r2[1] + Math.cos(n2) * u2];
    return h2[0] = h2[0] % 180, (h2[0] < -90 || h2[0] > 90) && (h2[0] = Math.sign(h2[0]) * 180 - h2[0], h2[1] += 180), h2[1] = (h2[1] % 360 + 540) % 360 - 180, [h2[0], h2[1]];
  }
  timeZone() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.time_zone);
  }
  language() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.language);
  }
};
function Ze2(i2, e2, r2 = (t2) => t2) {
  let t2 = {};
  for (let a2 of i2) {
    let n2 = e2(a2);
    t2[n2] === void 0 && (t2[n2] = []), t2[n2].push(r2(a2));
  }
  return t2;
}
var Me2 = { fail: () => {
  throw new m2("No words found that match the given length.");
}, closest: (i2, e2) => {
  let r2 = Ze2(i2, (s2) => s2.length), t2 = Object.keys(r2).map(Number), a2 = Math.min(...t2), n2 = Math.max(...t2), o2 = Math.min(e2.min - a2, n2 - e2.max);
  return i2.filter((s2) => s2.length === e2.min - o2 || s2.length === e2.max + o2);
}, shortest: (i2) => {
  let e2 = Math.min(...i2.map((r2) => r2.length));
  return i2.filter((r2) => r2.length === e2);
}, longest: (i2) => {
  let e2 = Math.max(...i2.map((r2) => r2.length));
  return i2.filter((r2) => r2.length === e2);
}, "any-length": (i2) => [...i2] };
function T2(i2) {
  let { wordList: e2, length: r2, strategy: t2 = "any-length" } = i2;
  if (r2 != null) {
    let a2 = typeof r2 == "number" ? (o2) => o2.length === r2 : (o2) => o2.length >= r2.min && o2.length <= r2.max, n2 = e2.filter(a2);
    return n2.length > 0 ? n2 : typeof r2 == "number" ? Me2[t2](e2, { min: r2, max: r2 }) : Me2[t2](e2, r2);
  } else if (t2 === "shortest" || t2 === "longest") return Me2[t2](e2);
  return [...e2];
}
var ce2 = class extends p2 {
  word(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.lorem.word }));
  }
  words(e2 = 3) {
    return this.faker.helpers.multiple(() => this.word(), { count: e2 }).join(" ");
  }
  sentence(e2 = { min: 3, max: 10 }) {
    let r2 = this.words(e2);
    return `${r2.charAt(0).toUpperCase() + r2.substring(1)}.`;
  }
  slug(e2 = 3) {
    let r2 = this.words(e2);
    return this.faker.helpers.slugify(r2);
  }
  sentences(e2 = { min: 2, max: 6 }, r2 = " ") {
    return this.faker.helpers.multiple(() => this.sentence(), { count: e2 }).join(r2);
  }
  paragraph(e2 = 3) {
    return this.sentences(e2);
  }
  paragraphs(e2 = 3, r2 = `
`) {
    return this.faker.helpers.multiple(() => this.paragraph(), { count: e2 }).join(r2);
  }
  text() {
    let e2 = ["sentence", "sentences", "paragraph", "paragraphs", "lines"], r2 = this.faker.helpers.arrayElement(e2);
    return this[r2]();
  }
  lines(e2 = { min: 1, max: 5 }) {
    return this.sentences(e2, `
`);
  }
};
var le2 = class extends p2 {
  album() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.album);
  }
  artist() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.artist);
  }
  genre() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.genre);
  }
  songName() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.song_name);
  }
};
var me2 = class extends p2 {
  number(e2 = {}) {
    let { style: r2 = "human" } = e2, a2 = this.faker.definitions.phone_number.format[r2];
    if (!a2) throw new Error(`No definitions for ${r2} in this locale`);
    let n2 = this.faker.helpers.arrayElement(a2);
    return we2(this.faker, n2);
  }
  imei() {
    return this.faker.helpers.replaceCreditCardSymbols("##-######-######-L", "#");
  }
};
var ue2 = class extends p2 {
  chemicalElement() {
    return this.faker.helpers.arrayElement(this.faker.definitions.science.chemical_element);
  }
  unit() {
    return this.faker.helpers.arrayElement(this.faker.definitions.science.unit);
  }
};
var Yr = ["video", "audio", "image", "text", "application"];
var Zr = ["application/pdf", "audio/mpeg", "audio/wav", "image/png", "image/jpeg", "image/gif", "video/mp4", "video/mpeg", "text/html"];
var Jr = ["en", "wl", "ww"];
var Je2 = { index: "o", slot: "s", mac: "x", pci: "p" };
var Xr = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
var pe2 = class extends p2 {
  fileName(e2 = {}) {
    let { extensionCount: r2 = 1 } = e2, t2 = this.faker.word.words().toLowerCase().replaceAll(/\W/g, "_"), a2 = this.faker.helpers.multiple(() => this.fileExt(), { count: r2 }).join(".");
    return a2.length === 0 ? t2 : `${t2}.${a2}`;
  }
  commonFileName(e2) {
    return `${this.fileName({ extensionCount: 0 })}.${e2 || this.commonFileExt()}`;
  }
  mimeType() {
    let e2 = Object.keys(this.faker.definitions.system.mime_type);
    return this.faker.helpers.arrayElement(e2);
  }
  commonFileType() {
    return this.faker.helpers.arrayElement(Yr);
  }
  commonFileExt() {
    return this.fileExt(this.faker.helpers.arrayElement(Zr));
  }
  fileType() {
    let e2 = this.faker.definitions.system.mime_type, r2 = new Set(Object.keys(e2).map((t2) => t2.split("/")[0]));
    return this.faker.helpers.arrayElement([...r2]);
  }
  fileExt(e2) {
    let r2 = this.faker.definitions.system.mime_type;
    if (typeof e2 == "string") return this.faker.helpers.arrayElement(r2[e2].extensions);
    let t2 = new Set(Object.values(r2).flatMap(({ extensions: a2 }) => a2));
    return this.faker.helpers.arrayElement([...t2]);
  }
  directoryPath() {
    let e2 = this.faker.definitions.system.directory_path;
    return this.faker.helpers.arrayElement(e2);
  }
  filePath() {
    return `${this.directoryPath()}/${this.fileName()}`;
  }
  semver() {
    return [this.faker.number.int(9), this.faker.number.int(20), this.faker.number.int(20)].join(".");
  }
  networkInterface(e2 = {}) {
    let { interfaceType: r2 = this.faker.helpers.arrayElement(Jr), interfaceSchema: t2 = this.faker.helpers.objectKey(Je2) } = e2, a2, n2 = "";
    switch (t2) {
      case "index": {
        a2 = this.faker.string.numeric();
        break;
      }
      case "slot": {
        a2 = `${this.faker.string.numeric()}${this.faker.helpers.maybe(() => `f${this.faker.string.numeric()}`) ?? ""}${this.faker.helpers.maybe(() => `d${this.faker.string.numeric()}`) ?? ""}`;
        break;
      }
      case "mac": {
        a2 = this.faker.internet.mac("");
        break;
      }
      case "pci": {
        n2 = this.faker.helpers.maybe(() => `P${this.faker.string.numeric()}`) ?? "", a2 = `${this.faker.string.numeric()}s${this.faker.string.numeric()}${this.faker.helpers.maybe(() => `f${this.faker.string.numeric()}`) ?? ""}${this.faker.helpers.maybe(() => `d${this.faker.string.numeric()}`) ?? ""}`;
        break;
      }
    }
    return `${n2}${r2}${Je2[t2]}${a2}`;
  }
  cron(e2 = {}) {
    let { includeYear: r2 = false, includeNonStandard: t2 = false } = e2, a2 = [this.faker.number.int(59), "*"], n2 = [this.faker.number.int(23), "*"], o2 = [this.faker.number.int({ min: 1, max: 31 }), "*", "?"], s2 = [this.faker.number.int({ min: 1, max: 12 }), "*"], l2 = [this.faker.number.int(6), this.faker.helpers.arrayElement(Xr), "*", "?"], c2 = [this.faker.number.int({ min: 1970, max: 2099 }), "*"], u2 = this.faker.helpers.arrayElement(a2), h2 = this.faker.helpers.arrayElement(n2), f3 = this.faker.helpers.arrayElement(o2), g2 = this.faker.helpers.arrayElement(s2), b2 = this.faker.helpers.arrayElement(l2), y2 = this.faker.helpers.arrayElement(c2), N2 = `${u2} ${h2} ${f3} ${g2} ${b2}`;
    r2 && (N2 += ` ${y2}`);
    let k2 = ["@annually", "@daily", "@hourly", "@monthly", "@reboot", "@weekly", "@yearly"];
    return !t2 || this.faker.datatype.boolean() ? N2 : this.faker.helpers.arrayElement(k2);
  }
};
var he2 = class extends p2 {
  vehicle() {
    return `${this.manufacturer()} ${this.model()}`;
  }
  manufacturer() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.manufacturer);
  }
  model() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.model);
  }
  type() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.type);
  }
  fuel() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.fuel);
  }
  vin() {
    let e2 = ["o", "i", "q", "O", "I", "Q"];
    return `${this.faker.string.alphanumeric({ length: 10, casing: "upper", exclude: e2 })}${this.faker.string.alpha({ length: 1, casing: "upper", exclude: e2 })}${this.faker.string.alphanumeric({ length: 1, casing: "upper", exclude: e2 })}${this.faker.string.numeric({ length: 5, allowLeadingZeros: true })}`;
  }
  color() {
    return this.faker.color.human();
  }
  vrm() {
    return `${this.faker.string.alpha({ length: 2, casing: "upper" })}${this.faker.string.numeric({ length: 2, allowLeadingZeros: true })}${this.faker.string.alpha({ length: 3, casing: "upper" })}`;
  }
  bicycle() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.bicycle_type);
  }
};
var fe2 = class extends p2 {
  adjective(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.adjective }));
  }
  adverb(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.adverb }));
  }
  conjunction(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.conjunction }));
  }
  interjection(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.interjection }));
  }
  noun(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.noun }));
  }
  preposition(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.preposition }));
  }
  verb(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.verb }));
  }
  sample(e2 = {}) {
    let r2 = this.faker.helpers.shuffle([this.adjective, this.adverb, this.conjunction, this.interjection, this.noun, this.preposition, this.verb]);
    for (let t2 of r2) try {
      return t2(e2);
    } catch {
      continue;
    }
    throw new m2("No matching word data available for the current locale");
  }
  words(e2 = {}) {
    typeof e2 == "number" && (e2 = { count: e2 });
    let { count: r2 = { min: 1, max: 3 } } = e2;
    return this.faker.helpers.multiple(() => this.sample(), { count: r2 }).join(" ");
  }
};
var Xe2 = class extends $2 {
  rawDefinitions;
  definitions;
  airline = new F2(this);
  animal = new X2(this);
  book = new Q2(this);
  color = new G2(this);
  commerce = new q2(this);
  company = new ee2(this);
  database = new re2(this);
  date = new V2(this);
  finance = new te2(this);
  food = new ae2(this);
  git = new ne2(this);
  hacker = new ie2(this);
  helpers = new z2(this);
  image = new oe2(this);
  internet = new O2(this);
  location = new se2(this);
  lorem = new ce2(this);
  music = new le2(this);
  person = new U2(this);
  phone = new me2(this);
  science = new ue2(this);
  system = new pe2(this);
  vehicle = new he2(this);
  word = new fe2(this);
  get address() {
    return w2({ deprecated: "faker.address", proposed: "faker.location", since: "8.0", until: "10.0" }), this.location;
  }
  get name() {
    return w2({ deprecated: "faker.name", proposed: "faker.person", since: "8.0", until: "10.0" }), this.person;
  }
  constructor(e2) {
    super({ randomizer: e2.randomizer, seed: e2.seed });
    let { locale: r2 } = e2;
    if (Array.isArray(r2)) {
      if (r2.length === 0) throw new m2("The locale option must contain at least one locale definition.");
      r2 = We2(r2);
    }
    this.rawDefinitions = r2, this.definitions = Ue2(this.rawDefinitions);
  }
  getMetadata() {
    return this.rawDefinitions.metadata ?? {};
  }
};
var Qe2 = ["Academy Color Encoding System (ACES)", "Adobe RGB", "Adobe Wide Gamut RGB", "British Standard Colour (BS)", "CIE 1931 XYZ", "CIELAB", "CIELUV", "CIEUVW", "CMY", "CMYK", "DCI-P3", "Display-P3", "Federal Standard 595C", "HKS", "HSL", "HSLA", "HSLuv", "HSV", "HWB", "LCh", "LMS", "Munsell Color System", "Natural Color System (NSC)", "Pantone Matching System (PMS)", "ProPhoto RGB Color Space", "RAL", "RG", "RGBA", "RGK", "Rec. 2020", "Rec. 2100", "Rec. 601", "Rec. 709", "Uniform Color Spaces (UCSs)", "YDbDr", "YIQ", "YPbPr", "sRGB", "sYCC", "scRGB", "xvYCC"];
var Qr = { space: Qe2 };
var qe2 = Qr;
var er2 = ["ascii_bin", "ascii_general_ci", "cp1250_bin", "cp1250_general_ci", "utf8_bin", "utf8_general_ci", "utf8_unicode_ci"];
var rr2 = ["ARCHIVE", "BLACKHOLE", "CSV", "InnoDB", "MEMORY", "MyISAM"];
var tr2 = ["bigint", "binary", "bit", "blob", "boolean", "date", "datetime", "decimal", "double", "enum", "float", "geometry", "int", "mediumint", "point", "real", "serial", "set", "smallint", "text", "time", "timestamp", "tinyint", "varchar"];
var qr = { collation: er2, engine: rr2, type: tr2 };
var ar2 = qr;
var I2 = ["Africa/Abidjan", "Africa/Accra", "Africa/Addis_Ababa", "Africa/Algiers", "Africa/Asmara", "Africa/Bamako", "Africa/Bangui", "Africa/Banjul", "Africa/Bissau", "Africa/Blantyre", "Africa/Brazzaville", "Africa/Bujumbura", "Africa/Cairo", "Africa/Casablanca", "Africa/Ceuta", "Africa/Conakry", "Africa/Dakar", "Africa/Dar_es_Salaam", "Africa/Djibouti", "Africa/Douala", "Africa/El_Aaiun", "Africa/Freetown", "Africa/Gaborone", "Africa/Harare", "Africa/Johannesburg", "Africa/Juba", "Africa/Kampala", "Africa/Khartoum", "Africa/Kigali", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Lome", "Africa/Luanda", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Malabo", "Africa/Maputo", "Africa/Maseru", "Africa/Mbabane", "Africa/Mogadishu", "Africa/Monrovia", "Africa/Nairobi", "Africa/Ndjamena", "Africa/Niamey", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Porto-Novo", "Africa/Sao_Tome", "Africa/Tripoli", "Africa/Tunis", "Africa/Windhoek", "America/Adak", "America/Anchorage", "America/Anguilla", "America/Antigua", "America/Araguaina", "America/Argentina/Buenos_Aires", "America/Argentina/Catamarca", "America/Argentina/Cordoba", "America/Argentina/Jujuy", "America/Argentina/La_Rioja", "America/Argentina/Mendoza", "America/Argentina/Rio_Gallegos", "America/Argentina/Salta", "America/Argentina/San_Juan", "America/Argentina/San_Luis", "America/Argentina/Tucuman", "America/Argentina/Ushuaia", "America/Aruba", "America/Asuncion", "America/Atikokan", "America/Bahia", "America/Bahia_Banderas", "America/Barbados", "America/Belem", "America/Belize", "America/Blanc-Sablon", "America/Boa_Vista", "America/Bogota", "America/Boise", "America/Cambridge_Bay", "America/Campo_Grande", "America/Cancun", "America/Caracas", "America/Cayenne", "America/Cayman", "America/Chicago", "America/Chihuahua", "America/Ciudad_Juarez", "America/Costa_Rica", "America/Creston", "America/Cuiaba", "America/Curacao", "America/Danmarkshavn", "America/Dawson", "America/Dawson_Creek", "America/Denver", "America/Detroit", "America/Dominica", "America/Edmonton", "America/Eirunepe", "America/El_Salvador", "America/Fort_Nelson", "America/Fortaleza", "America/Glace_Bay", "America/Goose_Bay", "America/Grand_Turk", "America/Grenada", "America/Guadeloupe", "America/Guatemala", "America/Guayaquil", "America/Guyana", "America/Halifax", "America/Havana", "America/Hermosillo", "America/Indiana/Indianapolis", "America/Indiana/Knox", "America/Indiana/Marengo", "America/Indiana/Petersburg", "America/Indiana/Tell_City", "America/Indiana/Vevay", "America/Indiana/Vincennes", "America/Indiana/Winamac", "America/Inuvik", "America/Iqaluit", "America/Jamaica", "America/Juneau", "America/Kentucky/Louisville", "America/Kentucky/Monticello", "America/Kralendijk", "America/La_Paz", "America/Lima", "America/Los_Angeles", "America/Lower_Princes", "America/Maceio", "America/Managua", "America/Manaus", "America/Marigot", "America/Martinique", "America/Matamoros", "America/Mazatlan", "America/Menominee", "America/Merida", "America/Metlakatla", "America/Mexico_City", "America/Miquelon", "America/Moncton", "America/Monterrey", "America/Montevideo", "America/Montserrat", "America/Nassau", "America/New_York", "America/Nome", "America/Noronha", "America/North_Dakota/Beulah", "America/North_Dakota/Center", "America/North_Dakota/New_Salem", "America/Nuuk", "America/Ojinaga", "America/Panama", "America/Paramaribo", "America/Phoenix", "America/Port-au-Prince", "America/Port_of_Spain", "America/Porto_Velho", "America/Puerto_Rico", "America/Punta_Arenas", "America/Rankin_Inlet", "America/Recife", "America/Regina", "America/Resolute", "America/Rio_Branco", "America/Santarem", "America/Santiago", "America/Santo_Domingo", "America/Sao_Paulo", "America/Scoresbysund", "America/Sitka", "America/St_Barthelemy", "America/St_Johns", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Swift_Current", "America/Tegucigalpa", "America/Thule", "America/Tijuana", "America/Toronto", "America/Tortola", "America/Vancouver", "America/Whitehorse", "America/Winnipeg", "America/Yakutat", "America/Yellowknife", "Antarctica/Casey", "Antarctica/Davis", "Antarctica/DumontDUrville", "Antarctica/Macquarie", "Antarctica/Mawson", "Antarctica/McMurdo", "Antarctica/Palmer", "Antarctica/Rothera", "Antarctica/Syowa", "Antarctica/Troll", "Antarctica/Vostok", "Arctic/Longyearbyen", "Asia/Aden", "Asia/Almaty", "Asia/Amman", "Asia/Anadyr", "Asia/Aqtau", "Asia/Aqtobe", "Asia/Ashgabat", "Asia/Atyrau", "Asia/Baghdad", "Asia/Bahrain", "Asia/Baku", "Asia/Bangkok", "Asia/Barnaul", "Asia/Beirut", "Asia/Bishkek", "Asia/Brunei", "Asia/Chita", "Asia/Choibalsan", "Asia/Colombo", "Asia/Damascus", "Asia/Dhaka", "Asia/Dili", "Asia/Dubai", "Asia/Dushanbe", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Ho_Chi_Minh", "Asia/Hong_Kong", "Asia/Hovd", "Asia/Irkutsk", "Asia/Jakarta", "Asia/Jayapura", "Asia/Jerusalem", "Asia/Kabul", "Asia/Kamchatka", "Asia/Karachi", "Asia/Kathmandu", "Asia/Khandyga", "Asia/Kolkata", "Asia/Krasnoyarsk", "Asia/Kuala_Lumpur", "Asia/Kuching", "Asia/Kuwait", "Asia/Macau", "Asia/Magadan", "Asia/Makassar", "Asia/Manila", "Asia/Muscat", "Asia/Nicosia", "Asia/Novokuznetsk", "Asia/Novosibirsk", "Asia/Omsk", "Asia/Oral", "Asia/Phnom_Penh", "Asia/Pontianak", "Asia/Pyongyang", "Asia/Qatar", "Asia/Qostanay", "Asia/Qyzylorda", "Asia/Riyadh", "Asia/Sakhalin", "Asia/Samarkand", "Asia/Seoul", "Asia/Shanghai", "Asia/Singapore", "Asia/Srednekolymsk", "Asia/Taipei", "Asia/Tashkent", "Asia/Tbilisi", "Asia/Tehran", "Asia/Thimphu", "Asia/Tokyo", "Asia/Tomsk", "Asia/Ulaanbaatar", "Asia/Urumqi", "Asia/Ust-Nera", "Asia/Vientiane", "Asia/Vladivostok", "Asia/Yakutsk", "Asia/Yangon", "Asia/Yekaterinburg", "Asia/Yerevan", "Atlantic/Azores", "Atlantic/Bermuda", "Atlantic/Canary", "Atlantic/Cape_Verde", "Atlantic/Faroe", "Atlantic/Madeira", "Atlantic/Reykjavik", "Atlantic/South_Georgia", "Atlantic/St_Helena", "Atlantic/Stanley", "Australia/Adelaide", "Australia/Brisbane", "Australia/Broken_Hill", "Australia/Darwin", "Australia/Eucla", "Australia/Hobart", "Australia/Lindeman", "Australia/Lord_Howe", "Australia/Melbourne", "Australia/Perth", "Australia/Sydney", "Europe/Amsterdam", "Europe/Andorra", "Europe/Astrakhan", "Europe/Athens", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Bucharest", "Europe/Budapest", "Europe/Busingen", "Europe/Chisinau", "Europe/Copenhagen", "Europe/Dublin", "Europe/Gibraltar", "Europe/Guernsey", "Europe/Helsinki", "Europe/Isle_of_Man", "Europe/Istanbul", "Europe/Jersey", "Europe/Kaliningrad", "Europe/Kirov", "Europe/Kyiv", "Europe/Lisbon", "Europe/Ljubljana", "Europe/London", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Mariehamn", "Europe/Minsk", "Europe/Monaco", "Europe/Moscow", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Riga", "Europe/Rome", "Europe/Samara", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Saratov", "Europe/Simferopol", "Europe/Skopje", "Europe/Sofia", "Europe/Stockholm", "Europe/Tallinn", "Europe/Tirane", "Europe/Ulyanovsk", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Vilnius", "Europe/Volgograd", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich", "Indian/Antananarivo", "Indian/Chagos", "Indian/Christmas", "Indian/Cocos", "Indian/Comoro", "Indian/Kerguelen", "Indian/Mahe", "Indian/Maldives", "Indian/Mauritius", "Indian/Mayotte", "Indian/Reunion", "Pacific/Apia", "Pacific/Auckland", "Pacific/Bougainville", "Pacific/Chatham", "Pacific/Chuuk", "Pacific/Easter", "Pacific/Efate", "Pacific/Fakaofo", "Pacific/Fiji", "Pacific/Funafuti", "Pacific/Galapagos", "Pacific/Gambier", "Pacific/Guadalcanal", "Pacific/Guam", "Pacific/Honolulu", "Pacific/Kanton", "Pacific/Kiritimati", "Pacific/Kosrae", "Pacific/Kwajalein", "Pacific/Majuro", "Pacific/Marquesas", "Pacific/Midway", "Pacific/Nauru", "Pacific/Niue", "Pacific/Norfolk", "Pacific/Noumea", "Pacific/Pago_Pago", "Pacific/Palau", "Pacific/Pitcairn", "Pacific/Pohnpei", "Pacific/Port_Moresby", "Pacific/Rarotonga", "Pacific/Saipan", "Pacific/Tahiti", "Pacific/Tarawa", "Pacific/Tongatapu", "Pacific/Wake", "Pacific/Wallis"];
var et = { time_zone: I2 };
var nr2 = et;
var ir2 = ["ADP", "AGP", "AI", "API", "ASCII", "CLI", "COM", "CSS", "DNS", "DRAM", "EXE", "FTP", "GB", "HDD", "HEX", "HTTP", "IB", "IP", "JBOD", "JSON", "OCR", "PCI", "PNG", "RAM", "RSS", "SAS", "SCSI", "SDD", "SMS", "SMTP", "SQL", "SSD", "SSL", "TCP", "THX", "TLS", "UDP", "USB", "UTF8", "VGA", "XML", "XSS"];
var rt = { abbreviation: ir2 };
var or2 = rt;
var sr2 = { smiley: ["\u{1F600}", "\u{1F603}", "\u{1F604}", "\u{1F601}", "\u{1F606}", "\u{1F605}", "\u{1F923}", "\u{1F602}", "\u{1F642}", "\u{1F643}", "\u{1F609}", "\u{1F60A}", "\u{1F607}", "\u{1F970}", "\u{1F60D}", "\u{1F929}", "\u{1F618}", "\u{1F617}", "\u263A\uFE0F", "\u{1F61A}", "\u{1F619}", "\u{1F972}", "\u{1F60B}", "\u{1F61B}", "\u{1F61C}", "\u{1F92A}", "\u{1F61D}", "\u{1F911}", "\u{1F917}", "\u{1F92D}", "\u{1F92B}", "\u{1F914}", "\u{1F910}", "\u{1F928}", "\u{1F610}", "\u{1F611}", "\u{1F636}", "\u{1F636}\u200D\u{1F32B}\uFE0F", "\u{1F60F}", "\u{1F612}", "\u{1F644}", "\u{1F62C}", "\u{1F62E}\u200D\u{1F4A8}", "\u{1F925}", "\u{1F60C}", "\u{1F614}", "\u{1F62A}", "\u{1F924}", "\u{1F634}", "\u{1F637}", "\u{1F912}", "\u{1F915}", "\u{1F922}", "\u{1F92E}", "\u{1F927}", "\u{1F975}", "\u{1F976}", "\u{1F974}", "\u{1F635}", "\u{1F635}\u200D\u{1F4AB}", "\u{1F92F}", "\u{1F920}", "\u{1F973}", "\u{1F978}", "\u{1F60E}", "\u{1F913}", "\u{1F9D0}", "\u{1F615}", "\u{1F61F}", "\u{1F641}", "\u2639\uFE0F", "\u{1F62E}", "\u{1F62F}", "\u{1F632}", "\u{1F633}", "\u{1F97A}", "\u{1F626}", "\u{1F627}", "\u{1F628}", "\u{1F630}", "\u{1F625}", "\u{1F622}", "\u{1F62D}", "\u{1F631}", "\u{1F616}", "\u{1F623}", "\u{1F61E}", "\u{1F613}", "\u{1F629}", "\u{1F62B}", "\u{1F971}", "\u{1F624}", "\u{1F621}", "\u{1F620}", "\u{1F92C}", "\u{1F608}", "\u{1F47F}", "\u{1F480}", "\u2620\uFE0F", "\u{1F4A9}", "\u{1F921}", "\u{1F479}", "\u{1F47A}", "\u{1F47B}", "\u{1F47D}", "\u{1F47E}", "\u{1F916}", "\u{1F63A}", "\u{1F638}", "\u{1F639}", "\u{1F63B}", "\u{1F63C}", "\u{1F63D}", "\u{1F640}", "\u{1F63F}", "\u{1F63E}", "\u{1F648}", "\u{1F649}", "\u{1F64A}", "\u{1F48B}", "\u{1F48C}", "\u{1F498}", "\u{1F49D}", "\u{1F496}", "\u{1F497}", "\u{1F493}", "\u{1F49E}", "\u{1F495}", "\u{1F49F}", "\u2763\uFE0F", "\u{1F494}", "\u2764\uFE0F\u200D\u{1F525}", "\u2764\uFE0F\u200D\u{1FA79}", "\u2764\uFE0F", "\u{1F9E1}", "\u{1F49B}", "\u{1F49A}", "\u{1F499}", "\u{1F49C}", "\u{1F90E}", "\u{1F5A4}", "\u{1F90D}", "\u{1F4AF}", "\u{1F4A2}", "\u{1F4A5}", "\u{1F4AB}", "\u{1F4A6}", "\u{1F4A8}", "\u{1F573}\uFE0F", "\u{1F4A3}", "\u{1F4AC}", "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F", "\u{1F5E8}\uFE0F", "\u{1F5EF}\uFE0F", "\u{1F4AD}", "\u{1F4A4}"], body: ["\u{1F44B}", "\u{1F44B}\u{1F3FB}", "\u{1F44B}\u{1F3FC}", "\u{1F44B}\u{1F3FD}", "\u{1F44B}\u{1F3FE}", "\u{1F44B}\u{1F3FF}", "\u{1F91A}", "\u{1F91A}\u{1F3FB}", "\u{1F91A}\u{1F3FC}", "\u{1F91A}\u{1F3FD}", "\u{1F91A}\u{1F3FE}", "\u{1F91A}\u{1F3FF}", "\u{1F590}\uFE0F", "\u{1F590}\u{1F3FB}", "\u{1F590}\u{1F3FC}", "\u{1F590}\u{1F3FD}", "\u{1F590}\u{1F3FE}", "\u{1F590}\u{1F3FF}", "\u270B", "\u270B\u{1F3FB}", "\u270B\u{1F3FC}", "\u270B\u{1F3FD}", "\u270B\u{1F3FE}", "\u270B\u{1F3FF}", "\u{1F596}", "\u{1F596}\u{1F3FB}", "\u{1F596}\u{1F3FC}", "\u{1F596}\u{1F3FD}", "\u{1F596}\u{1F3FE}", "\u{1F596}\u{1F3FF}", "\u{1F44C}", "\u{1F44C}\u{1F3FB}", "\u{1F44C}\u{1F3FC}", "\u{1F44C}\u{1F3FD}", "\u{1F44C}\u{1F3FE}", "\u{1F44C}\u{1F3FF}", "\u{1F90C}", "\u{1F90C}\u{1F3FB}", "\u{1F90C}\u{1F3FC}", "\u{1F90C}\u{1F3FD}", "\u{1F90C}\u{1F3FE}", "\u{1F90C}\u{1F3FF}", "\u{1F90F}", "\u{1F90F}\u{1F3FB}", "\u{1F90F}\u{1F3FC}", "\u{1F90F}\u{1F3FD}", "\u{1F90F}\u{1F3FE}", "\u{1F90F}\u{1F3FF}", "\u270C\uFE0F", "\u270C\u{1F3FB}", "\u270C\u{1F3FC}", "\u270C\u{1F3FD}", "\u270C\u{1F3FE}", "\u270C\u{1F3FF}", "\u{1F91E}", "\u{1F91E}\u{1F3FB}", "\u{1F91E}\u{1F3FC}", "\u{1F91E}\u{1F3FD}", "\u{1F91E}\u{1F3FE}", "\u{1F91E}\u{1F3FF}", "\u{1F91F}", "\u{1F91F}\u{1F3FB}", "\u{1F91F}\u{1F3FC}", "\u{1F91F}\u{1F3FD}", "\u{1F91F}\u{1F3FE}", "\u{1F91F}\u{1F3FF}", "\u{1F918}", "\u{1F918}\u{1F3FB}", "\u{1F918}\u{1F3FC}", "\u{1F918}\u{1F3FD}", "\u{1F918}\u{1F3FE}", "\u{1F918}\u{1F3FF}", "\u{1F919}", "\u{1F919}\u{1F3FB}", "\u{1F919}\u{1F3FC}", "\u{1F919}\u{1F3FD}", "\u{1F919}\u{1F3FE}", "\u{1F919}\u{1F3FF}", "\u{1F448}", "\u{1F448}\u{1F3FB}", "\u{1F448}\u{1F3FC}", "\u{1F448}\u{1F3FD}", "\u{1F448}\u{1F3FE}", "\u{1F448}\u{1F3FF}", "\u{1F449}", "\u{1F449}\u{1F3FB}", "\u{1F449}\u{1F3FC}", "\u{1F449}\u{1F3FD}", "\u{1F449}\u{1F3FE}", "\u{1F449}\u{1F3FF}", "\u{1F446}", "\u{1F446}\u{1F3FB}", "\u{1F446}\u{1F3FC}", "\u{1F446}\u{1F3FD}", "\u{1F446}\u{1F3FE}", "\u{1F446}\u{1F3FF}", "\u{1F595}", "\u{1F595}\u{1F3FB}", "\u{1F595}\u{1F3FC}", "\u{1F595}\u{1F3FD}", "\u{1F595}\u{1F3FE}", "\u{1F595}\u{1F3FF}", "\u{1F447}", "\u{1F447}\u{1F3FB}", "\u{1F447}\u{1F3FC}", "\u{1F447}\u{1F3FD}", "\u{1F447}\u{1F3FE}", "\u{1F447}\u{1F3FF}", "\u261D\uFE0F", "\u261D\u{1F3FB}", "\u261D\u{1F3FC}", "\u261D\u{1F3FD}", "\u261D\u{1F3FE}", "\u261D\u{1F3FF}", "\u{1F44D}", "\u{1F44D}\u{1F3FB}", "\u{1F44D}\u{1F3FC}", "\u{1F44D}\u{1F3FD}", "\u{1F44D}\u{1F3FE}", "\u{1F44D}\u{1F3FF}", "\u{1F44E}", "\u{1F44E}\u{1F3FB}", "\u{1F44E}\u{1F3FC}", "\u{1F44E}\u{1F3FD}", "\u{1F44E}\u{1F3FE}", "\u{1F44E}\u{1F3FF}", "\u270A", "\u270A\u{1F3FB}", "\u270A\u{1F3FC}", "\u270A\u{1F3FD}", "\u270A\u{1F3FE}", "\u270A\u{1F3FF}", "\u{1F44A}", "\u{1F44A}\u{1F3FB}", "\u{1F44A}\u{1F3FC}", "\u{1F44A}\u{1F3FD}", "\u{1F44A}\u{1F3FE}", "\u{1F44A}\u{1F3FF}", "\u{1F91B}", "\u{1F91B}\u{1F3FB}", "\u{1F91B}\u{1F3FC}", "\u{1F91B}\u{1F3FD}", "\u{1F91B}\u{1F3FE}", "\u{1F91B}\u{1F3FF}", "\u{1F91C}", "\u{1F91C}\u{1F3FB}", "\u{1F91C}\u{1F3FC}", "\u{1F91C}\u{1F3FD}", "\u{1F91C}\u{1F3FE}", "\u{1F91C}\u{1F3FF}", "\u{1F44F}", "\u{1F44F}\u{1F3FB}", "\u{1F44F}\u{1F3FC}", "\u{1F44F}\u{1F3FD}", "\u{1F44F}\u{1F3FE}", "\u{1F44F}\u{1F3FF}", "\u{1F64C}", "\u{1F64C}\u{1F3FB}", "\u{1F64C}\u{1F3FC}", "\u{1F64C}\u{1F3FD}", "\u{1F64C}\u{1F3FE}", "\u{1F64C}\u{1F3FF}", "\u{1F450}", "\u{1F450}\u{1F3FB}", "\u{1F450}\u{1F3FC}", "\u{1F450}\u{1F3FD}", "\u{1F450}\u{1F3FE}", "\u{1F450}\u{1F3FF}", "\u{1F932}", "\u{1F932}\u{1F3FB}", "\u{1F932}\u{1F3FC}", "\u{1F932}\u{1F3FD}", "\u{1F932}\u{1F3FE}", "\u{1F932}\u{1F3FF}", "\u{1F91D}", "\u{1F64F}", "\u{1F64F}\u{1F3FB}", "\u{1F64F}\u{1F3FC}", "\u{1F64F}\u{1F3FD}", "\u{1F64F}\u{1F3FE}", "\u{1F64F}\u{1F3FF}", "\u270D\uFE0F", "\u270D\u{1F3FB}", "\u270D\u{1F3FC}", "\u270D\u{1F3FD}", "\u270D\u{1F3FE}", "\u270D\u{1F3FF}", "\u{1F485}", "\u{1F485}\u{1F3FB}", "\u{1F485}\u{1F3FC}", "\u{1F485}\u{1F3FD}", "\u{1F485}\u{1F3FE}", "\u{1F485}\u{1F3FF}", "\u{1F933}", "\u{1F933}\u{1F3FB}", "\u{1F933}\u{1F3FC}", "\u{1F933}\u{1F3FD}", "\u{1F933}\u{1F3FE}", "\u{1F933}\u{1F3FF}", "\u{1F4AA}", "\u{1F4AA}\u{1F3FB}", "\u{1F4AA}\u{1F3FC}", "\u{1F4AA}\u{1F3FD}", "\u{1F4AA}\u{1F3FE}", "\u{1F4AA}\u{1F3FF}", "\u{1F9BE}", "\u{1F9BF}", "\u{1F9B5}", "\u{1F9B5}\u{1F3FB}", "\u{1F9B5}\u{1F3FC}", "\u{1F9B5}\u{1F3FD}", "\u{1F9B5}\u{1F3FE}", "\u{1F9B5}\u{1F3FF}", "\u{1F9B6}", "\u{1F9B6}\u{1F3FB}", "\u{1F9B6}\u{1F3FC}", "\u{1F9B6}\u{1F3FD}", "\u{1F9B6}\u{1F3FE}", "\u{1F9B6}\u{1F3FF}", "\u{1F442}", "\u{1F442}\u{1F3FB}", "\u{1F442}\u{1F3FC}", "\u{1F442}\u{1F3FD}", "\u{1F442}\u{1F3FE}", "\u{1F442}\u{1F3FF}", "\u{1F9BB}", "\u{1F9BB}\u{1F3FB}", "\u{1F9BB}\u{1F3FC}", "\u{1F9BB}\u{1F3FD}", "\u{1F9BB}\u{1F3FE}", "\u{1F9BB}\u{1F3FF}", "\u{1F443}", "\u{1F443}\u{1F3FB}", "\u{1F443}\u{1F3FC}", "\u{1F443}\u{1F3FD}", "\u{1F443}\u{1F3FE}", "\u{1F443}\u{1F3FF}", "\u{1F9E0}", "\u{1FAC0}", "\u{1FAC1}", "\u{1F9B7}", "\u{1F9B4}", "\u{1F440}", "\u{1F441}\uFE0F", "\u{1F445}", "\u{1F444}"], person: ["\u{1F476}", "\u{1F476}\u{1F3FB}", "\u{1F476}\u{1F3FC}", "\u{1F476}\u{1F3FD}", "\u{1F476}\u{1F3FE}", "\u{1F476}\u{1F3FF}", "\u{1F9D2}", "\u{1F9D2}\u{1F3FB}", "\u{1F9D2}\u{1F3FC}", "\u{1F9D2}\u{1F3FD}", "\u{1F9D2}\u{1F3FE}", "\u{1F9D2}\u{1F3FF}", "\u{1F466}", "\u{1F466}\u{1F3FB}", "\u{1F466}\u{1F3FC}", "\u{1F466}\u{1F3FD}", "\u{1F466}\u{1F3FE}", "\u{1F466}\u{1F3FF}", "\u{1F467}", "\u{1F467}\u{1F3FB}", "\u{1F467}\u{1F3FC}", "\u{1F467}\u{1F3FD}", "\u{1F467}\u{1F3FE}", "\u{1F467}\u{1F3FF}", "\u{1F9D1}", "\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FF}", "\u{1F471}", "\u{1F471}\u{1F3FB}", "\u{1F471}\u{1F3FC}", "\u{1F471}\u{1F3FD}", "\u{1F471}\u{1F3FE}", "\u{1F471}\u{1F3FF}", "\u{1F468}", "\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FF}", "\u{1F9D4}", "\u{1F9D4}\u{1F3FB}", "\u{1F9D4}\u{1F3FC}", "\u{1F9D4}\u{1F3FD}", "\u{1F9D4}\u{1F3FE}", "\u{1F9D4}\u{1F3FF}", "\u{1F9D4}\u200D\u2642\uFE0F", "\u{1F9D4}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D4}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D4}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D4}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D4}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9D4}\u200D\u2640\uFE0F", "\u{1F9D4}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D4}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D4}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D4}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D4}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F468}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FB}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B0}", "\u{1F468}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FB}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B1}", "\u{1F468}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FB}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B3}", "\u{1F468}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FB}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B2}", "\u{1F469}", "\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FF}", "\u{1F469}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FB}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B0}", "\u{1F9D1}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B0}", "\u{1F469}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FB}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B1}", "\u{1F9D1}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B1}", "\u{1F469}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FB}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B3}", "\u{1F9D1}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B3}", "\u{1F469}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FB}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B2}", "\u{1F9D1}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B2}", "\u{1F471}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F471}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9D3}", "\u{1F9D3}\u{1F3FB}", "\u{1F9D3}\u{1F3FC}", "\u{1F9D3}\u{1F3FD}", "\u{1F9D3}\u{1F3FE}", "\u{1F9D3}\u{1F3FF}", "\u{1F474}", "\u{1F474}\u{1F3FB}", "\u{1F474}\u{1F3FC}", "\u{1F474}\u{1F3FD}", "\u{1F474}\u{1F3FE}", "\u{1F474}\u{1F3FF}", "\u{1F475}", "\u{1F475}\u{1F3FB}", "\u{1F475}\u{1F3FC}", "\u{1F475}\u{1F3FD}", "\u{1F475}\u{1F3FE}", "\u{1F475}\u{1F3FF}", "\u{1F64D}", "\u{1F64D}\u{1F3FB}", "\u{1F64D}\u{1F3FC}", "\u{1F64D}\u{1F3FD}", "\u{1F64D}\u{1F3FE}", "\u{1F64D}\u{1F3FF}", "\u{1F64D}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F64D}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F64E}", "\u{1F64E}\u{1F3FB}", "\u{1F64E}\u{1F3FC}", "\u{1F64E}\u{1F3FD}", "\u{1F64E}\u{1F3FE}", "\u{1F64E}\u{1F3FF}", "\u{1F64E}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F64E}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F645}", "\u{1F645}\u{1F3FB}", "\u{1F645}\u{1F3FC}", "\u{1F645}\u{1F3FD}", "\u{1F645}\u{1F3FE}", "\u{1F645}\u{1F3FF}", "\u{1F645}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F645}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F646}", "\u{1F646}\u{1F3FB}", "\u{1F646}\u{1F3FC}", "\u{1F646}\u{1F3FD}", "\u{1F646}\u{1F3FE}", "\u{1F646}\u{1F3FF}", "\u{1F646}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F646}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F481}", "\u{1F481}\u{1F3FB}", "\u{1F481}\u{1F3FC}", "\u{1F481}\u{1F3FD}", "\u{1F481}\u{1F3FE}", "\u{1F481}\u{1F3FF}", "\u{1F481}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F481}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F64B}", "\u{1F64B}\u{1F3FB}", "\u{1F64B}\u{1F3FC}", "\u{1F64B}\u{1F3FD}", "\u{1F64B}\u{1F3FE}", "\u{1F64B}\u{1F3FF}", "\u{1F64B}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F64B}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9CF}", "\u{1F9CF}\u{1F3FB}", "\u{1F9CF}\u{1F3FC}", "\u{1F9CF}\u{1F3FD}", "\u{1F9CF}\u{1F3FE}", "\u{1F9CF}\u{1F3FF}", "\u{1F9CF}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9CF}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F647}", "\u{1F647}\u{1F3FB}", "\u{1F647}\u{1F3FC}", "\u{1F647}\u{1F3FD}", "\u{1F647}\u{1F3FE}", "\u{1F647}\u{1F3FF}", "\u{1F647}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F647}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F926}", "\u{1F926}\u{1F3FB}", "\u{1F926}\u{1F3FC}", "\u{1F926}\u{1F3FD}", "\u{1F926}\u{1F3FE}", "\u{1F926}\u{1F3FF}", "\u{1F926}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F926}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F937}", "\u{1F937}\u{1F3FB}", "\u{1F937}\u{1F3FC}", "\u{1F937}\u{1F3FD}", "\u{1F937}\u{1F3FE}", "\u{1F937}\u{1F3FF}", "\u{1F937}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F937}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9D1}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FB}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FC}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FD}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FE}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FF}\u200D\u2695\uFE0F", "\u{1F468}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FB}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FC}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FD}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FF}\u200D\u2695\uFE0F", "\u{1F469}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FB}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FC}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FD}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FE}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FF}\u200D\u2695\uFE0F", "\u{1F9D1}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F393}", "\u{1F468}\u200D\u{1F393}", "\u{1F468}\u{1F3FB}\u200D\u{1F393}", "\u{1F468}\u{1F3FC}\u200D\u{1F393}", "\u{1F468}\u{1F3FD}\u200D\u{1F393}", "\u{1F468}\u{1F3FE}\u200D\u{1F393}", "\u{1F468}\u{1F3FF}\u200D\u{1F393}", "\u{1F469}\u200D\u{1F393}", "\u{1F469}\u{1F3FB}\u200D\u{1F393}", "\u{1F469}\u{1F3FC}\u200D\u{1F393}", "\u{1F469}\u{1F3FD}\u200D\u{1F393}", "\u{1F469}\u{1F3FE}\u200D\u{1F393}", "\u{1F469}\u{1F3FF}\u200D\u{1F393}", "\u{1F9D1}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3EB}", "\u{1F468}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FB}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FC}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FD}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FE}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FF}\u200D\u{1F3EB}", "\u{1F469}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FB}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FC}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FD}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FE}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FF}\u200D\u{1F3EB}", "\u{1F9D1}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FB}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FC}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FD}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FE}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FF}\u200D\u2696\uFE0F", "\u{1F468}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FB}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FC}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FD}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FE}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FF}\u200D\u2696\uFE0F", "\u{1F469}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FB}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FC}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FD}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FE}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FF}\u200D\u2696\uFE0F", "\u{1F9D1}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F33E}", "\u{1F468}\u200D\u{1F33E}", "\u{1F468}\u{1F3FB}\u200D\u{1F33E}", "\u{1F468}\u{1F3FC}\u200D\u{1F33E}", "\u{1F468}\u{1F3FD}\u200D\u{1F33E}", "\u{1F468}\u{1F3FE}\u200D\u{1F33E}", "\u{1F468}\u{1F3FF}\u200D\u{1F33E}", "\u{1F469}\u200D\u{1F33E}", "\u{1F469}\u{1F3FB}\u200D\u{1F33E}", "\u{1F469}\u{1F3FC}\u200D\u{1F33E}", "\u{1F469}\u{1F3FD}\u200D\u{1F33E}", "\u{1F469}\u{1F3FE}\u200D\u{1F33E}", "\u{1F469}\u{1F3FF}\u200D\u{1F33E}", "\u{1F9D1}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F373}", "\u{1F468}\u200D\u{1F373}", "\u{1F468}\u{1F3FB}\u200D\u{1F373}", "\u{1F468}\u{1F3FC}\u200D\u{1F373}", "\u{1F468}\u{1F3FD}\u200D\u{1F373}", "\u{1F468}\u{1F3FE}\u200D\u{1F373}", "\u{1F468}\u{1F3FF}\u200D\u{1F373}", "\u{1F469}\u200D\u{1F373}", "\u{1F469}\u{1F3FB}\u200D\u{1F373}", "\u{1F469}\u{1F3FC}\u200D\u{1F373}", "\u{1F469}\u{1F3FD}\u200D\u{1F373}", "\u{1F469}\u{1F3FE}\u200D\u{1F373}", "\u{1F469}\u{1F3FF}\u200D\u{1F373}", "\u{1F9D1}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F527}", "\u{1F468}\u200D\u{1F527}", "\u{1F468}\u{1F3FB}\u200D\u{1F527}", "\u{1F468}\u{1F3FC}\u200D\u{1F527}", "\u{1F468}\u{1F3FD}\u200D\u{1F527}", "\u{1F468}\u{1F3FE}\u200D\u{1F527}", "\u{1F468}\u{1F3FF}\u200D\u{1F527}", "\u{1F469}\u200D\u{1F527}", "\u{1F469}\u{1F3FB}\u200D\u{1F527}", "\u{1F469}\u{1F3FC}\u200D\u{1F527}", "\u{1F469}\u{1F3FD}\u200D\u{1F527}", "\u{1F469}\u{1F3FE}\u200D\u{1F527}", "\u{1F469}\u{1F3FF}\u200D\u{1F527}", "\u{1F9D1}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3ED}", "\u{1F468}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FB}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FC}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FD}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FE}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FF}\u200D\u{1F3ED}", "\u{1F469}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FB}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FC}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FD}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FE}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FF}\u200D\u{1F3ED}", "\u{1F9D1}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F4BC}", "\u{1F468}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FB}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FC}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FD}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FE}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FF}\u200D\u{1F4BC}", "\u{1F469}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FB}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FC}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FD}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FE}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FF}\u200D\u{1F4BC}", "\u{1F9D1}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F52C}", "\u{1F468}\u200D\u{1F52C}", "\u{1F468}\u{1F3FB}\u200D\u{1F52C}", "\u{1F468}\u{1F3FC}\u200D\u{1F52C}", "\u{1F468}\u{1F3FD}\u200D\u{1F52C}", "\u{1F468}\u{1F3FE}\u200D\u{1F52C}", "\u{1F468}\u{1F3FF}\u200D\u{1F52C}", "\u{1F469}\u200D\u{1F52C}", "\u{1F469}\u{1F3FB}\u200D\u{1F52C}", "\u{1F469}\u{1F3FC}\u200D\u{1F52C}", "\u{1F469}\u{1F3FD}\u200D\u{1F52C}", "\u{1F469}\u{1F3FE}\u200D\u{1F52C}", "\u{1F469}\u{1F3FF}\u200D\u{1F52C}", "\u{1F9D1}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F4BB}", "\u{1F468}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FB}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FC}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FD}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FE}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FF}\u200D\u{1F4BB}", "\u{1F469}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FB}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FC}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FD}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FE}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FF}\u200D\u{1F4BB}", "\u{1F9D1}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3A4}", "\u{1F468}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FB}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FC}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FD}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FE}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FF}\u200D\u{1F3A4}", "\u{1F469}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FB}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FC}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FD}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FE}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FF}\u200D\u{1F3A4}", "\u{1F9D1}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3A8}", "\u{1F468}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FB}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FC}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FD}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FE}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FF}\u200D\u{1F3A8}", "\u{1F469}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FB}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FC}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FD}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FE}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FF}\u200D\u{1F3A8}", "\u{1F9D1}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FB}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FC}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FD}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FE}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FF}\u200D\u2708\uFE0F", "\u{1F468}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FB}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FC}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FD}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FE}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FF}\u200D\u2708\uFE0F", "\u{1F469}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FB}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FC}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FD}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FE}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FF}\u200D\u2708\uFE0F", "\u{1F9D1}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F680}", "\u{1F468}\u200D\u{1F680}", "\u{1F468}\u{1F3FB}\u200D\u{1F680}", "\u{1F468}\u{1F3FC}\u200D\u{1F680}", "\u{1F468}\u{1F3FD}\u200D\u{1F680}", "\u{1F468}\u{1F3FE}\u200D\u{1F680}", "\u{1F468}\u{1F3FF}\u200D\u{1F680}", "\u{1F469}\u200D\u{1F680}", "\u{1F469}\u{1F3FB}\u200D\u{1F680}", "\u{1F469}\u{1F3FC}\u200D\u{1F680}", "\u{1F469}\u{1F3FD}\u200D\u{1F680}", "\u{1F469}\u{1F3FE}\u200D\u{1F680}", "\u{1F469}\u{1F3FF}\u200D\u{1F680}", "\u{1F9D1}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F692}", "\u{1F468}\u200D\u{1F692}", "\u{1F468}\u{1F3FB}\u200D\u{1F692}", "\u{1F468}\u{1F3FC}\u200D\u{1F692}", "\u{1F468}\u{1F3FD}\u200D\u{1F692}", "\u{1F468}\u{1F3FE}\u200D\u{1F692}", "\u{1F468}\u{1F3FF}\u200D\u{1F692}", "\u{1F469}\u200D\u{1F692}", "\u{1F469}\u{1F3FB}\u200D\u{1F692}", "\u{1F469}\u{1F3FC}\u200D\u{1F692}", "\u{1F469}\u{1F3FD}\u200D\u{1F692}", "\u{1F469}\u{1F3FE}\u200D\u{1F692}", "\u{1F469}\u{1F3FF}\u200D\u{1F692}", "\u{1F46E}", "\u{1F46E}\u{1F3FB}", "\u{1F46E}\u{1F3FC}", "\u{1F46E}\u{1F3FD}", "\u{1F46E}\u{1F3FE}", "\u{1F46E}\u{1F3FF}", "\u{1F46E}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F46E}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F575}\uFE0F", "\u{1F575}\u{1F3FB}", "\u{1F575}\u{1F3FC}", "\u{1F575}\u{1F3FD}", "\u{1F575}\u{1F3FE}", "\u{1F575}\u{1F3FF}", "\u{1F575}\uFE0F\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F575}\uFE0F\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F482}", "\u{1F482}\u{1F3FB}", "\u{1F482}\u{1F3FC}", "\u{1F482}\u{1F3FD}", "\u{1F482}\u{1F3FE}", "\u{1F482}\u{1F3FF}", "\u{1F482}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F482}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F977}", "\u{1F977}\u{1F3FB}", "\u{1F977}\u{1F3FC}", "\u{1F977}\u{1F3FD}", "\u{1F977}\u{1F3FE}", "\u{1F977}\u{1F3FF}", "\u{1F477}", "\u{1F477}\u{1F3FB}", "\u{1F477}\u{1F3FC}", "\u{1F477}\u{1F3FD}", "\u{1F477}\u{1F3FE}", "\u{1F477}\u{1F3FF}", "\u{1F477}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F477}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F934}", "\u{1F934}\u{1F3FB}", "\u{1F934}\u{1F3FC}", "\u{1F934}\u{1F3FD}", "\u{1F934}\u{1F3FE}", "\u{1F934}\u{1F3FF}", "\u{1F478}", "\u{1F478}\u{1F3FB}", "\u{1F478}\u{1F3FC}", "\u{1F478}\u{1F3FD}", "\u{1F478}\u{1F3FE}", "\u{1F478}\u{1F3FF}", "\u{1F473}", "\u{1F473}\u{1F3FB}", "\u{1F473}\u{1F3FC}", "\u{1F473}\u{1F3FD}", "\u{1F473}\u{1F3FE}", "\u{1F473}\u{1F3FF}", "\u{1F473}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F473}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F472}", "\u{1F472}\u{1F3FB}", "\u{1F472}\u{1F3FC}", "\u{1F472}\u{1F3FD}", "\u{1F472}\u{1F3FE}", "\u{1F472}\u{1F3FF}", "\u{1F9D5}", "\u{1F9D5}\u{1F3FB}", "\u{1F9D5}\u{1F3FC}", "\u{1F9D5}\u{1F3FD}", "\u{1F9D5}\u{1F3FE}", "\u{1F9D5}\u{1F3FF}", "\u{1F935}", "\u{1F935}\u{1F3FB}", "\u{1F935}\u{1F3FC}", "\u{1F935}\u{1F3FD}", "\u{1F935}\u{1F3FE}", "\u{1F935}\u{1F3FF}", "\u{1F935}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F935}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F470}", "\u{1F470}\u{1F3FB}", "\u{1F470}\u{1F3FC}", "\u{1F470}\u{1F3FD}", "\u{1F470}\u{1F3FE}", "\u{1F470}\u{1F3FF}", "\u{1F470}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F470}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F930}", "\u{1F930}\u{1F3FB}", "\u{1F930}\u{1F3FC}", "\u{1F930}\u{1F3FD}", "\u{1F930}\u{1F3FE}", "\u{1F930}\u{1F3FF}", "\u{1F931}", "\u{1F931}\u{1F3FB}", "\u{1F931}\u{1F3FC}", "\u{1F931}\u{1F3FD}", "\u{1F931}\u{1F3FE}", "\u{1F931}\u{1F3FF}", "\u{1F469}\u200D\u{1F37C}", "\u{1F469}\u{1F3FB}\u200D\u{1F37C}", "\u{1F469}\u{1F3FC}\u200D\u{1F37C}", "\u{1F469}\u{1F3FD}\u200D\u{1F37C}", "\u{1F469}\u{1F3FE}\u200D\u{1F37C}", "\u{1F469}\u{1F3FF}\u200D\u{1F37C}", "\u{1F468}\u200D\u{1F37C}", "\u{1F468}\u{1F3FB}\u200D\u{1F37C}", "\u{1F468}\u{1F3FC}\u200D\u{1F37C}", "\u{1F468}\u{1F3FD}\u200D\u{1F37C}", "\u{1F468}\u{1F3FE}\u200D\u{1F37C}", "\u{1F468}\u{1F3FF}\u200D\u{1F37C}", "\u{1F9D1}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F37C}", "\u{1F47C}", "\u{1F47C}\u{1F3FB}", "\u{1F47C}\u{1F3FC}", "\u{1F47C}\u{1F3FD}", "\u{1F47C}\u{1F3FE}", "\u{1F47C}\u{1F3FF}", "\u{1F385}", "\u{1F385}\u{1F3FB}", "\u{1F385}\u{1F3FC}", "\u{1F385}\u{1F3FD}", "\u{1F385}\u{1F3FE}", "\u{1F385}\u{1F3FF}", "\u{1F936}", "\u{1F936}\u{1F3FB}", "\u{1F936}\u{1F3FC}", "\u{1F936}\u{1F3FD}", "\u{1F936}\u{1F3FE}", "\u{1F936}\u{1F3FF}", "\u{1F9D1}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F384}", "\u{1F9B8}", "\u{1F9B8}\u{1F3FB}", "\u{1F9B8}\u{1F3FC}", "\u{1F9B8}\u{1F3FD}", "\u{1F9B8}\u{1F3FE}", "\u{1F9B8}\u{1F3FF}", "\u{1F9B8}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9B8}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9B9}", "\u{1F9B9}\u{1F3FB}", "\u{1F9B9}\u{1F3FC}", "\u{1F9B9}\u{1F3FD}", "\u{1F9B9}\u{1F3FE}", "\u{1F9B9}\u{1F3FF}", "\u{1F9B9}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9B9}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9D9}", "\u{1F9D9}\u{1F3FB}", "\u{1F9D9}\u{1F3FC}", "\u{1F9D9}\u{1F3FD}", "\u{1F9D9}\u{1F3FE}", "\u{1F9D9}\u{1F3FF}", "\u{1F9D9}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9D9}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9DA}", "\u{1F9DA}\u{1F3FB}", "\u{1F9DA}\u{1F3FC}", "\u{1F9DA}\u{1F3FD}", "\u{1F9DA}\u{1F3FE}", "\u{1F9DA}\u{1F3FF}", "\u{1F9DA}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9DA}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9DB}", "\u{1F9DB}\u{1F3FB}", "\u{1F9DB}\u{1F3FC}", "\u{1F9DB}\u{1F3FD}", "\u{1F9DB}\u{1F3FE}", "\u{1F9DB}\u{1F3FF}", "\u{1F9DB}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9DB}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9DC}", "\u{1F9DC}\u{1F3FB}", "\u{1F9DC}\u{1F3FC}", "\u{1F9DC}\u{1F3FD}", "\u{1F9DC}\u{1F3FE}", "\u{1F9DC}\u{1F3FF}", "\u{1F9DC}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9DC}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9DD}", "\u{1F9DD}\u{1F3FB}", "\u{1F9DD}\u{1F3FC}", "\u{1F9DD}\u{1F3FD}", "\u{1F9DD}\u{1F3FE}", "\u{1F9DD}\u{1F3FF}", "\u{1F9DD}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9DD}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9DE}", "\u{1F9DE}\u200D\u2642\uFE0F", "\u{1F9DE}\u200D\u2640\uFE0F", "\u{1F9DF}", "\u{1F9DF}\u200D\u2642\uFE0F", "\u{1F9DF}\u200D\u2640\uFE0F", "\u{1F486}", "\u{1F486}\u{1F3FB}", "\u{1F486}\u{1F3FC}", "\u{1F486}\u{1F3FD}", "\u{1F486}\u{1F3FE}", "\u{1F486}\u{1F3FF}", "\u{1F486}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F486}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F487}", "\u{1F487}\u{1F3FB}", "\u{1F487}\u{1F3FC}", "\u{1F487}\u{1F3FD}", "\u{1F487}\u{1F3FE}", "\u{1F487}\u{1F3FF}", "\u{1F487}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F487}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F6B6}", "\u{1F6B6}\u{1F3FB}", "\u{1F6B6}\u{1F3FC}", "\u{1F6B6}\u{1F3FD}", "\u{1F6B6}\u{1F3FE}", "\u{1F6B6}\u{1F3FF}", "\u{1F6B6}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F6B6}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9CD}", "\u{1F9CD}\u{1F3FB}", "\u{1F9CD}\u{1F3FC}", "\u{1F9CD}\u{1F3FD}", "\u{1F9CD}\u{1F3FE}", "\u{1F9CD}\u{1F3FF}", "\u{1F9CD}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9CD}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9CE}", "\u{1F9CE}\u{1F3FB}", "\u{1F9CE}\u{1F3FC}", "\u{1F9CE}\u{1F3FD}", "\u{1F9CE}\u{1F3FE}", "\u{1F9CE}\u{1F3FF}", "\u{1F9CE}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9CE}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9D1}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9AF}", "\u{1F468}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FB}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FC}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FD}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FE}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FF}\u200D\u{1F9AF}", "\u{1F469}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FB}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FC}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FD}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FE}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FF}\u200D\u{1F9AF}", "\u{1F9D1}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9BC}", "\u{1F468}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FB}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FC}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FD}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FE}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FF}\u200D\u{1F9BC}", "\u{1F469}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FB}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FC}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FD}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FE}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FF}\u200D\u{1F9BC}", "\u{1F9D1}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9BD}", "\u{1F468}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FB}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FC}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FD}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FE}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FF}\u200D\u{1F9BD}", "\u{1F469}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FB}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FC}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FD}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FE}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FF}\u200D\u{1F9BD}", "\u{1F3C3}", "\u{1F3C3}\u{1F3FB}", "\u{1F3C3}\u{1F3FC}", "\u{1F3C3}\u{1F3FD}", "\u{1F3C3}\u{1F3FE}", "\u{1F3C3}\u{1F3FF}", "\u{1F3C3}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F3C3}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F483}", "\u{1F483}\u{1F3FB}", "\u{1F483}\u{1F3FC}", "\u{1F483}\u{1F3FD}", "\u{1F483}\u{1F3FE}", "\u{1F483}\u{1F3FF}", "\u{1F57A}", "\u{1F57A}\u{1F3FB}", "\u{1F57A}\u{1F3FC}", "\u{1F57A}\u{1F3FD}", "\u{1F57A}\u{1F3FE}", "\u{1F57A}\u{1F3FF}", "\u{1F574}\uFE0F", "\u{1F574}\u{1F3FB}", "\u{1F574}\u{1F3FC}", "\u{1F574}\u{1F3FD}", "\u{1F574}\u{1F3FE}", "\u{1F574}\u{1F3FF}", "\u{1F46F}", "\u{1F46F}\u200D\u2642\uFE0F", "\u{1F46F}\u200D\u2640\uFE0F", "\u{1F9D6}", "\u{1F9D6}\u{1F3FB}", "\u{1F9D6}\u{1F3FC}", "\u{1F9D6}\u{1F3FD}", "\u{1F9D6}\u{1F3FE}", "\u{1F9D6}\u{1F3FF}", "\u{1F9D6}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9D6}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9D7}", "\u{1F9D7}\u{1F3FB}", "\u{1F9D7}\u{1F3FC}", "\u{1F9D7}\u{1F3FD}", "\u{1F9D7}\u{1F3FE}", "\u{1F9D7}\u{1F3FF}", "\u{1F9D7}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9D7}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F93A}", "\u{1F3C7}", "\u{1F3C7}\u{1F3FB}", "\u{1F3C7}\u{1F3FC}", "\u{1F3C7}\u{1F3FD}", "\u{1F3C7}\u{1F3FE}", "\u{1F3C7}\u{1F3FF}", "\u26F7\uFE0F", "\u{1F3C2}", "\u{1F3C2}\u{1F3FB}", "\u{1F3C2}\u{1F3FC}", "\u{1F3C2}\u{1F3FD}", "\u{1F3C2}\u{1F3FE}", "\u{1F3C2}\u{1F3FF}", "\u{1F3CC}\uFE0F", "\u{1F3CC}\u{1F3FB}", "\u{1F3CC}\u{1F3FC}", "\u{1F3CC}\u{1F3FD}", "\u{1F3CC}\u{1F3FE}", "\u{1F3CC}\u{1F3FF}", "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F3C4}", "\u{1F3C4}\u{1F3FB}", "\u{1F3C4}\u{1F3FC}", "\u{1F3C4}\u{1F3FD}", "\u{1F3C4}\u{1F3FE}", "\u{1F3C4}\u{1F3FF}", "\u{1F3C4}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F3C4}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F6A3}", "\u{1F6A3}\u{1F3FB}", "\u{1F6A3}\u{1F3FC}", "\u{1F6A3}\u{1F3FD}", "\u{1F6A3}\u{1F3FE}", "\u{1F6A3}\u{1F3FF}", "\u{1F6A3}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F6A3}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F3CA}", "\u{1F3CA}\u{1F3FB}", "\u{1F3CA}\u{1F3FC}", "\u{1F3CA}\u{1F3FD}", "\u{1F3CA}\u{1F3FE}", "\u{1F3CA}\u{1F3FF}", "\u{1F3CA}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F3CA}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FF}\u200D\u2640\uFE0F", "\u26F9\uFE0F", "\u26F9\u{1F3FB}", "\u26F9\u{1F3FC}", "\u26F9\u{1F3FD}", "\u26F9\u{1F3FE}", "\u26F9\u{1F3FF}", "\u26F9\uFE0F\u200D\u2642\uFE0F", "\u26F9\u{1F3FB}\u200D\u2642\uFE0F", "\u26F9\u{1F3FC}\u200D\u2642\uFE0F", "\u26F9\u{1F3FD}\u200D\u2642\uFE0F", "\u26F9\u{1F3FE}\u200D\u2642\uFE0F", "\u26F9\u{1F3FF}\u200D\u2642\uFE0F", "\u26F9\uFE0F\u200D\u2640\uFE0F", "\u26F9\u{1F3FB}\u200D\u2640\uFE0F", "\u26F9\u{1F3FC}\u200D\u2640\uFE0F", "\u26F9\u{1F3FD}\u200D\u2640\uFE0F", "\u26F9\u{1F3FE}\u200D\u2640\uFE0F", "\u26F9\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F3CB}\uFE0F", "\u{1F3CB}\u{1F3FB}", "\u{1F3CB}\u{1F3FC}", "\u{1F3CB}\u{1F3FD}", "\u{1F3CB}\u{1F3FE}", "\u{1F3CB}\u{1F3FF}", "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F6B4}", "\u{1F6B4}\u{1F3FB}", "\u{1F6B4}\u{1F3FC}", "\u{1F6B4}\u{1F3FD}", "\u{1F6B4}\u{1F3FE}", "\u{1F6B4}\u{1F3FF}", "\u{1F6B4}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F6B4}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F6B5}", "\u{1F6B5}\u{1F3FB}", "\u{1F6B5}\u{1F3FC}", "\u{1F6B5}\u{1F3FD}", "\u{1F6B5}\u{1F3FE}", "\u{1F6B5}\u{1F3FF}", "\u{1F6B5}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F6B5}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F938}", "\u{1F938}\u{1F3FB}", "\u{1F938}\u{1F3FC}", "\u{1F938}\u{1F3FD}", "\u{1F938}\u{1F3FE}", "\u{1F938}\u{1F3FF}", "\u{1F938}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F938}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F93C}", "\u{1F93C}\u200D\u2642\uFE0F", "\u{1F93C}\u200D\u2640\uFE0F", "\u{1F93D}", "\u{1F93D}\u{1F3FB}", "\u{1F93D}\u{1F3FC}", "\u{1F93D}\u{1F3FD}", "\u{1F93D}\u{1F3FE}", "\u{1F93D}\u{1F3FF}", "\u{1F93D}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F93D}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F93E}", "\u{1F93E}\u{1F3FB}", "\u{1F93E}\u{1F3FC}", "\u{1F93E}\u{1F3FD}", "\u{1F93E}\u{1F3FE}", "\u{1F93E}\u{1F3FF}", "\u{1F93E}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F93E}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F939}", "\u{1F939}\u{1F3FB}", "\u{1F939}\u{1F3FC}", "\u{1F939}\u{1F3FD}", "\u{1F939}\u{1F3FE}", "\u{1F939}\u{1F3FF}", "\u{1F939}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F939}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F9D8}", "\u{1F9D8}\u{1F3FB}", "\u{1F9D8}\u{1F3FC}", "\u{1F9D8}\u{1F3FD}", "\u{1F9D8}\u{1F3FE}", "\u{1F9D8}\u{1F3FF}", "\u{1F9D8}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FF}\u200D\u2642\uFE0F", "\u{1F9D8}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FF}\u200D\u2640\uFE0F", "\u{1F6C0}", "\u{1F6C0}\u{1F3FB}", "\u{1F6C0}\u{1F3FC}", "\u{1F6C0}\u{1F3FD}", "\u{1F6C0}\u{1F3FE}", "\u{1F6C0}\u{1F3FF}", "\u{1F6CC}", "\u{1F6CC}\u{1F3FB}", "\u{1F6CC}\u{1F3FC}", "\u{1F6CC}\u{1F3FD}", "\u{1F6CC}\u{1F3FE}", "\u{1F6CC}\u{1F3FF}", "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F46D}", "\u{1F46D}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F46D}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F46D}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F46D}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F46D}\u{1F3FF}", "\u{1F46B}", "\u{1F46B}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F46B}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F46B}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F46B}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F46B}\u{1F3FF}", "\u{1F46C}", "\u{1F46C}\u{1F3FB}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F46C}\u{1F3FC}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F46C}\u{1F3FD}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F46C}\u{1F3FE}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F46C}\u{1F3FF}", "\u{1F48F}", "\u{1F48F}\u{1F3FB}", "\u{1F48F}\u{1F3FC}", "\u{1F48F}\u{1F3FD}", "\u{1F48F}\u{1F3FE}", "\u{1F48F}\u{1F3FF}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FF}", "\u{1F491}", "\u{1F491}\u{1F3FB}", "\u{1F491}\u{1F3FC}", "\u{1F491}\u{1F3FD}", "\u{1F491}\u{1F3FE}", "\u{1F491}\u{1F3FF}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F9D1}\u{1F3FE}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FF}", "\u{1F46A}", "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}", "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}", "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}", "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}", "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", "\u{1F468}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F467}", "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", "\u{1F469}\u200D\u{1F466}", "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", "\u{1F469}\u200D\u{1F467}", "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", "\u{1F5E3}\uFE0F", "\u{1F464}", "\u{1F465}", "\u{1FAC2}", "\u{1F463}"], nature: ["\u{1F435}", "\u{1F412}", "\u{1F98D}", "\u{1F9A7}", "\u{1F436}", "\u{1F415}", "\u{1F9AE}", "\u{1F415}\u200D\u{1F9BA}", "\u{1F429}", "\u{1F43A}", "\u{1F98A}", "\u{1F99D}", "\u{1F431}", "\u{1F408}", "\u{1F408}\u200D\u2B1B", "\u{1F981}", "\u{1F42F}", "\u{1F405}", "\u{1F406}", "\u{1F434}", "\u{1F40E}", "\u{1F984}", "\u{1F993}", "\u{1F98C}", "\u{1F9AC}", "\u{1F42E}", "\u{1F402}", "\u{1F403}", "\u{1F404}", "\u{1F437}", "\u{1F416}", "\u{1F417}", "\u{1F43D}", "\u{1F40F}", "\u{1F411}", "\u{1F410}", "\u{1F42A}", "\u{1F42B}", "\u{1F999}", "\u{1F992}", "\u{1F418}", "\u{1F9A3}", "\u{1F98F}", "\u{1F99B}", "\u{1F42D}", "\u{1F401}", "\u{1F400}", "\u{1F439}", "\u{1F430}", "\u{1F407}", "\u{1F43F}\uFE0F", "\u{1F9AB}", "\u{1F994}", "\u{1F987}", "\u{1F43B}", "\u{1F43B}\u200D\u2744\uFE0F", "\u{1F428}", "\u{1F43C}", "\u{1F9A5}", "\u{1F9A6}", "\u{1F9A8}", "\u{1F998}", "\u{1F9A1}", "\u{1F43E}", "\u{1F983}", "\u{1F414}", "\u{1F413}", "\u{1F423}", "\u{1F424}", "\u{1F425}", "\u{1F426}", "\u{1F427}", "\u{1F54A}\uFE0F", "\u{1F985}", "\u{1F986}", "\u{1F9A2}", "\u{1F989}", "\u{1F9A4}", "\u{1FAB6}", "\u{1F9A9}", "\u{1F99A}", "\u{1F99C}", "\u{1F438}", "\u{1F40A}", "\u{1F422}", "\u{1F98E}", "\u{1F40D}", "\u{1F432}", "\u{1F409}", "\u{1F995}", "\u{1F996}", "\u{1F433}", "\u{1F40B}", "\u{1F42C}", "\u{1F9AD}", "\u{1F41F}", "\u{1F420}", "\u{1F421}", "\u{1F988}", "\u{1F419}", "\u{1F41A}", "\u{1F40C}", "\u{1F98B}", "\u{1F41B}", "\u{1F41C}", "\u{1F41D}", "\u{1FAB2}", "\u{1F41E}", "\u{1F997}", "\u{1FAB3}", "\u{1F577}\uFE0F", "\u{1F578}\uFE0F", "\u{1F982}", "\u{1F99F}", "\u{1FAB0}", "\u{1FAB1}", "\u{1F9A0}", "\u{1F490}", "\u{1F338}", "\u{1F4AE}", "\u{1F3F5}\uFE0F", "\u{1F339}", "\u{1F940}", "\u{1F33A}", "\u{1F33B}", "\u{1F33C}", "\u{1F337}", "\u{1F331}", "\u{1FAB4}", "\u{1F332}", "\u{1F333}", "\u{1F334}", "\u{1F335}", "\u{1F33E}", "\u{1F33F}", "\u2618\uFE0F", "\u{1F340}", "\u{1F341}", "\u{1F342}", "\u{1F343}"], food: ["\u{1F347}", "\u{1F348}", "\u{1F349}", "\u{1F34A}", "\u{1F34B}", "\u{1F34C}", "\u{1F34D}", "\u{1F96D}", "\u{1F34E}", "\u{1F34F}", "\u{1F350}", "\u{1F351}", "\u{1F352}", "\u{1F353}", "\u{1FAD0}", "\u{1F95D}", "\u{1F345}", "\u{1FAD2}", "\u{1F965}", "\u{1F951}", "\u{1F346}", "\u{1F954}", "\u{1F955}", "\u{1F33D}", "\u{1F336}\uFE0F", "\u{1FAD1}", "\u{1F952}", "\u{1F96C}", "\u{1F966}", "\u{1F9C4}", "\u{1F9C5}", "\u{1F344}", "\u{1F95C}", "\u{1F330}", "\u{1F35E}", "\u{1F950}", "\u{1F956}", "\u{1FAD3}", "\u{1F968}", "\u{1F96F}", "\u{1F95E}", "\u{1F9C7}", "\u{1F9C0}", "\u{1F356}", "\u{1F357}", "\u{1F969}", "\u{1F953}", "\u{1F354}", "\u{1F35F}", "\u{1F355}", "\u{1F32D}", "\u{1F96A}", "\u{1F32E}", "\u{1F32F}", "\u{1FAD4}", "\u{1F959}", "\u{1F9C6}", "\u{1F95A}", "\u{1F373}", "\u{1F958}", "\u{1F372}", "\u{1FAD5}", "\u{1F963}", "\u{1F957}", "\u{1F37F}", "\u{1F9C8}", "\u{1F9C2}", "\u{1F96B}", "\u{1F371}", "\u{1F358}", "\u{1F359}", "\u{1F35A}", "\u{1F35B}", "\u{1F35C}", "\u{1F35D}", "\u{1F360}", "\u{1F362}", "\u{1F363}", "\u{1F364}", "\u{1F365}", "\u{1F96E}", "\u{1F361}", "\u{1F95F}", "\u{1F960}", "\u{1F961}", "\u{1F980}", "\u{1F99E}", "\u{1F990}", "\u{1F991}", "\u{1F9AA}", "\u{1F366}", "\u{1F367}", "\u{1F368}", "\u{1F369}", "\u{1F36A}", "\u{1F382}", "\u{1F370}", "\u{1F9C1}", "\u{1F967}", "\u{1F36B}", "\u{1F36C}", "\u{1F36D}", "\u{1F36E}", "\u{1F36F}", "\u{1F37C}", "\u{1F95B}", "\u2615", "\u{1FAD6}", "\u{1F375}", "\u{1F376}", "\u{1F37E}", "\u{1F377}", "\u{1F378}", "\u{1F379}", "\u{1F37A}", "\u{1F37B}", "\u{1F942}", "\u{1F943}", "\u{1F964}", "\u{1F9CB}", "\u{1F9C3}", "\u{1F9C9}", "\u{1F9CA}", "\u{1F962}", "\u{1F37D}\uFE0F", "\u{1F374}", "\u{1F944}", "\u{1F52A}", "\u{1F3FA}"], travel: ["\u{1F30D}", "\u{1F30E}", "\u{1F30F}", "\u{1F310}", "\u{1F5FA}\uFE0F", "\u{1F5FE}", "\u{1F9ED}", "\u{1F3D4}\uFE0F", "\u26F0\uFE0F", "\u{1F30B}", "\u{1F5FB}", "\u{1F3D5}\uFE0F", "\u{1F3D6}\uFE0F", "\u{1F3DC}\uFE0F", "\u{1F3DD}\uFE0F", "\u{1F3DE}\uFE0F", "\u{1F3DF}\uFE0F", "\u{1F3DB}\uFE0F", "\u{1F3D7}\uFE0F", "\u{1F9F1}", "\u{1FAA8}", "\u{1FAB5}", "\u{1F6D6}", "\u{1F3D8}\uFE0F", "\u{1F3DA}\uFE0F", "\u{1F3E0}", "\u{1F3E1}", "\u{1F3E2}", "\u{1F3E3}", "\u{1F3E4}", "\u{1F3E5}", "\u{1F3E6}", "\u{1F3E8}", "\u{1F3E9}", "\u{1F3EA}", "\u{1F3EB}", "\u{1F3EC}", "\u{1F3ED}", "\u{1F3EF}", "\u{1F3F0}", "\u{1F492}", "\u{1F5FC}", "\u{1F5FD}", "\u26EA", "\u{1F54C}", "\u{1F6D5}", "\u{1F54D}", "\u26E9\uFE0F", "\u{1F54B}", "\u26F2", "\u26FA", "\u{1F301}", "\u{1F303}", "\u{1F3D9}\uFE0F", "\u{1F304}", "\u{1F305}", "\u{1F306}", "\u{1F307}", "\u{1F309}", "\u2668\uFE0F", "\u{1F3A0}", "\u{1F3A1}", "\u{1F3A2}", "\u{1F488}", "\u{1F3AA}", "\u{1F682}", "\u{1F683}", "\u{1F684}", "\u{1F685}", "\u{1F686}", "\u{1F687}", "\u{1F688}", "\u{1F689}", "\u{1F68A}", "\u{1F69D}", "\u{1F69E}", "\u{1F68B}", "\u{1F68C}", "\u{1F68D}", "\u{1F68E}", "\u{1F690}", "\u{1F691}", "\u{1F692}", "\u{1F693}", "\u{1F694}", "\u{1F695}", "\u{1F696}", "\u{1F697}", "\u{1F698}", "\u{1F699}", "\u{1F6FB}", "\u{1F69A}", "\u{1F69B}", "\u{1F69C}", "\u{1F3CE}\uFE0F", "\u{1F3CD}\uFE0F", "\u{1F6F5}", "\u{1F9BD}", "\u{1F9BC}", "\u{1F6FA}", "\u{1F6B2}", "\u{1F6F4}", "\u{1F6F9}", "\u{1F6FC}", "\u{1F68F}", "\u{1F6E3}\uFE0F", "\u{1F6E4}\uFE0F", "\u{1F6E2}\uFE0F", "\u26FD", "\u{1F6A8}", "\u{1F6A5}", "\u{1F6A6}", "\u{1F6D1}", "\u{1F6A7}", "\u2693", "\u26F5", "\u{1F6F6}", "\u{1F6A4}", "\u{1F6F3}\uFE0F", "\u26F4\uFE0F", "\u{1F6E5}\uFE0F", "\u{1F6A2}", "\u2708\uFE0F", "\u{1F6E9}\uFE0F", "\u{1F6EB}", "\u{1F6EC}", "\u{1FA82}", "\u{1F4BA}", "\u{1F681}", "\u{1F69F}", "\u{1F6A0}", "\u{1F6A1}", "\u{1F6F0}\uFE0F", "\u{1F680}", "\u{1F6F8}", "\u{1F6CE}\uFE0F", "\u{1F9F3}", "\u231B", "\u23F3", "\u231A", "\u23F0", "\u23F1\uFE0F", "\u23F2\uFE0F", "\u{1F570}\uFE0F", "\u{1F55B}", "\u{1F567}", "\u{1F550}", "\u{1F55C}", "\u{1F551}", "\u{1F55D}", "\u{1F552}", "\u{1F55E}", "\u{1F553}", "\u{1F55F}", "\u{1F554}", "\u{1F560}", "\u{1F555}", "\u{1F561}", "\u{1F556}", "\u{1F562}", "\u{1F557}", "\u{1F563}", "\u{1F558}", "\u{1F564}", "\u{1F559}", "\u{1F565}", "\u{1F55A}", "\u{1F566}", "\u{1F311}", "\u{1F312}", "\u{1F313}", "\u{1F314}", "\u{1F315}", "\u{1F316}", "\u{1F317}", "\u{1F318}", "\u{1F319}", "\u{1F31A}", "\u{1F31B}", "\u{1F31C}", "\u{1F321}\uFE0F", "\u2600\uFE0F", "\u{1F31D}", "\u{1F31E}", "\u{1FA90}", "\u2B50", "\u{1F31F}", "\u{1F320}", "\u{1F30C}", "\u2601\uFE0F", "\u26C5", "\u26C8\uFE0F", "\u{1F324}\uFE0F", "\u{1F325}\uFE0F", "\u{1F326}\uFE0F", "\u{1F327}\uFE0F", "\u{1F328}\uFE0F", "\u{1F329}\uFE0F", "\u{1F32A}\uFE0F", "\u{1F32B}\uFE0F", "\u{1F32C}\uFE0F", "\u{1F300}", "\u{1F308}", "\u{1F302}", "\u2602\uFE0F", "\u2614", "\u26F1\uFE0F", "\u26A1", "\u2744\uFE0F", "\u2603\uFE0F", "\u26C4", "\u2604\uFE0F", "\u{1F525}", "\u{1F4A7}", "\u{1F30A}"], activity: ["\u{1F383}", "\u{1F384}", "\u{1F386}", "\u{1F387}", "\u{1F9E8}", "\u2728", "\u{1F388}", "\u{1F389}", "\u{1F38A}", "\u{1F38B}", "\u{1F38D}", "\u{1F38E}", "\u{1F38F}", "\u{1F390}", "\u{1F391}", "\u{1F9E7}", "\u{1F380}", "\u{1F381}", "\u{1F397}\uFE0F", "\u{1F39F}\uFE0F", "\u{1F3AB}", "\u{1F396}\uFE0F", "\u{1F3C6}", "\u{1F3C5}", "\u{1F947}", "\u{1F948}", "\u{1F949}", "\u26BD", "\u26BE", "\u{1F94E}", "\u{1F3C0}", "\u{1F3D0}", "\u{1F3C8}", "\u{1F3C9}", "\u{1F3BE}", "\u{1F94F}", "\u{1F3B3}", "\u{1F3CF}", "\u{1F3D1}", "\u{1F3D2}", "\u{1F94D}", "\u{1F3D3}", "\u{1F3F8}", "\u{1F94A}", "\u{1F94B}", "\u{1F945}", "\u26F3", "\u26F8\uFE0F", "\u{1F3A3}", "\u{1F93F}", "\u{1F3BD}", "\u{1F3BF}", "\u{1F6F7}", "\u{1F94C}", "\u{1F3AF}", "\u{1FA80}", "\u{1FA81}", "\u{1F3B1}", "\u{1F52E}", "\u{1FA84}", "\u{1F9FF}", "\u{1F3AE}", "\u{1F579}\uFE0F", "\u{1F3B0}", "\u{1F3B2}", "\u{1F9E9}", "\u{1F9F8}", "\u{1FA85}", "\u{1FA86}", "\u2660\uFE0F", "\u2665\uFE0F", "\u2666\uFE0F", "\u2663\uFE0F", "\u265F\uFE0F", "\u{1F0CF}", "\u{1F004}", "\u{1F3B4}", "\u{1F3AD}", "\u{1F5BC}\uFE0F", "\u{1F3A8}", "\u{1F9F5}", "\u{1FAA1}", "\u{1F9F6}", "\u{1FAA2}"], object: ["\u{1F453}", "\u{1F576}\uFE0F", "\u{1F97D}", "\u{1F97C}", "\u{1F9BA}", "\u{1F454}", "\u{1F455}", "\u{1F456}", "\u{1F9E3}", "\u{1F9E4}", "\u{1F9E5}", "\u{1F9E6}", "\u{1F457}", "\u{1F458}", "\u{1F97B}", "\u{1FA71}", "\u{1FA72}", "\u{1FA73}", "\u{1F459}", "\u{1F45A}", "\u{1F45B}", "\u{1F45C}", "\u{1F45D}", "\u{1F6CD}\uFE0F", "\u{1F392}", "\u{1FA74}", "\u{1F45E}", "\u{1F45F}", "\u{1F97E}", "\u{1F97F}", "\u{1F460}", "\u{1F461}", "\u{1FA70}", "\u{1F462}", "\u{1F451}", "\u{1F452}", "\u{1F3A9}", "\u{1F393}", "\u{1F9E2}", "\u{1FA96}", "\u26D1\uFE0F", "\u{1F4FF}", "\u{1F484}", "\u{1F48D}", "\u{1F48E}", "\u{1F507}", "\u{1F508}", "\u{1F509}", "\u{1F50A}", "\u{1F4E2}", "\u{1F4E3}", "\u{1F4EF}", "\u{1F514}", "\u{1F515}", "\u{1F3BC}", "\u{1F3B5}", "\u{1F3B6}", "\u{1F399}\uFE0F", "\u{1F39A}\uFE0F", "\u{1F39B}\uFE0F", "\u{1F3A4}", "\u{1F3A7}", "\u{1F4FB}", "\u{1F3B7}", "\u{1FA97}", "\u{1F3B8}", "\u{1F3B9}", "\u{1F3BA}", "\u{1F3BB}", "\u{1FA95}", "\u{1F941}", "\u{1FA98}", "\u{1F4F1}", "\u{1F4F2}", "\u260E\uFE0F", "\u{1F4DE}", "\u{1F4DF}", "\u{1F4E0}", "\u{1F50B}", "\u{1F50C}", "\u{1F4BB}", "\u{1F5A5}\uFE0F", "\u{1F5A8}\uFE0F", "\u2328\uFE0F", "\u{1F5B1}\uFE0F", "\u{1F5B2}\uFE0F", "\u{1F4BD}", "\u{1F4BE}", "\u{1F4BF}", "\u{1F4C0}", "\u{1F9EE}", "\u{1F3A5}", "\u{1F39E}\uFE0F", "\u{1F4FD}\uFE0F", "\u{1F3AC}", "\u{1F4FA}", "\u{1F4F7}", "\u{1F4F8}", "\u{1F4F9}", "\u{1F4FC}", "\u{1F50D}", "\u{1F50E}", "\u{1F56F}\uFE0F", "\u{1F4A1}", "\u{1F526}", "\u{1F3EE}", "\u{1FA94}", "\u{1F4D4}", "\u{1F4D5}", "\u{1F4D6}", "\u{1F4D7}", "\u{1F4D8}", "\u{1F4D9}", "\u{1F4DA}", "\u{1F4D3}", "\u{1F4D2}", "\u{1F4C3}", "\u{1F4DC}", "\u{1F4C4}", "\u{1F4F0}", "\u{1F5DE}\uFE0F", "\u{1F4D1}", "\u{1F516}", "\u{1F3F7}\uFE0F", "\u{1F4B0}", "\u{1FA99}", "\u{1F4B4}", "\u{1F4B5}", "\u{1F4B6}", "\u{1F4B7}", "\u{1F4B8}", "\u{1F4B3}", "\u{1F9FE}", "\u{1F4B9}", "\u2709\uFE0F", "\u{1F4E7}", "\u{1F4E8}", "\u{1F4E9}", "\u{1F4E4}", "\u{1F4E5}", "\u{1F4E6}", "\u{1F4EB}", "\u{1F4EA}", "\u{1F4EC}", "\u{1F4ED}", "\u{1F4EE}", "\u{1F5F3}\uFE0F", "\u270F\uFE0F", "\u2712\uFE0F", "\u{1F58B}\uFE0F", "\u{1F58A}\uFE0F", "\u{1F58C}\uFE0F", "\u{1F58D}\uFE0F", "\u{1F4DD}", "\u{1F4BC}", "\u{1F4C1}", "\u{1F4C2}", "\u{1F5C2}\uFE0F", "\u{1F4C5}", "\u{1F4C6}", "\u{1F5D2}\uFE0F", "\u{1F5D3}\uFE0F", "\u{1F4C7}", "\u{1F4C8}", "\u{1F4C9}", "\u{1F4CA}", "\u{1F4CB}", "\u{1F4CC}", "\u{1F4CD}", "\u{1F4CE}", "\u{1F587}\uFE0F", "\u{1F4CF}", "\u{1F4D0}", "\u2702\uFE0F", "\u{1F5C3}\uFE0F", "\u{1F5C4}\uFE0F", "\u{1F5D1}\uFE0F", "\u{1F512}", "\u{1F513}", "\u{1F50F}", "\u{1F510}", "\u{1F511}", "\u{1F5DD}\uFE0F", "\u{1F528}", "\u{1FA93}", "\u26CF\uFE0F", "\u2692\uFE0F", "\u{1F6E0}\uFE0F", "\u{1F5E1}\uFE0F", "\u2694\uFE0F", "\u{1F52B}", "\u{1FA83}", "\u{1F3F9}", "\u{1F6E1}\uFE0F", "\u{1FA9A}", "\u{1F527}", "\u{1FA9B}", "\u{1F529}", "\u2699\uFE0F", "\u{1F5DC}\uFE0F", "\u2696\uFE0F", "\u{1F9AF}", "\u{1F517}", "\u26D3\uFE0F", "\u{1FA9D}", "\u{1F9F0}", "\u{1F9F2}", "\u{1FA9C}", "\u2697\uFE0F", "\u{1F9EA}", "\u{1F9EB}", "\u{1F9EC}", "\u{1F52C}", "\u{1F52D}", "\u{1F4E1}", "\u{1F489}", "\u{1FA78}", "\u{1F48A}", "\u{1FA79}", "\u{1FA7A}", "\u{1F6AA}", "\u{1F6D7}", "\u{1FA9E}", "\u{1FA9F}", "\u{1F6CF}\uFE0F", "\u{1F6CB}\uFE0F", "\u{1FA91}", "\u{1F6BD}", "\u{1FAA0}", "\u{1F6BF}", "\u{1F6C1}", "\u{1FAA4}", "\u{1FA92}", "\u{1F9F4}", "\u{1F9F7}", "\u{1F9F9}", "\u{1F9FA}", "\u{1F9FB}", "\u{1FAA3}", "\u{1F9FC}", "\u{1FAA5}", "\u{1F9FD}", "\u{1F9EF}", "\u{1F6D2}", "\u{1F6AC}", "\u26B0\uFE0F", "\u{1FAA6}", "\u26B1\uFE0F", "\u{1F5FF}", "\u{1FAA7}"], symbol: ["\u{1F3E7}", "\u{1F6AE}", "\u{1F6B0}", "\u267F", "\u{1F6B9}", "\u{1F6BA}", "\u{1F6BB}", "\u{1F6BC}", "\u{1F6BE}", "\u{1F6C2}", "\u{1F6C3}", "\u{1F6C4}", "\u{1F6C5}", "\u26A0\uFE0F", "\u{1F6B8}", "\u26D4", "\u{1F6AB}", "\u{1F6B3}", "\u{1F6AD}", "\u{1F6AF}", "\u{1F6B1}", "\u{1F6B7}", "\u{1F4F5}", "\u{1F51E}", "\u2622\uFE0F", "\u2623\uFE0F", "\u2B06\uFE0F", "\u2197\uFE0F", "\u27A1\uFE0F", "\u2198\uFE0F", "\u2B07\uFE0F", "\u2199\uFE0F", "\u2B05\uFE0F", "\u2196\uFE0F", "\u2195\uFE0F", "\u2194\uFE0F", "\u21A9\uFE0F", "\u21AA\uFE0F", "\u2934\uFE0F", "\u2935\uFE0F", "\u{1F503}", "\u{1F504}", "\u{1F519}", "\u{1F51A}", "\u{1F51B}", "\u{1F51C}", "\u{1F51D}", "\u{1F6D0}", "\u269B\uFE0F", "\u{1F549}\uFE0F", "\u2721\uFE0F", "\u2638\uFE0F", "\u262F\uFE0F", "\u271D\uFE0F", "\u2626\uFE0F", "\u262A\uFE0F", "\u262E\uFE0F", "\u{1F54E}", "\u{1F52F}", "\u2648", "\u2649", "\u264A", "\u264B", "\u264C", "\u264D", "\u264E", "\u264F", "\u2650", "\u2651", "\u2652", "\u2653", "\u26CE", "\u{1F500}", "\u{1F501}", "\u{1F502}", "\u25B6\uFE0F", "\u23E9", "\u23ED\uFE0F", "\u23EF\uFE0F", "\u25C0\uFE0F", "\u23EA", "\u23EE\uFE0F", "\u{1F53C}", "\u23EB", "\u{1F53D}", "\u23EC", "\u23F8\uFE0F", "\u23F9\uFE0F", "\u23FA\uFE0F", "\u23CF\uFE0F", "\u{1F3A6}", "\u{1F505}", "\u{1F506}", "\u{1F4F6}", "\u{1F4F3}", "\u{1F4F4}", "\u2640\uFE0F", "\u2642\uFE0F", "\u26A7\uFE0F", "\u2716\uFE0F", "\u2795", "\u2796", "\u2797", "\u267E\uFE0F", "\u203C\uFE0F", "\u2049\uFE0F", "\u2753", "\u2754", "\u2755", "\u2757", "\u3030\uFE0F", "\u{1F4B1}", "\u{1F4B2}", "\u2695\uFE0F", "\u267B\uFE0F", "\u269C\uFE0F", "\u{1F531}", "\u{1F4DB}", "\u{1F530}", "\u2B55", "\u2705", "\u2611\uFE0F", "\u2714\uFE0F", "\u274C", "\u274E", "\u27B0", "\u27BF", "\u303D\uFE0F", "\u2733\uFE0F", "\u2734\uFE0F", "\u2747\uFE0F", "\xA9\uFE0F", "\xAE\uFE0F", "\u2122\uFE0F", "#\uFE0F\u20E3", "*\uFE0F\u20E3", "0\uFE0F\u20E3", "1\uFE0F\u20E3", "2\uFE0F\u20E3", "3\uFE0F\u20E3", "4\uFE0F\u20E3", "5\uFE0F\u20E3", "6\uFE0F\u20E3", "7\uFE0F\u20E3", "8\uFE0F\u20E3", "9\uFE0F\u20E3", "\u{1F51F}", "\u{1F520}", "\u{1F521}", "\u{1F522}", "\u{1F523}", "\u{1F524}", "\u{1F170}\uFE0F", "\u{1F18E}", "\u{1F171}\uFE0F", "\u{1F191}", "\u{1F192}", "\u{1F193}", "\u2139\uFE0F", "\u{1F194}", "\u24C2\uFE0F", "\u{1F195}", "\u{1F196}", "\u{1F17E}\uFE0F", "\u{1F197}", "\u{1F17F}\uFE0F", "\u{1F198}", "\u{1F199}", "\u{1F19A}", "\u{1F201}", "\u{1F202}\uFE0F", "\u{1F237}\uFE0F", "\u{1F236}", "\u{1F22F}", "\u{1F250}", "\u{1F239}", "\u{1F21A}", "\u{1F232}", "\u{1F251}", "\u{1F238}", "\u{1F234}", "\u{1F233}", "\u3297\uFE0F", "\u3299\uFE0F", "\u{1F23A}", "\u{1F235}", "\u{1F534}", "\u{1F7E0}", "\u{1F7E1}", "\u{1F7E2}", "\u{1F535}", "\u{1F7E3}", "\u{1F7E4}", "\u26AB", "\u26AA", "\u{1F7E5}", "\u{1F7E7}", "\u{1F7E8}", "\u{1F7E9}", "\u{1F7E6}", "\u{1F7EA}", "\u{1F7EB}", "\u2B1B", "\u2B1C", "\u25FC\uFE0F", "\u25FB\uFE0F", "\u25FE", "\u25FD", "\u25AA\uFE0F", "\u25AB\uFE0F", "\u{1F536}", "\u{1F537}", "\u{1F538}", "\u{1F539}", "\u{1F53A}", "\u{1F53B}", "\u{1F4A0}", "\u{1F518}", "\u{1F533}", "\u{1F532}"], flag: ["\u{1F3C1}", "\u{1F6A9}", "\u{1F38C}", "\u{1F3F4}", "\u{1F3F3}\uFE0F", "\u{1F3F3}\uFE0F\u200D\u{1F308}", "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F", "\u{1F3F4}\u200D\u2620\uFE0F", "\u{1F1E6}\u{1F1E8}", "\u{1F1E6}\u{1F1E9}", "\u{1F1E6}\u{1F1EA}", "\u{1F1E6}\u{1F1EB}", "\u{1F1E6}\u{1F1EC}", "\u{1F1E6}\u{1F1EE}", "\u{1F1E6}\u{1F1F1}", "\u{1F1E6}\u{1F1F2}", "\u{1F1E6}\u{1F1F4}", "\u{1F1E6}\u{1F1F6}", "\u{1F1E6}\u{1F1F7}", "\u{1F1E6}\u{1F1F8}", "\u{1F1E6}\u{1F1F9}", "\u{1F1E6}\u{1F1FA}", "\u{1F1E6}\u{1F1FC}", "\u{1F1E6}\u{1F1FD}", "\u{1F1E6}\u{1F1FF}", "\u{1F1E7}\u{1F1E6}", "\u{1F1E7}\u{1F1E7}", "\u{1F1E7}\u{1F1E9}", "\u{1F1E7}\u{1F1EA}", "\u{1F1E7}\u{1F1EB}", "\u{1F1E7}\u{1F1EC}", "\u{1F1E7}\u{1F1ED}", "\u{1F1E7}\u{1F1EE}", "\u{1F1E7}\u{1F1EF}", "\u{1F1E7}\u{1F1F1}", "\u{1F1E7}\u{1F1F2}", "\u{1F1E7}\u{1F1F3}", "\u{1F1E7}\u{1F1F4}", "\u{1F1E7}\u{1F1F6}", "\u{1F1E7}\u{1F1F7}", "\u{1F1E7}\u{1F1F8}", "\u{1F1E7}\u{1F1F9}", "\u{1F1E7}\u{1F1FB}", "\u{1F1E7}\u{1F1FC}", "\u{1F1E7}\u{1F1FE}", "\u{1F1E7}\u{1F1FF}", "\u{1F1E8}\u{1F1E6}", "\u{1F1E8}\u{1F1E8}", "\u{1F1E8}\u{1F1E9}", "\u{1F1E8}\u{1F1EB}", "\u{1F1E8}\u{1F1EC}", "\u{1F1E8}\u{1F1ED}", "\u{1F1E8}\u{1F1EE}", "\u{1F1E8}\u{1F1F0}", "\u{1F1E8}\u{1F1F1}", "\u{1F1E8}\u{1F1F2}", "\u{1F1E8}\u{1F1F3}", "\u{1F1E8}\u{1F1F4}", "\u{1F1E8}\u{1F1F5}", "\u{1F1E8}\u{1F1F7}", "\u{1F1E8}\u{1F1FA}", "\u{1F1E8}\u{1F1FB}", "\u{1F1E8}\u{1F1FC}", "\u{1F1E8}\u{1F1FD}", "\u{1F1E8}\u{1F1FE}", "\u{1F1E8}\u{1F1FF}", "\u{1F1E9}\u{1F1EA}", "\u{1F1E9}\u{1F1EC}", "\u{1F1E9}\u{1F1EF}", "\u{1F1E9}\u{1F1F0}", "\u{1F1E9}\u{1F1F2}", "\u{1F1E9}\u{1F1F4}", "\u{1F1E9}\u{1F1FF}", "\u{1F1EA}\u{1F1E6}", "\u{1F1EA}\u{1F1E8}", "\u{1F1EA}\u{1F1EA}", "\u{1F1EA}\u{1F1EC}", "\u{1F1EA}\u{1F1ED}", "\u{1F1EA}\u{1F1F7}", "\u{1F1EA}\u{1F1F8}", "\u{1F1EA}\u{1F1F9}", "\u{1F1EA}\u{1F1FA}", "\u{1F1EB}\u{1F1EE}", "\u{1F1EB}\u{1F1EF}", "\u{1F1EB}\u{1F1F0}", "\u{1F1EB}\u{1F1F2}", "\u{1F1EB}\u{1F1F4}", "\u{1F1EB}\u{1F1F7}", "\u{1F1EC}\u{1F1E6}", "\u{1F1EC}\u{1F1E7}", "\u{1F1EC}\u{1F1E9}", "\u{1F1EC}\u{1F1EA}", "\u{1F1EC}\u{1F1EB}", "\u{1F1EC}\u{1F1EC}", "\u{1F1EC}\u{1F1ED}", "\u{1F1EC}\u{1F1EE}", "\u{1F1EC}\u{1F1F1}", "\u{1F1EC}\u{1F1F2}", "\u{1F1EC}\u{1F1F3}", "\u{1F1EC}\u{1F1F5}", "\u{1F1EC}\u{1F1F6}", "\u{1F1EC}\u{1F1F7}", "\u{1F1EC}\u{1F1F8}", "\u{1F1EC}\u{1F1F9}", "\u{1F1EC}\u{1F1FA}", "\u{1F1EC}\u{1F1FC}", "\u{1F1EC}\u{1F1FE}", "\u{1F1ED}\u{1F1F0}", "\u{1F1ED}\u{1F1F2}", "\u{1F1ED}\u{1F1F3}", "\u{1F1ED}\u{1F1F7}", "\u{1F1ED}\u{1F1F9}", "\u{1F1ED}\u{1F1FA}", "\u{1F1EE}\u{1F1E8}", "\u{1F1EE}\u{1F1E9}", "\u{1F1EE}\u{1F1EA}", "\u{1F1EE}\u{1F1F1}", "\u{1F1EE}\u{1F1F2}", "\u{1F1EE}\u{1F1F3}", "\u{1F1EE}\u{1F1F4}", "\u{1F1EE}\u{1F1F6}", "\u{1F1EE}\u{1F1F7}", "\u{1F1EE}\u{1F1F8}", "\u{1F1EE}\u{1F1F9}", "\u{1F1EF}\u{1F1EA}", "\u{1F1EF}\u{1F1F2}", "\u{1F1EF}\u{1F1F4}", "\u{1F1EF}\u{1F1F5}", "\u{1F1F0}\u{1F1EA}", "\u{1F1F0}\u{1F1EC}", "\u{1F1F0}\u{1F1ED}", "\u{1F1F0}\u{1F1EE}", "\u{1F1F0}\u{1F1F2}", "\u{1F1F0}\u{1F1F3}", "\u{1F1F0}\u{1F1F5}", "\u{1F1F0}\u{1F1F7}", "\u{1F1F0}\u{1F1FC}", "\u{1F1F0}\u{1F1FE}", "\u{1F1F0}\u{1F1FF}", "\u{1F1F1}\u{1F1E6}", "\u{1F1F1}\u{1F1E7}", "\u{1F1F1}\u{1F1E8}", "\u{1F1F1}\u{1F1EE}", "\u{1F1F1}\u{1F1F0}", "\u{1F1F1}\u{1F1F7}", "\u{1F1F1}\u{1F1F8}", "\u{1F1F1}\u{1F1F9}", "\u{1F1F1}\u{1F1FA}", "\u{1F1F1}\u{1F1FB}", "\u{1F1F1}\u{1F1FE}", "\u{1F1F2}\u{1F1E6}", "\u{1F1F2}\u{1F1E8}", "\u{1F1F2}\u{1F1E9}", "\u{1F1F2}\u{1F1EA}", "\u{1F1F2}\u{1F1EB}", "\u{1F1F2}\u{1F1EC}", "\u{1F1F2}\u{1F1ED}", "\u{1F1F2}\u{1F1F0}", "\u{1F1F2}\u{1F1F1}", "\u{1F1F2}\u{1F1F2}", "\u{1F1F2}\u{1F1F3}", "\u{1F1F2}\u{1F1F4}", "\u{1F1F2}\u{1F1F5}", "\u{1F1F2}\u{1F1F6}", "\u{1F1F2}\u{1F1F7}", "\u{1F1F2}\u{1F1F8}", "\u{1F1F2}\u{1F1F9}", "\u{1F1F2}\u{1F1FA}", "\u{1F1F2}\u{1F1FB}", "\u{1F1F2}\u{1F1FC}", "\u{1F1F2}\u{1F1FD}", "\u{1F1F2}\u{1F1FE}", "\u{1F1F2}\u{1F1FF}", "\u{1F1F3}\u{1F1E6}", "\u{1F1F3}\u{1F1E8}", "\u{1F1F3}\u{1F1EA}", "\u{1F1F3}\u{1F1EB}", "\u{1F1F3}\u{1F1EC}", "\u{1F1F3}\u{1F1EE}", "\u{1F1F3}\u{1F1F1}", "\u{1F1F3}\u{1F1F4}", "\u{1F1F3}\u{1F1F5}", "\u{1F1F3}\u{1F1F7}", "\u{1F1F3}\u{1F1FA}", "\u{1F1F3}\u{1F1FF}", "\u{1F1F4}\u{1F1F2}", "\u{1F1F5}\u{1F1E6}", "\u{1F1F5}\u{1F1EA}", "\u{1F1F5}\u{1F1EB}", "\u{1F1F5}\u{1F1EC}", "\u{1F1F5}\u{1F1ED}", "\u{1F1F5}\u{1F1F0}", "\u{1F1F5}\u{1F1F1}", "\u{1F1F5}\u{1F1F2}", "\u{1F1F5}\u{1F1F3}", "\u{1F1F5}\u{1F1F7}", "\u{1F1F5}\u{1F1F8}", "\u{1F1F5}\u{1F1F9}", "\u{1F1F5}\u{1F1FC}", "\u{1F1F5}\u{1F1FE}", "\u{1F1F6}\u{1F1E6}", "\u{1F1F7}\u{1F1EA}", "\u{1F1F7}\u{1F1F4}", "\u{1F1F7}\u{1F1F8}", "\u{1F1F7}\u{1F1FA}", "\u{1F1F7}\u{1F1FC}", "\u{1F1F8}\u{1F1E6}", "\u{1F1F8}\u{1F1E7}", "\u{1F1F8}\u{1F1E8}", "\u{1F1F8}\u{1F1E9}", "\u{1F1F8}\u{1F1EA}", "\u{1F1F8}\u{1F1EC}", "\u{1F1F8}\u{1F1ED}", "\u{1F1F8}\u{1F1EE}", "\u{1F1F8}\u{1F1EF}", "\u{1F1F8}\u{1F1F0}", "\u{1F1F8}\u{1F1F1}", "\u{1F1F8}\u{1F1F2}", "\u{1F1F8}\u{1F1F3}", "\u{1F1F8}\u{1F1F4}", "\u{1F1F8}\u{1F1F7}", "\u{1F1F8}\u{1F1F8}", "\u{1F1F8}\u{1F1F9}", "\u{1F1F8}\u{1F1FB}", "\u{1F1F8}\u{1F1FD}", "\u{1F1F8}\u{1F1FE}", "\u{1F1F8}\u{1F1FF}", "\u{1F1F9}\u{1F1E6}", "\u{1F1F9}\u{1F1E8}", "\u{1F1F9}\u{1F1E9}", "\u{1F1F9}\u{1F1EB}", "\u{1F1F9}\u{1F1EC}", "\u{1F1F9}\u{1F1ED}", "\u{1F1F9}\u{1F1EF}", "\u{1F1F9}\u{1F1F0}", "\u{1F1F9}\u{1F1F1}", "\u{1F1F9}\u{1F1F2}", "\u{1F1F9}\u{1F1F3}", "\u{1F1F9}\u{1F1F4}", "\u{1F1F9}\u{1F1F7}", "\u{1F1F9}\u{1F1F9}", "\u{1F1F9}\u{1F1FB}", "\u{1F1F9}\u{1F1FC}", "\u{1F1F9}\u{1F1FF}", "\u{1F1FA}\u{1F1E6}", "\u{1F1FA}\u{1F1EC}", "\u{1F1FA}\u{1F1F2}", "\u{1F1FA}\u{1F1F3}", "\u{1F1FA}\u{1F1F8}", "\u{1F1FA}\u{1F1FE}", "\u{1F1FA}\u{1F1FF}", "\u{1F1FB}\u{1F1E6}", "\u{1F1FB}\u{1F1E8}", "\u{1F1FB}\u{1F1EA}", "\u{1F1FB}\u{1F1EC}", "\u{1F1FB}\u{1F1EE}", "\u{1F1FB}\u{1F1F3}", "\u{1F1FB}\u{1F1FA}", "\u{1F1FC}\u{1F1EB}", "\u{1F1FC}\u{1F1F8}", "\u{1F1FD}\u{1F1F0}", "\u{1F1FE}\u{1F1EA}", "\u{1F1FE}\u{1F1F9}", "\u{1F1FF}\u{1F1E6}", "\u{1F1FF}\u{1F1F2}", "\u{1F1FF}\u{1F1FC}"] };
var cr2 = { informational: [100, 101, 102, 103], success: [200, 201, 202, 203, 204, 205, 206, 207, 208, 226], redirection: [300, 301, 302, 303, 304, 305, 306, 307, 308], clientError: [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451], serverError: [500, 501, 502, 503, 504, 505, 506, 507, 508, 510, 511] };
var lr2 = ["HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "none"];
var mr2 = ['Mozilla/5.0 (compatible; MSIE {{number.int({"min":6,"max":10})}}.0; Windows NT {{helpers.arrayElement(["5.1","5.2","6.0","6.1","6.2","6.3","10.0"])}}; Trident/{{number.int({"min":4,"max":7})}}.0)', 'Mozilla/5.0 (Windows NT {{helpers.arrayElement(["5.1","5.2","6.0","6.1","6.2","6.3","10.0"])}}; Win64; x64) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Chrome/{{number.int({"min":55,"max":131})}}.{{system.semver}} Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}} Edg/{{number.int({"min":110,"max":131})}}.{{system.semver}}', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Version/16.1 Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}}', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:{{number.int({"min":75, "max":133})}}.0) Gecko/20100101 Firefox/{{number.int({"min":75, "max":133})}}.0', 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_15_7) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Chrome/{{number.int({"min":55,"max":131})}}.{{system.semver}} Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}}', 'Mozilla/5.0 (X11; Linux x86_64; rv:{{number.int({"min":75,"max":133})}}.0) Gecko/20100101 Firefox/{{number.int({"min":75,"max":133})}}.0', "FakerBot/{{system.semver}}", "Googlebot/2.1 (+http://www.google.com/bot.html)", 'Mozilla/5.0 (iPhone; CPU iPhone OS {{number.int({"min":10,"max":18})}}_{{number.int({"min":0,"max":4})}} like Mac OS X) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Version/{{number.int({"min":10,"max":18})}}_{{number.int({"min":0,"max":4})}} Mobile/15E148 Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}', 'Mozilla/5.0 (Linux; Android {{number.int({"min":5,"max":13})}}; {{helpers.arrayElement(["SM-G998U","SM-G998B","SM-G998N","SM-G998P","SM-T800"])}}) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Chrome/{{number.int({"min":55,"max":131})}}.{{system.semver}} Mobile Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}'];
var tt = { emoji: sr2, http_status_code: cr2, jwt_algorithm: lr2, user_agent_pattern: mr2 };
var ur2 = tt;
var pr2 = [{ alpha2: "AD", alpha3: "AND", numeric: "020" }, { alpha2: "AE", alpha3: "ARE", numeric: "784" }, { alpha2: "AF", alpha3: "AFG", numeric: "004" }, { alpha2: "AG", alpha3: "ATG", numeric: "028" }, { alpha2: "AI", alpha3: "AIA", numeric: "660" }, { alpha2: "AL", alpha3: "ALB", numeric: "008" }, { alpha2: "AM", alpha3: "ARM", numeric: "051" }, { alpha2: "AO", alpha3: "AGO", numeric: "024" }, { alpha2: "AQ", alpha3: "ATA", numeric: "010" }, { alpha2: "AR", alpha3: "ARG", numeric: "032" }, { alpha2: "AS", alpha3: "ASM", numeric: "016" }, { alpha2: "AT", alpha3: "AUT", numeric: "040" }, { alpha2: "AU", alpha3: "AUS", numeric: "036" }, { alpha2: "AW", alpha3: "ABW", numeric: "533" }, { alpha2: "AX", alpha3: "ALA", numeric: "248" }, { alpha2: "AZ", alpha3: "AZE", numeric: "031" }, { alpha2: "BA", alpha3: "BIH", numeric: "070" }, { alpha2: "BB", alpha3: "BRB", numeric: "052" }, { alpha2: "BD", alpha3: "BGD", numeric: "050" }, { alpha2: "BE", alpha3: "BEL", numeric: "056" }, { alpha2: "BF", alpha3: "BFA", numeric: "854" }, { alpha2: "BG", alpha3: "BGR", numeric: "100" }, { alpha2: "BH", alpha3: "BHR", numeric: "048" }, { alpha2: "BI", alpha3: "BDI", numeric: "108" }, { alpha2: "BJ", alpha3: "BEN", numeric: "204" }, { alpha2: "BL", alpha3: "BLM", numeric: "652" }, { alpha2: "BM", alpha3: "BMU", numeric: "060" }, { alpha2: "BN", alpha3: "BRN", numeric: "096" }, { alpha2: "BO", alpha3: "BOL", numeric: "068" }, { alpha2: "BQ", alpha3: "BES", numeric: "535" }, { alpha2: "BR", alpha3: "BRA", numeric: "076" }, { alpha2: "BS", alpha3: "BHS", numeric: "044" }, { alpha2: "BT", alpha3: "BTN", numeric: "064" }, { alpha2: "BV", alpha3: "BVT", numeric: "074" }, { alpha2: "BW", alpha3: "BWA", numeric: "072" }, { alpha2: "BY", alpha3: "BLR", numeric: "112" }, { alpha2: "BZ", alpha3: "BLZ", numeric: "084" }, { alpha2: "CA", alpha3: "CAN", numeric: "124" }, { alpha2: "CC", alpha3: "CCK", numeric: "166" }, { alpha2: "CD", alpha3: "COD", numeric: "180" }, { alpha2: "CF", alpha3: "CAF", numeric: "140" }, { alpha2: "CG", alpha3: "COG", numeric: "178" }, { alpha2: "CH", alpha3: "CHE", numeric: "756" }, { alpha2: "CI", alpha3: "CIV", numeric: "384" }, { alpha2: "CK", alpha3: "COK", numeric: "184" }, { alpha2: "CL", alpha3: "CHL", numeric: "152" }, { alpha2: "CM", alpha3: "CMR", numeric: "120" }, { alpha2: "CN", alpha3: "CHN", numeric: "156" }, { alpha2: "CO", alpha3: "COL", numeric: "170" }, { alpha2: "CR", alpha3: "CRI", numeric: "188" }, { alpha2: "CU", alpha3: "CUB", numeric: "192" }, { alpha2: "CV", alpha3: "CPV", numeric: "132" }, { alpha2: "CW", alpha3: "CUW", numeric: "531" }, { alpha2: "CX", alpha3: "CXR", numeric: "162" }, { alpha2: "CY", alpha3: "CYP", numeric: "196" }, { alpha2: "CZ", alpha3: "CZE", numeric: "203" }, { alpha2: "DE", alpha3: "DEU", numeric: "276" }, { alpha2: "DJ", alpha3: "DJI", numeric: "262" }, { alpha2: "DK", alpha3: "DNK", numeric: "208" }, { alpha2: "DM", alpha3: "DMA", numeric: "212" }, { alpha2: "DO", alpha3: "DOM", numeric: "214" }, { alpha2: "DZ", alpha3: "DZA", numeric: "012" }, { alpha2: "EC", alpha3: "ECU", numeric: "218" }, { alpha2: "EE", alpha3: "EST", numeric: "233" }, { alpha2: "EG", alpha3: "EGY", numeric: "818" }, { alpha2: "EH", alpha3: "ESH", numeric: "732" }, { alpha2: "ER", alpha3: "ERI", numeric: "232" }, { alpha2: "ES", alpha3: "ESP", numeric: "724" }, { alpha2: "ET", alpha3: "ETH", numeric: "231" }, { alpha2: "FI", alpha3: "FIN", numeric: "246" }, { alpha2: "FJ", alpha3: "FJI", numeric: "242" }, { alpha2: "FK", alpha3: "FLK", numeric: "238" }, { alpha2: "FM", alpha3: "FSM", numeric: "583" }, { alpha2: "FO", alpha3: "FRO", numeric: "234" }, { alpha2: "FR", alpha3: "FRA", numeric: "250" }, { alpha2: "GA", alpha3: "GAB", numeric: "266" }, { alpha2: "GB", alpha3: "GBR", numeric: "826" }, { alpha2: "GD", alpha3: "GRD", numeric: "308" }, { alpha2: "GE", alpha3: "GEO", numeric: "268" }, { alpha2: "GF", alpha3: "GUF", numeric: "254" }, { alpha2: "GG", alpha3: "GGY", numeric: "831" }, { alpha2: "GH", alpha3: "GHA", numeric: "288" }, { alpha2: "GI", alpha3: "GIB", numeric: "292" }, { alpha2: "GL", alpha3: "GRL", numeric: "304" }, { alpha2: "GM", alpha3: "GMB", numeric: "270" }, { alpha2: "GN", alpha3: "GIN", numeric: "324" }, { alpha2: "GP", alpha3: "GLP", numeric: "312" }, { alpha2: "GQ", alpha3: "GNQ", numeric: "226" }, { alpha2: "GR", alpha3: "GRC", numeric: "300" }, { alpha2: "GS", alpha3: "SGS", numeric: "239" }, { alpha2: "GT", alpha3: "GTM", numeric: "320" }, { alpha2: "GU", alpha3: "GUM", numeric: "316" }, { alpha2: "GW", alpha3: "GNB", numeric: "624" }, { alpha2: "GY", alpha3: "GUY", numeric: "328" }, { alpha2: "HK", alpha3: "HKG", numeric: "344" }, { alpha2: "HM", alpha3: "HMD", numeric: "334" }, { alpha2: "HN", alpha3: "HND", numeric: "340" }, { alpha2: "HR", alpha3: "HRV", numeric: "191" }, { alpha2: "HT", alpha3: "HTI", numeric: "332" }, { alpha2: "HU", alpha3: "HUN", numeric: "348" }, { alpha2: "ID", alpha3: "IDN", numeric: "360" }, { alpha2: "IE", alpha3: "IRL", numeric: "372" }, { alpha2: "IL", alpha3: "ISR", numeric: "376" }, { alpha2: "IM", alpha3: "IMN", numeric: "833" }, { alpha2: "IN", alpha3: "IND", numeric: "356" }, { alpha2: "IO", alpha3: "IOT", numeric: "086" }, { alpha2: "IQ", alpha3: "IRQ", numeric: "368" }, { alpha2: "IR", alpha3: "IRN", numeric: "364" }, { alpha2: "IS", alpha3: "ISL", numeric: "352" }, { alpha2: "IT", alpha3: "ITA", numeric: "380" }, { alpha2: "JE", alpha3: "JEY", numeric: "832" }, { alpha2: "JM", alpha3: "JAM", numeric: "388" }, { alpha2: "JO", alpha3: "JOR", numeric: "400" }, { alpha2: "JP", alpha3: "JPN", numeric: "392" }, { alpha2: "KE", alpha3: "KEN", numeric: "404" }, { alpha2: "KG", alpha3: "KGZ", numeric: "417" }, { alpha2: "KH", alpha3: "KHM", numeric: "116" }, { alpha2: "KI", alpha3: "KIR", numeric: "296" }, { alpha2: "KM", alpha3: "COM", numeric: "174" }, { alpha2: "KN", alpha3: "KNA", numeric: "659" }, { alpha2: "KP", alpha3: "PRK", numeric: "408" }, { alpha2: "KR", alpha3: "KOR", numeric: "410" }, { alpha2: "KW", alpha3: "KWT", numeric: "414" }, { alpha2: "KY", alpha3: "CYM", numeric: "136" }, { alpha2: "KZ", alpha3: "KAZ", numeric: "398" }, { alpha2: "LA", alpha3: "LAO", numeric: "418" }, { alpha2: "LB", alpha3: "LBN", numeric: "422" }, { alpha2: "LC", alpha3: "LCA", numeric: "662" }, { alpha2: "LI", alpha3: "LIE", numeric: "438" }, { alpha2: "LK", alpha3: "LKA", numeric: "144" }, { alpha2: "LR", alpha3: "LBR", numeric: "430" }, { alpha2: "LS", alpha3: "LSO", numeric: "426" }, { alpha2: "LT", alpha3: "LTU", numeric: "440" }, { alpha2: "LU", alpha3: "LUX", numeric: "442" }, { alpha2: "LV", alpha3: "LVA", numeric: "428" }, { alpha2: "LY", alpha3: "LBY", numeric: "434" }, { alpha2: "MA", alpha3: "MAR", numeric: "504" }, { alpha2: "MC", alpha3: "MCO", numeric: "492" }, { alpha2: "MD", alpha3: "MDA", numeric: "498" }, { alpha2: "ME", alpha3: "MNE", numeric: "499" }, { alpha2: "MF", alpha3: "MAF", numeric: "663" }, { alpha2: "MG", alpha3: "MDG", numeric: "450" }, { alpha2: "MH", alpha3: "MHL", numeric: "584" }, { alpha2: "MK", alpha3: "MKD", numeric: "807" }, { alpha2: "ML", alpha3: "MLI", numeric: "466" }, { alpha2: "MM", alpha3: "MMR", numeric: "104" }, { alpha2: "MN", alpha3: "MNG", numeric: "496" }, { alpha2: "MO", alpha3: "MAC", numeric: "446" }, { alpha2: "MP", alpha3: "MNP", numeric: "580" }, { alpha2: "MQ", alpha3: "MTQ", numeric: "474" }, { alpha2: "MR", alpha3: "MRT", numeric: "478" }, { alpha2: "MS", alpha3: "MSR", numeric: "500" }, { alpha2: "MT", alpha3: "MLT", numeric: "470" }, { alpha2: "MU", alpha3: "MUS", numeric: "480" }, { alpha2: "MV", alpha3: "MDV", numeric: "462" }, { alpha2: "MW", alpha3: "MWI", numeric: "454" }, { alpha2: "MX", alpha3: "MEX", numeric: "484" }, { alpha2: "MY", alpha3: "MYS", numeric: "458" }, { alpha2: "MZ", alpha3: "MOZ", numeric: "508" }, { alpha2: "NA", alpha3: "NAM", numeric: "516" }, { alpha2: "NC", alpha3: "NCL", numeric: "540" }, { alpha2: "NE", alpha3: "NER", numeric: "562" }, { alpha2: "NF", alpha3: "NFK", numeric: "574" }, { alpha2: "NG", alpha3: "NGA", numeric: "566" }, { alpha2: "NI", alpha3: "NIC", numeric: "558" }, { alpha2: "NL", alpha3: "NLD", numeric: "528" }, { alpha2: "NO", alpha3: "NOR", numeric: "578" }, { alpha2: "NP", alpha3: "NPL", numeric: "524" }, { alpha2: "NR", alpha3: "NRU", numeric: "520" }, { alpha2: "NU", alpha3: "NIU", numeric: "570" }, { alpha2: "NZ", alpha3: "NZL", numeric: "554" }, { alpha2: "OM", alpha3: "OMN", numeric: "512" }, { alpha2: "PA", alpha3: "PAN", numeric: "591" }, { alpha2: "PE", alpha3: "PER", numeric: "604" }, { alpha2: "PF", alpha3: "PYF", numeric: "258" }, { alpha2: "PG", alpha3: "PNG", numeric: "598" }, { alpha2: "PH", alpha3: "PHL", numeric: "608" }, { alpha2: "PK", alpha3: "PAK", numeric: "586" }, { alpha2: "PL", alpha3: "POL", numeric: "616" }, { alpha2: "PM", alpha3: "SPM", numeric: "666" }, { alpha2: "PN", alpha3: "PCN", numeric: "612" }, { alpha2: "PR", alpha3: "PRI", numeric: "630" }, { alpha2: "PS", alpha3: "PSE", numeric: "275" }, { alpha2: "PT", alpha3: "PRT", numeric: "620" }, { alpha2: "PW", alpha3: "PLW", numeric: "585" }, { alpha2: "PY", alpha3: "PRY", numeric: "600" }, { alpha2: "QA", alpha3: "QAT", numeric: "634" }, { alpha2: "RE", alpha3: "REU", numeric: "638" }, { alpha2: "RO", alpha3: "ROU", numeric: "642" }, { alpha2: "RS", alpha3: "SRB", numeric: "688" }, { alpha2: "RU", alpha3: "RUS", numeric: "643" }, { alpha2: "RW", alpha3: "RWA", numeric: "646" }, { alpha2: "SA", alpha3: "SAU", numeric: "682" }, { alpha2: "SB", alpha3: "SLB", numeric: "090" }, { alpha2: "SC", alpha3: "SYC", numeric: "690" }, { alpha2: "SD", alpha3: "SDN", numeric: "729" }, { alpha2: "SE", alpha3: "SWE", numeric: "752" }, { alpha2: "SG", alpha3: "SGP", numeric: "702" }, { alpha2: "SH", alpha3: "SHN", numeric: "654" }, { alpha2: "SI", alpha3: "SVN", numeric: "705" }, { alpha2: "SJ", alpha3: "SJM", numeric: "744" }, { alpha2: "SK", alpha3: "SVK", numeric: "703" }, { alpha2: "SL", alpha3: "SLE", numeric: "694" }, { alpha2: "SM", alpha3: "SMR", numeric: "674" }, { alpha2: "SN", alpha3: "SEN", numeric: "686" }, { alpha2: "SO", alpha3: "SOM", numeric: "706" }, { alpha2: "SR", alpha3: "SUR", numeric: "740" }, { alpha2: "SS", alpha3: "SSD", numeric: "728" }, { alpha2: "ST", alpha3: "STP", numeric: "678" }, { alpha2: "SV", alpha3: "SLV", numeric: "222" }, { alpha2: "SX", alpha3: "SXM", numeric: "534" }, { alpha2: "SY", alpha3: "SYR", numeric: "760" }, { alpha2: "SZ", alpha3: "SWZ", numeric: "748" }, { alpha2: "TC", alpha3: "TCA", numeric: "796" }, { alpha2: "TD", alpha3: "TCD", numeric: "148" }, { alpha2: "TF", alpha3: "ATF", numeric: "260" }, { alpha2: "TG", alpha3: "TGO", numeric: "768" }, { alpha2: "TH", alpha3: "THA", numeric: "764" }, { alpha2: "TJ", alpha3: "TJK", numeric: "762" }, { alpha2: "TK", alpha3: "TKL", numeric: "772" }, { alpha2: "TL", alpha3: "TLS", numeric: "626" }, { alpha2: "TM", alpha3: "TKM", numeric: "795" }, { alpha2: "TN", alpha3: "TUN", numeric: "788" }, { alpha2: "TO", alpha3: "TON", numeric: "776" }, { alpha2: "TR", alpha3: "TUR", numeric: "792" }, { alpha2: "TT", alpha3: "TTO", numeric: "780" }, { alpha2: "TV", alpha3: "TUV", numeric: "798" }, { alpha2: "TW", alpha3: "TWN", numeric: "158" }, { alpha2: "TZ", alpha3: "TZA", numeric: "834" }, { alpha2: "UA", alpha3: "UKR", numeric: "804" }, { alpha2: "UG", alpha3: "UGA", numeric: "800" }, { alpha2: "UM", alpha3: "UMI", numeric: "581" }, { alpha2: "US", alpha3: "USA", numeric: "840" }, { alpha2: "UY", alpha3: "URY", numeric: "858" }, { alpha2: "UZ", alpha3: "UZB", numeric: "860" }, { alpha2: "VA", alpha3: "VAT", numeric: "336" }, { alpha2: "VC", alpha3: "VCT", numeric: "670" }, { alpha2: "VE", alpha3: "VEN", numeric: "862" }, { alpha2: "VG", alpha3: "VGB", numeric: "092" }, { alpha2: "VI", alpha3: "VIR", numeric: "850" }, { alpha2: "VN", alpha3: "VNM", numeric: "704" }, { alpha2: "VU", alpha3: "VUT", numeric: "548" }, { alpha2: "WF", alpha3: "WLF", numeric: "876" }, { alpha2: "WS", alpha3: "WSM", numeric: "882" }, { alpha2: "YE", alpha3: "YEM", numeric: "887" }, { alpha2: "YT", alpha3: "MYT", numeric: "175" }, { alpha2: "ZA", alpha3: "ZAF", numeric: "710" }, { alpha2: "ZM", alpha3: "ZMB", numeric: "894" }, { alpha2: "ZW", alpha3: "ZWE", numeric: "716" }];
var at2 = { country_code: pr2, time_zone: I2 };
var hr2 = at2;
var nt = { title: "Base", code: "base" };
var fr2 = nt;
var br2 = ["/Applications", "/bin", "/boot", "/boot/defaults", "/dev", "/etc", "/etc/defaults", "/etc/mail", "/etc/namedb", "/etc/periodic", "/etc/ppp", "/home", "/home/user", "/home/user/dir", "/lib", "/Library", "/lost+found", "/media", "/mnt", "/net", "/Network", "/opt", "/opt/bin", "/opt/include", "/opt/lib", "/opt/sbin", "/opt/share", "/private", "/private/tmp", "/private/var", "/proc", "/rescue", "/root", "/sbin", "/selinux", "/srv", "/sys", "/System", "/tmp", "/Users", "/usr", "/usr/X11R6", "/usr/bin", "/usr/include", "/usr/lib", "/usr/libdata", "/usr/libexec", "/usr/local/bin", "/usr/local/src", "/usr/obj", "/usr/ports", "/usr/sbin", "/usr/share", "/usr/src", "/var", "/var/log", "/var/mail", "/var/spool", "/var/tmp", "/var/yp"];
var dr2 = { "application/epub+zip": { extensions: ["epub"] }, "application/gzip": { extensions: ["gz"] }, "application/java-archive": { extensions: ["jar", "war", "ear"] }, "application/json": { extensions: ["json", "map"] }, "application/ld+json": { extensions: ["jsonld"] }, "application/msword": { extensions: ["doc", "dot"] }, "application/octet-stream": { extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] }, "application/ogg": { extensions: ["ogx"] }, "application/pdf": { extensions: ["pdf"] }, "application/rtf": { extensions: ["rtf"] }, "application/vnd.amazon.ebook": { extensions: ["azw"] }, "application/vnd.apple.installer+xml": { extensions: ["mpkg"] }, "application/vnd.mozilla.xul+xml": { extensions: ["xul"] }, "application/vnd.ms-excel": { extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] }, "application/vnd.ms-fontobject": { extensions: ["eot"] }, "application/vnd.ms-powerpoint": { extensions: ["ppt", "pps", "pot"] }, "application/vnd.oasis.opendocument.presentation": { extensions: ["odp"] }, "application/vnd.oasis.opendocument.spreadsheet": { extensions: ["ods"] }, "application/vnd.oasis.opendocument.text": { extensions: ["odt"] }, "application/vnd.openxmlformats-officedocument.presentationml.presentation": { extensions: ["pptx"] }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { extensions: ["xlsx"] }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { extensions: ["docx"] }, "application/vnd.rar": { extensions: ["rar"] }, "application/vnd.visio": { extensions: ["vsd", "vst", "vss", "vsw"] }, "application/x-7z-compressed": { extensions: ["7z"] }, "application/x-abiword": { extensions: ["abw"] }, "application/x-bzip": { extensions: ["bz"] }, "application/x-bzip2": { extensions: ["bz2", "boz"] }, "application/x-csh": { extensions: ["csh"] }, "application/x-freearc": { extensions: ["arc"] }, "application/x-httpd-php": { extensions: ["php"] }, "application/x-sh": { extensions: ["sh"] }, "application/x-tar": { extensions: ["tar"] }, "application/xhtml+xml": { extensions: ["xhtml", "xht"] }, "application/xml": { extensions: ["xml", "xsl", "xsd", "rng"] }, "application/zip": { extensions: ["zip"] }, "audio/3gpp": { extensions: ["3gpp"] }, "audio/3gpp2": { extensions: ["3g2"] }, "audio/aac": { extensions: ["aac"] }, "audio/midi": { extensions: ["mid", "midi", "kar", "rmi"] }, "audio/mpeg": { extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] }, "audio/ogg": { extensions: ["oga", "ogg", "spx", "opus"] }, "audio/opus": { extensions: ["opus"] }, "audio/wav": { extensions: ["wav"] }, "audio/webm": { extensions: ["weba"] }, "font/otf": { extensions: ["otf"] }, "font/ttf": { extensions: ["ttf"] }, "font/woff": { extensions: ["woff"] }, "font/woff2": { extensions: ["woff2"] }, "image/avif": { extensions: ["avif"] }, "image/bmp": { extensions: ["bmp"] }, "image/gif": { extensions: ["gif"] }, "image/jpeg": { extensions: ["jpeg", "jpg", "jpe"] }, "image/png": { extensions: ["png"] }, "image/svg+xml": { extensions: ["svg", "svgz"] }, "image/tiff": { extensions: ["tif", "tiff"] }, "image/vnd.microsoft.icon": { extensions: ["ico"] }, "image/webp": { extensions: ["webp"] }, "text/calendar": { extensions: ["ics", "ifb"] }, "text/css": { extensions: ["css"] }, "text/csv": { extensions: ["csv"] }, "text/html": { extensions: ["html", "htm", "shtml"] }, "text/javascript": { extensions: ["js", "mjs"] }, "text/plain": { extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"] }, "video/3gpp": { extensions: ["3gp", "3gpp"] }, "video/3gpp2": { extensions: ["3g2"] }, "video/mp2t": { extensions: ["ts"] }, "video/mp4": { extensions: ["mp4", "mp4v", "mpg4"] }, "video/mpeg": { extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"] }, "video/ogg": { extensions: ["ogv"] }, "video/webm": { extensions: ["webm"] }, "video/x-msvideo": { extensions: ["avi"] } };
var it = { directory_path: br2, mime_type: dr2 };
var gr2 = it;
var ot = { color: qe2, database: ar2, date: nr2, hacker: or2, internet: ur2, location: hr2, metadata: fr2, system: gr2 };
var Fi = ot;

// ../../node_modules/@faker-js/faker/dist/chunk-IHAWQA3S.js
var f2 = new Xe2({ locale: [ys, Fi] });

// src/templating/faker-functions.ts
var fakerFunctions = {
  guid: () => f2.string.uuid(),
  timestamp: () => f2.date.anytime().getTime().toString(),
  isoTimestamp: () => f2.date.anytime().toISOString(),
  randomUUID: () => f2.string.uuid(),
  randomAlphaNumeric: () => f2.string.alphanumeric(),
  randomBoolean: () => f2.datatype.boolean(),
  randomInt: () => f2.number.int(),
  randomColor: () => f2.color.human(),
  randomHexColor: () => f2.internet.color(),
  randomAbbreviation: () => f2.hacker.abbreviation(),
  randomIP: () => f2.internet.ip(),
  randomIPV6: () => f2.internet.ipv6(),
  randomMACAddress: () => f2.internet.mac(),
  randomPassword: () => f2.internet.password(),
  randomLocale: () => f2.location.countryCode(),
  randomUserAgent: () => f2.internet.userAgent(),
  randomProtocol: () => f2.internet.protocol(),
  randomSemver: () => f2.system.semver(),
  randomFirstName: () => f2.person.firstName(),
  randomLastName: () => f2.person.lastName(),
  randomFullName: () => f2.person.fullName(),
  randomNamePrefix: () => f2.person.prefix(),
  randomNameSuffix: () => f2.person.suffix(),
  randomJobArea: () => f2.person.jobArea(),
  randomJobDescriptor: () => f2.person.jobDescriptor(),
  randomJobTitle: () => f2.person.jobTitle(),
  randomJobType: () => f2.person.jobType(),
  randomPhoneNumber: () => f2.phone.number(),
  randomPhoneNumberExt: () => f2.phone.number(),
  randomCity: () => f2.location.city(),
  randomStreetName: () => f2.location.street(),
  randomStreetAddress: () => f2.location.streetAddress(),
  randomCountry: () => f2.location.country(),
  randomCountryCode: () => f2.location.countryCode(),
  randomLatitude: () => f2.location.latitude(),
  randomLongitude: () => f2.location.longitude(),
  randomAvatarImage: () => f2.image.avatar(),
  randomImageUrl: () => f2.image.url(),
  randomAbstractImage: () => f2.image.urlLoremFlickr({ category: "abstract" }),
  randomAnimalsImage: () => f2.image.urlLoremFlickr({ category: "animals" }),
  randomBusinessImage: () => f2.image.urlLoremFlickr({ category: "business" }),
  randomCatsImage: () => f2.image.urlLoremFlickr({ category: "cats" }),
  randomCityImage: () => f2.image.urlLoremFlickr({ category: "city" }),
  randomFoodImage: () => f2.image.urlLoremFlickr({ category: "food" }),
  randomNightlifeImage: () => f2.image.urlLoremFlickr({ category: "nightlife" }),
  randomFashionImage: () => f2.image.urlLoremFlickr({ category: "fashion" }),
  randomPeopleImage: () => f2.image.urlLoremFlickr({ category: "people" }),
  randomNatureImage: () => f2.image.urlLoremFlickr({ category: "nature" }),
  randomSportsImage: () => f2.image.urlLoremFlickr({ category: "sports" }),
  randomTransportImage: () => f2.image.urlLoremFlickr({ category: "transport" }),
  randomImageDataUri: () => f2.image.dataUri(),
  randomBankAccount: () => f2.finance.accountNumber(),
  randomBankAccountName: () => f2.finance.accountName(),
  randomCreditCardMask: () => f2.finance.maskedNumber(),
  randomBankAccountBic: () => f2.finance.bic(),
  randomBankAccountIban: () => f2.finance.iban(),
  randomTransactionType: () => f2.finance.transactionType(),
  randomCurrencyCode: () => f2.finance.currencyCode(),
  randomCurrencyName: () => f2.finance.currencyName(),
  randomCurrencySymbol: () => f2.finance.currencySymbol(),
  randomBitcoin: () => f2.finance.bitcoinAddress(),
  randomCompanyName: () => f2.company.name(),
  randomCompanySuffix: () => f2.company.name(),
  randomBs: () => f2.company.buzzPhrase(),
  randomBsAdjective: () => f2.company.buzzAdjective(),
  randomBsBuzz: () => f2.company.buzzVerb(),
  randomBsNoun: () => f2.company.buzzNoun(),
  randomCatchPhrase: () => f2.company.catchPhrase(),
  randomCatchPhraseAdjective: () => f2.company.catchPhraseAdjective(),
  randomCatchPhraseDescriptor: () => f2.company.catchPhraseDescriptor(),
  randomCatchPhraseNoun: () => f2.company.catchPhraseNoun(),
  randomDatabaseColumn: () => f2.database.column(),
  randomDatabaseType: () => f2.database.type(),
  randomDatabaseCollation: () => f2.database.collation(),
  randomDatabaseEngine: () => f2.database.engine(),
  randomDateFuture: () => f2.date.future().toISOString(),
  randomDatePast: () => f2.date.past().toISOString(),
  randomDateRecent: () => f2.date.recent().toISOString(),
  randomWeekday: () => f2.date.weekday(),
  randomMonth: () => f2.date.month(),
  randomDomainName: () => f2.internet.domainName(),
  randomDomainSuffix: () => f2.internet.domainSuffix(),
  randomDomainWord: () => f2.internet.domainWord(),
  randomEmail: () => f2.internet.email(),
  randomExampleEmail: () => f2.internet.exampleEmail(),
  randomUserName: () => f2.internet.userName(),
  randomUrl: () => f2.internet.url(),
  randomFileName: () => f2.system.fileName(),
  randomFileType: () => f2.system.fileType(),
  randomFileExt: () => f2.system.fileExt(),
  randomCommonFileName: () => f2.system.commonFileName(),
  randomCommonFileType: () => f2.system.commonFileType(),
  randomCommonFileExt: () => f2.system.commonFileExt(),
  randomFilePath: () => f2.system.filePath(),
  randomDirectoryPath: () => f2.system.directoryPath(),
  randomMimeType: () => f2.system.mimeType(),
  randomPrice: () => f2.commerce.price(),
  randomProduct: () => f2.commerce.product(),
  randomProductAdjective: () => f2.commerce.productAdjective(),
  randomProductMaterial: () => f2.commerce.productMaterial(),
  randomProductName: () => f2.commerce.productName(),
  randomDepartment: () => f2.commerce.department(),
  randomNoun: () => f2.hacker.noun(),
  randomVerb: () => f2.hacker.verb(),
  randomIngverb: () => f2.hacker.ingverb(),
  randomAdjective: () => f2.hacker.adjective(),
  randomWord: () => f2.hacker.noun(),
  randomWords: () => f2.lorem.words(),
  randomPhrase: () => f2.hacker.phrase(),
  randomLoremWord: () => f2.lorem.word(),
  randomLoremWords: () => f2.lorem.words(),
  randomLoremSentence: () => f2.lorem.sentence(),
  randomLoremSentences: () => f2.lorem.sentences(),
  randomLoremParagraph: () => f2.lorem.paragraph(),
  randomLoremParagraphs: () => f2.lorem.paragraphs(),
  randomLoremText: () => f2.lorem.text(),
  randomLoremSlug: () => f2.lorem.slug(),
  randomLoremLines: () => f2.lorem.lines()
};

// ../insomnia-scripting-environment/src/objects/interpolator.ts
var import_nunjucks = __toESM(require_nunjucks());
var Interpolator = class {
  engine;
  constructor(config2) {
    this.engine = import_nunjucks.default.configure(config2);
  }
  render = (template2, context) => {
    return this.engine.renderString(this.renderWithFaker(template2), context);
  };
  renderWithFaker = (template2) => {
    const segments = template2.split("}}");
    if (segments.length === 1) {
      return template2;
    }
    const translatedSegments = segments.map((segment) => {
      const tagStart = segment.lastIndexOf("{{");
      if (tagStart < 0) {
        return segment;
      }
      const tagName = segment.slice(tagStart + 2).trim();
      if (!tagName.startsWith("$")) {
        return segment + "}}";
      }
      const funcName = tagName.slice(1);
      if (!fakerFunctions[funcName]) {
        throw new Error(`replaceIn: no faker function is found: ${funcName}`);
      }
      const generated = fakerFunctions[funcName]();
      return segment.slice(0, tagStart) + generated;
    });
    return translatedSegments.join("");
  };
};
var interpolator = new Interpolator({
  autoescape: false,
  // Don't escape HTML
  throwOnUndefined: true,
  // Strict mode
  tags: {
    blockStart: "{%",
    blockEnd: "%}",
    variableStart: "{{",
    variableEnd: "}}",
    commentStart: "{#",
    commentEnd: "#}"
  }
});
function getInterpolator() {
  return interpolator;
}

// ../insomnia-scripting-environment/src/objects/properties.ts
var unsupportedError = (featureName, alternative) => {
  const message = `${featureName} is not supported yet` + (alternative ? `, please use ${alternative} instead temporarily.` : "");
  return new Error(message);
};
var PropertyBase = class {
  _kind = "PropertyBase";
  _parent = void 0;
  description;
  constructor(description) {
    this.description = description;
  }
  static propertyIsMeta(_value, key) {
    return key && key.startsWith("_");
  }
  static propertyUnprefixMeta(_value, key) {
    return key.startsWith("_") ? key.slice(1) : key;
  }
  // TODO: temporarily disable this
  // static toJSON(obj: { toJSON: () => string }) {
  //     return obj.toJSON();
  // }
  meta() {
    return {};
  }
  parent() {
    return this._parent;
  }
  forEachParent(_options, iterator) {
    const currentParent = this.parent();
    if (!currentParent) {
      return;
    }
    const queue = [currentParent];
    const parents = [];
    while (queue.length > 0) {
      const ancestor = queue.shift();
      if (!ancestor) {
        continue;
      }
      const cloned = (0, import_clone5.default)(ancestor);
      const keepIterating = iterator(cloned);
      parents.push(cloned);
      if (!keepIterating) {
        break;
      }
      const olderAncestor = ancestor.parent();
      if (olderAncestor) {
        queue.push(olderAncestor);
      }
    }
    return parents;
  }
  findInParents(property2, customizer) {
    const currentParent = this.parent();
    if (!currentParent) {
      return;
    }
    const queue = [currentParent];
    while (queue.length > 0) {
      const ancestor = queue.shift();
      if (!ancestor) {
        continue;
      }
      const cloned = (0, import_clone5.default)(ancestor);
      const hasProperty = Object.keys(cloned.meta()).includes(property2);
      if (!hasProperty) {
      } else {
        if (customizer) {
          if (customizer(cloned)) {
            return cloned;
          }
        } else {
          return cloned;
        }
      }
      const olderAncestor = ancestor.parent();
      if (olderAncestor) {
        queue.push(olderAncestor);
      }
    }
    return void 0;
  }
  toJSON() {
    const entriesToExport = Object.entries(this).filter(
      (kv) => typeof kv[1] !== "function" && kv[1] !== void 0 && kv[0] !== "_kind"
    );
    return Object.fromEntries(entriesToExport);
  }
  toObject() {
    return this.toJSON();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};
var Property = class extends PropertyBase {
  id;
  name;
  disabled;
  // TODO: parent property will be introduced when collection manipulation is supported
  constructor(id, name, disabled, info) {
    super();
    this._kind = "Property";
    this.id = info?.id || id || "";
    this.name = info?.name || name || "";
    this.disabled = disabled || false;
  }
  static _index = "id";
  static replaceSubstitutions(content, ...variables) {
    if (!Array.isArray(variables) || typeof content !== "string") {
      throw new Error(
        "replaceSubstitutions: the first param's type is not string or other parameters are not an array"
      );
    }
    let context = {};
    variables.reverse().forEach((variable) => context = { ...context, ...variable });
    return getInterpolator().render(content, context);
  }
  static replaceSubstitutionsIn(obj, ...variables) {
    if (!Array.isArray(variables) || typeof obj !== "object") {
      throw new Error(
        "replaceSubstitutions: the first param's type is not object or other parameters are not an array"
      );
    }
    try {
      const content = JSON.stringify(obj);
      let context = {};
      variables.reverse().forEach((variable) => {
        context = { ...context, ...variable };
      });
      const rendered = getInterpolator().render(content, context);
      return JSON.parse(rendered);
    } catch (e2) {
      throw new Error(`replaceSubstitutionsIn: ${e2.toString()}`);
    }
  }
  describe(content, typeName) {
    this._kind = typeName;
    this.description = content;
  }
};
var PropertyList = class {
  constructor(typeClass, parent, populate) {
    this.typeClass = typeClass;
    this.parent = parent;
    this.parent = parent;
    this.list = populate;
  }
  _kind = "PropertyList";
  list = [];
  static isPropertyList(obj) {
    return "_kind" in obj && obj._kind === "PropertyList";
  }
  add(item) {
    this.list.push(item);
  }
  all() {
    return this.list.map((pp) => pp.toJSON());
  }
  append(item) {
    this.add(item);
  }
  assimilate(source, prune) {
    if (prune) {
      this.clear();
    }
    if ("list" in source) {
      this.list.push(...source.list);
    } else {
      this.list.push(...source);
    }
  }
  clear() {
    this.list = [];
  }
  count() {
    return this.list.length;
  }
  each(iterator, context) {
    const it2 = iterator;
    it2.context = context;
    this.list.forEach(it2);
  }
  // TODO: unsupported yet as properties are not organized as hierarchy
  eachParent(_iterator, _context) {
    throw unsupportedError("eachParent");
  }
  filter(rule, context) {
    const it2 = rule;
    it2.context = context;
    return this.list.filter(it2);
  }
  // TODO: support returning {Item|ItemGroup}
  find(rule, context) {
    const finder = rule;
    finder.context = context;
    return this.list.find(finder);
  }
  // it does not return underlying type of the item because they are not supported
  get(key) {
    return this.one(key);
  }
  // TODO: value is not used as its usage is unknown
  has(item, _value) {
    return this.indexOf(item) >= 0;
  }
  idx(index) {
    if (index <= this.list.length - 1) {
      return this.list[index];
    }
    return void 0;
  }
  indexOf(item) {
    const indexFieldName = this.typeClass._index || "id";
    for (let i2 = 0; i2 < this.list.length; i2++) {
      const record = this.list[i2];
      if (typeof item === "string" && record[indexFieldName] === item) {
        return i2;
      }
      const itemRecord = item;
      if (record[indexFieldName] === itemRecord[indexFieldName]) {
        return i2;
      }
    }
    return -1;
  }
  insert(item, before2) {
    if (before2 != null && before2 >= 0 && before2 <= this.list.length - 1) {
      this.list = [...this.list.slice(0, before2), item, ...this.list.slice(before2)];
    } else {
      this.append(item);
    }
  }
  insertAfter(item, after3) {
    if (after3 != null && after3 >= 0 && after3 <= this.list.length - 1) {
      this.list = [...this.list.slice(0, after3 + 1), item, ...this.list.slice(after3 + 1)];
    } else {
      this.append(item);
    }
  }
  map(iterator, context) {
    const it2 = iterator;
    it2.context = context;
    return this.list.map(it2);
  }
  one(id) {
    const indexFieldName = this.typeClass._index || "id";
    for (let i2 = this.list.length - 1; i2 >= 0; i2--) {
      const record = this.list[i2];
      if (record[indexFieldName] === id) {
        if ("valueOf" in this.list[i2] && typeof this.list[i2].valueOf === "function") {
          return this.list[i2].valueOf();
        }
        return this.list[i2];
      }
    }
    return void 0;
  }
  populate(items) {
    this.list = [...this.list, ...items];
  }
  prepend(item) {
    this.list = [item, ...this.list];
  }
  reduce(iterator, accumulator, context) {
    const it2 = iterator;
    it2.context = context;
    return this.list.reduce(it2, accumulator);
  }
  remove(predicate, context) {
    if (typeof predicate === "function") {
      const reversePredicate = (item) => !predicate(item);
      this.list = this.filter(reversePredicate, context);
    } else {
      this.list = this.filter((item) => !(0, import_deep_equal.default)(predicate, item), context);
    }
  }
  repopulate(items) {
    this.clear();
    this.populate(items);
  }
  // TODO: unsupported yet
  toObject(_excludeDisabled, _caseSensitive, _multiValue, _sanitizeKeys) {
    return this.list.map((elem) => elem.toJSON());
  }
  toString() {
    const itemStrs = this.list.map((item) => item.toString());
    return `[${itemStrs.join("; ")}]`;
  }
  upsert(item) {
    if (item == null) {
      return false;
    }
    const itemIdx = this.indexOf(item);
    if (itemIdx >= 0) {
      this.list = [...this.list.splice(0, itemIdx), item, ...this.list.splice(itemIdx + 1)];
      return false;
    }
    this.add(item);
    return true;
  }
};

// ../insomnia-scripting-environment/src/objects/variables.ts
var Variable = class extends Property {
  /**
   * Represents the unique identifier for a variable.
   */
  key;
  /**
   * Represents the value of a variable, which can be of any type.
   */
  value;
  /**
   * The type of the variable, represented as a string.
   */
  type;
  /** @ignore */
  _kind = "Variable";
  /**
   * Constructs a new instance of the class with the provided variable definition.
   *
   * @param def - An optional object containing the variable definition. If provided,
   *              it initializes the instance properties with the values from the object.
   *              If not provided, default values are used.
   */
  constructor(def) {
    super();
    this.id = def ? def.id || "" : "";
    this.key = def ? def.key : "";
    this.name = def ? def.name : "";
    this.value = def ? def.value : "";
    this.type = def && def.type ? def.type : "Variable";
    this.disabled = def ? def.disabled : false;
  }
  /** @ignore */
  static _index = "key";
  // unknown usage and unsupported
  /** @ignore */
  static types() {
    throw unsupportedError("types");
  }
  /**
   * This method casts the provided value to its underlying value if it is a Variable object.
   *
   * @param value - The value to be cast. It can be of any type.
   * @returns The underlying value of the Variable object if the input is a Variable; otherwise, returns `undefined`.
   */
  cast(value) {
    if ("_kind" in value && value._kind === "Variable") {
      return value.value;
    }
    return void 0;
  }
  /**
   * Retrieves the current value of the variable.
   *
   * @returns The value of the variable.
   */
  get() {
    return this.value;
  }
  /**
   * Sets the value of the variable.
   *
   * @param value - The new value to assign to the variable.
   */
  set(value) {
    this.value = value;
  }
};
var VariableList = class extends PropertyList {
  /** @ignore */
  _kind = "VariableList";
  /**
   * Constructs a new instance of the class.
   *
   * @param parent - The parent `PropertyList` instance, or `undefined` if there is no parent.
   * @param populate - An array of items of type {@link Variable} used to populate the list.
   */
  constructor(parent, populate) {
    super(Variable, void 0, populate);
    this.parent = parent;
  }
  /**
   * Determines if the given object is a VariableList.
   *
   * @param obj - The object to check.
   * @returns A boolean indicating whether the object is a VariableList.
   */
  static isVariableList(obj) {
    return "_kind" in obj && obj._kind === "VariableList";
  }
};

// ../insomnia-scripting-environment/src/objects/auth.ts
var AuthTypes = /* @__PURE__ */ new Set([
  "noauth",
  "basic",
  "bearer",
  "jwt",
  "digest",
  "oauth1",
  "oauth2",
  "hawk",
  "awsv4",
  "ntlm",
  "apikey",
  "edgegrid",
  "asap",
  "netrc"
]);
function rawOptionsToVariables(options, targetType) {
  if (VariableList.isVariableList(options)) {
    return [options];
  } else if ("type" in options) {
    const optsObj = options;
    const optsVarLists = Object.entries(optsObj).filter((optsObjEntry) => {
      return optsObjEntry[0] === targetType;
    }).map((optsEntry) => {
      const optVars = optsEntry[1].map((opt) => {
        return new Variable({
          key: opt.key,
          value: opt.value
        });
      });
      return new VariableList(void 0, optVars);
    });
    return optsVarLists;
  } else if ("length" in options) {
    return [new VariableList(void 0, options)];
  }
  throw new Error("options is not valid: it must be VariableList<Variable> | Variable[] | object");
}
var RequestAuth = class _RequestAuth extends Property {
  type;
  authOptions = /* @__PURE__ */ new Map();
  constructor(options, parent) {
    super();
    if (!_RequestAuth.isValidType(options.type)) {
      throw new Error(`invalid auth type ${options.type}`);
    }
    this.type = options.type;
    const optsObj = options;
    const optsEntries = Object.entries(optsObj).filter((optsObjEntry) => optsObjEntry[0] !== "type");
    optsEntries.map((optsEntry) => {
      const optVars = optsEntry[1].map((opt) => {
        return new Variable({
          key: opt.key,
          value: opt.value,
          type: opt.type
        });
      });
      return {
        type: optsEntry[0],
        options: new VariableList(void 0, optVars)
      };
    }).forEach((authOpts) => {
      this.authOptions.set(authOpts.type, authOpts.options);
    });
    this._parent = parent;
  }
  static isValidType(authType) {
    return AuthTypes.has(authType);
  }
  clear(type) {
    if (_RequestAuth.isValidType(type)) {
      this.authOptions.delete(type);
    }
  }
  parameters() {
    return this.authOptions.get(this.type);
  }
  toJSON() {
    const obj = { type: this.type };
    const authOption = this.authOptions.get(this.type);
    if (!authOption) {
      return obj;
    }
    if (this.type === "noauth" || this.type === "netrc") {
      return obj;
    }
    obj[this.type] = authOption.map((optValue) => optValue.toJSON(), {});
    return obj;
  }
  update(options, type) {
    const currentType = type ? type : this.type;
    const authOpts = rawOptionsToVariables(options, currentType);
    if (authOpts.length > 0 && authOpts[0]) {
      this.type = currentType;
      this.authOptions.set(currentType, authOpts[0]);
    } else {
      throw new Error("no valid RequestAuth options is found");
    }
  }
  use(type, options) {
    if (!_RequestAuth.isValidType(type)) {
      throw new Error(
        `invalid type (${type}), it must be noauth | basic | bearer | jwt | digest | oauth1 | oauth2 | hawk | awsv4 | ntlm | apikey | edgegrid | asap.`
      );
    }
    const authOpts = rawOptionsToVariables(options, type);
    if (authOpts.length > 0 && authOpts[0]) {
      this.type = type;
      this.authOptions.set(type, authOpts[0]);
    } else {
      throw new Error("no valid RequestAuth options is found");
    }
  }
};
function fromPreRequestAuth(auth) {
  const authObj = auth.toJSON();
  const findValueInKvArray = (targetKey, kvs) => kvs?.find(({ key }) => key === targetKey)?.value || "";
  const findValueInOauth2Options = (targetKey, kvs) => {
    if (!kvs) {
      return "";
    }
    for (const kv of kvs) {
      if (typeof kv.value === "string" && kv.key === targetKey) {
        return kv.value;
      } else if (Array.isArray(kv.value)) {
        const matched = kv.value.find((subKv) => subKv.key === targetKey);
        if (matched != null) {
          return matched.value;
        }
      }
    }
    return "";
  };
  switch (authObj.type) {
    case "noauth": {
      return {
        type: "none",
        disabled: true
      };
    }
    case "apikey": {
      return {
        type: "apikey",
        disabled: findValueInKvArray("disabled", authObj.apikey) === "true",
        key: findValueInKvArray("key", authObj.apikey),
        value: findValueInKvArray("value", authObj.apikey),
        addTo: findValueInKvArray("in", authObj.apikey)
      };
    }
    case "bearer": {
      return {
        type: "bearer",
        disabled: findValueInKvArray("disabled", authObj.bearer) === "true",
        token: findValueInKvArray("token", authObj.bearer),
        prefix: findValueInKvArray("prefix", authObj.bearer)
      };
    }
    case "basic": {
      return {
        type: "basic",
        disabled: findValueInKvArray("disabled", authObj.basic) === "true",
        useISO88591: findValueInKvArray("useISO88591", authObj.basic) === "true",
        username: findValueInKvArray("username", authObj.basic),
        password: findValueInKvArray("password", authObj.basic)
      };
    }
    case "digest": {
      return {
        type: "digest",
        disabled: findValueInKvArray("disabled", authObj.digest) === "true",
        username: findValueInKvArray("username", authObj.digest),
        password: findValueInKvArray("password", authObj.digest)
      };
    }
    case "ntlm": {
      return {
        type: "ntlm",
        disabled: findValueInKvArray("disabled", authObj.ntlm) === "true",
        username: findValueInKvArray("username", authObj.ntlm),
        password: findValueInKvArray("password", authObj.ntlm)
      };
    }
    case "oauth1": {
      const signMethod = (() => {
        const method2 = findValueInKvArray("signatureMethod", authObj.oauth1);
        const unsupportedError2 = new Error(
          `auth transforming(fromPreRequestAuth): unsupported signatureMethod type for oauth1: ${method2}`
        );
        switch (method2) {
          case "HMAC-SHA1": {
            return "HMAC-SHA1";
          }
          case "HMAC-SHA256": {
            return "HMAC-SHA256";
          }
          case "HMAC-SHA512": {
            throw unsupportedError2;
          }
          case "RSA-SHA1": {
            return "RSA-SHA1";
          }
          case "RSA-SHA256": {
            throw unsupportedError2;
          }
          case "RSA-SHA512": {
            throw unsupportedError2;
          }
          case "PLAINTEXT": {
            return "PLAINTEXT";
          }
          default: {
            throw new Error(
              `auth transforming(fromPreRequestAuth): unknown signatureMethod type for oauth1: ${method2}`
            );
          }
        }
      })();
      return {
        type: "oauth1",
        disabled: findValueInKvArray("disabled", authObj.oauth1) === "true",
        signatureMethod: signMethod,
        consumerKey: findValueInKvArray("consumerKey", authObj.oauth1),
        consumerSecret: findValueInKvArray("consumerSecret", authObj.oauth1),
        tokenKey: findValueInKvArray("token", authObj.oauth1),
        tokenSecret: findValueInKvArray("tokenSecret", authObj.oauth1),
        privateKey: findValueInKvArray("privateKey", authObj.oauth1),
        // it is not supported in the script side
        version: findValueInKvArray("version", authObj.oauth1),
        nonce: findValueInKvArray("nonce", authObj.oauth1),
        timestamp: findValueInKvArray("timestamp", authObj.oauth1),
        callback: findValueInKvArray("callback", authObj.oauth1),
        realm: findValueInKvArray("realm", authObj.oauth1),
        verifier: findValueInKvArray("verifier", authObj.oauth1),
        includeBodyHash: findValueInKvArray("includeBodyHash", authObj.oauth1) === "true"
      };
    }
    case "oauth2": {
      const inputGrantType = findValueInOauth2Options("grant_type", authObj.oauth2);
      const grantType = (() => {
        switch (inputGrantType) {
          case "authorization_code":
          case "authorization_code_with_pkce": {
            return "authorization_code";
          }
          case "implicit": {
            return "implicit";
          }
          case "password_credentials": {
            return "password";
          }
          case "client_credentials": {
            return "client_credentials";
          }
          case "refresh_token": {
            return "refresh_token";
          }
          default: {
            throw new Error(
              `auth transforming(fromPreRequestAuth): unknown auth grant type for oauth2: ${inputGrantType}`
            );
          }
        }
      })();
      const responseType = (() => {
        const inputResponseType = findValueInOauth2Options("response_type", authObj.oauth2);
        if (["code", "id_token", "id_token token", "none", "token", ""].includes(inputResponseType)) {
          return inputResponseType;
        }
        throw new Error(
          `unknown response type for oauth2: "${inputResponseType}", it could be: 'code' | 'id_token' | 'id_token token' | 'none' | 'token' | ''`
        );
      })();
      return {
        type: "oauth2",
        disabled: findValueInOauth2Options("disabled", authObj.oauth2) === "true",
        grantType,
        authorizationUrl: findValueInOauth2Options("authUrl", authObj.oauth2),
        accessTokenUrl: findValueInOauth2Options("accessTokenUrl", authObj.oauth2),
        clientId: findValueInOauth2Options("clientId", authObj.oauth2),
        clientSecret: findValueInOauth2Options("clientSecret", authObj.oauth2),
        scope: findValueInOauth2Options("scope", authObj.oauth2),
        code: findValueInOauth2Options("code_verifier", authObj.oauth2),
        accessToken: findValueInOauth2Options("accessToken", authObj.oauth2),
        pkceMethod: findValueInOauth2Options("challengeAlgorithm", authObj.oauth2),
        usePkce: findValueInOauth2Options("grant_type", authObj.oauth2) === "authorization_code_with_pkce",
        username: findValueInOauth2Options("username", authObj.oauth2),
        password: findValueInOauth2Options("password", authObj.oauth2),
        redirectUrl: findValueInOauth2Options("callBackUrl", authObj.oauth2),
        state: findValueInOauth2Options("state", authObj.oauth2),
        refreshToken: findValueInOauth2Options("refreshTokenUrl", authObj.oauth2),
        credentialsInBody: findValueInOauth2Options("client_authentication", authObj.oauth2) === "body",
        audience: findValueInOauth2Options("audience", authObj.oauth2) || "",
        resource: findValueInOauth2Options("resource", authObj.oauth2) || "",
        // following properties are not supported yet in the script side, just try to find and set them
        tokenPrefix: findValueInOauth2Options("tokenPrefix", authObj.oauth2),
        responseType,
        origin: findValueInOauth2Options("origin", authObj.oauth2)
      };
    }
    case "awsv4": {
      return {
        type: "iam",
        disabled: findValueInKvArray("disabled", authObj.awsv4) === "true",
        accessKeyId: findValueInKvArray("accessKey", authObj.awsv4),
        secretAccessKey: findValueInKvArray("secretKey", authObj.awsv4),
        sessionToken: findValueInKvArray("sessionToken", authObj.awsv4),
        region: findValueInKvArray("region", authObj.awsv4),
        service: findValueInKvArray("service", authObj.awsv4)
      };
    }
    case "hawk": {
      return {
        type: "hawk",
        disabled: findValueInKvArray("disabled", authObj.hawk) === "true",
        algorithm: findValueInKvArray("algorithm", authObj.hawk) === "sha256" ? "sha256" : "sha1",
        id: findValueInKvArray("authId", authObj.hawk),
        key: findValueInKvArray("authKey", authObj.hawk),
        ext: findValueInKvArray("extraData", authObj.hawk),
        validatePayload: findValueInKvArray("validatePayload", authObj.hawk) === "true"
        // TODO(george): some keys are lost here, see if we can support them in Insomnia
        // timestamp
        // delegation
        // app
        // nonce
        // user
      };
    }
    case "asap": {
      return {
        type: "asap",
        disabled: findValueInKvArray("disabled", authObj.asap) === "true",
        issuer: findValueInKvArray("iss", authObj.asap),
        subject: findValueInKvArray("sub", authObj.asap),
        audience: findValueInKvArray("aud", authObj.asap),
        additionalClaims: findValueInKvArray("claims", authObj.asap),
        keyId: findValueInKvArray("kid", authObj.asap),
        privateKey: findValueInKvArray("privateKey", authObj.asap)
      };
    }
    case "netrc": {
      throw new Error("netrc is not supported yet");
    }
    default: {
      throw new Error(`unknown auth type: ${authObj.type}`);
    }
  }
}
function toPreRequestAuth(auth) {
  if (!auth || !("type" in auth) || !auth.type) {
    return { type: "noauth" };
  }
  switch (auth.type) {
    case "none": {
      return { type: "noauth" };
    }
    case "apikey": {
      return {
        type: "apikey",
        apikey: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "key", value: auth.key || "" },
          { key: "value", value: auth.value || "" },
          { key: "in", value: auth.addTo || "" }
        ]
      };
    }
    case "bearer": {
      return {
        type: "bearer",
        bearer: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "token", value: auth.token || "" },
          { key: "prefix", value: auth.prefix || "" }
        ]
      };
    }
    case "basic": {
      return {
        type: "basic",
        basic: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "useISO88591", value: auth.useISO88591 ? "true" : "false" },
          { key: "username", value: auth.username || "" },
          { key: "password", value: auth.password || "" }
        ]
      };
    }
    case "digest": {
      return {
        type: "digest",
        digest: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "username", value: auth.username || "" },
          { key: "password", value: auth.password || "" }
        ]
      };
    }
    case "ntlm": {
      return {
        type: "ntlm",
        ntlm: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "username", value: auth.username || "" },
          { key: "password", value: auth.password || "" }
        ]
      };
    }
    case "oauth1": {
      return {
        type: "oauth1",
        oauth1: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "signatureMethod", value: auth.signatureMethod || "" },
          { key: "consumerKey", value: auth.consumerKey || "" },
          { key: "consumerSecret", value: auth.consumerSecret || "" },
          { key: "token", value: auth.tokenKey || "" },
          { key: "tokenSecret", value: auth.tokenSecret || "" },
          { key: "privateKey", value: auth.privateKey || "" },
          { key: "version", value: auth.version || "" },
          { key: "nonce", value: auth.nonce || "" },
          { key: "timestamp", value: auth.timestamp || "" },
          { key: "callback", value: auth.callback || "" },
          { key: "realm", value: auth.realm || "" },
          { key: "verifier", value: auth.verifier || "" },
          { key: "includeBodyHash", value: auth.includeBodyHash ? "true" : "false" }
        ]
      };
    }
    case "oauth2": {
      const inputGrantType = auth.grantType;
      const grantType = (() => {
        switch (inputGrantType) {
          case "authorization_code": {
            return auth.usePkce ? "authorization_code_with_pkce" : "authorization_code";
          }
          case "implicit": {
            return "implicit";
          }
          case "password": {
            return "password_credentials";
          }
          case "client_credentials": {
            return "client_credentials";
          }
          case "refresh_token": {
            return "refresh_token";
          }
          default: {
            throw new Error(
              `auth transforming(toPreRequestAuth): unknown auth grant type for oauth2: ${inputGrantType}`
            );
          }
        }
      })();
      return {
        type: "oauth2",
        oauth2: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "grant_type", value: grantType },
          { key: "authUrl", value: auth.authorizationUrl || "" },
          { key: "accessTokenUrl", value: auth.accessTokenUrl || "" },
          { key: "clientId", value: auth.clientId || "" },
          { key: "clientSecret", value: auth.clientSecret || "" },
          { key: "scope", value: auth.scope || "" },
          { key: "code_verifier", value: auth.code || "" },
          { key: "accessToken", value: auth.accessToken || "" },
          { key: "challengeAlgorithm", value: auth.pkceMethod || "" },
          // { key: 'scope', value: auth.usePkce || ''},
          { key: "username", value: auth.username || "" },
          { key: "password", value: auth.password || "" },
          { key: "callBackUrl", value: auth.redirectUrl || "" },
          { key: "state", value: auth.state || "" },
          { key: "refreshTokenUrl", value: auth.refreshToken || "" },
          { key: "client_authentication", value: auth.credentialsInBody ? "body" : "header" },
          {
            key: "tokenRequestParams",
            value: [
              {
                key: "audience",
                value: auth.audience || "",
                enabled: true,
                send_as: "request_url"
                // request_body or request_header
              },
              {
                key: "resource",
                value: auth.resource || "",
                enabled: true,
                send_as: "request_url"
                // request_body or request_header
              }
            ]
          },
          // following properties are not supported in script side, still set them
          { key: "tokenPrefix", value: auth.tokenPrefix || "" },
          { key: "response_type", value: auth.responseType || "" },
          { key: "origin", value: auth.origin || "" }
        ]
      };
    }
    case "iam": {
      return {
        type: "awsv4",
        awsv4: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "accessKey", value: auth.accessKeyId || "" },
          { key: "secretKey", value: auth.secretAccessKey || "" },
          { key: "sessionToken", value: auth.sessionToken || "" },
          { key: "region", value: auth.region || "" },
          { key: "service", value: auth.service || "" }
        ]
      };
    }
    case "hawk": {
      return {
        type: "hawk",
        hawk: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "algorithm", value: auth.algorithm || "" },
          { key: "authId", value: auth.id || "" },
          { key: "authKey", value: auth.key || "" },
          { key: "extraData", value: auth.ext || "" },
          { key: "validatePayload", value: auth.validatePayload ? "true" : "false" },
          // TODO(george): these fields are not supported in Insomnia side
          { key: "timestamp", value: "" },
          { key: "delegation", value: "" },
          { key: "app", value: "" },
          { key: "nonce", value: "" },
          { key: "user", value: "" },
          { key: "includePayloadHash", value: "false" }
        ]
      };
    }
    case "asap": {
      return {
        type: "asap",
        asap: [
          { key: "disabled", value: auth.disabled ? "true" : "false" },
          { key: "iss", value: auth.issuer || "" },
          { key: "sub", value: auth.subject || "" },
          { key: "aud", value: auth.audience || "" },
          { key: "claims", value: auth.additionalClaims || "" },
          { key: "kid", value: auth.keyId || "" },
          { key: "privateKey", value: auth.privateKey || "" }
        ]
      };
    }
    case "netrc": {
      throw new Error("netrc auth is not supported in scripting yet");
    }
    case "singleToken": {
      throw new Error("singleToken auth is not supported in scripting yet");
    }
    default: {
      throw new Error(`unknown auth type: ${auth.type}`);
    }
  }
}

// ../insomnia-scripting-environment/src/objects/utils.ts
function checkIfUrlIncludesTag(url) {
  return /{%/.test(`${url}`) || /%}/.test(`${url}`) || /{{/.test(`${url}`) || /}}/.test(`${url}`);
}

// ../insomnia-scripting-environment/src/objects/urls.ts
var UrlSearchParams = URLSearchParams;
var QueryParam = class _QueryParam extends Property {
  _kind = "QueryParam";
  key;
  value;
  type;
  // the `multiline` and `fileName` are properties from Insomnia
  // they are added here to avoid being dropped
  multiline;
  fileName;
  constructor(options) {
    super();
    if (typeof options === "string") {
      try {
        const optionsObj = JSON.parse(options);
        this.key = optionsObj.key;
        this.value = optionsObj.value;
        this.type = optionsObj.type;
        this.multiline = optionsObj.multiline;
        this.disabled = optionsObj.disabled;
        this.fileName = optionsObj.fileName;
      } catch (e2) {
        throw new Error(`invalid QueryParam options ${e2}`);
      }
    } else if (typeof options === "object" && "key" in options && "value" in options) {
      this.key = options.key;
      this.value = options.value;
      this.type = options.type;
      this.multiline = options.multiline;
      this.disabled = options.disabled;
      this.fileName = options.fileName;
    } else {
      throw new Error("unknown options for new QueryParam");
    }
  }
  // TODO:
  // (static) _postman_propertyAllowsMultipleValues :Boolean
  // (static) _postman_propertyIndexKey :String
  static _index = "key";
  static parse(queryStr) {
    const params = new UrlSearchParams(queryStr);
    return Array.from(params.entries()).map((entry) => ({ key: entry[0], value: entry[1] }));
  }
  static parseSingle(paramStr, _idx, _all) {
    const pairs = _QueryParam.parse(paramStr);
    if (pairs.length === 0) {
      throw new Error("invalid search query string");
    }
    return pairs[0];
  }
  static unparse(params) {
    const searchParams = new UrlSearchParams();
    if (Array.isArray(params)) {
      params.forEach((entry) => searchParams.append(entry.key, entry.value || ""));
    } else {
      Object.entries(params).forEach((entry) => searchParams.append(entry[0], entry[1]));
    }
    return searchParams.toString();
  }
  static unparseSingle(obj) {
    if ("key" in obj && "value" in obj) {
      const params = new UrlSearchParams();
      params.append(obj.key, obj.value);
      return params.toString();
    }
    return {};
  }
  toString() {
    const params = new UrlSearchParams();
    params.append(this.key, this.value || "");
    return params.toString();
  }
  toRawString() {
    return `${this.key}=${this.value}`;
  }
  update(param) {
    if (typeof param === "string") {
      const paramObj = _QueryParam.parseSingle(param);
      if (!paramObj) {
        throw new Error("failed to update param: input `param` is invalid");
      }
      this.key = typeof paramObj.key === "string" ? paramObj.key : "";
      this.value = typeof paramObj.value === "string" ? paramObj.value : "";
    } else if ("key" in param && "value" in param) {
      this.key = param.key;
      this.value = param.value;
      this.type = param.type;
    } else {
      throw new Error("the param for update must be: string | { key: string; value: string }");
    }
  }
};
var Url = class extends PropertyBase {
  _kind = "Url";
  id;
  urlObject;
  origin;
  queryParams = [];
  // query params are handled separately as URL object encodes content
  get auth() {
    return this.urlObject && this.urlObject.username !== "" ? { username: this.urlObject.username, password: this.urlObject.password } : void 0;
  }
  get hash() {
    const fullHash = this.urlObject ? this.urlObject.hash : "";
    return fullHash.startsWith("#") ? fullHash.slice(1) : fullHash;
  }
  get host() {
    return this.urlObject ? this.urlObject.hostname.split(".") : [];
  }
  get path() {
    return this.urlObject ? this.urlObject.pathname.split("/").filter((segment) => segment.trim() !== "") : [];
  }
  get port() {
    return this.urlObject ? this.urlObject.port : "";
  }
  get protocol() {
    return this.urlObject ? this.urlObject.protocol : "";
  }
  get query() {
    return new PropertyList(QueryParam, void 0, this.queryParams);
  }
  get variables() {
    return [];
  }
  constructor(def) {
    super();
    this.initFields(def);
  }
  initFields(urlOptions) {
    if (typeof urlOptions === "string") {
      const ifUrlIncludesTag = checkIfUrlIncludesTag(urlOptions);
      if (URL.canParse(urlOptions) && !ifUrlIncludesTag) {
        this.urlObject = new URL(urlOptions);
        this.urlObject.searchParams.forEach((value, key) => {
          this.queryParams = [...this.queryParams, new QueryParam({ key, value })];
        });
        this.urlObject.search = "";
      } else {
        this.urlObject = void 0;
      }
      this.origin = urlOptions;
    } else if (typeof urlOptions === "object") {
      const protocolStr = (urlOptions.protocol || "").trim() ? urlOptions.protocol.trim() : "https://";
      const authStr = urlOptions.auth ? `${urlOptions.auth.username}:${urlOptions.auth.password}@` : "";
      const hostStr = urlOptions.host.join(".");
      const portStr = urlOptions.port ? `:${urlOptions.port}` : "";
      const pathStr = urlOptions.path && urlOptions.path.length > 0 ? `/${urlOptions.path.filter((segment) => segment.trim() !== "").join("/")}` : "";
      const queryStr = urlOptions.query && urlOptions.query.length > 0 ? "?" + urlOptions.query.map((pair) => `${pair.key}=${pair.value}`).join("&") : "";
      const hashStr = urlOptions.hash ? `#${urlOptions.hash}` : "";
      const urlString = `${protocolStr}${authStr}${hostStr}${portStr}${pathStr}${queryStr}${hashStr}`;
      if (URL.canParse(urlString)) {
        this.urlObject = new URL(urlString);
        this.urlObject.searchParams.forEach((value, key) => {
          this.queryParams = [...this.queryParams, new QueryParam({ key, value })];
        });
        this.urlObject.search = "";
      } else {
        this.urlObject = void 0;
      }
      this.origin = urlString;
    } else {
      throw new Error(`url is invalid: ${urlOptions} `);
    }
  }
  static _index = "id";
  static isUrl(obj) {
    return "_kind" in obj && obj._kind === "Url";
  }
  static parse(urlStr) {
    if (URL.canParse(urlStr)) {
      const urlObject = new URL(urlStr);
      const auth = urlObject.username === "" ? void 0 : { username: urlObject.username, password: urlObject.password };
      const query = Array.from(urlObject.searchParams.entries()).map((entry) => ({ key: entry[0], value: entry[1] }));
      return {
        auth,
        protocol: urlObject.protocol,
        host: urlObject.hostname.split("."),
        port: urlObject.port,
        path: urlObject.pathname.split("/"),
        query,
        hash: urlObject.hash,
        variables: []
      };
    }
    return void 0;
  }
  addQueryParams(params) {
    if (typeof params === "string") {
      const pairs = params.split("&");
      pairs.forEach((pair) => {
        const parts = pair.split("=");
        this.queryParams = [...this.queryParams, new QueryParam({ key: parts[0], value: parts[1] })];
      });
    } else if (Array.isArray(params)) {
      params.forEach((pair) => {
        this.queryParams = [...this.queryParams, new QueryParam({ ...pair })];
      });
    } else {
      throw new Error(`addQueryParams: invalid params: ${JSON.stringify(params)}`);
    }
  }
  getHost() {
    if (this.urlObject) {
      return this.urlObject.hostname;
    }
    return "";
  }
  getPath(_unresolved) {
    if (this.urlObject) {
      return this.urlObject.pathname;
    }
    return "";
  }
  getPathWithQuery() {
    if (this.getPath(true).trim() === "") {
      return this.getQueryString();
    }
    return `${this.getPath(true)}?${this.getQueryString()}`;
  }
  getQueryString() {
    return this.queryParams.filter((param) => !param.disabled).map((param) => param.toRawString()).join("&");
  }
  getRemote(_forcePort) {
    if (this.urlObject) {
      return this.urlObject.host;
    }
    return "";
  }
  removeQueryParams(params) {
    if (typeof params === "string") {
      this.queryParams = this.queryParams.filter((param) => param.key !== params);
    } else if (Array.isArray(params)) {
      this.queryParams = this.queryParams.filter((param) => {
        const shouldDelete = params.some((paramToRemove) => {
          if (typeof paramToRemove === "string") {
            return param.key === paramToRemove;
          }
          return param.key === paramToRemove.key;
        });
        return !shouldDelete;
      });
    } else {
      throw new Error(
        "removeQueryParams: failed to remove query params: unknown params type, only supports QueryParam[], string[] or string"
      );
    }
  }
  toString(_forceProtocol) {
    if (this.urlObject) {
      const newUrlObject = new URL(this.urlObject.toString());
      newUrlObject.search = this.getQueryString();
      const urlInString = newUrlObject.toString();
      if (this.urlObject.pathname === "/" && urlInString === this.origin + "/") {
        return urlInString.slice(0, urlInString.length - 1);
      }
      return urlInString;
    }
    return this.origin || "";
  }
  toStringWithoutQuery(_forceProtocol) {
    if (this.urlObject) {
      const newUrlObject = new URL(this.urlObject.toString());
      newUrlObject.search = "";
      const urlInString = newUrlObject.toString();
      if (this.urlObject.pathname === "/" && urlInString === this.origin + "/") {
        return urlInString.slice(0, urlInString.length - 1);
      }
      return urlInString;
    }
    return this.origin || "";
  }
  update(url) {
    this.initFields(url);
  }
};
var UrlMatchPattern = class _UrlMatchPattern extends Property {
  // scheme
  // scheme: 'http:' | 'https:' | '*' | 'file:';
  // host
  // About wildcard:
  // If you use a wildcard in the host pattern
  // it must be the first or only character, and it must be followed by a period (.) or forward slash (/).
  // path
  // Must contain at least a forward slash
  // The slash by itself matches any path.
  // Special cases: https://developer.chrome.com/docs/extensions/develop/concepts/match-patterns#special
  // "<all_urls>"
  // "file:///"
  // "http://localhost/*"
  // It doesn't support match patterns for top Level domains (TLD).
  id = "";
  pattern;
  constructor(pattern) {
    super();
    this.pattern = pattern;
  }
  static _index = "id";
  static MATCH_ALL_URLS = "<all_urls>";
  static pattern = void 0;
  // TODO: its usage is unknown
  static PROTOCOL_DELIMITER = "+";
  // TODO: the url can not start with -
  getProtocols() {
    if (this.pattern === "<all_urls>") {
      return ["http", "https", "file"];
    }
    const protocolEndPos = this.pattern.indexOf("://");
    if (protocolEndPos < 0) {
      return [];
    }
    const protocolPattern = this.pattern.slice(0, protocolEndPos);
    const protocols = protocolPattern.split(_UrlMatchPattern.PROTOCOL_DELIMITER);
    return protocols.map((protocol) => protocol.replace(":", ""));
  }
  test(urlStr) {
    const protoEndPos = urlStr.indexOf(":");
    const protoStr = urlStr.slice(0, protoEndPos);
    const hostStr = this.getHost(urlStr);
    const pathStr = this.getPath(this.pattern);
    const portStr = this.getPort(urlStr);
    return this.testProtocol(protoStr) && this.testHost(hostStr) && this.testPath(pathStr) && this.testPort(portStr, protoStr);
  }
  getHost(urlStr) {
    const protocolEndPos = urlStr.indexOf("://") + 3;
    const hostBegPos = protocolEndPos;
    const portBegPos = urlStr.indexOf(":", protocolEndPos);
    const pathBegPos = urlStr.indexOf("/", protocolEndPos);
    const queryBegPos = urlStr.indexOf("?", protocolEndPos);
    const hashBegPos = urlStr.indexOf("?", protocolEndPos);
    let hostEndPos = urlStr.length;
    if (portBegPos >= 0) {
      hostEndPos = portBegPos;
    } else if (pathBegPos >= 0) {
      hostEndPos = pathBegPos;
    } else if (queryBegPos >= 0) {
      hostEndPos = queryBegPos;
    } else if (hashBegPos >= 0) {
      hostEndPos = hashBegPos;
    }
    return urlStr.slice(hostBegPos, hostEndPos);
  }
  testHost(hostStr) {
    const patternSegments = this.getHost(this.pattern).split(".");
    const inputHostSegments = hostStr.split(".");
    if (patternSegments.length !== inputHostSegments.length) {
      return false;
    }
    for (const [i2, patternSegment] of patternSegments.entries()) {
      if (patternSegment === "*") {
        continue;
      } else if (patternSegment !== inputHostSegments[i2]) {
        return false;
      }
    }
    return true;
  }
  getPath(urlStr) {
    const protocolEndPos = urlStr.indexOf("://") + 3;
    const hostBegPos = protocolEndPos;
    const pathBegPos = urlStr.indexOf("/", hostBegPos);
    if (pathBegPos < 0) {
      return "";
    }
    const queryBegPos = urlStr.indexOf("?");
    const hashBegPos = urlStr.indexOf("#");
    let pathEndPos = urlStr.length;
    if (queryBegPos >= 0) {
      pathEndPos = queryBegPos;
    } else if (hashBegPos >= 0) {
      pathEndPos = hashBegPos;
    }
    return urlStr.slice(pathBegPos, pathEndPos);
  }
  testPath(pathStr) {
    const patternSegments = this.getPath(this.pattern).split("/");
    const inputSegments = pathStr.split("/");
    if (patternSegments.length !== inputSegments.length) {
      return false;
    }
    for (const [i2, patternSegment] of patternSegments.entries()) {
      if (patternSegment === "*") {
        continue;
      } else if (patternSegment !== inputSegments[i2]) {
        return false;
      }
    }
    return true;
  }
  getPort(urlStr) {
    const protocolEndPos = urlStr.indexOf("/") + 2;
    const hostBegPos = protocolEndPos;
    let portBegPos = urlStr.indexOf(":", protocolEndPos);
    if (portBegPos <= 0) {
      return "";
    }
    portBegPos += 1;
    let portEndPos = urlStr.length;
    const pathBegPos = urlStr.indexOf("/", hostBegPos);
    const queryBegPos = urlStr.indexOf("?");
    const hashBegPos = urlStr.indexOf("#");
    if (pathBegPos >= 0) {
      portEndPos = pathBegPos;
    } else if (queryBegPos >= 0) {
      portEndPos = queryBegPos;
    } else if (hashBegPos >= 0) {
      portEndPos = hashBegPos;
    }
    return urlStr.slice(portBegPos, portEndPos);
  }
  testPort(port, protocol) {
    if (!this.testProtocol(protocol)) {
      return false;
    }
    const portPattern = this.getPort(this.pattern);
    if (portPattern === "*") {
      return true;
    } else if (portPattern === "" || port === "") {
      const protos = this.getProtocols();
      if (protocol === "https") {
        return protos.includes("https") && (port === "443" && portPattern === "" || port === "" && portPattern === "443" || port === "" && portPattern === "");
      } else if (protocol === "http") {
        return protos.includes("http") && (port === "80" && portPattern === "" || port === "" && portPattern === "80" || port === "" && portPattern === "");
      }
    }
    return portPattern === port;
  }
  testProtocol(protocol) {
    const protoPatterns = this.getProtocols();
    for (const pattern of protoPatterns) {
      if (pattern === "*") {
        return true;
      } else if (pattern === protocol) {
        return true;
      }
    }
    return false;
  }
  toString() {
    return this.pattern;
  }
  update(pattern) {
    this.pattern = pattern;
  }
};
var UrlMatchPatternList = class extends PropertyList {
  _kind = "UrlMatchPatternList";
  constructor(parent, populate) {
    super(UrlMatchPattern, void 0, populate);
    this.parent = parent;
  }
  static isUrlMatchPatternList(obj) {
    return "_kind" in obj && obj._kind === "UrlMatchPatternList";
  }
  test(urlStr) {
    return this.filter((matchPattern) => matchPattern.test(urlStr), {}).length > 0;
  }
};
function toUrlObject(url) {
  if (!url) {
    throw new Error("Request URL is not specified");
  }
  return typeof url === "string" ? new Url(url) : url;
}

// ../insomnia-scripting-environment/src/objects/certificates.ts
var Certificate = class extends Property {
  _kind = "Certificate";
  name;
  matches;
  key;
  cert;
  passphrase;
  pfx;
  // PFX or PKCS12 Certificate
  constructor(options) {
    super();
    this.name = options.name;
    this.matches = new UrlMatchPatternList(
      void 0,
      options.matches ? options.matches.map((matchStr) => new UrlMatchPattern(matchStr)) : []
    );
    this.key = options.key;
    this.cert = options.cert;
    this.passphrase = options.passphrase;
    this.pfx = options.pfx;
    this.disabled = options.disabled;
  }
  static isCertificate(obj) {
    return "_kind" in obj && obj._kind === "Certificate";
  }
  canApplyTo(url) {
    return this.matches ? this.matches.test(url) : false;
  }
  update(options) {
    this.name = options.name;
    this.matches = new UrlMatchPatternList(
      void 0,
      options.matches ? options.matches.map((matchStr) => new UrlMatchPattern(matchStr)) : []
    );
    this.key = options.key;
    this.cert = options.cert;
    this.passphrase = options.passphrase;
    this.pfx = options.pfx;
  }
};

// ../insomnia-scripting-environment/src/objects/cookies.ts
var import_tough_cookie = __toESM(require_cookie());
init_esm_node();

// ../insomnia-scripting-environment/src/objects/console.ts
var Console = class {
  rows = [];
  // TODO: support replacing substitution
  /** @ignore */
  printLog = (rows, level, ...values2) => {
    try {
      const content = values2.map((value) => {
        return typeof value === "string" ? value : JSON.stringify(value, null, 2);
      }).join(" ");
      const row = {
        value: `${level}: ${content}`,
        name: "Text",
        timestamp: Date.now()
      };
      rows.push(row);
    } catch (e2) {
      rows.push({
        value: "error: " + JSON.stringify(e2, null, 2),
        name: "Text",
        timestamp: Date.now()
      });
    }
  };
  /**
   * Logs the provided values to the console with a log level of 'log'.
   *
   * @param values - The values to be logged. Accepts any number of arguments of any type.
   */
  log = (...values2) => {
    this.printLog(this.rows, "log", ...values2);
  };
  /**
   * Logs the provided values to the console with a log level of 'warn'.
   *
   * @param values - The values to be logged. Accepts any number of arguments of any type.
   */
  warn = (...values2) => {
    this.printLog(this.rows, "warn", ...values2);
  };
  /**
   * Logs the provided values to the console with a log level of 'debug'.
   *
   * @param values - The values to be logged. Accepts any number of arguments of any type.
   */
  debug = (...values2) => {
    this.printLog(this.rows, "debug", ...values2);
  };
  /**
   * Logs the provided values to the console with a log level of 'info'.
   *
   * @param values - The values to be logged. Accepts any number of arguments of any type.
   */
  info = (...values2) => {
    this.printLog(this.rows, "info", ...values2);
  };
  /**
   * Logs the provided values to the console with a log level of 'error'.
   *
   * @param values - The values to be logged. Accepts any number of arguments of any type.
   */
  error = (...values2) => {
    this.printLog(this.rows, "error", ...values2);
  };
  /**
   * Clears the console output for the specified log level.
   * This method is currently not supported.
   */
  clear = (_level, _message, ..._optionalParams) => {
    throw new Error('currently "clear" is not supported for the timeline');
  };
  /** @ignore */
  dumpLogs = () => {
    return this.rows.map((row) => JSON.stringify(row) + "\n").join("\n");
  };
  /** @ignore */
  dumpLogsAsArray = () => {
    return this.rows.map((row) => JSON.stringify(row) + "\n");
  };
};
var builtInConsole = new Console();
function getExistingConsole() {
  return builtInConsole;
}
function getNewConsole() {
  builtInConsole = new Console();
  return builtInConsole;
}

// ../insomnia-scripting-environment/src/objects/cookies.ts
var Cookie = class _Cookie extends Property {
  _kind = "Cookie";
  cookie;
  extensions;
  insoExtensions = {};
  constructor(cookieDef) {
    super();
    if (typeof cookieDef === "string") {
      const cookieDefParsed = _Cookie.parse(cookieDef);
      if (!cookieDefParsed) {
        throw new Error("failed to parse cookie, the cookie string seems invalid");
      }
      cookieDef = cookieDefParsed;
    }
    const def = { ...cookieDef };
    this.extensions = def.extensions ? [...def.extensions] : [];
    def.extensions = [];
    const cookie = import_tough_cookie.Cookie.fromJSON(def);
    if (!cookie) {
      throw new Error("failed to parse cookie, the cookie string seems invalid");
    }
    this.id = cookieDef.id || "";
    this.cookie = cookie;
    this.insoExtensions = {
      creation: cookieDef.creation,
      creationIndex: cookieDef.creationIndex,
      lastAccessed: cookieDef.lastAccessed,
      pathIsDefault: cookieDef.pathIsDefault
    };
  }
  static _index = "key";
  static isCookie(obj) {
    return "_kind" in obj && obj._kind === "Cookie";
  }
  static parse(cookieStr) {
    const cookieObj = import_tough_cookie.Cookie.parse(cookieStr, { loose: true });
    if (!cookieObj) {
      throw new Error("failed to parse cookie, the cookie string seems invalid");
    }
    const hostOnly = cookieObj.extensions?.includes("HostOnly") || false;
    const session = cookieObj.extensions?.includes("Session") || false;
    if (hostOnly) {
      cookieObj.extensions = cookieObj.extensions?.filter((item) => item !== "HostOnly") || [];
    }
    if (session) {
      cookieObj.extensions = cookieObj.extensions?.filter((item) => item !== "Session") || [];
    }
    const extensions = cookieObj.extensions?.map((entry) => {
      if (typeof entry === "string") {
        const equalPos = entry.indexOf("=");
        if (equalPos > 0) {
          return { key: entry.slice(0, equalPos), value: entry.slice(equalPos + 1) };
        }
        return { key: entry, value: "true" };
      } else if ("key" in entry && "value" in entry && typeof entry.key === "string" && typeof entry.value === "string") {
        return { key: entry.key, value: entry.value };
      }
      throw new Error("failed to create cookie, extension must be: { key: string; value: string }[]");
    });
    return {
      key: cookieObj.key,
      value: cookieObj.value,
      expires: cookieObj.expires || void 0,
      maxAge: cookieObj.maxAge,
      domain: cookieObj.domain || void 0,
      path: cookieObj.path || void 0,
      secure: cookieObj.secure || false,
      httpOnly: cookieObj.httpOnly || false,
      hostOnly,
      session,
      extensions
    };
  }
  static stringify(cookie) {
    return cookie.toString();
  }
  static unparseSingle(cookieOpt) {
    const cookie = new _Cookie(cookieOpt);
    if (!cookie) {
      throw new Error("failed to unparse cookie, the cookie options seems invalid");
    }
    return cookie.toString();
  }
  static unparse(cookies) {
    const cookieStrs = cookies.map((cookie) => cookie.toString());
    return cookieStrs.join("; ");
  }
  toString = () => {
    const hostOnlyPart = this.cookie.hostOnly ? "; HostOnly" : "";
    const sessionPart = this.cookie.extensions?.includes("session") ? "; Session" : "";
    const extensionPart = this.extensions && this.extensions.length > 0 ? "; " + this.extensions.map((ext) => `${ext.key}=${ext.value}`).join(";") : "";
    return this.cookie.toString() + hostOnlyPart + sessionPart + extensionPart;
  };
  valueOf = () => {
    return this.cookie.toJSON().value;
  };
  get key() {
    return this.cookie.toJSON().key;
  }
  toJSON = () => {
    return {
      id: this.id,
      key: this.cookie.key,
      value: this.cookie.value,
      expires: this.cookie.expires === "Infinity" ? void 0 : this.cookie.expires,
      maxAge: this.cookie.maxAge,
      domain: this.cookie.domain,
      path: this.cookie.path,
      secure: this.cookie.secure,
      httpOnly: this.cookie.httpOnly,
      hostOnly: this.cookie.hostOnly,
      session: this.cookie.extensions?.includes("session"),
      extensions: this.extensions,
      // extra fields from Insomnia
      creation: this.insoExtensions.creation,
      creationIndex: this.insoExtensions.creationIndex,
      lastAccessed: this.insoExtensions.lastAccessed,
      pathIsDefault: this.insoExtensions.pathIsDefault
    };
  };
};
var CookieList = class extends PropertyList {
  _kind = "CookieList";
  constructor(cookies) {
    super(Cookie, void 0, cookies);
  }
  static isCookieList(obj) {
    return "_kind" in obj && obj._kind === "CookieList";
  }
};
var CookieObject = class extends CookieList {
  cookieJar;
  constructor(cookieJar2) {
    const cookies = cookieJar2 ? cookieJar2.cookies.map((cookie) => {
      let expires = null;
      if (cookie.expires || cookie.expires === 0) {
        if (typeof cookie.expires === "number") {
          expires = new Date(cookie.expires);
        } else {
          expires = cookie.expires;
        }
      }
      return new Cookie({
        id: cookie.id,
        key: cookie.key,
        value: cookie.value,
        expires,
        maxAge: void 0,
        // not supported in Insomnia
        domain: cookie.domain,
        path: cookie.path,
        secure: cookie.secure,
        httpOnly: cookie.httpOnly,
        hostOnly: cookie.hostOnly,
        session: void 0,
        // not supported in Insomnia
        extensions: void 0,
        // TODO: its format from Insomnia is unknown
        // follows are properties from Insomnia
        creation: cookie.creation,
        creationIndex: cookie.creationIndex,
        lastAccessed: cookie.lastAccessed,
        pathIsDefault: cookie.pathIsDefault
      });
    }) : [];
    super(cookies);
    const scriptCookieJar = cookieJar2 ? new CookieJar(cookieJar2.name, cookies) : new CookieJar("", []);
    this.cookieJar = scriptCookieJar;
    this.typeClass = Cookie;
  }
  jar() {
    return this.cookieJar;
  }
};
var CookieJar = class {
  // CookieJar from tough-cookie can not be used, as it will fail in comparing context location and cookies' domain
  // as it reads location from the browser window, it is "localhost"
  jar;
  // Map<domain, Map<cookieKey, cookieObject>>
  jarName;
  constructor(jarName, cookies) {
    this.jarName = jarName;
    this.jar = /* @__PURE__ */ new Map();
    if (cookies) {
      cookies.forEach((cookie) => {
        const properties = cookie.toJSON();
        if (!properties.domain) {
          getExistingConsole().warn(`domain is not specified for the cookie "${cookie.key}" so it is omitted`);
          return;
        }
        const domainCookies = this.jar.get(properties.domain) || /* @__PURE__ */ new Map();
        this.jar.set(properties.domain, domainCookies.set(properties.key, cookie));
      });
    }
  }
  set(url, key, value, cb) {
    const domainCookies = this.jar.get(url) || /* @__PURE__ */ new Map();
    if (typeof value === "string") {
      const domainCookie = new Cookie({
        key,
        value,
        domain: url
      });
      this.jar.set(url, domainCookies.set(key, domainCookie));
      cb(void 0, domainCookie);
    } else {
      const domainCookie = new Cookie(value);
      this.jar.set(url, domainCookies.set(key, domainCookie));
      cb(void 0, domainCookie);
    }
  }
  // TODO: create a better method for setting cookie, or overload the above method
  // set(
  //     url: string,
  //     info: { name: string; value: string; httpOnly: boolean },
  //     cb: (error?: Error, cookie?: Cookie) => void,
  // ) {
  //     try {
  //         const cookie = new ToughCookie({ key: info.name, value: info.value, httpOnly: info.httpOnly });
  //         this.jar.setCookieSync(cookie, url, { http: info.httpOnly });
  //         cb(undefined, new Cookie({ key: info.name, value: info.value, httpOnly: info.httpOnly }));
  //     } catch (e) {
  //         cb(e, undefined);
  //     }
  // }
  get(url, name, cb) {
    const domainCookies = this.jar.get(url) || /* @__PURE__ */ new Map();
    cb(void 0, domainCookies.get(name));
  }
  getAll(url, cb) {
    const domainCookies = this.jar.get(url) || /* @__PURE__ */ new Map();
    cb(void 0, Array.from(domainCookies.values()));
  }
  unset(url, name, cb) {
    const domainCookies = this.jar.get(url);
    if (!domainCookies) {
      cb(void 0);
    } else {
      domainCookies.delete(name);
      cb(void 0);
    }
  }
  clear(url, cb) {
    this.jar.delete(url);
    cb(void 0);
  }
  toInsomniaCookieJar() {
    const cookies = new Array();
    Array.from(this.jar.values()).forEach((domainCookies) => {
      Array.from(domainCookies.values()).forEach((cookie) => {
        const cookieObj = cookie.toJSON();
        cookies.push({
          id: cookieObj.id,
          key: cookieObj.key,
          value: cookieObj.value,
          expires: cookieObj.expires || "Infinity",
          // transform it back to 'Infinity', avoid edge cases
          domain: cookieObj.domain || void 0,
          path: cookieObj.path || void 0,
          secure: cookieObj.secure,
          httpOnly: cookieObj.httpOnly,
          extensions: cookieObj.extensions || void 0,
          creation: cookieObj.creation,
          creationIndex: cookieObj.creationIndex,
          hostOnly: cookieObj.hostOnly || void 0,
          pathIsDefault: cookieObj.pathIsDefault,
          lastAccessed: cookieObj.lastAccessed
        });
      });
    });
    return {
      name: this.jarName,
      cookies
    };
  }
};
function mergeCookieJar(originalCookieJar, updatedCookieJar) {
  const cookiesWithId = updatedCookieJar.cookies.map((cookie) => {
    if (!cookie.id) {
      cookie.id = v4_default();
    }
    return cookie;
  });
  return {
    ...originalCookieJar,
    cookies: cookiesWithId
  };
}

// ../insomnia-scripting-environment/src/objects/headers.ts
var Header = class _Header extends Property {
  /** @ignore */
  _kind = "Header";
  /**
   * Represents the name of the header.
   */
  key;
  /**
   * Represents the value of a header.
   */
  value;
  /**
   * Constructs a new instance of the class with the provided header definition or string.
   *
   * @param opts - A `HeaderDefinition` object or a string representing a single header.
   *               If a string is provided, it will be parsed into a header object.
   * @param name - (Optional) A string that overrides the `key` property of the header.
   *               If not provided, the `name` property from the `opts` object will be used.
   */
  constructor(opts, name) {
    super();
    if (typeof opts === "string") {
      const obj = _Header.parseSingle(opts);
      this.key = obj.key;
      this.value = obj.value;
    } else {
      this.id = opts.id ? opts.id : "";
      this.key = opts.key ? opts.key : "";
      this.name = name ? name : opts.name ? opts.name : "";
      this.value = opts.value ? opts.value : "";
      this.disabled = opts ? opts.disabled : false;
    }
  }
  /** @ignore */
  static _index = "key";
  /**
   * Creates a new `Header` instance.
   *
   * @param input - An object containing `key` and `value` properties, or a string.
   *                If not provided, defaults to an object with empty `key` and `value`.
   * @param name - An optional name for the header.
   * @returns A new `Header` instance.
   */
  static create(input, name) {
    return new _Header(input || { key: "", value: "" }, name);
  }
  /**
   * Determines if the given object is a Header object.
   * @param obj - The object to check.
   * @returns `true` if the object is a Header, otherwise `false`.
   */
  static isHeader(obj) {
    return "_kind" in obj && obj._kind === "Header";
  }
  // example: 'Content-Type: application/json\nUser-Agent: MyClientLibrary/2.0\n'
  /**
   * Parses a header string into an array of key-value pair objects.
   *
   * The input string is expected to have headers separated by newline characters.
   * Each non-empty line is processed and converted into an object with `key` and `value` properties.
   *
   * @param headerString - The raw header string to be parsed.
   * @returns An array of objects, where each object represents a header with `key` and `value` properties.
   */
  static parse(headerString) {
    return headerString.split("\n").filter((kvPart) => kvPart.trim() !== "").map((kvPart) => _Header.parseSingle(kvPart));
  }
  /**
   * Parses a single HTTP header string into an object containing the key and value.
   *
   * The input string should follow the format `Key: Value`, where the first colon (`:`)
   * separates the header key from its value. Leading and trailing whitespace around
   * the key and value will be trimmed.
   *
   * @param headerStr - The HTTP header string to parse.
   * @returns An object containing the `key` and `value` of the header.
   * @throws {Error} If the input string does not contain a colon or is otherwise invalid.
   *
   * @example
   * ```typescript
   * const header = Headers.parseSingle('Content-Type: application/json');
   * console.log(header); // { key: 'Content-Type', value: 'application/json' }
   * ```
   */
  static parseSingle(headerStr) {
    const separatorPos = headerStr.indexOf(":");
    if (separatorPos <= 0) {
      throw new Error("Header.parseSingle: the header string seems invalid");
    }
    const key = headerStr.slice(0, separatorPos);
    const value = headerStr.slice(separatorPos + 1);
    return { key: key.trim(), value: value.trim() };
  }
  /**
   * Converts an array of headers into a single string representation.
   *
   * @param headers - An array of header objects, each containing a `key` and `value` property,
   * or a `PropertyList` of `Header` objects.
   * @param separator - An optional string used to separate the headers in the resulting string.
   * Defaults to a newline character (`\n`) if not provided.
   * @returns A string representation of the headers, joined by the specified separator.
   */
  static unparse(headers, separator) {
    const headerArray = headers.map((header) => this.unparseSingle(header), {});
    return headerArray.join(separator || "\n");
  }
  /**
   * Converts a header object into a single header string in the format "key: value".
   *
   * @param header - The header object to unparse. It can either be an object with
   *                 `key` and `value` properties or an instance of the `Header` class.
   * @returns The header represented as a string in the format "key: value".
   */
  static unparseSingle(header) {
    return `${header.key}: ${header.value}`;
  }
  /**
   * Updates the current header with a new key-value pair.
   *
   * @param newHeader - An object containing the new key and value for the header.
   *   - `key`: The new key for the header.
   *   - `value`: The new value for the header.
   */
  update(newHeader) {
    this.key = newHeader.key;
    this.value = newHeader.value;
  }
  /**
   * Return the value of the current object.
   *
   * @returns The value associated with the current object.
   */
  valueOf() {
    return this.value;
  }
};
var HeaderList = class extends PropertyList {
  /**
   * Constructs a new instance of the class.
   *
   * @param parent - The parent `PropertyList` instance or `undefined` if there is no parent.
   * @param populate - An array of items of {@link Header} to initialize the list with.
   */
  constructor(parent, populate) {
    super(Header, void 0, populate);
    this.parent = parent;
  }
  /**
   * Determines if the given object is a HeaderList.
   * @param obj - The object to check.
   * @returns `true` if the object is a HeaderList, otherwise `false`.
   */
  static isHeaderList(obj) {
    return "_kind" in obj && obj._kind === "HeaderList";
  }
  /**
   * Calculates the total size of all headers in the list.
   *
   * This method maps each header to its string representation, calculates the
   * length of each string, and sums up the lengths to determine the total size.
   *
   * @returns The total size of all headers as a number.
   */
  contentSize() {
    return this.list.map((header) => header.toString()).map((headerStr) => headerStr.length).reduce((totalSize, headerSize) => totalSize + headerSize, 0);
  }
};

// ../insomnia-scripting-environment/src/objects/proxy-configs.ts
var ProxyConfig = class extends Property {
  /** @ignore */
  _kind = "ProxyConfig";
  /**
   * The hostname or IP address of the proxy server.
   */
  host;
  /**
   * A string pattern used to match specific criteria or conditions.
   * This can be used for filtering or identifying relevant configurations.
   */
  match;
  /**
   * The port number to be used for the proxy configuration.
   * This is an optional property and, if not specified, the default port
   * for the protocol being used will be applied.
   */
  port;
  tunnel;
  /**
   * Indicates whether authentication is required for the proxy configuration.
   */
  authenticate;
  /**
   * The username associated with the proxy configuration.
   */
  username;
  /**
   * The password associated with the proxy configuration.
   */
  password;
  /**
   * A list of hostnames or IP addresses to bypass the proxy for.
   */
  bypass;
  // it is for compatibility with Insomnia's bypass list
  /**
   * The protocol used in the proxy configuration, such as "http" or "https".
   */
  protocol;
  // following properties are hidden as they are not used while must be exposed
  /** @ignore */
  static authenticate = false;
  /** @ignore */
  static bypass = new UrlMatchPatternList(void 0, []);
  /** @ignore */
  static host = "";
  /** @ignore */
  static match = "";
  /** @ignore */
  static password = "";
  /** @ignore */
  static port = void 0;
  /** @ignore */
  static tunnel = false;
  // unsupported
  /** @ignore */
  static username = "";
  /** @ignore */
  static protocol = "https:";
  /**
   * Constructs a new instance of the proxy configuration object.
   *
   * @param def - The definition object containing the proxy configuration properties.
   * @param def.id - (Optional) The unique identifier for the proxy configuration.
   * @param def.name - (Optional) The name of the proxy configuration.
   * @param def.match - The match pattern for the proxy configuration. It is used to initialize the {@link UrlMatchPattern} object internally.
   * @param def.host - The host address of the proxy server.
   * @param def.port - (Optional) The port number of the proxy server.
   * @param def.tunnel - Indicates whether the proxy uses tunneling.
   * @param def.disabled - (Optional) Indicates whether the proxy configuration is disabled.
   * @param def.authenticate - Indicates whether the proxy requires authentication.
   * @param def.username - The username for proxy authentication.
   * @param def.password - The password for proxy authentication.
   * @param def.bypass - (Optional) A list of hosts to bypass the proxy.
   * @param def.protocol - The protocol used by the proxy (e.g., HTTP, HTTPS).
   */
  constructor(def) {
    super();
    this.id = def.id ? def.id : "";
    this.name = def.name ? def.name : "";
    this.disabled = def.disabled ? def.disabled : false;
    this.host = def.host;
    this.match = def.match;
    this.port = def.port;
    this.tunnel = def.tunnel;
    this.authenticate = def.authenticate;
    this.username = def.username;
    this.password = def.password;
    this.bypass = def.bypass || [];
    this.protocol = def.protocol;
  }
  static _index = "key";
  /**
   * Determines if the given object is a ProxyConfig.
   * @param obj - The object to check.
   * @returns `true` if the object is a ProxyConfig, otherwise `false`.
   */
  static isProxyConfig(obj) {
    return "_kind" in obj && obj._kind === "ProxyConfig";
  }
  /**
   * Retrieves the list of protocols specified in the match pattern.
   *
   * The match pattern is expected to follow a format such as
   * 'http+https://example.com/*', where protocols are separated by a '+'.
   * This method parses the match pattern and extracts the protocols.
   *
   * @returns {string[]} An array of protocol strings extracted from the match pattern.
   */
  getProtocols() {
    const urlMatch = new UrlMatchPattern(this.match);
    return urlMatch.getProtocols();
  }
  /**
   * Constructs and returns the full proxy URL as a string.
   *
   * The URL is built based on the protocol, host, port, and optional
   * authentication credentials (username and password) of the proxy.
   *
   * @returns {string} The full proxy URL in the format:
   *   - With authentication: `protocol://username:password@host:port`
   *   - Without authentication: `protocol://host:port`
   */
  getProxyUrl() {
    const portSegment = this.port === void 0 ? "" : `:${this.port}`;
    if (this.authenticate) {
      return `${this.protocol}//${this.username}:${this.password}@${this.host}${portSegment}`;
    }
    return `${this.protocol}//${this.host}${portSegment}`;
  }
  /**
   * Tests whether a given URL matches the proxy configuration.
   *
   * @param url - The URL to test. If not provided, the method will return `false`.
   * @returns `true` if the URL matches the proxy configuration and is not bypassed;
   *          otherwise, `false`.
   */
  test(url) {
    if (!url) {
      return false;
    }
    if (this.bypass.includes(url)) {
      return false;
    }
    const urlMatch = new UrlMatchPattern(this.match);
    return urlMatch.test(url);
  }
  /**
   * Updates the proxy configuration with the provided options.
   *
   * @param options - An object containing the new proxy configuration options.
   *                  The `bypass` and `protocol` properties are omitted and cannot be updated.
   *                  The following properties can be updated:
   *                  - `host`: The hostname or IP address of the proxy server.
   *                  - `match`: A pattern to match URLs for which the proxy should be used.
   *                  - `port`: The port number of the proxy server.
   *                  - `tunnel`: A boolean indicating whether to use tunneling.
   *                  - `authenticate`: A boolean indicating whether authentication is required.
   *                  - `username`: The username for proxy authentication.
   *                  - `password`: The password for proxy authentication.
   */
  update(options) {
    this.host = options.host;
    this.match = options.match;
    this.port = options.port;
    this.tunnel = options.tunnel;
    this.authenticate = options.authenticate;
    this.username = options.username;
    this.password = options.password;
  }
  /**
   * Updates the list of protocols. Currently this method is not supported in Insomnia
   *
   * @param _protocols - An array of protocol strings to update.
   * @throws {Error} Always throws an error indicating that this method is not supported.
   */
  updateProtocols(_protocols) {
    throw new Error("updateProtocols is not supported in Insomnia");
  }
};
function transformToSdkProxyOptions(httpProxy, httpsProxy, proxyEnabled, noProxy) {
  const bestProxy = httpsProxy || httpProxy || "";
  const enabledProxy = proxyEnabled && bestProxy.trim() !== "";
  const bypassProxyList = noProxy ? noProxy.split(",").map((urlStr) => urlStr.trim()) : [];
  const proxy = {
    disabled: !enabledProxy,
    match: "<all_urls>",
    bypass: bypassProxyList,
    host: "",
    port: void 0,
    tunnel: false,
    authenticate: false,
    username: "",
    password: "",
    protocol: "http"
  };
  if (bestProxy !== "") {
    let sanitizedProxy = bestProxy;
    if (!bestProxy.includes("://")) {
      getExistingConsole().warn(`The protocol is missing for proxy, 'https:' is enabled for: ${bestProxy}`);
      sanitizedProxy = `https://${bestProxy}`;
    }
    try {
      const sanitizedProxyUrlOptions = new URL(sanitizedProxy);
      if (sanitizedProxyUrlOptions.port !== "") {
        proxy.port = parseInt(sanitizedProxyUrlOptions.port, 10);
      }
      proxy.protocol = sanitizedProxyUrlOptions.protocol;
      proxy.host = sanitizedProxyUrlOptions.hostname;
      proxy.username = sanitizedProxyUrlOptions.username;
      proxy.password = sanitizedProxyUrlOptions.password;
      if (proxy.username || proxy.password) {
        proxy.authenticate = true;
      }
    } catch (e2) {
      throw new Error(`Failed to parse proxy (${sanitizedProxy}): ${e2.message}`);
    }
  }
  return proxy;
}

// ../insomnia-scripting-environment/src/objects/request.ts
init_client_certificate();
var FormParam = class extends Property {
  key;
  value;
  type;
  constructor(options) {
    super();
    this.key = options.key;
    this.value = options.value;
    this.type = options.type;
    this.disabled = options.disabled;
  }
  static _postman_propertyAllowsMultipleValues() {
    throw new Error("unsupported");
  }
  static _postman_propertyIndexKey() {
    throw new Error("unsupported");
  }
  // TODO: it is not supported yet in existing scripts
  // static parse(param: FormParam) {
  // }
  toJSON() {
    return { key: this.key, value: this.value, type: this.type, disabled: this.disabled };
  }
  toString() {
    const key = encodeURIComponent(this.key);
    const value = encodeURIComponent(this.value);
    return `${key}=${value}`;
  }
  valueOf() {
    return this.value;
  }
};
function getClassFields(opts) {
  const formdata = opts.formdata ? new PropertyList(
    FormParam,
    void 0,
    opts.formdata.map(
      (formParamObj) => new FormParam({
        ...formParamObj
      })
    )
  ) : void 0;
  let urlencoded = void 0;
  if (opts.urlencoded != null) {
    if (typeof opts.urlencoded === "string") {
      const queryParamObj = QueryParam.parse(opts.urlencoded);
      urlencoded = new PropertyList(
        QueryParam,
        void 0,
        Object.entries(queryParamObj).map((entry) => ({ key: entry[0], value: JSON.stringify(entry[1]) })).map((kv) => new QueryParam(kv))
      );
    } else {
      urlencoded = new PropertyList(
        QueryParam,
        void 0,
        opts.urlencoded.map((entry) => ({
          key: entry.key,
          value: entry.value,
          type: entry.type,
          disabled: entry.disabled,
          fileName: entry.fileName,
          multiline: entry.multiline
        })).map((kv) => new QueryParam(kv))
      );
    }
  }
  return {
    mode: opts.mode,
    file: opts.file,
    graphql: opts.graphql,
    raw: opts.raw,
    options: opts.options,
    formdata,
    urlencoded
  };
}
var RequestBody = class extends PropertyBase {
  mode;
  // type of request data
  // It can be a file path (when used with Node.js) or a unique ID (when used with the browser).
  // or it could be "data:application/octet-stream;base64"
  file;
  formdata;
  graphql;
  // raw graphql data
  // TODO: option's usage is unknown
  raw;
  // raw body
  urlencoded;
  // URL encoded body params
  options;
  // request body options
  constructor(opts) {
    super();
    const transformedOpts = getClassFields(opts);
    this.mode = transformedOpts.mode;
    this.file = transformedOpts.file;
    this.formdata = transformedOpts.formdata;
    this.graphql = transformedOpts.graphql;
    this.options = transformedOpts.options;
    this.raw = transformedOpts.raw;
    this.urlencoded = transformedOpts.urlencoded;
  }
  isEmpty() {
    switch (this.mode) {
      case "formdata": {
        return this.formdata == null;
      }
      case "urlencoded": {
        return this.urlencoded == null;
      }
      case "raw": {
        return this.raw == null;
      }
      case "file": {
        return this.file == null;
      }
      case "graphql": {
        return this.graphql == null;
      }
      default: {
        throw new Error(`isEmpty: mode (${this.mode}) is unexpected`);
      }
    }
  }
  toString() {
    if (this.mode === void 0) {
      return "";
    }
    try {
      switch (this.mode) {
        case "formdata": {
          return this.formdata?.map((param) => param.toString(), {}).join("&") || "";
        }
        case "urlencoded": {
          return this.urlencoded?.map((param) => param.toString(), {}).join("&") || "";
        }
        case "raw": {
          return this.raw || "";
        }
        case "file": {
          return this.file || "";
        }
        case "graphql": {
          return this.graphql ? JSON.stringify(this.graphql) : "";
        }
        default: {
          throw new Error(`mode (${this.mode}) is unexpected`);
        }
      }
    } catch (e2) {
      throw new Error(`toString: ${e2}`);
    }
  }
  update(opts) {
    const transformedOpts = getClassFields(opts);
    this.mode = transformedOpts.mode;
    this.file = transformedOpts.file;
    this.formdata = transformedOpts.formdata;
    this.graphql = transformedOpts.graphql;
    this.options = transformedOpts.options;
    this.raw = transformedOpts.raw;
    this.urlencoded = transformedOpts.urlencoded;
  }
};
function requestOptionsToClassFields(options) {
  const url = toUrlObject(options.url);
  const method2 = options.method || "GET";
  let headers;
  if (options.header != null) {
    if (Array.isArray(options.header)) {
      headers = new HeaderList(void 0, options.header ? options.header.map((header) => new Header(header)) : []);
    } else {
      headers = new HeaderList(
        void 0,
        Object.entries(options.header).map((entry) => new Header({ key: entry[0], value: entry[1] }))
      );
    }
  } else {
    headers = new HeaderList(void 0, new Array());
  }
  const body = options.body ? new RequestBody(options.body) : void 0;
  const auth = new RequestAuth(options.auth || { type: "noauth" });
  const proxy = options.proxy ? new ProxyConfig(options.proxy) : void 0;
  const certificate = options.certificate ? new Certificate(options.certificate) : void 0;
  const pathParameters = options.pathParameters ? options.pathParameters : new Array();
  return {
    name: options.name || "",
    url,
    method: method2,
    headers,
    body,
    auth,
    proxy,
    certificate,
    pathParameters
  };
}
var Request2 = class _Request extends Property {
  name;
  url;
  method;
  headers;
  body;
  auth;
  proxy;
  certificate;
  pathParameters;
  constructor(options) {
    super();
    this._kind = "Request";
    const transformedOpts = requestOptionsToClassFields(options);
    this.name = transformedOpts.name;
    this.url = transformedOpts.url;
    this.method = transformedOpts.method;
    this.headers = transformedOpts.headers;
    this.body = transformedOpts.body;
    this.auth = transformedOpts.auth;
    this.proxy = transformedOpts.proxy;
    this.certificate = transformedOpts.certificate;
    this.pathParameters = transformedOpts.pathParameters;
  }
  static isRequest(obj) {
    return "_kind" in obj && obj._kind === "Request";
  }
  addHeader(header) {
    if (Header.isHeader(header)) {
      const headerInstance = header;
      this.headers.add(headerInstance);
    } else if ("key" in header && "value" in header) {
      const headerInstance = new Header(header);
      this.headers.add(headerInstance);
    } else {
      throw new Error("header must be Header | {key: string; value: string}");
    }
  }
  addQueryParams(params) {
    this.url.addQueryParams(params);
  }
  authorizeUsing(authType, options) {
    const selectedAuth = typeof authType === "string" ? authType : authType.type;
    this.auth.use(selectedAuth, options || { type: "noauth" });
  }
  clone() {
    return new _Request({ ...this.toJSON() });
  }
  forEachHeader(callback) {
    this.headers.each(callback, {});
  }
  getHeaders(options) {
    const headerMap = /* @__PURE__ */ new Map();
    this.headers.each((header) => {
      const enabled = options?.enabled ? header.disabled == null || !header.disabled : true;
      const isFalsyValue = options?.sanitizeKeys ? !header.value : false;
      const hasName = !!header.key;
      if (!enabled || isFalsyValue || !hasName) {
        return;
      }
      header.key = options?.ignoreCase ? header.key?.toLocaleLowerCase() : header.key;
      if (headerMap.has(header.key)) {
        const existingHeader = headerMap.get(header.key) || [];
        headerMap.set(header.key, [...existingHeader, header.value]);
      } else {
        headerMap.set(header.key, [header.value]);
      }
    }, {});
    const headersObj = {};
    Array.from(headerMap.entries()).forEach((headerEntry) => {
      headersObj[headerEntry[0]] = headerEntry[1];
    });
    return headersObj;
  }
  removeHeader(toRemove, options) {
    const filteredHeaders = this.headers.filter((header) => {
      if (!header.key) {
        return false;
      }
      if (typeof toRemove === "string") {
        return options != null && options.ignoreCase ? header.key.toLocaleLowerCase() !== toRemove.toLocaleLowerCase() : header.key !== toRemove;
      } else if (toRemove instanceof Header) {
        if (!toRemove.key) {
          return false;
        }
        return options != null && options.ignoreCase ? header.key.toLocaleLowerCase() !== toRemove.key.toLocaleLowerCase() : header.key !== toRemove.key;
      }
      throw new Error('type of the "toRemove" must be: string | Header');
    }, {});
    this.headers = new HeaderList(void 0, filteredHeaders);
  }
  removeQueryParams(params) {
    this.url.removeQueryParams(params);
  }
  size() {
    return calculatePayloadSize((this.body || "").toString(), this.headers);
  }
  toJSON() {
    return {
      url: this.url.toString(),
      method: this.method,
      header: this.headers.map((header) => header.toJSON(), {}),
      body: {
        mode: this.body?.mode,
        file: this.body?.file,
        formdata: this.body?.formdata?.map((formParam) => formParam.toJSON(), {}),
        graphql: this.body?.graphql,
        raw: this.body?.raw,
        urlencoded: this.body?.urlencoded?.map((queryParam) => queryParam.toJSON(), {})
      },
      auth: this.auth.toJSON(),
      proxy: this.proxy ? {
        match: this.proxy.match,
        host: this.proxy.host,
        port: this.proxy.port,
        tunnel: this.proxy.tunnel,
        disabled: this.proxy.disabled,
        authenticate: this.proxy.authenticate,
        username: this.proxy.username,
        password: this.proxy.password,
        protocol: this.proxy.protocol
      } : void 0,
      certificate: this.certificate ? {
        name: this.certificate?.name,
        matches: this.certificate?.matches?.map((match) => match.toString(), {}),
        key: this.certificate?.key,
        cert: this.certificate?.cert,
        passphrase: this.certificate?.passphrase,
        pfx: this.certificate?.pfx
      } : void 0
    };
  }
  update(options) {
    const transformedOptions = requestOptionsToClassFields(options);
    this.name = transformedOptions.name;
    this.url = transformedOptions.url;
    this.method = transformedOptions.method;
    this.headers = transformedOptions.headers;
    this.body = transformedOptions.body;
    this.auth = transformedOptions.auth;
    this.proxy = transformedOptions.proxy;
    this.certificate = transformedOptions.certificate;
    this.pathParameters = transformedOptions.pathParameters;
  }
  upsertHeader(header) {
    this.headers = new HeaderList(
      void 0,
      this.headers.filter((existingHeader) => existingHeader.key !== header.key, {})
    );
    this.headers.append(new Header(header));
  }
};
function mergeSettings(originalSettings, updatedReq) {
  const proxyEnabled = updatedReq.proxy != null && !updatedReq.proxy.disabled && updatedReq.proxy.getProxyUrl() !== "";
  if (!proxyEnabled) {
    return originalSettings;
  }
  const proxyUrl = updatedReq.proxy?.getProxyUrl();
  if (!proxyUrl) {
    return originalSettings;
  }
  const httpProxy = proxyUrl;
  const httpsProxy = proxyUrl;
  return {
    ...originalSettings,
    proxyEnabled,
    httpProxy,
    httpsProxy
  };
}
function mergeClientCertificates(originalClientCertificates, updatedReq) {
  if (!updatedReq.certificate) {
    return originalClientCertificates;
  } else if (updatedReq.certificate.key == null && updatedReq.certificate.cert == null && updatedReq.certificate.pfx == null) {
    return originalClientCertificates;
  }
  const baseCertificate = originalClientCertificates && originalClientCertificates.length > 0 ? {
    // TODO: remove baseModelPart currently it is necessary for type checking
    ...init3(),
    ...originalClientCertificates[0]
  } : {
    // TODO: remove baseModelPart currently it is necessary for type checking
    ...init3(),
    _id: "",
    type: "",
    parentId: "",
    modified: 0,
    created: 0,
    isPrivate: false,
    name: ""
  };
  if (updatedReq.certificate.pfx && updatedReq.certificate.pfx?.src !== "") {
    const specifiedCert = {
      ...baseCertificate,
      type: "ClientCertificate",
      key: null,
      cert: null,
      name: updatedReq.certificate.name || "",
      disabled: updatedReq.certificate.disabled || false,
      passphrase: updatedReq.certificate.passphrase || null,
      pfx: updatedReq.certificate.pfx?.src,
      host: "*"
    };
    return [specifiedCert, ...originalClientCertificates];
  } else if (updatedReq && updatedReq.certificate.key && updatedReq.certificate.cert && updatedReq.certificate.key?.src !== "" && updatedReq.certificate.cert?.src !== "") {
    const specifiedCert = {
      ...baseCertificate,
      _id: "",
      type: "ClientCertificate",
      parentId: "",
      modified: 0,
      created: 0,
      isPrivate: false,
      name: updatedReq.certificate.name || "",
      disabled: updatedReq.certificate.disabled || false,
      host: "*",
      key: updatedReq.certificate.key?.src,
      cert: updatedReq.certificate.cert?.src,
      passphrase: updatedReq.certificate.passphrase || null,
      pfx: null
    };
    return [specifiedCert, ...originalClientCertificates];
  }
  throw new Error('Invalid certificate configuration: "cert+key" and "pfx" can not be set at the same time');
}
function toScriptRequestBody(insomniaReqBody) {
  let reqBodyOpt = { mode: void 0 };
  if (insomniaReqBody.text !== void 0) {
    reqBodyOpt = {
      mode: "raw",
      raw: insomniaReqBody.text
    };
  } else if (insomniaReqBody.fileName !== void 0 && insomniaReqBody.fileName !== "") {
    reqBodyOpt = {
      mode: "file",
      file: insomniaReqBody.fileName
    };
  } else if (insomniaReqBody.params !== void 0) {
    reqBodyOpt = {
      mode: "urlencoded",
      urlencoded: insomniaReqBody.params.map((param) => ({
        key: param.name,
        value: param.value,
        type: param.type,
        multiline: param.multiline,
        disabled: param.disabled,
        fileName: param.fileName
      }))
    };
  }
  return reqBodyOpt;
}
function mergeRequestBody(updatedReqBody, originalReqBody) {
  let mimeType = "application/octet-stream";
  if (updatedReqBody) {
    switch (updatedReqBody.mode) {
      case void 0: {
        mimeType = "application/octet-stream";
        break;
      }
      case "raw": {
        mimeType = "text/plain";
        break;
      }
      case "file": {
        mimeType = "application/octet-stream";
        break;
      }
      case "formdata": {
        mimeType = "multipart/form-data";
        break;
      }
      case "urlencoded": {
        mimeType = "application/x-www-form-urlencoded";
        break;
      }
      case "graphql": {
        mimeType = "application/json";
        break;
      }
      default: {
        throw new Error(`unknown request body mode: ${updatedReqBody.mode}`);
      }
    }
  }
  if (originalReqBody.mimeType) {
    mimeType = originalReqBody.mimeType;
  }
  try {
    const textContent = updatedReqBody?.raw !== void 0 ? updatedReqBody?.raw : updatedReqBody?.graphql ? JSON.stringify(updatedReqBody?.graphql) : void 0;
    return {
      mimeType,
      text: textContent,
      fileName: updatedReqBody?.file,
      params: updatedReqBody?.urlencoded?.map((param) => {
        return {
          name: param.key,
          value: param.value,
          type: param.type,
          fileName: param.fileName,
          multiline: param.multiline,
          disabled: param.disabled
        };
      }, {})
    };
  } catch (e2) {
    throw new Error(`failed to update body: ${e2}`);
  }
}
function mergeRequests(originalReq, updatedReq) {
  const queryParamObjects = updatedReq.url.query.map(
    (queryParam) => ({
      name: queryParam.key,
      value: queryParam.value,
      disabled: queryParam.disabled
    }),
    {}
  );
  const updatedReqProperties = {
    name: updatedReq.name,
    url: updatedReq.url.toStringWithoutQuery(),
    method: updatedReq.method,
    body: mergeRequestBody(updatedReq.body, originalReq.body),
    headers: updatedReq.headers.map(
      (header) => ({
        name: header.key,
        value: header.value,
        disabled: header.disabled
      }),
      {}
    ),
    authentication: fromPreRequestAuth(updatedReq.auth),
    preRequestScript: "",
    pathParameters: updatedReq.pathParameters,
    parameters: queryParamObjects
  };
  return {
    ...originalReq,
    ...updatedReqProperties
  };
}
function calculatePayloadSize(body, headers) {
  const bodySize = new Blob([body]).size;
  const headerSize = calculateHeadersSize(headers);
  return {
    body: bodySize,
    header: headerSize,
    total: bodySize + headerSize,
    source: "COMPUTED"
  };
}
function calculateHeadersSize(headers) {
  const headerSize = new Blob([headers.reduce((acc, header) => acc + header.toString() + "\n", "", {})]).size;
  return headerSize;
}

// ../insomnia-scripting-environment/src/objects/response.ts
var import_ajv = __toESM(require_ajv());

// ../../node_modules/chai/index.mjs
var import_index4 = __toESM(require_chai2(), 1);
var expect = import_index4.default.expect;
var version2 = import_index4.default.version;
var Assertion = import_index4.default.Assertion;
var AssertionError = import_index4.default.AssertionError;
var util = import_index4.default.util;
var config = import_index4.default.config;
var use = import_index4.default.use;
var should = import_index4.default.should;
var assert = import_index4.default.assert;
var core = import_index4.default.core;

// ../insomnia-scripting-environment/src/objects/response.ts
init_constants();
init_response();
var Response2 = class _Response extends Property {
  body;
  code;
  cookies;
  headers;
  originalRequest;
  responseTime;
  status;
  stream;
  bytesRead;
  //
  constructor(options) {
    super();
    this._kind = "Response";
    this.body = options.body || "";
    this.code = options.code;
    this.cookies = new CookieList(options.cookie?.map((cookie) => new Cookie(cookie)) || []);
    this.headers = new HeaderList(void 0, options.header?.map((headerOpt) => new Header(headerOpt)) || []);
    this.originalRequest = options.originalRequest;
    this.responseTime = options.responseTime;
    this.stream = options.stream;
    this.status = options.reason || RESPONSE_CODE_REASONS[options.code] || "";
    this.bytesRead = options.bytesRead || 0;
  }
  // TODO: the accurate type of the response should be given
  static createFromNode(response, cookies) {
    return new _Response({
      cookie: cookies,
      body: response.body.toString(),
      stream: response.stream,
      header: response.headers,
      code: response.statusCode,
      reason: response.statusMessage,
      responseTime: response.elapsedTime,
      originalRequest: response.originalRequest
    });
  }
  static isResponse(obj) {
    return "_kind" in obj && obj._kind === "Response";
  }
  contentInfo() {
    const mimeInfo = {
      mimeType: "application/octet-stream",
      mimeFormat: "",
      // TODO: it's definition is unknown
      charset: "utf-8"
    };
    const contentType = this.headers.find((header) => header.key === "Content-Type");
    if (contentType) {
      const directives = contentType.valueOf().split("; ");
      if (directives.length === 0) {
        throw new Error("contentInfo: header Content-Type value is blank");
      } else {
        const mimeType = directives[0];
        if (!mimeType) {
          throw new Error("contentInfo: mime type in header Content-Type is invalid");
        }
        mimeInfo.mimeType = mimeType;
        directives.forEach((dir) => {
          if (dir.startsWith("charset")) {
            mimeInfo.charset = dir.slice(dir.indexOf("=") + 1);
          }
        });
      }
    }
    const fileInfo = {
      extension: "",
      name: "unknown"
    };
    const contentDisposition = this.headers.find((header) => header.key === "Content-Disposition");
    if (contentDisposition) {
      const directives = contentDisposition.valueOf().split("; ");
      directives.forEach((dir) => {
        if (dir.startsWith("filename")) {
          const fileName = fileInfo.extension = dir.slice(dir.indexOf("=") + 1);
          fileInfo.name = fileName.slice(1, fileName.lastIndexOf("."));
          fileInfo.extension = fileName.slice(fileName.lastIndexOf(".") + 1, fileName.length - 1);
        }
      });
    }
    return {
      mimeType: mimeInfo.mimeType,
      mimeFormat: mimeInfo.mimeFormat,
      charset: mimeInfo.charset,
      fileExtension: fileInfo.extension,
      fileName: fileInfo.name,
      contentType: contentType?.valueOf() || "application/octet-stream"
    };
  }
  dataURI() {
    const contentInfo = this.contentInfo();
    const bodyInBase64 = this.stream || this.body;
    if (!bodyInBase64) {
      throw new Error("dataURI(): response body is not defined");
    }
    return `data:${contentInfo.contentType};baseg4, ${bodyInBase64}`;
  }
  json(reviver, _strict) {
    try {
      return JSON.parse(this.body.toString(), reviver);
    } catch (e2) {
      throw new Error(`json: failed to parse: ${e2}`);
    }
  }
  jsonp(_reviver, _strict) {
    throw unsupportedError("jsonp()");
  }
  reason() {
    return this.status;
  }
  size() {
    const headerSize = calculateHeadersSize(this.headers);
    return {
      body: this.bytesRead,
      header: headerSize,
      total: this.bytesRead + headerSize,
      source: "COMPUTED"
    };
  }
  text() {
    return this.body.toString();
  }
  // Besides chai.expect, "to" is extended to support cases like:
  // insomnia.response.to.have.status(200);
  // insomnia.response.to.not.have.status(200);
  get to() {
    const respAssertion = new Assertion(this);
    use((_chai, utils) => {
      utils.addProperty(Assertion.prototype, "withBody", () => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        let respBody = void 0;
        try {
          respBody = resp.body ? resp.json() : void 0;
        } catch (e2) {
          respBody = resp.body;
        }
        if (negate3) {
          new Assertion(respBody === void 0 || respBody === null || respBody === "").to.equal(true);
        } else {
          new Assertion(respBody).to.exist.and.not.equal("");
        }
      });
      utils.addProperty(Assertion.prototype, "error", () => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        if (negate3) {
          new Assertion(resp.code).to.be.not.within(400, 500);
        } else {
          new Assertion(resp.code).to.be.within(400, 500);
        }
      });
      utils.addProperty(Assertion.prototype, "ok", () => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        if (negate3) {
          new Assertion(resp.code).to.not.equal(200);
        } else {
          new Assertion(resp.code).to.equal(200);
        }
      });
      utils.addProperty(Assertion.prototype, "json", () => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        let respBody = void 0;
        try {
          respBody = resp.body ? resp.json() : void 0;
        } catch (e2) {
          respBody = resp.body;
        }
        if (negate3) {
          new Assertion(respBody).to.be.not.an("object");
        } else {
          new Assertion(respBody).to.be.an("object");
        }
      });
      utils.addMethod(Assertion.prototype, "status", (val) => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        if (negate3) {
          new Assertion(resp.code).to.not.equal(val);
        } else {
          new Assertion(resp.code).to.equal(val);
        }
      });
      utils.addMethod(Assertion.prototype, "header", (headerName) => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        if (negate3) {
          new Assertion(resp.headers.get(headerName)).to.not.exist;
        } else {
          new Assertion(resp.headers.get(headerName)).to.exist;
        }
      });
      utils.addMethod(Assertion.prototype, "body", (bodyContent) => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        if (negate3) {
          new Assertion(resp.body).to.not.equal(bodyContent);
        } else {
          new Assertion(resp.body).to.equal(bodyContent);
        }
      });
      utils.addMethod(Assertion.prototype, "jsonBody", (val) => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        let respBody = void 0;
        try {
          respBody = resp.body ? resp.json() : {};
        } catch (e2) {
          respBody = {};
        }
        if (negate3) {
          new Assertion(respBody).to.not.have.property(val);
        } else {
          new Assertion(respBody).to.have.property(val);
        }
      });
      utils.addMethod(Assertion.prototype, "jsonSchema", (schema, options) => {
        const resp = utils.flag(respAssertion, "object");
        const negate3 = utils.flag(respAssertion, "negate");
        let respBody = void 0;
        try {
          respBody = resp.body ? resp.json() : {};
        } catch (e2) {
          respBody = {};
        }
        const ajv = new import_ajv.Ajv(options);
        const validate = ajv.compile(schema);
        if (validate(respBody)) {
          if (negate3) {
            new Assertion(true, "expected schema does match the response body").to.be.false;
          } else {
            new Assertion(true).to.be.true;
          }
        } else {
          const errorMsg = validate.errors?.reduce((acc, error) => {
            return `${acc}
${error.instancePath}: ${error.message}`;
          }, "");
          if (negate3) {
            new Assertion(errorMsg, "expected schema does match the response body").to.not.equal("");
          } else {
            new Assertion(errorMsg, `expected schema not match ${errorMsg}`).to.equal("");
          }
        }
      });
    });
    return respAssertion;
  }
};
function toScriptResponse(originalRequest, partialInsoResponse, responseBody) {
  if ("error" in partialInsoResponse) {
    return void 0;
  }
  const partialResponse = partialInsoResponse;
  const headers = partialResponse.headers ? partialResponse.headers.map(
    (insoHeader) => ({
      key: insoHeader.name,
      value: insoHeader.value
    }),
    {}
  ) : [];
  const insoCookieOptions = partialResponse.headers ? partialResponse.headers.filter((header) => {
    return header.name.toLowerCase() === "set-cookie";
  }, {}).map((setCookieHeader) => Cookie.parse(setCookieHeader.value)) : [];
  const responseOption = {
    code: partialResponse.statusCode || 0,
    reason: partialResponse.statusMessage,
    header: headers,
    cookie: insoCookieOptions,
    body: responseBody,
    // stream is duplicated with body
    responseTime: partialResponse.elapsedTime,
    originalRequest,
    bytesRead: partialResponse.bytesRead
  };
  return new Response2(responseOption);
}
async function readBodyFromPath(response) {
  if (!response || "error" in response) {
    return "";
  } else if (!response.bodyPath) {
    return "";
  }
  const nodejsReadCurlResponse = process.type === "renderer" ? window.bridge.readCurlResponse : readCurlResponse;
  const readResponseResult = await nodejsReadCurlResponse({
    bodyPath: response.bodyPath,
    bodyCompression: response.bodyCompression
  });
  if (readResponseResult.error) {
    throw new Error(`Failed to read body: ${readResponseResult.error}`);
  }
  return readResponseResult.body;
}

// ../insomnia-scripting-environment/src/objects/environments.ts
var Environment = class {
  /**
   * The name of the environment.
   * This property is used to store the identifier or display name of the environment.
   * It is intended to be a private field and should not be accessed directly outside the class.
   */
  _name;
  kvs = /* @__PURE__ */ new Map();
  /**
   * Constructs an instance of the environment object.
   * Initializes the environment with a name and a key-value store derived from the provided JSON object.
   *
   * @param name - The name of the environment.
   * @param jsonObject - An optional object containing key-value pairs to initialize the environment.
   *                     If undefined, an empty key-value store will be created.
   */
  constructor(name, jsonObject) {
    this._name = name;
    this.kvs = new Map(Object.entries(jsonObject || {}));
  }
  /**
   * Gets the name of the environment.
   *
   * @returns {string} The name of the environment.
   */
  get name() {
    return this._name;
  }
  /**
   * Checks if a variable with the specified name exists in the environment.
   *
   * @param variableName - The name of the variable to check for existence.
   * @returns `true` if the variable exists, otherwise `false`.
   */
  has = (variableName) => {
    return this.kvs.has(variableName);
  };
  /**
   * Retrieves the value associated with the specified environment variable name.
   *
   * @param variableName - The name of the environment variable to retrieve.
   * @returns The value of the specified environment variable, or `undefined` if it does not exist.
   */
  get = (variableName) => {
    return this.kvs.get(variableName);
  };
  /**
   * Sets a variable in the key-value store with the specified name and value.
   * If the provided value is `null`, a warning is logged and the variable is not set.
   *
   * @param variableName - The name of the variable to set.
   * @param variableValue - The value to assign to the variable. Can be a boolean, number, string, undefined, or null.
   *                        If `null`, the variable will not be set, and a warning will be logged.
   */
  set = (variableName, variableValue) => {
    if (variableValue === null) {
      getExistingConsole().warn(`Variable "${variableName}" has a null value`);
      return;
    }
    this.kvs.set(variableName, variableValue);
  };
  /**
   * Removes a variable from the environment by its name.
   *
   * @param variableName - The name of the variable to be removed.
   */
  unset = (variableName) => {
    this.kvs.delete(variableName);
  };
  /**
   * Clears all key-value pairs stored in the environment.
   * This method removes all entries from the internal storage.
   */
  clear = () => {
    this.kvs.clear();
  };
  /**
   * Replaces placeholders in the given template string with values from the environment object.
   *
   * It supports following placeholders:
   * - `insomnia.environment.replaceIn("My id is {{$randomUUID}}")`, which generates a random UUID.
   * - `insomnia.environment.replaceIn("Visiting URL: {{urlValueFromEnvironment}}")`, which replaces `urlValueFromEnvironment` with the value of that variable in the active environment.
   *
   * @param template - The template string containing placeholders to be replaced.
   * @returns The rendered string with placeholders replaced by their corresponding values.
   */
  replaceIn = (template2) => {
    return getInterpolator().render(template2, this.toObject());
  };
  /**
   * Converts the key-value pairs stored in the current instance into a plain JavaScript object.
   *
   * @returns {Record<string, any>} A plain object representation of the key-value pairs.
   */
  toObject = () => {
    return Object.fromEntries(this.kvs.entries());
  };
};
function mergeFolderLevelVars(folderLevelVars) {
  const mergedFolderLevelObject = folderLevelVars.reduce((merged, folderLevelEnv) => {
    return { ...merged, ...folderLevelEnv.toObject() };
  }, {});
  return new Environment("mergedFolderLevelVars", mergedFolderLevelObject);
}
var Variables = class {
  // TODO: support vars for all levels
  globalVars;
  baseGlobalVars;
  collectionVars;
  environmentVars;
  iterationDataVars;
  folderLevelVars;
  localVars;
  /**
   * Constructs an instance of the class with the provided environment variables.
   *
   * @param args - An object containing various environment variables.
   * @param args.baseGlobalVars - The base global environment variables.
   * @param args.globalVars - The selected global environment variables.
   * @param args.collectionVars - The base environment variables.
   * @param args.environmentVars - The selected environment variables.
   * @param args.iterationDataVars - The iteration data (from the collectio runner) variables.
   * @param args.folderLevelVars - An array of folder-level environment variables from parent folders.
   * @param args.localVars - The local environment variables, which are only valid during the execution.
   */
  constructor(args) {
    this.baseGlobalVars = args.baseGlobalVars;
    this.globalVars = args.globalVars;
    this.collectionVars = args.collectionVars;
    this.environmentVars = args.environmentVars;
    this.iterationDataVars = args.iterationDataVars;
    this.folderLevelVars = args.folderLevelVars;
    this.localVars = args.localVars;
  }
  /**
   * Checks if a variable with the specified name exists in any of the defined variable scopes.
   *
   * The method searches through the following scopes in order:
   * 1. Local variables
   * 2. Folder-level variables
   * 3. Iteration data variables
   * 4. Environment variables
   * 5. Collection variables
   * 6. Global variables
   * 7. Base global variables
   *
   * @param variableName - The name of the variable to check for existence.
   * @returns `true` if the variable exists in any scope; otherwise, `false`.
   */
  has = (variableName) => {
    const baseGlobalVarsHas = this.baseGlobalVars.has(variableName);
    const globalVarsHas = this.globalVars.has(variableName);
    const collectionVarsHas = this.collectionVars.has(variableName);
    const environmentVarsHas = this.environmentVars.has(variableName);
    const iterationDataVarsHas = this.iterationDataVars.has(variableName);
    const folderLevelVarsHas = this.folderLevelVars.some((vars) => vars.has(variableName));
    const localVarsHas = this.localVars.has(variableName);
    return localVarsHas || folderLevelVarsHas || iterationDataVarsHas || environmentVarsHas || collectionVarsHas || globalVarsHas || baseGlobalVarsHas;
  };
  /**
   * Retrieves the value of a variable by searching through the variable hierarchy.
   *
   * The method searches for the variable in the following order of precedence:
   * 1. Local variables
   * 2. Folder-level variables
   * 3. Iteration data variables
   * 4. Environment variables
   * 5. Collection variables
   * 6. Global variables
   * 7. Base global variables
   *
   * Returns the first value found in the hierarchy.
   *
   * @param variableName - The name of the variable to retrieve
   * @returns The value of the variable if found, otherwise undefined
   */
  get = (variableName) => {
    let finalVal;
    [
      this.localVars,
      mergeFolderLevelVars(this.folderLevelVars),
      this.iterationDataVars,
      this.environmentVars,
      this.collectionVars,
      this.globalVars,
      this.baseGlobalVars
    ].forEach((vars) => {
      const value = vars.get(variableName);
      if (!finalVal && value) {
        finalVal = value;
      }
    });
    return finalVal;
  };
  /**
   * Sets a local variable with the specified name and value.
   * If the provided value is `null`, a warning is logged and the variable is not set.
   *
   * @param variableName - The name of the variable to set.
   * @param variableValue - The value to assign to the variable. Can be a boolean, number, string, undefined, or null.
   *                        If `null`, the variable will not be set and a warning will be logged.
   */
  set = (variableName, variableValue) => {
    if (variableValue === null) {
      getExistingConsole().warn(`Variable "${variableName}" has a null value`);
      return;
    }
    this.localVars.set(variableName, variableValue);
  };
  /**
   * Replaces placeholders in the given template string with values from the current environment context.
   *
   * It supports following placeholders:
   * - `insomnia.variables.replaceIn("My id is {{$randomUUID}}")`, which generates a random UUID.
   * - `insomnia.variables.replaceIn("Visiting URL: {{urlValueFromEnvironment}}")`, which replaces `urlValueFromEnvironment` with the value of that variable in the active environment.
   *
   * @param template - The template string containing placeholders to be replaced.
   * @returns The rendered string with placeholders replaced by their corresponding values.
   */
  replaceIn = (template2) => {
    const context = this.toObject();
    return getInterpolator().render(template2, context);
  };
  /**
   * Converts the current environment variables into a single consolidated object.
   *
   * This method aggregates various levels of variables including global, collection,
   * environment, iteration data, folder-level, and local variables.
   *
   * @returns {Record<string, any>} A consolidated object containing all environment variables.
   */
  toObject = () => {
    return [
      this.baseGlobalVars,
      this.globalVars,
      this.collectionVars,
      this.environmentVars,
      this.iterationDataVars,
      mergeFolderLevelVars(this.folderLevelVars),
      this.localVars
    ].map((vars) => vars.toObject()).reduce((ctx, obj) => ({ ...ctx, ...obj }), {});
  };
  /** @ignore */
  localVarsToObject = () => {
    return this.localVars.toObject();
  };
};
var Vault = class extends Environment {
  /**
   * Constructs an instance of the Vault class.
   *
   * @param name - The name associated with the environment.
   * @param jsonObject - An optional JSON object representing the vault's data.
   * @param enableVaultInScripts - A boolean flag indicating whether vault access is enabled in scripts.
   *
   * @throws Will throw an error if `enableVaultInScripts` is `false` and an attempt is made to get or set a property.
   */
  constructor(name, jsonObject, enableVaultInScripts) {
    super(name, jsonObject);
    return new Proxy(this, {
      // throw error on get or set method call if enableVaultInScripts is false
      get: (target, prop, receiver) => {
        if (!enableVaultInScripts) {
          throw new Error("Vault is disabled in script");
        }
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        if (!enableVaultInScripts) {
          throw new Error("Vault is disabled in script");
        }
        return Reflect.set(target, prop, value, receiver);
      }
    });
  }
  /** @ignore */
  unset = () => {
    throw new Error("Vault can not be unset in script");
  };
  /** @ignore */
  clear = () => {
    throw new Error("Vault can not be cleared in script");
  };
  /** @ignore */
  set = () => {
    throw new Error("Vault can not be set in script");
  };
};

// ../insomnia-scripting-environment/src/objects/folders.ts
var Folder = class {
  /**
   * A unique identifier for the folder.
   */
  id;
  /**
   * The name of the folder.
   */
  name;
  /**
   * Represents the environment associated with the folder.
   * Provides access to folder-level environment variables.
   */
  environment;
  /**
   * Constructs a new instance of the Folder class.
   *
   * @param id - The unique identifier for the folder.
   * @param name - The name of the folder.
   * @param environmentObject - An optional object representing the associated folder-level environment.
   */
  constructor(id, name, environmentObject) {
    this.id = id;
    this.name = name;
    this.environment = new Environment(`${id}.environment`, environmentObject);
  }
  /**
   * Converts the folder instance into a plain JavaScript object representation.
   *
   * @returns An object containing the folder's `id`, `name`, and `environment` properties.
   *          The `environment` property is also converted to its object representation.
   */
  toObject = () => {
    return {
      id: this.id,
      name: this.name,
      environment: this.environment.toObject()
    };
  };
};
var ParentFolders = class {
  /**
   * Creates an instance of the class with a list of folders.
   *
   * @param folders - An array of `Folder` objects to initialize the instance with, from bottom to top.
   */
  constructor(folders) {
    this.folders = folders;
  }
  /**
   * Retrieves a folder by its ID or name.
   *
   * @param idOrName - The ID or name of the folder to retrieve.
   * @returns The folder object that matches the given ID or name.
   * @throws {Error} If no folder with the specified ID or name is found.
   */
  get = (idOrName) => {
    const folder = this.folders.find((folder2) => folder2.name === idOrName || folder2.id === idOrName);
    if (!folder) {
      throw new Error(`Folder "${idOrName}" not found`);
    }
    return folder;
  };
  /**
   * Retrieves a folder by its unique identifier.
   *
   * @param id - The unique identifier of the folder to retrieve.
   * @returns The folder object with the specified ID.
   * @throws Error if no folder with the given ID is found.
   */
  getById = (id) => {
    const folder = this.folders.find((folder2) => folder2.id === id);
    if (!folder) {
      throw new Error(`Folder "${id}" not found`);
    }
    return folder;
  };
  /**
   * Retrieves a folder by its name.
   *
   * @param folderName - The name of the folder to retrieve.
   * @returns The folder object with the specified name.
   * @throws {Error} If no folder with the specified name is found.
   */
  getByName = (folderName) => {
    const folder = this.folders.find((folder2) => folder2.name === folderName);
    if (!folder) {
      throw new Error(`Folder "${folderName}" not found`);
    }
    return folder;
  };
  /**
   * Searches for a specific value in the environments of the folders, starting from the nearest ancestor folder
   * and moving towards the top ancestor folder.
   *
   * @param valueKey - The key of the value to search for in the folder environments.
   * @returns The value associated with the specified key if found, otherwise `undefined`.
   */
  findValue = (valueKey) => {
    const targetEnv = [...this.folders].reverse().find((folder) => folder.environment.has(valueKey));
    return targetEnv !== void 0 ? targetEnv.environment.get(valueKey) : void 0;
  };
  /**
   * Converts the current folder structure into a plain JavaScript object representation.
   *
   * @returns An array of objects representing the folder structure.
   */
  toObject = () => {
    return this.folders.map((folder) => folder.toObject());
  };
  /**
   * Retrieves the environments associated with the folders.
   *
   * @returns An array of environments extracted from the folders.
   */
  getEnvironments = () => {
    return this.folders.map((folder) => folder.environment);
  };
};

// src/network/certificate.ts
init_protocol();

// src/network/url-matches-cert-host.ts
var import_node_url = require("node:url");
init_misc();
init_protocol();
var DEFAULT_PORT = 443;
function urlMatchesCertHost(certificateHost, requestUrl, needCheckPort = true) {
  const cHostWithProtocol = setDefaultProtocol(certificateHost, "https:");
  const { hostname, port } = (0, import_node_url.parse)(requestUrl);
  let certificateHostWithProtocol = new import_node_url.URL("https://example.com");
  try {
    certificateHostWithProtocol = new import_node_url.URL(cHostWithProtocol);
  } catch (err) {
    return false;
  }
  const { hostname: cHostname, port: cPort } = certificateHostWithProtocol;
  const assumedPort = parseInt(port) || DEFAULT_PORT;
  const assumedCPort = parseInt(cPort) || DEFAULT_PORT;
  const cHostnameRegex = escapeRegex(cHostname || "").replace(/\\\*/g, ".*");
  const cPortRegex = escapeRegex(cPort || "").replace(/\\\*/g, ".*");
  if (needCheckPort) {
    if ((cPort + "").includes("*")) {
      if (!(port || "").match(`^${cPortRegex}$`)) {
        return false;
      }
    } else {
      if (assumedCPort !== assumedPort) {
        return false;
      }
    }
  }
  if (!(hostname || "").match(`^${cHostnameRegex}$`)) {
    return false;
  }
  return true;
}

// src/network/certificate.ts
function filterClientCertificates(clientCertificates, requestUrl, protocol) {
  const res = clientCertificates.filter(
    (c2) => !c2.disabled && urlMatchesCertHost(setDefaultProtocol(c2.host, protocol), requestUrl, true)
  );
  if (!res.length) {
    return clientCertificates.filter(
      (c2) => !c2.disabled && urlMatchesCertHost(setDefaultProtocol(c2.host, protocol), requestUrl, false)
    );
  }
  return res;
}

// ../insomnia-scripting-environment/src/objects/execution.ts
var Execution = class {
  _skipRequest;
  _nextRequestIdOrName;
  location;
  constructor(options) {
    const { location, skipRequest = false, nextRequestIdOrName = "" } = options;
    if (Array.isArray(location)) {
      this.location = new Proxy([...location], {
        get: (target, prop, receiver) => {
          if (prop === "current") {
            return target.length > 0 ? target[target.length - 1] : "";
          }
          return Reflect.get(target, prop, receiver);
        }
      });
      this._skipRequest = skipRequest;
      this._nextRequestIdOrName = nextRequestIdOrName;
    } else {
      throw new Error("Location input must be array of string");
    }
  }
  skipRequest = () => {
    this._skipRequest = true;
  };
  setNextRequest = (requestIdOrName) => {
    this._nextRequestIdOrName = requestIdOrName;
  };
  toObject = () => {
    return {
      location: Array.from(this.location),
      skipRequest: this._skipRequest,
      nextRequestIdOrName: this._nextRequestIdOrName
    };
  };
};

// ../insomnia-scripting-environment/src/objects/request-info.ts
var RequestInfo = class {
  /**
   * The name of the event associated with the request.
   * It could be 'prerequest` or 'test'.
   */
  eventName;
  /**
   * The current iteration number of the request execution.
   * This value represents how many times the request has been executed
   * in a loop or sequence.
   */
  iteration;
  /**
   * The number of iterations that have been executed.
   * This property tracks how many times a specific operation or process
   * has been repeated.
   */
  iterationCount;
  /**
   * The name of the request.
   * This property holds the user-defined name for the request, which can be used
   * to identify or reference the request within the application.
   */
  requestName;
  /**
   * The unique identifier for the request.
   */
  requestId;
  /**
   * Constructs a new instance of the `RequestInfo` class.
   *
   * @param options - An object containing initialization options for the request information.
   * @param options.eventName - The name of the event associated with the request. Defaults to `'prerequest'`.
   * @param options.iteration - The current iteration number of the request. Defaults to `1`.
   * @param options.iterationCount - The total number of iterations for the request. Defaults to `1`.
   * @param options.requestName - The name of the request. Defaults to an empty string.
   * @param options.requestId - The unique identifier of the request. Defaults to an empty string.
   */
  constructor(options) {
    this.eventName = options.eventName || "prerequest";
    this.iteration = options.iteration || 1;
    this.iterationCount = options.iterationCount || 1;
    this.requestName = options.requestName || "";
    this.requestId = options.requestId || "";
  }
  /**
   * Converts the current instance of the object into a plain JavaScript object.
   *
   * @returns An object containing the following properties:
   * - `eventName`: The name of the event associated with the request.
   * - `iteration`: The current iteration number of the request.
   * - `iterationCount`: The total number of iterations for the request.
   * - `requestName`: The name of the request.
   * - `requestId`: The unique identifier of the request.
   */
  toObject = () => {
    return {
      eventName: this.eventName,
      iteration: this.iteration,
      iterationCount: this.iterationCount,
      requestName: this.requestName,
      requestId: this.requestId
    };
  };
};

// ../insomnia-scripting-environment/src/objects/send-request.ts
init_response();
var import_tough_cookie2 = __toESM(require_cookie());
init_esm_node();
async function sendRequest(request2, cb, settings2) {
  return new Promise(async (resolve, reject2) => {
    try {
      const requestOptions = requestToCurlOptions(request2, settings2);
      const nodejsCurlRequest = process.type === "renderer" ? window.bridge.curlRequest : (await Promise.resolve().then(() => (init_libcurl_promise(), libcurl_promise_exports))).curlRequest;
      const output = await nodejsCurlRequest(requestOptions);
      const transformedOutput = await curlOutputToResponse(output, request2);
      if (cb) {
        cb(void 0, transformedOutput);
      }
      return resolve(transformedOutput);
    } catch (e2) {
      if (cb) {
        cb(e2, void 0);
        resolve(void 0);
      } else {
        reject2(e2);
      }
    }
  });
}
function requestToCurlOptions(req, settings2) {
  const id = v4_default();
  const settingFollowRedirects = settings2.followRedirects ? "on" : "off";
  if (typeof req === "string") {
    return {
      requestId: `pre-request-script-adhoc-req-simple:${id}`,
      req: {
        headers: [],
        method: "GET",
        body: { mimeType: void 0 },
        // no body is set so it's type is undefined
        authentication: fromPreRequestAuth(new RequestAuth({ type: "noauth" })),
        settingFollowRedirects,
        settingRebuildPath: true,
        settingSendCookies: true,
        url: req,
        // currently cookies should be handled by user in headers
        cookieJar: {
          cookies: []
        },
        cookies: [],
        suppressUserAgent: false
      },
      finalUrl: req,
      settings: settings2,
      certificates: [],
      caCertficatePath: null,
      socketPath: void 0,
      authHeader: void 0
      // TODO: add this for bearer and other auth methods
    };
  } else if (req instanceof Request2 || typeof req === "object") {
    const finalReq = req instanceof Request2 ? req : new Request2(req);
    let mimeType = "application/octet-stream";
    if (finalReq.body) {
      switch (finalReq.body.mode) {
        case "raw": {
          mimeType = "text/plain";
          break;
        }
        case "file": {
          mimeType = "application/octet-stream";
          break;
        }
        case "formdata": {
          mimeType = "multipart/form-data";
          break;
        }
        case "urlencoded": {
          mimeType = "application/x-www-form-urlencoded";
          break;
        }
        case "graphql": {
          mimeType = "application/json";
          break;
        }
        default: {
          mimeType = "text/plain";
        }
      }
    }
    const urlencodedParams = finalReq.body?.urlencoded?.all().map((param) => ({ name: param.key, value: param.value }));
    const formdataParams = finalReq.body?.formdata?.all().map((param) => ({
      type: param.type,
      name: param.key,
      value: param.type === "file" ? "" : param.value,
      fileName: param.type === "file" ? param.value : ""
    }));
    const params = finalReq.body?.mode === "formdata" || finalReq.body?.mode === "urlencoded" ? finalReq.body?.mode === "formdata" ? formdataParams : urlencodedParams : [];
    return {
      requestId: finalReq.id || `pre-request-script-adhoc-req-custom:${id}`,
      req: {
        headers: finalReq.headers.map((header) => ({ name: header.key, value: header.value }), {}),
        method: finalReq.method,
        body: {
          mimeType,
          method: finalReq.method,
          text: finalReq.body?.toString(),
          params,
          fileName: finalReq.body?.mode === "file" ? finalReq.body?.toString() : void 0
        },
        authentication: fromPreRequestAuth(finalReq.auth),
        settingFollowRedirects,
        settingRebuildPath: true,
        settingSendCookies: true,
        url: finalReq.url.toString(),
        // currently cookies should be handled by user in headers
        cookieJar: {
          cookies: []
        },
        cookies: [],
        suppressUserAgent: finalReq.headers.map((h2) => h2.key.toLowerCase() === "user-agent" && h2.disabled === true, {}).length > 0
      },
      finalUrl: finalReq.url.toString(),
      settings: settings2,
      certificates: finalReq.certificate ? [
        {
          host: finalReq.certificate?.name || "",
          passphrase: finalReq.certificate?.passphrase || "",
          cert: finalReq.certificate?.cert?.src || "",
          key: finalReq.certificate?.key?.src || "",
          pfx: finalReq.certificate?.pfx?.src || "",
          // unused fields because they are not persisted
          disabled: false,
          isPrivate: false,
          _id: "",
          type: "",
          parentId: "",
          modified: 0,
          created: 0,
          name: ""
        }
      ] : [],
      caCertficatePath: null,
      // the request in pre-request script doesn't support customizing ca yet
      socketPath: void 0,
      authHeader: void 0
      // TODO: add this for bearer and other auth methods
    };
  }
  throw new Error("the request type must be: string | Request | RequestOptions.");
}
async function curlOutputToResponse(result2, request2) {
  if (result2.headerResults.length === 0) {
    throw new Error("curlOutputToResponse: no header result is found");
  }
  if (result2.patch.error) {
    throw result2.patch.error;
  }
  const lastRedirect = result2.headerResults[result2.headerResults.length - 1];
  if (!lastRedirect) {
    throw new Error("curlOutputToResponse: the lastRedirect is not defined");
  }
  const originalRequest = typeof request2 === "string" ? new Request2({ url: request2, method: "GET" }) : request2 instanceof Request2 ? request2 : new Request2(request2);
  const headers = lastRedirect.headers.map((header) => ({
    key: header.name,
    value: header.value
  }));
  const cookieHeaders = lastRedirect.headers.filter((header) => {
    return header.name.toLowerCase() === "set-cookie";
  });
  const cookies = cookieHeaders.map((cookieHeader) => {
    const cookieObj = import_tough_cookie2.Cookie.parse(cookieHeader.value || "", { loose: true });
    if (cookieObj) {
      return {
        key: cookieObj.key,
        value: cookieObj.value,
        expires: cookieObj.expires,
        maxAge: cookieObj.maxAge,
        domain: cookieObj.domain,
        path: cookieObj.path,
        secure: cookieObj.secure,
        httpOnly: cookieObj.httpOnly,
        hostOnly: cookieObj.hostOnly
        // session: cookieObj.session, // not supported
        // extensions: cookieObj.extensions,
      };
    }
    return cookieObj;
  }).filter((cookieOpt) => cookieOpt !== void 0);
  if (!result2.responseBodyPath) {
    return new Response2({
      code: lastRedirect.code,
      reason: lastRedirect.reason,
      header: headers,
      cookie: cookies,
      body: "",
      stream: void 0,
      responseTime: result2.patch.elapsedTime,
      originalRequest
    });
  }
  const nodejsReadCurlResponse = process.type === "renderer" ? window.bridge.readCurlResponse : readCurlResponse;
  const bodyResult = await nodejsReadCurlResponse({
    bodyPath: result2.responseBodyPath,
    bodyCompression: result2.patch.bodyCompression
  });
  if (bodyResult.error) {
    throw new Error(bodyResult.error);
  }
  return new Response2({
    code: lastRedirect.code,
    reason: lastRedirect.reason,
    header: headers,
    cookie: cookies,
    body: bodyResult.body,
    // stream is always undefined
    // because it is inaccurate to differentiate if body is binary
    stream: void 0,
    responseTime: result2.patch.elapsedTime,
    originalRequest
  });
}

// ../insomnia-scripting-environment/src/objects/test.ts
async function test(msg, fn, log) {
  const wrapFn = async () => {
    const started = performance.now();
    try {
      await fn();
      const executionTime = performance.now() - started;
      log({
        testCase: msg,
        status: "passed",
        executionTime,
        category: "unknown"
      });
    } catch (e2) {
      const executionTime = performance.now() - started;
      log({
        testCase: msg,
        status: "failed",
        executionTime,
        errorMessage: `error: ${e2} | ACTUAL: ${e2.actual} | EXPECTED: ${e2.expected}`,
        category: "unknown"
      });
    }
  };
  const testPromise = wrapFn();
  startTestObserver(testPromise);
  return testPromise;
}
var testPromises = new Array();
async function waitForAllTestsDone() {
  await Promise.allSettled(testPromises);
  testPromises = [];
}
function startTestObserver(promise) {
  testPromises.push(promise);
}
async function skip(msg, _2, log) {
  log({
    testCase: msg,
    status: "skipped",
    executionTime: 0,
    category: "unknown"
  });
}

// ../insomnia-scripting-environment/src/objects/insomnia.ts
var InsomniaObject = class {
  environment;
  collectionVariables;
  baseEnvironment;
  variables;
  request;
  cookies;
  info;
  response;
  execution;
  vault;
  clientCertificates;
  _expect = expect;
  _test = test;
  _skip = skip;
  iterationData;
  // TODO: follows will be enabled after Insomnia supports them
  globals;
  baseGlobals;
  _settings;
  requestTestResults;
  parentFolders;
  constructor(rawObj) {
    this.globals = rawObj.globals;
    this.baseGlobals = rawObj.baseGlobals;
    this.environment = rawObj.environment;
    this.baseEnvironment = rawObj.baseEnvironment;
    this.collectionVariables = this.baseEnvironment;
    this.iterationData = rawObj.iterationData;
    this.variables = rawObj.variables;
    this.cookies = rawObj.cookies;
    this.response = rawObj.response;
    this.execution = rawObj.execution;
    this.vault = rawObj.vault;
    this.info = rawObj.requestInfo;
    this.request = rawObj.request;
    this._settings = rawObj.settings;
    this.clientCertificates = rawObj.clientCertificates;
    this.requestTestResults = new Array();
    this.parentFolders = rawObj.parentFolders;
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        if (prop === "test") {
          const testHandler = async (msg, fn) => {
            await this._test(msg, fn, this.pushRequestTestResult);
          };
          testHandler.skip = async (msg, fn) => {
            await this._skip(msg, fn, this.pushRequestTestResult);
          };
          return testHandler;
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  sendRequest(request2, cb) {
    return sendRequest(request2, cb, this._settings);
  }
  test = () => {
  };
  pushRequestTestResult = (testResult) => {
    this.requestTestResults = [...this.requestTestResults, testResult];
  };
  expect = (exp) => {
    return this._expect(exp);
  };
  get settings() {
    return void 0;
  }
  toObject = () => {
    return {
      globals: this.globals.toObject(),
      baseGlobals: this.baseGlobals.toObject(),
      environment: this.environment.toObject(),
      baseEnvironment: this.baseEnvironment.toObject(),
      iterationData: this.iterationData.toObject(),
      variables: this.variables.localVarsToObject(),
      request: this.request,
      settings: this.settings,
      clientCertificates: this.clientCertificates,
      cookieJar: this.cookies.jar().toInsomniaCookieJar(),
      info: this.info.toObject(),
      response: this.response ? this.response.toObject() : void 0,
      requestTestResults: this.requestTestResults,
      execution: this.execution.toObject(),
      parentFolders: this.parentFolders.toObject()
    };
  };
};
async function initInsomniaObject(rawObj, log) {
  const baseGlobals = new Environment(rawObj.baseGlobals?.name || "baseGlobals", rawObj.baseGlobals?.data || {});
  const globals = rawObj.globals?.id === rawObj.baseGlobals?.id ? baseGlobals : new Environment(rawObj.globals?.name || "globals", rawObj.globals?.data || {});
  const baseEnvironment = new Environment(rawObj.baseEnvironment.name || "", rawObj.baseEnvironment.data);
  const environment2 = rawObj.baseEnvironment.id === rawObj.environment.id ? baseEnvironment : new Environment(rawObj.environment.name || "", rawObj.environment.data);
  if (rawObj.baseEnvironment.id === rawObj.environment.id) {
    log(
      "warning: No environment is selected, modification of insomnia.environment will be applied to the base environment."
    );
  }
  const iterationData = rawObj.iterationData ? new Environment(rawObj.iterationData.name, rawObj.iterationData.data) : new Environment("iterationData", {});
  const localVariables = rawObj.transientVariables ? new Environment(rawObj.transientVariables.name, rawObj.transientVariables.data) : new Environment("transientVariables", {});
  const enableVaultInScripts = rawObj.settings?.enableVaultInScripts || false;
  const vault = rawObj.vault ? new Vault("vault", rawObj.vault, enableVaultInScripts) : new Vault("vault", {}, enableVaultInScripts);
  const cookies = new CookieObject(rawObj.cookieJar);
  const requestInfo = new RequestInfo({
    eventName: rawObj.requestInfo.eventName || "prerequest",
    iteration: rawObj.requestInfo.iteration || 1,
    iterationCount: rawObj.requestInfo.iterationCount || 0,
    requestName: rawObj.request.name,
    requestId: rawObj.request._id
  });
  const parentFolders = new ParentFolders(
    rawObj.parentFolders.map((folderObj) => new Folder(folderObj.id, folderObj.name, folderObj.environment))
  );
  const variables = new Variables({
    baseGlobalVars: baseGlobals,
    globalVars: globals,
    environmentVars: environment2,
    collectionVars: baseEnvironment,
    iterationDataVars: iterationData,
    folderLevelVars: parentFolders.getEnvironments(),
    localVars: localVariables
  });
  const ifUrlIncludesTag = checkIfUrlIncludesTag(rawObj.request.url);
  const matchedCertificates = filterClientCertificates(rawObj.clientCertificates || [], rawObj.request.url);
  const initEmptyCert = ifUrlIncludesTag || matchedCertificates?.length === 0;
  if (initEmptyCert) {
    getExistingConsole().warn(
      "The URL contains tags or no matched certificate found, insomnia.request.certificate is initialized as an empty certificate."
    );
  }
  const defaultCertificate = initEmptyCert ? {
    disabled: false,
    name: "Default Certificate",
    matches: [],
    key: void 0,
    cert: void 0,
    passphrase: void 0,
    pfx: void 0
  } : {
    disabled: matchedCertificates[0].disabled,
    name: "The first matched certificate from Settings",
    matches: [matchedCertificates[0].host],
    key: { src: matchedCertificates[0].key || "" },
    cert: { src: matchedCertificates[0].cert || "" },
    passphrase: matchedCertificates[0].passphrase || void 0,
    pfx: { src: matchedCertificates[0].pfx || "" }
    // PFX or PKCS12 Certificate
  };
  const proxy = transformToSdkProxyOptions(
    rawObj.settings.httpProxy,
    rawObj.settings.httpsProxy,
    rawObj.settings.proxyEnabled,
    rawObj.settings.noProxy
  );
  const reqUrl = toUrlObject(rawObj.request.url);
  reqUrl.addQueryParams(
    rawObj.request.parameters.map((param) => ({ key: param.name, value: param.value, disabled: param.disabled }))
  );
  const reqOpt = {
    name: rawObj.request.name,
    url: reqUrl,
    method: rawObj.request.method,
    header: rawObj.request.headers.map((header) => ({
      key: header.name,
      value: header.value,
      disabled: header.disabled
    })),
    body: toScriptRequestBody(rawObj.request.body),
    auth: toPreRequestAuth(rawObj.request.authentication),
    proxy,
    certificate: defaultCertificate,
    pathParameters: rawObj.request.pathParameters
  };
  const request2 = new Request2(reqOpt);
  const execution = new Execution({
    location: rawObj.execution.location,
    skipRequest: rawObj.execution.skipRequest,
    nextRequestIdOrName: rawObj.execution.nextRequestIdOrName
  });
  const responseBody = await readBodyFromPath(rawObj.response);
  const response = rawObj.response ? toScriptResponse(request2, rawObj.response, responseBody) : void 0;
  return new InsomniaObject({
    globals,
    baseGlobals,
    environment: environment2,
    baseEnvironment,
    iterationData,
    vault,
    variables,
    request: request2,
    settings: rawObj.settings,
    clientCertificates: rawObj.clientCertificates,
    cookies,
    requestInfo,
    response,
    execution,
    parentFolders
  });
}

// ../insomnia-scripting-environment/src/objects/async-objects.ts
var scriptPromises = new Array();

// src/entry.hidden-window.ts
init2({
  ...SENTRY_OPTIONS
});
window.bridge.onmessage(
  async (data, callback) => {
    window.bridge.setBusy(true);
    try {
      const timeout = data.context.timeout || 5e3;
      const timeoutPromise = new window.bridge.Promise((resolve) => {
        setTimeout(() => {
          resolve({ error: "Timeout: Running script took too long" });
        }, timeout);
      });
      const result2 = await window.bridge.Promise.race([timeoutPromise, runScript(data)]);
      callback(result2);
    } catch (err) {
      const errMessage = err.message ? `Error from Pre-request or after-response script:
      
${err.message}` : err;
      const fullErrMessage = `${errMessage}

${err.stack ? `Stack: ${err.stack}` : ""}`;
      captureException(errMessage, {
        tags: {
          source: "hidden-window"
        }
      });
      callback({ error: fullErrMessage });
    } finally {
      window.bridge.setBusy(false);
    }
  }
);
var runScript = async ({ script, context }) => {
  const scriptConsole = getNewConsole();
  const executionContext = await initInsomniaObject(context, scriptConsole.log);
  const AsyncFunction = (async () => {
  }).constructor;
  const executeScript = AsyncFunction(
    "insomnia",
    "require",
    "console",
    "_",
    "setTimeout",
    // disable these as they are not supported in web or existing implementation
    "setImmediate",
    "queueMicrotask",
    "process",
    "waitForAllTestsDone",
    `
      const $ = insomnia;
      window.bridge.resetAsyncTasks(); // exclude unnecessary ones
      ${script};
      await waitForAllTestsDone();
      window.bridge.stopMonitorAsyncTasks();  // the next one should not be monitored
      await window.bridge.asyncTasksAllSettled();
      return insomnia;`
  );
  const mutatedInsomniaObject = await executeScript(
    executionContext,
    window.bridge.requireInterceptor,
    scriptConsole,
    compat_exports2,
    proxiedSetTimeout,
    void 0,
    void 0,
    void 0,
    waitForAllTestsDone
  );
  if (mutatedInsomniaObject == null || !(mutatedInsomniaObject instanceof InsomniaObject)) {
    throw new Error("insomnia object is invalid or script returns earlier than expected.");
  }
  const mutatedContextObject = mutatedInsomniaObject.toObject();
  const updatedRequest = mergeRequests(context.request, mutatedContextObject.request);
  const updatedSettings = mergeSettings(context.settings, mutatedContextObject.request);
  const updatedCertificates = mergeClientCertificates(
    mutatedContextObject.clientCertificates,
    mutatedContextObject.request
  );
  const updatedCookieJar = mergeCookieJar(context.cookieJar, mutatedContextObject.cookieJar);
  return {
    ...context,
    environment: {
      id: context.environment.id,
      name: context.environment.name,
      data: mutatedContextObject.environment
    },
    baseEnvironment: {
      id: context.baseEnvironment.id,
      name: context.baseEnvironment.name,
      data: mutatedContextObject.baseEnvironment
    },
    iterationData: context.iterationData ? {
      name: context.iterationData.name,
      data: mutatedContextObject.iterationData
    } : void 0,
    transientVariables: {
      name: context.transientVariables?.name || "transientVariables",
      data: mutatedContextObject.variables
    },
    request: updatedRequest,
    execution: mutatedContextObject.execution,
    settings: updatedSettings,
    clientCertificates: updatedCertificates,
    cookieJar: updatedCookieJar,
    globals: context.globals && {
      id: context.globals.id,
      name: context.globals.name,
      data: mutatedContextObject.globals
    },
    baseGlobals: context.baseGlobals && {
      id: context.baseGlobals.id,
      name: context.baseGlobals.name,
      data: mutatedContextObject.baseGlobals
    },
    requestTestResults: mutatedContextObject.requestTestResults,
    logs: scriptConsole.dumpLogsAsArray(),
    parentFolders: mutatedContextObject.parentFolders
  };
};
function proxiedSetTimeout(callback, ms) {
  let resolveHdl;
  new Promise((resolve) => {
    resolveHdl = resolve;
  });
  return setTimeout(() => {
    callback();
    resolveHdl(null);
  }, ms);
}
/*! Bundled license information:

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

tough-cookie/lib/pubsuffix-psl.js:
  (*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/store.js:
tough-cookie/lib/permuteDomain.js:
tough-cookie/lib/pathMatch.js:
tough-cookie/lib/memstore.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/cookie.js:
  (*!
   * Copyright (c) 2015-2020, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

assertion-error/index.js:
  (*!
   * assertion-error
   * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
   * MIT Licensed
   *)
  (*!
   * Return a function that will copy properties from
   * one object to another excluding any originally
   * listed. Returned function will create a new `{}`.
   *
   * @param {String} excluded properties ...
   * @return {Function}
   *)
  (*!
   * Primary Exports
   *)
  (*!
   * Inherit from Error.prototype
   *)
  (*!
   * Statically set name
   *)
  (*!
   * Ensure correct constructor
   *)

chai/lib/chai/utils/flag.js:
  (*!
   * Chai - flag utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/test.js:
  (*!
   * Chai - test utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Module dependencies
   *)

chai/lib/chai/utils/expectTypes.js:
  (*!
   * Chai - expectTypes utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/getActual.js:
  (*!
   * Chai - getActual utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/objDisplay.js:
  (*!
   * Chai - flag utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Module dependencies
   *)

chai/lib/chai/utils/getMessage.js:
  (*!
   * Chai - message composition utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Module dependencies
   *)

chai/lib/chai/utils/transferFlags.js:
  (*!
   * Chai - transferFlags utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)

chai/lib/chai/utils/isProxyEnabled.js:
  (*!
   * Chai - isProxyEnabled helper
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/addProperty.js:
  (*!
   * Chai - addProperty utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/addLengthGuard.js:
  (*!
   * Chai - addLengthGuard utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/getProperties.js:
  (*!
   * Chai - getProperties utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/proxify.js:
  (*!
   * Chai - proxify utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/addMethod.js:
  (*!
   * Chai - addMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/overwriteProperty.js:
  (*!
   * Chai - overwriteProperty utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/overwriteMethod.js:
  (*!
   * Chai - overwriteMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/addChainableMethod.js:
  (*!
   * Chai - addChainingMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Module dependencies
   *)
  (*!
   * Module variables
   *)

chai/lib/chai/utils/overwriteChainableMethod.js:
  (*!
   * Chai - overwriteChainableMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/compareByInspect.js:
  (*!
   * Chai - compareByInspect utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Module dependencies
   *)

chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js:
  (*!
   * Chai - getOwnEnumerablePropertySymbols utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/getOwnEnumerableProperties.js:
  (*!
   * Chai - getOwnEnumerableProperties utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Module dependencies
   *)

chai/lib/chai/utils/isNaN.js:
  (*!
   * Chai - isNaN utility
   * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
   * MIT Licensed
   *)

chai/lib/chai/utils/index.js:
  (*!
   * chai
   * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Dependencies that are used for multiple exports are required here only once
   *)
  (*!
   * test utility
   *)
  (*!
   * type utility
   *)
  (*!
   * expectTypes utility
   *)
  (*!
   * message utility
   *)
  (*!
   * actual utility
   *)
  (*!
   * Inspect util
   *)
  (*!
   * Object Display util
   *)
  (*!
   * Flag utility
   *)
  (*!
   * Flag transferring utility
   *)
  (*!
   * Deep equal utility
   *)
  (*!
   * Deep path info
   *)
  (*!
   * Check if a property exists
   *)
  (*!
   * Function name
   *)
  (*!
   * add Property
   *)
  (*!
   * add Method
   *)
  (*!
   * overwrite Property
   *)
  (*!
   * overwrite Method
   *)
  (*!
   * Add a chainable method
   *)
  (*!
   * Overwrite chainable method
   *)
  (*!
   * Compare by inspect method
   *)
  (*!
   * Get own enumerable property symbols method
   *)
  (*!
   * Get own enumerable properties method
   *)
  (*!
   * Checks error against a given set of criteria
   *)
  (*!
   * Proxify util
   *)
  (*!
   * addLengthGuard util
   *)
  (*!
   * isProxyEnabled helper
   *)
  (*!
   * isNaN method
   *)
  (*!
   * getOperator method
   *)

chai/lib/chai/assertion.js:
  (*!
   * chai
   * http://chaijs.com
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Module dependencies.
   *)
  (*!
   * Module export.
   *)
  (*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   *)
  (*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   *)

chai/lib/chai/core/assertions.js:
  (*!
   * chai
   * http://chaijs.com
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/interface/expect.js:
chai/lib/chai/interface/should.js:
  (*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)

chai/lib/chai/interface/assert.js:
  (*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai dependencies.
   *)
  (*!
   * Module export.
   *)
  (*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   *)
  (*!
   * Aliases.
   *)

chai/lib/chai.js:
  (*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai version
   *)
  (*!
   * Assertion Error
   *)
  (*!
   * Utils for plugins (not exported)
   *)
  (*!
   * Utility Functions
   *)
  (*!
   * Configuration
   *)
  (*!
   * Primary `Assertion` prototype
   *)
  (*!
   * Core Assertions
   *)
  (*!
   * Expect interface
   *)
  (*!
   * Should interface
   *)
  (*!
   * Assert interface
   *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=entry.hidden-window.min.js.map
