// src/components/Form.tsx
import { Component as Component5, createRef } from "react";
import {
  createSchemaUtils,
  deepEquals as deepEquals2,
  getChangedFields,
  getTemplate as getTemplate25,
  getUiOptions as getUiOptions17,
  isObject as isObject6,
  mergeObjects as mergeObjects3,
  NAME_KEY,
  RJSF_ADDITIONAL_PROPERTIES_FLAG,
  shouldRender as shouldRender2,
  SUBMIT_BTN_OPTIONS_KEY,
  toErrorList,
  UI_GLOBAL_OPTIONS_KEY as UI_GLOBAL_OPTIONS_KEY2,
  UI_OPTIONS_KEY as UI_OPTIONS_KEY3,
  validationDataMerge,
  createErrorHandler,
  unwrapErrorHandler
} from "@rjsf/utils";
import _cloneDeep from "lodash/cloneDeep";
import _forEach from "lodash/forEach";
import _get from "lodash/get";
import _isEmpty from "lodash/isEmpty";
import _isNil from "lodash/isNil";
import _pick from "lodash/pick";
import _set from "lodash/set";
import _toPath from "lodash/toPath";

// src/getDefaultRegistry.ts
import { englishStringTranslator } from "@rjsf/utils";

// src/components/fields/ArrayField.tsx
import { Component } from "react";
import {
  getTemplate,
  getWidget,
  getUiOptions,
  isFixedItems,
  allowAdditionalItems,
  isCustomWidget,
  optionsList,
  TranslatableString,
  ITEMS_KEY
} from "@rjsf/utils";
import cloneDeep from "lodash/cloneDeep";
import get from "lodash/get";
import isObject from "lodash/isObject";
import set from "lodash/set";
import uniqueId from "lodash/uniqueId";
import { jsx } from "react/jsx-runtime";
function generateRowId() {
  return uniqueId("rjsf-array-item-");
}
function generateKeyedFormData(formData) {
  return !Array.isArray(formData) ? [] : formData.map((item) => {
    return {
      key: generateRowId(),
      item
    };
  });
}
function keyedToPlainFormData(keyedFormData) {
  if (Array.isArray(keyedFormData)) {
    return keyedFormData.map((keyedItem) => keyedItem.item);
  }
  return [];
}
var ArrayField = class extends Component {
  /** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(props) {
    super(props);
    const { formData = [] } = props;
    const keyedFormData = generateKeyedFormData(formData);
    this.state = {
      keyedFormData,
      updatedKeyedFormData: false
    };
  }
  /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It
   * regenerates the keyed form data and returns it
   *
   * @param nextProps - The next set of props data
   * @param prevState - The previous set of state data
   */
  static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.updatedKeyedFormData) {
      return {
        updatedKeyedFormData: false
      };
    }
    const nextFormData = Array.isArray(nextProps.formData) ? nextProps.formData : [];
    const previousKeyedFormData = prevState.keyedFormData || [];
    const newKeyedFormData = nextFormData.length === previousKeyedFormData.length ? previousKeyedFormData.map((previousKeyedFormDatum, index) => {
      return {
        key: previousKeyedFormDatum.key,
        item: nextFormData[index]
      };
    }) : generateKeyedFormData(nextFormData);
    return {
      keyedFormData: newKeyedFormData
    };
  }
  /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to
   * the description from the schema.items, and finally the string "Item"
   */
  get itemTitle() {
    const { schema, registry } = this.props;
    const { translateString } = registry;
    return get(
      schema,
      [ITEMS_KEY, "title"],
      get(schema, [ITEMS_KEY, "description"], translateString(TranslatableString.ArrayItemTitle))
    );
  }
  /** Determines whether the item described in the schema is always required, which is determined by whether any item
   * may be null.
   *
   * @param itemSchema - The schema for the item
   * @return - True if the item schema type does not contain the "null" type
   */
  isItemRequired(itemSchema) {
    if (Array.isArray(itemSchema.type)) {
      return !itemSchema.type.includes("null");
    }
    return itemSchema.type !== "null";
  }
  /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding
   * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the
   * `formData` matches that value, then false is returned, otherwise true is returned.
   *
   * @param formItems - The list of items in the form
   * @returns - True if the item is addable otherwise false
   */
  canAddItem(formItems) {
    const { schema, uiSchema, registry } = this.props;
    let { addable } = getUiOptions(uiSchema, registry.globalUiOptions);
    if (addable !== false) {
      if (schema.maxItems !== void 0) {
        addable = formItems.length < schema.maxItems;
      } else {
        addable = true;
      }
    }
    return addable;
  }
  /** Returns the default form information for an item based on the schema for that item. Deals with the possibility
   * that the schema is fixed and allows additional items.
   */
  _getNewFormDataRow = () => {
    const { schema, registry } = this.props;
    const { schemaUtils } = registry;
    let itemSchema = schema.items;
    if (isFixedItems(schema) && allowAdditionalItems(schema)) {
      itemSchema = schema.additionalItems;
    }
    return schemaUtils.getDefaultFormState(itemSchema);
  };
  /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data
   * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into
   * the state, and then returning `onChange()` with the plain form data converted from the keyed data
   *
   * @param event - The event for the click
   * @param [index] - The optional index at which to add the new data
   */
  _handleAddClick(event, index) {
    if (event) {
      event.preventDefault();
    }
    const { onChange, errorSchema } = this.props;
    const { keyedFormData } = this.state;
    let newErrorSchema;
    if (errorSchema) {
      newErrorSchema = {};
      for (const idx in errorSchema) {
        const i = parseInt(idx);
        if (index === void 0 || i < index) {
          set(newErrorSchema, [i], errorSchema[idx]);
        } else if (i >= index) {
          set(newErrorSchema, [i + 1], errorSchema[idx]);
        }
      }
    }
    const newKeyedFormDataRow = {
      key: generateRowId(),
      item: this._getNewFormDataRow()
    };
    const newKeyedFormData = [...keyedFormData];
    if (index !== void 0) {
      newKeyedFormData.splice(index, 0, newKeyedFormDataRow);
    } else {
      newKeyedFormData.push(newKeyedFormDataRow);
    }
    this.setState(
      {
        keyedFormData: newKeyedFormData,
        updatedKeyedFormData: true
      },
      // add click will pass the empty `path` array to the onChange which adds the appropriate path
      () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
    );
  }
  /** Callback handler for when the user clicks on the add button. Creates a new row of keyed form data at the end of
   * the list, adding it into the state, and then returning `onChange()` with the plain form data converted from the
   * keyed data
   *
   * @param event - The event for the click
   */
  onAddClick = (event) => {
    this._handleAddClick(event);
  };
  /** Callback handler for when the user clicks on the add button on an existing array element. Creates a new row of
   * keyed form data inserted at the `index`, adding it into the state, and then returning `onChange()` with the plain
   * form data converted from the keyed data
   *
   * @param index - The index at which the add button is clicked
   */
  onAddIndexClick = (index) => {
    return (event) => {
      this._handleAddClick(event, index);
    };
  };
  /** Callback handler for when the user clicks on the copy button on an existing array element. Clones the row of
   * keyed form data at the `index` into the next position in the state, and then returning `onChange()` with the plain
   * form data converted from the keyed data
   *
   * @param index - The index at which the copy button is clicked
   */
  onCopyIndexClick = (index) => {
    return (event) => {
      if (event) {
        event.preventDefault();
      }
      const { onChange, errorSchema } = this.props;
      const { keyedFormData } = this.state;
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (i <= index) {
            set(newErrorSchema, [i], errorSchema[idx]);
          } else if (i > index) {
            set(newErrorSchema, [i + 1], errorSchema[idx]);
          }
        }
      }
      const newKeyedFormDataRow = {
        key: generateRowId(),
        item: cloneDeep(keyedFormData[index].item)
      };
      const newKeyedFormData = [...keyedFormData];
      if (index !== void 0) {
        newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);
      } else {
        newKeyedFormData.push(newKeyedFormDataRow);
      }
      this.setState(
        {
          keyedFormData: newKeyedFormData,
          updatedKeyedFormData: true
        },
        // Copy index will pass the empty `path` array to the onChange which adds the appropriate path
        () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
      );
    };
  };
  /** Callback handler for when the user clicks on the remove button on an existing array element. Removes the row of
   * keyed form data at the `index` in the state, and then returning `onChange()` with the plain form data converted
   * from the keyed data
   *
   * @param index - The index at which the remove button is clicked
   */
  onDropIndexClick = (index) => {
    return (event) => {
      if (event) {
        event.preventDefault();
      }
      const { onChange, errorSchema } = this.props;
      const { keyedFormData } = this.state;
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (i < index) {
            set(newErrorSchema, [i], errorSchema[idx]);
          } else if (i > index) {
            set(newErrorSchema, [i - 1], errorSchema[idx]);
          }
        }
      }
      const newKeyedFormData = keyedFormData.filter((_, i) => i !== index);
      this.setState(
        {
          keyedFormData: newKeyedFormData,
          updatedKeyedFormData: true
        },
        // drop index will pass the empty `path` array to the onChange which adds the appropriate path
        () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
      );
    };
  };
  /** Callback handler for when the user clicks on one of the move item buttons on an existing array element. Moves the
   * row of keyed form data at the `index` to the `newIndex` in the state, and then returning `onChange()` with the
   * plain form data converted from the keyed data
   *
   * @param index - The index of the item to move
   * @param newIndex - The index to where the item is to be moved
   */
  onReorderClick = (index, newIndex) => {
    return (event) => {
      if (event) {
        event.preventDefault();
        event.currentTarget.blur();
      }
      const { onChange, errorSchema } = this.props;
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (i == index) {
            set(newErrorSchema, [newIndex], errorSchema[index]);
          } else if (i == newIndex) {
            set(newErrorSchema, [index], errorSchema[newIndex]);
          } else {
            set(newErrorSchema, [idx], errorSchema[i]);
          }
        }
      }
      const { keyedFormData } = this.state;
      function reOrderArray() {
        const _newKeyedFormData = keyedFormData.slice();
        _newKeyedFormData.splice(index, 1);
        _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);
        return _newKeyedFormData;
      }
      const newKeyedFormData = reOrderArray();
      this.setState(
        {
          keyedFormData: newKeyedFormData
        },
        // reorder click will pass the empty `path` array to the onChange which adds the appropriate path
        () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
      );
    };
  };
  /** Callback handler used to deal with changing the value of the data in the array at the `index`. Calls the
   * `onChange` callback with the updated form data
   *
   * @param index - The index of the item being changed
   */
  onChangeForIndex = (index) => {
    return (value, path, newErrorSchema, id) => {
      const { onChange } = this.props;
      const changePath = Array.isArray(path) ? path.slice() : [];
      changePath.unshift(index);
      onChange(
        // We need to treat undefined items as nulls to have validation.
        // See https://github.com/tdegrunt/jsonschema/issues/206
        value === void 0 ? null : value,
        changePath,
        newErrorSchema,
        id
      );
    };
  };
  /** Callback handler used to change the value for a checkbox */
  onSelectChange = (value) => {
    const { onChange, idSchema } = this.props;
    onChange(value, [], void 0, idSchema && idSchema.$id);
  };
  /** Helper method to compute item UI schema for both normal and fixed arrays
   * Handles both static object and dynamic function cases
   *
   * @param uiSchema - The parent UI schema containing items definition
   * @param item - The item data
   * @param index - The index of the item
   * @param formContext - The form context
   * @returns The computed UI schema for the item
   */
  computeItemUiSchema(uiSchema, item, index, formContext) {
    if (typeof uiSchema.items === "function") {
      try {
        const result = uiSchema.items(item, index, formContext);
        return result;
      } catch (e) {
        console.error(`Error executing dynamic uiSchema.items function for item at index ${index}:`, e);
        return void 0;
      }
    } else {
      return uiSchema.items;
    }
  }
  /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements
   */
  render() {
    const { schema, uiSchema, idSchema, registry } = this.props;
    const { schemaUtils, translateString } = registry;
    if (!(ITEMS_KEY in schema)) {
      const uiOptions = getUiOptions(uiSchema);
      const UnsupportedFieldTemplate = getTemplate(
        "UnsupportedFieldTemplate",
        registry,
        uiOptions
      );
      return /* @__PURE__ */ jsx(
        UnsupportedFieldTemplate,
        {
          schema,
          idSchema,
          reason: translateString(TranslatableString.MissingItems),
          registry
        }
      );
    }
    if (schemaUtils.isMultiSelect(schema)) {
      return this.renderMultiSelect();
    }
    if (isCustomWidget(uiSchema)) {
      return this.renderCustomWidget();
    }
    if (isFixedItems(schema)) {
      return this.renderFixedArray();
    }
    if (schemaUtils.isFilesArray(schema, uiSchema)) {
      return this.renderFiles();
    }
    return this.renderNormalArray();
  }
  /** Renders a normal array without any limitations of length
   */
  renderNormalArray() {
    const {
      schema,
      uiSchema = {},
      errorSchema,
      idSchema,
      name,
      title,
      disabled = false,
      readonly = false,
      autofocus = false,
      required = false,
      registry,
      onBlur,
      onFocus,
      idPrefix,
      idSeparator = "_",
      rawErrors
    } = this.props;
    const { keyedFormData } = this.state;
    const fieldTitle = schema.title || title || name;
    const { schemaUtils, formContext } = registry;
    const uiOptions = getUiOptions(uiSchema);
    const _schemaItems = isObject(schema.items) ? schema.items : {};
    const itemsSchema = schemaUtils.retrieveSchema(_schemaItems);
    const formData = keyedToPlainFormData(this.state.keyedFormData);
    const canAdd = this.canAddItem(formData);
    const arrayProps = {
      canAdd,
      items: keyedFormData.map((keyedItem, index) => {
        const { key, item } = keyedItem;
        const itemCast = item;
        const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);
        const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
        const itemIdPrefix = idSchema.$id + idSeparator + index;
        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);
        const itemUiSchema = this.computeItemUiSchema(uiSchema, item, index, formContext);
        return this.renderArrayFieldItem({
          key,
          index,
          name: name && `${name}-${index}`,
          title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
          canAdd,
          canMoveUp: index > 0,
          canMoveDown: index < formData.length - 1,
          itemSchema,
          itemIdSchema,
          itemErrorSchema,
          itemData: itemCast,
          itemUiSchema,
          autofocus: autofocus && index === 0,
          onBlur,
          onFocus,
          rawErrors,
          totalItems: keyedFormData.length
        });
      }),
      className: `rjsf-field rjsf-field-array rjsf-field-array-of-${itemsSchema.type}`,
      disabled,
      idSchema,
      uiSchema,
      onAddClick: this.onAddClick,
      readonly,
      required,
      schema,
      title: fieldTitle,
      formContext,
      formData,
      rawErrors,
      registry
    };
    const Template = getTemplate("ArrayFieldTemplate", registry, uiOptions);
    return /* @__PURE__ */ jsx(Template, { ...arrayProps });
  }
  /** Renders an array using the custom widget provided by the user in the `uiSchema`
   */
  renderCustomWidget() {
    const {
      schema,
      idSchema,
      uiSchema,
      disabled = false,
      readonly = false,
      autofocus = false,
      required = false,
      hideError,
      placeholder,
      onBlur,
      onFocus,
      formData: items = [],
      registry,
      rawErrors,
      name
    } = this.props;
    const { widgets: widgets2, formContext, globalUiOptions, schemaUtils } = registry;
    const { widget, title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);
    const Widget = getWidget(schema, widget, widgets2);
    const label = uiTitle ?? schema.title ?? name;
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    return /* @__PURE__ */ jsx(
      Widget,
      {
        id: idSchema.$id,
        name,
        multiple: true,
        onChange: this.onSelectChange,
        onBlur,
        onFocus,
        options,
        schema,
        uiSchema,
        registry,
        value: items,
        disabled,
        readonly,
        hideError,
        required,
        label,
        hideLabel: !displayLabel,
        placeholder,
        formContext,
        autofocus,
        rawErrors
      }
    );
  }
  /** Renders an array as a set of checkboxes
   */
  renderMultiSelect() {
    const {
      schema,
      idSchema,
      uiSchema,
      formData: items = [],
      disabled = false,
      readonly = false,
      autofocus = false,
      required = false,
      placeholder,
      onBlur,
      onFocus,
      registry,
      rawErrors,
      name
    } = this.props;
    const { widgets: widgets2, schemaUtils, formContext, globalUiOptions } = registry;
    const itemsSchema = schemaUtils.retrieveSchema(schema.items, items);
    const enumOptions = optionsList(itemsSchema, uiSchema);
    const { widget = "select", title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);
    const Widget = getWidget(schema, widget, widgets2);
    const label = uiTitle ?? schema.title ?? name;
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    return /* @__PURE__ */ jsx(
      Widget,
      {
        id: idSchema.$id,
        name,
        multiple: true,
        onChange: this.onSelectChange,
        onBlur,
        onFocus,
        options: { ...options, enumOptions },
        schema,
        uiSchema,
        registry,
        value: items,
        disabled,
        readonly,
        required,
        label,
        hideLabel: !displayLabel,
        placeholder,
        formContext,
        autofocus,
        rawErrors
      }
    );
  }
  /** Renders an array of files using the `FileWidget`
   */
  renderFiles() {
    const {
      schema,
      uiSchema,
      idSchema,
      name,
      disabled = false,
      readonly = false,
      autofocus = false,
      required = false,
      onBlur,
      onFocus,
      registry,
      formData: items = [],
      rawErrors
    } = this.props;
    const { widgets: widgets2, formContext, globalUiOptions, schemaUtils } = registry;
    const { widget = "files", title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);
    const Widget = getWidget(schema, widget, widgets2);
    const label = uiTitle ?? schema.title ?? name;
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    return /* @__PURE__ */ jsx(
      Widget,
      {
        options,
        id: idSchema.$id,
        name,
        multiple: true,
        onChange: this.onSelectChange,
        onBlur,
        onFocus,
        schema,
        uiSchema,
        value: items,
        disabled,
        readonly,
        required,
        registry,
        formContext,
        autofocus,
        rawErrors,
        label,
        hideLabel: !displayLabel
      }
    );
  }
  /** Renders an array that has a maximum limit of items
   */
  renderFixedArray() {
    const {
      schema,
      uiSchema = {},
      formData = [],
      errorSchema,
      idPrefix,
      idSeparator = "_",
      idSchema,
      name,
      title,
      disabled = false,
      readonly = false,
      autofocus = false,
      required = false,
      registry,
      onBlur,
      onFocus,
      rawErrors
    } = this.props;
    const { keyedFormData } = this.state;
    let { formData: items = [] } = this.props;
    const fieldTitle = schema.title || title || name;
    const uiOptions = getUiOptions(uiSchema);
    const { schemaUtils, formContext } = registry;
    const _schemaItems = isObject(schema.items) ? schema.items : [];
    const itemSchemas = _schemaItems.map(
      (item, index) => schemaUtils.retrieveSchema(item, formData[index])
    );
    const additionalSchema = isObject(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, formData) : null;
    if (!items || items.length < itemSchemas.length) {
      items = items || [];
      items = items.concat(new Array(itemSchemas.length - items.length));
    }
    const canAdd = this.canAddItem(items) && !!additionalSchema;
    const arrayProps = {
      canAdd,
      className: "rjsf-field rjsf-field-array rjsf-field-array-fixed-items",
      disabled,
      idSchema,
      formData,
      items: keyedFormData.map((keyedItem, index) => {
        const { key, item } = keyedItem;
        const itemCast = item;
        const additional = index >= itemSchemas.length;
        const itemSchema = (additional && isObject(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, itemCast) : itemSchemas[index]) || {};
        const itemIdPrefix = idSchema.$id + idSeparator + index;
        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);
        let itemUiSchema;
        if (additional) {
          itemUiSchema = uiSchema.additionalItems;
        } else {
          if (Array.isArray(uiSchema.items)) {
            itemUiSchema = uiSchema.items[index];
          } else {
            itemUiSchema = this.computeItemUiSchema(uiSchema, item, index, formContext);
          }
        }
        const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
        return this.renderArrayFieldItem({
          key,
          index,
          name: name && `${name}-${index}`,
          title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
          canAdd,
          canRemove: additional,
          canMoveUp: index >= itemSchemas.length + 1,
          canMoveDown: additional && index < items.length - 1,
          itemSchema,
          itemData: itemCast,
          itemUiSchema,
          itemIdSchema,
          itemErrorSchema,
          autofocus: autofocus && index === 0,
          onBlur,
          onFocus,
          rawErrors,
          totalItems: keyedFormData.length
        });
      }),
      onAddClick: this.onAddClick,
      readonly,
      required,
      registry,
      schema,
      uiSchema,
      title: fieldTitle,
      formContext,
      errorSchema,
      rawErrors
    };
    const Template = getTemplate("ArrayFieldTemplate", registry, uiOptions);
    return /* @__PURE__ */ jsx(Template, { ...arrayProps });
  }
  /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send
   * back to the `ArrayFieldItemTemplate`.
   *
   * @param props - The props for the individual array item to be rendered
   */
  renderArrayFieldItem(props) {
    const {
      key,
      index,
      name,
      canAdd,
      canRemove = true,
      canMoveUp,
      canMoveDown,
      itemSchema,
      itemData,
      itemUiSchema,
      itemIdSchema,
      itemErrorSchema,
      autofocus,
      onBlur,
      onFocus,
      rawErrors,
      totalItems,
      title
    } = props;
    const { disabled, hideError, idPrefix, idSeparator, readonly, uiSchema, registry, formContext } = this.props;
    const {
      fields: { ArraySchemaField, SchemaField: SchemaField2 },
      globalUiOptions
    } = registry;
    const ItemSchemaField = ArraySchemaField || SchemaField2;
    const { orderable = true, removable = true, copyable = false } = getUiOptions(uiSchema, globalUiOptions);
    const has4 = {
      moveUp: orderable && canMoveUp,
      moveDown: orderable && canMoveDown,
      copy: copyable && canAdd,
      remove: removable && canRemove,
      toolbar: false
    };
    has4.toolbar = Object.keys(has4).some((key2) => has4[key2]);
    return {
      children: /* @__PURE__ */ jsx(
        ItemSchemaField,
        {
          name,
          title,
          index,
          schema: itemSchema,
          uiSchema: itemUiSchema,
          formData: itemData,
          formContext,
          errorSchema: itemErrorSchema,
          idPrefix,
          idSeparator,
          idSchema: itemIdSchema,
          required: this.isItemRequired(itemSchema),
          onChange: this.onChangeForIndex(index),
          onBlur,
          onFocus,
          registry,
          disabled,
          readonly,
          hideError,
          autofocus,
          rawErrors
        }
      ),
      buttonsProps: {
        idSchema: itemIdSchema,
        disabled,
        readonly,
        canAdd,
        hasCopy: has4.copy,
        hasMoveUp: has4.moveUp,
        hasMoveDown: has4.moveDown,
        hasRemove: has4.remove,
        index,
        totalItems,
        onAddIndexClick: this.onAddIndexClick,
        onCopyIndexClick: this.onCopyIndexClick,
        onDropIndexClick: this.onDropIndexClick,
        onReorderClick: this.onReorderClick,
        registry,
        schema: itemSchema,
        uiSchema: itemUiSchema
      },
      className: "rjsf-array-item",
      disabled,
      hasToolbar: has4.toolbar,
      index,
      totalItems,
      key,
      readonly,
      registry,
      schema: itemSchema,
      uiSchema: itemUiSchema
    };
  }
};
var ArrayField_default = ArrayField;

// src/components/fields/BooleanField.tsx
import { useCallback } from "react";
import {
  getWidget as getWidget2,
  getUiOptions as getUiOptions2,
  optionsList as optionsList2,
  TranslatableString as TranslatableString2
} from "@rjsf/utils";
import isObject2 from "lodash/isObject";
import { jsx as jsx2 } from "react/jsx-runtime";
function BooleanField(props) {
  const {
    schema,
    name,
    uiSchema,
    idSchema,
    formData,
    registry,
    required,
    disabled,
    readonly,
    hideError,
    autofocus,
    title,
    onChange,
    onFocus,
    onBlur,
    rawErrors
  } = props;
  const { title: schemaTitle } = schema;
  const { widgets: widgets2, formContext, translateString, globalUiOptions } = registry;
  const {
    widget = "checkbox",
    title: uiTitle,
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: displayLabel = true,
    enumNames,
    ...options
  } = getUiOptions2(uiSchema, globalUiOptions);
  const Widget = getWidget2(schema, widget, widgets2);
  const yes = translateString(TranslatableString2.YesLabel);
  const no = translateString(TranslatableString2.NoLabel);
  let enumOptions;
  const label = uiTitle ?? schemaTitle ?? title ?? name;
  if (Array.isArray(schema.oneOf)) {
    enumOptions = optionsList2(
      {
        oneOf: schema.oneOf.map((option) => {
          if (isObject2(option)) {
            return {
              ...option,
              title: option.title || (option.const === true ? yes : no)
            };
          }
          return void 0;
        }).filter((o) => o)
        // cast away the error that typescript can't grok is fixed
      },
      uiSchema
    );
  } else {
    const enums = schema.enum ?? [true, false];
    if (!enumNames && enums.length === 2 && enums.every((v) => typeof v === "boolean")) {
      enumOptions = [
        {
          value: enums[0],
          label: enums[0] ? yes : no
        },
        {
          value: enums[1],
          label: enums[1] ? yes : no
        }
      ];
    } else {
      enumOptions = optionsList2({ enum: enums }, uiSchema);
    }
  }
  const onWidgetChange = useCallback(
    (value, errorSchema, id) => {
      return onChange(value, [], errorSchema, id);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsx2(
    Widget,
    {
      options: { ...options, enumOptions },
      schema,
      uiSchema,
      id: idSchema.$id,
      name,
      onChange: onWidgetChange,
      onFocus,
      onBlur,
      label,
      hideLabel: !displayLabel,
      value: formData,
      required,
      disabled,
      readonly,
      hideError,
      registry,
      formContext,
      autofocus,
      rawErrors
    }
  );
}
var BooleanField_default = BooleanField;

// src/components/fields/LayoutGridField.tsx
import { PureComponent } from "react";
import {
  ANY_OF_KEY,
  getDiscriminatorFieldFromSchema,
  getTemplate as getTemplate2,
  getTestIds,
  getUiOptions as getUiOptions3,
  hashObject,
  ID_KEY,
  lookupFromFormContext,
  mergeObjects,
  ONE_OF_KEY,
  PROPERTIES_KEY,
  READONLY_KEY,
  UI_OPTIONS_KEY,
  UI_GLOBAL_OPTIONS_KEY,
  ITEMS_KEY as ITEMS_KEY2
} from "@rjsf/utils";
import cloneDeep2 from "lodash/cloneDeep";
import each from "lodash/each";
import flatten from "lodash/flatten";
import get2 from "lodash/get";
import has from "lodash/has";
import includes from "lodash/includes";
import intersection from "lodash/intersection";
import isEmpty from "lodash/isEmpty";
import isFunction from "lodash/isFunction";
import isEqual from "lodash/isEqual";
import isObject3 from "lodash/isObject";
import isPlainObject from "lodash/isPlainObject";
import isString from "lodash/isString";
import isUndefined from "lodash/isUndefined";
import last from "lodash/last";
import set2 from "lodash/set";
import { jsx as jsx3 } from "react/jsx-runtime";
import { createElement } from "react";
var LOOKUP_REGEX = /^\$lookup=(.+)/;
var LAYOUT_GRID_UI_OPTION = "layoutGrid";
var LAYOUT_GRID_OPTION = `ui:${LAYOUT_GRID_UI_OPTION}`;
function getNonNullishValue(value, fallback) {
  return value ?? fallback;
}
function isNumericIndex(str) {
  return /^\d+?$/.test(str);
}
var LayoutGridField = class _LayoutGridField extends PureComponent {
  static defaultProps = {
    layoutGridSchema: void 0
  };
  static TEST_IDS = getTestIds();
  /** Computes the uiSchema for the field with `name` from the `uiProps` and `uiSchema` provided. The field UI Schema
   * will always contain a copy of the global options from the `uiSchema` (so they can be passed down) as well as
   * copying them into the local ui options. When the `forceReadonly` flag is true, then the field UI Schema is
   * updated to make "readonly" be true. When the `schemaReadonly` flag is true AND the field UI Schema does NOT have
   * the flag already provided, then we also make "readonly" true. We always make sure to return the final value of the
   * field UI Schema's "readonly" flag as `uiReadonly` along with the `fieldUiSchema` in the return value.
   *
   * @param field - The name of the field to pull the existing UI Schema for
   * @param uiProps - Any props that should be put into the field's uiSchema
   * @param [uiSchema] - The optional UI Schema from which to get the UI schema for the field
   * @param [schemaReadonly] - Optional flag indicating whether the schema indicates the field is readonly
   * @param [forceReadonly] - Optional flag indicating whether the Form itself is in readonly mode
   */
  static computeFieldUiSchema(field, uiProps, uiSchema, schemaReadonly, forceReadonly) {
    const globalUiOptions = get2(uiSchema, [UI_GLOBAL_OPTIONS_KEY], {});
    const localUiSchema = get2(uiSchema, field);
    const localUiOptions = { ...get2(localUiSchema, [UI_OPTIONS_KEY], {}), ...uiProps, ...globalUiOptions };
    const fieldUiSchema = { ...localUiSchema };
    if (!isEmpty(localUiOptions)) {
      set2(fieldUiSchema, [UI_OPTIONS_KEY], localUiOptions);
    }
    if (!isEmpty(globalUiOptions)) {
      set2(fieldUiSchema, [UI_GLOBAL_OPTIONS_KEY], globalUiOptions);
    }
    let { readonly: uiReadonly } = getUiOptions3(fieldUiSchema);
    if (forceReadonly === true || isUndefined(uiReadonly) && schemaReadonly === true) {
      uiReadonly = true;
      if (has(localUiOptions, READONLY_KEY)) {
        set2(fieldUiSchema, [UI_OPTIONS_KEY, READONLY_KEY], true);
      } else {
        set2(fieldUiSchema, `ui:${READONLY_KEY}`, true);
      }
    }
    return { fieldUiSchema, uiReadonly };
  }
  /** Given an `operator`, `datum` and `value` determines whether this condition is considered matching. Matching
   * depends on the `operator`. The `datum` and `value` are converted into arrays if they aren't already and then the
   * contents of the two arrays are compared using the `operator`. When `operator` is All, then the two arrays must be
   * equal to match. When `operator` is SOME then the intersection of the two arrays must have at least one value in
   * common to match. When `operator` is NONE then the intersection of the two arrays must not have any values in common
   * to match.
   *
   * @param [operator] - The optional operator for the condition
   * @param [datum] - The optional datum for the condition, this can be an item or a list of items of type unknown
   * @param [value='$0m3tH1nG Un3xP3cT3d'] The optional value for the condition, defaulting to a highly unlikely value
   *        to avoid comparing two undefined elements when `value` was forgotten in the condition definition.
   *        This can be an item or a list of items of type unknown
   * @returns - True if the condition matches, false otherwise
   */
  static conditionMatches(operator, datum, value = "$0m3tH1nG Un3xP3cT3d") {
    const data = flatten([datum]).sort();
    const values = flatten([value]).sort();
    switch (operator) {
      case "all" /* ALL */:
        return isEqual(data, values);
      case "some" /* SOME */:
        return intersection(data, values).length > 0;
      case "none" /* NONE */:
        return intersection(data, values).length === 0;
      default:
        return false;
    }
  }
  /** From within the `layoutGridSchema` finds the `children` and any extra `gridProps` from the object keyed by
   * `schemaKey`. If the `children` contains extra `gridProps` and those props contain a `className` string, try to
   * lookup whether that `className` has a replacement value in the `registry` using the `FORM_CONTEXT_LOOKUP_BASE`.
   * When the `className` value contains multiple classNames separated by a space, the lookup will look for a
   * replacement value for each `className` and combine them into one.
   *
   * @param layoutGridSchema - The GridSchemaType instance from which to obtain the `schemaKey` children and extra props
   * @param schemaKey - A `GridType` value, used to get the children and extra props from within the `layoutGridSchema`
   * @param registry - The `@rjsf` Registry from which to look up `classNames` if they are present in the extra props
   * @returns - An object containing the list of `LayoutGridSchemaType` `children` and any extra `gridProps`
   * @throws - A `TypeError` when the `children` is not an array
   */
  static findChildrenAndProps(layoutGridSchema, schemaKey, registry) {
    let gridProps = {};
    let children = layoutGridSchema[schemaKey];
    if (isPlainObject(children)) {
      const { children: elements, className: toMapClassNames, ...otherProps } = children;
      children = elements;
      if (toMapClassNames) {
        const classes = toMapClassNames.split(" ");
        const className = classes.map((ele) => lookupFromFormContext(registry, ele, ele)).join(" ");
        gridProps = { ...otherProps, className };
      } else {
        gridProps = otherProps;
      }
    }
    if (!Array.isArray(children)) {
      throw new TypeError(`Expected array for "${schemaKey}" in ${JSON.stringify(layoutGridSchema)}`);
    }
    return { children, gridProps };
  }
  /** Generates an idSchema for the `schema` using `@rjsf`'s `toIdSchema` util, passing the `baseIdSchema`'s `$id` value
   * as the id prefix.
   *
   * @param schemaUtils - The `SchemaUtilsType` used to call `toIdSchema`
   * @param schema - The schema to generate the idSchema for
   * @param baseIdSchema - The IdSchema for the base
   * @param formData - The formData to pass the `toIdSchema`
   * @param [idSeparator] - The param to pass into the `toIdSchema` util which will use it to join the `idSchema` paths
   * @returns - The generated `idSchema` for the `schema`
   */
  static getIdSchema(schemaUtils, baseIdSchema, formData, schema = {}, idSeparator) {
    const baseId = get2(baseIdSchema, ID_KEY);
    return schemaUtils.toIdSchema(schema, baseId, formData, baseId, idSeparator);
  }
  /** Computes the `rawSchema` and `idSchema` for a `schema` and a `potentialIndex`. If the `schema` is of type array,
   * has an `ITEMS_KEY` element and `potentialIndex` represents a numeric value, the element at `ITEMS_KEY` is checked
   * to see if it is an array. If it is AND the `potentialIndex`th element is available, it is used as the `rawSchema`,
   * otherwise the last value of the element is used. If it is not, then the element is used as the `rawSchema`. In
   * either case, an `idSchema` is computed for the array index. If the `schema` does not represent an array or the
   * `potentialIndex` is not a numeric value, then `rawSchema` is returned as undefined and given `idSchema` is returned
   * as is.
   *
   * @param schema - The schema to generate the idSchema for
   * @param idSchema - The IdSchema for the schema
   * @param potentialIndex - A string containing a potential index
   * @param [idSeparator] - The param to pass into the `toIdSchema` util which will use it to join the `idSchema` paths
   * @returns - An object containing the `rawSchema` and `idSchema` of an array item, otherwise an undefined `rawSchema`
   */
  static computeArraySchemasIfPresent(schema, idSchema, potentialIndex, idSeparator) {
    let rawSchema;
    if (isNumericIndex(potentialIndex) && schema && schema?.type === "array" && has(schema, ITEMS_KEY2)) {
      const index = Number(potentialIndex);
      const items = schema[ITEMS_KEY2];
      if (Array.isArray(items)) {
        if (index > items.length) {
          rawSchema = last(items);
        } else {
          rawSchema = items[index];
        }
      } else {
        rawSchema = items;
      }
      idSchema = { [ID_KEY]: `${idSchema[ID_KEY]}${idSeparator ?? "_"}${index}` };
    }
    return { rawSchema, idSchema };
  }
  /** Given a `dottedPath` to a field in the `initialSchema`, iterate through each individual path in the schema until
   * the leaf path is found and returned (along with whether that leaf path `isRequired`) OR no schema exists for an
   * element in the path. If the leaf schema element happens to be a oneOf/anyOf then also return the oneOf/anyOf as
   * `options`.
   *
   * @param schemaUtils - The `SchemaUtilsType` used to call `retrieveSchema`
   * @param dottedPath - The dotted-path to the field for which to get the schema
   * @param initialSchema - The initial schema to start the search from
   * @param formData - The formData, useful for resolving a oneOf/anyOf selection in the path hierarchy
   * @param initialIdSchema - The initial idSchema to start the search from
   * @param [idSeparator] - The param to pass into the `toIdSchema` util which will use it to join the `idSchema` paths
   * @returns - An object containing the destination schema, isRequired and isReadonly flags for the field and options
   *            info if a oneOf/anyOf
   */
  static getSchemaDetailsForField(schemaUtils, dottedPath, initialSchema, formData, initialIdSchema, idSeparator) {
    let rawSchema = initialSchema;
    let idSchema = initialIdSchema;
    const parts = dottedPath.split(".");
    const leafPath = parts.pop();
    let schema = schemaUtils.retrieveSchema(rawSchema, formData);
    let innerData = formData;
    let isReadonly = schema.readOnly;
    parts.forEach((part) => {
      if (has(schema, PROPERTIES_KEY)) {
        rawSchema = get2(schema, [PROPERTIES_KEY, part], {});
        idSchema = get2(idSchema, part, {});
      } else if (schema && (has(schema, ONE_OF_KEY) || has(schema, ANY_OF_KEY))) {
        const xxx = has(schema, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;
        const selectedSchema = schemaUtils.findSelectedOptionInXxxOf(schema, part, xxx, innerData);
        const selectedIdSchema = _LayoutGridField.getIdSchema(
          schemaUtils,
          idSchema,
          formData,
          selectedSchema,
          idSeparator
        );
        rawSchema = get2(selectedSchema, [PROPERTIES_KEY, part], {});
        idSchema = get2(selectedIdSchema, part, {});
      } else {
        const result = _LayoutGridField.computeArraySchemasIfPresent(schema, idSchema, part, idSeparator);
        rawSchema = result.rawSchema ?? {};
        idSchema = result.idSchema;
      }
      innerData = get2(innerData, part, {});
      schema = schemaUtils.retrieveSchema(rawSchema, innerData);
      isReadonly = getNonNullishValue(schema.readOnly, isReadonly);
    });
    let optionsInfo;
    let isRequired = false;
    if (isEmpty(schema)) {
      schema = void 0;
    }
    if (schema && leafPath) {
      if (schema && (has(schema, ONE_OF_KEY) || has(schema, ANY_OF_KEY))) {
        const xxx = has(schema, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;
        schema = schemaUtils.findSelectedOptionInXxxOf(schema, leafPath, xxx, innerData);
        const rawIdSchema = _LayoutGridField.getIdSchema(schemaUtils, idSchema, formData, schema, idSeparator);
        idSchema = mergeObjects(rawIdSchema, idSchema);
      }
      isRequired = schema !== void 0 && Array.isArray(schema.required) && includes(schema.required, leafPath);
      const result = _LayoutGridField.computeArraySchemasIfPresent(schema, idSchema, leafPath, idSeparator);
      if (result.rawSchema) {
        schema = result.rawSchema;
        idSchema = result.idSchema;
      } else {
        schema = get2(schema, [PROPERTIES_KEY, leafPath]);
        schema = schema ? schemaUtils.retrieveSchema(schema) : schema;
        idSchema = get2(idSchema, leafPath, {});
      }
      isReadonly = getNonNullishValue(schema?.readOnly, isReadonly);
      if (schema && (has(schema, ONE_OF_KEY) || has(schema, ANY_OF_KEY))) {
        const xxx = has(schema, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;
        const discriminator = getDiscriminatorFieldFromSchema(schema);
        optionsInfo = { options: schema[xxx], hasDiscriminator: !!discriminator };
      }
    }
    return { schema, isRequired, isReadonly, optionsInfo, idSchema };
  }
  /** Gets the custom render component from the `render`, by either determining that it is either already a function or
   * it is a non-function value that can be used to look up the function in the registry. If no function can be found,
   * null is returned.
   *
   * @param render - The potential render function or lookup name to one
   * @param registry - The `@rjsf` Registry from which to look up `classNames` if they are present in the extra props
   * @returns - Either a render function if available, or null if not
   */
  static getCustomRenderComponent(render, registry) {
    let customRenderer = render;
    if (isString(customRenderer)) {
      customRenderer = lookupFromFormContext(registry, customRenderer);
    }
    if (isFunction(customRenderer)) {
      return customRenderer;
    }
    return null;
  }
  /** Extract the `name`, and optional `render` and all other props from the `gridSchema`. We look up the `render` to
   * see if can be resolved to a UIComponent. If `name` does not exist and there is an optional `render` UIComponent, we
   * set the `rendered` component with only specified props for that component in the object.
   *
   * @param registry - The `@rjsf` Registry from which to look up `classNames` if they are present in the extra props
   * @param gridSchema - The string or object that represents the configuration for the grid field
   * @returns - The UIComponentPropsType computed from the gridSchema
   */
  static computeUIComponentPropsFromGridSchema(registry, gridSchema) {
    let name;
    let UIComponent = null;
    let uiProps = {};
    let rendered;
    if (isString(gridSchema) || isUndefined(gridSchema)) {
      name = gridSchema ?? "";
    } else {
      const { name: innerName = "", render, ...innerProps } = gridSchema;
      name = innerName;
      uiProps = innerProps;
      if (!isEmpty(uiProps)) {
        each(uiProps, (prop, key) => {
          if (isString(prop)) {
            const match = LOOKUP_REGEX.exec(prop);
            if (Array.isArray(match) && match.length > 1) {
              const name2 = match[1];
              uiProps[key] = lookupFromFormContext(registry, name2, name2);
            }
          }
        });
      }
      UIComponent = _LayoutGridField.getCustomRenderComponent(render, registry);
      if (!innerName && UIComponent) {
        rendered = /* @__PURE__ */ jsx3(UIComponent, { ...innerProps, "data-testid": _LayoutGridField.TEST_IDS.uiComponent });
      }
    }
    return { name, UIComponent, uiProps, rendered };
  }
  /** Constructs an `LayoutGridField` with the given `props`
   *
   * @param props - The `LayoutGridField` for this template
   */
  constructor(props) {
    super(props);
  }
  /** Generates an `onChange` handler for the field associated with the `dottedPath`. This handler will clone and update
   * the `formData` with the new `value` and the `errorSchema` if an `errSchema` is provided. After updating those two
   * elements, they will then be passed on to the `onChange` handler of the `LayoutFieldGrid`.
   *
   * @param dottedPath - The dotted-path to the field for which to generate the onChange handler
   * @returns - The `onChange` handling function for the `dottedPath` field
   */
  onFieldChange = (dottedPath) => {
    return (value, path, errSchema, id) => {
      const { onChange, errorSchema } = this.props;
      let newErrorSchema = errorSchema;
      if (errSchema && errorSchema) {
        newErrorSchema = cloneDeep2(errorSchema);
        set2(newErrorSchema, dottedPath, errSchema);
      }
      onChange(value, dottedPath.split("."), newErrorSchema, id);
    };
  };
  /** Renders the `children` of the `GridType.CONDITION` if it passes. The `layoutGridSchema` for the
   * `GridType.CONDITION` is separated into the `children` and other `gridProps`. The `gridProps` are used to extract
   * the `operator`, `field` and `value` of the condition. If the condition matches, then all of the `children` are
   * rendered, otherwise null is returned.
   *
   * @param layoutGridSchema - The string or object that represents the configuration for the grid field
   * @returns - The rendered the children for the `GridType.CONDITION` or null
   */
  renderCondition(layoutGridSchema) {
    const { formData, registry } = this.props;
    const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
      layoutGridSchema,
      "ui:condition" /* CONDITION */,
      registry
    );
    const { operator, field = "", value } = gridProps;
    const fieldData = get2(formData, field, null);
    if (_LayoutGridField.conditionMatches(operator, fieldData, value)) {
      return this.renderChildren(children);
    }
    return null;
  }
  /** Renders a material-ui `GridTemplate` as an item. The `layoutGridSchema` for the `GridType.COLUMN` is separated
   * into the `children` and other `gridProps`. The `gridProps` will be spread onto the outer `GridTemplate`. Inside
   * the `GridTemplate` all the `children` are rendered.
   *
   * @param layoutGridSchema - The string or object that represents the configuration for the grid field
   * @returns - The rendered `GridTemplate` containing the children for the `GridType.COLUMN`
   */
  renderCol(layoutGridSchema) {
    const { registry, uiSchema } = this.props;
    const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
      layoutGridSchema,
      "ui:col" /* COLUMN */,
      registry
    );
    const uiOptions = getUiOptions3(uiSchema);
    const GridTemplate2 = getTemplate2("GridTemplate", registry, uiOptions);
    return /* @__PURE__ */ jsx3(GridTemplate2, { column: true, "data-testid": _LayoutGridField.TEST_IDS.col, ...gridProps, children: this.renderChildren(children) });
  }
  /** Renders a material-ui `GridTemplate` as an item. The `layoutGridSchema` for the `GridType.COLUMNS` is separated
   * into the `children` and other `gridProps`. The `children` is iterated on and `gridProps` will be spread onto the
   * outer `GridTemplate`. Each child will have their own rendered `GridTemplate`.
   *
   * @param layoutGridSchema - The string or object that represents the configuration for the grid field
   * @returns - The rendered `GridTemplate` containing the children for the `GridType.COLUMNS`
   */
  renderColumns(layoutGridSchema) {
    const { registry, uiSchema } = this.props;
    const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
      layoutGridSchema,
      "ui:columns" /* COLUMNS */,
      registry
    );
    const uiOptions = getUiOptions3(uiSchema);
    const GridTemplate2 = getTemplate2("GridTemplate", registry, uiOptions);
    return children.map((child) => /* @__PURE__ */ jsx3(
      GridTemplate2,
      {
        column: true,
        "data-testid": _LayoutGridField.TEST_IDS.col,
        ...gridProps,
        children: this.renderChildren([child])
      },
      `column-${hashObject(child)}`
    ));
  }
  /** Renders a material-ui `GridTemplate` as a container. The
   * `layoutGridSchema` for the `GridType.ROW` is separated into the `children` and other `gridProps`. The `gridProps`
   * will be spread onto the outer `GridTemplate`. Inside of the `GridTemplate` all of the `children` are rendered.
   *
   * @param layoutGridSchema - The string or object that represents the configuration for the grid field
   * @returns - The rendered `GridTemplate` containing the children for the `GridType.ROW`
   */
  renderRow(layoutGridSchema) {
    const { registry, uiSchema } = this.props;
    const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
      layoutGridSchema,
      "ui:row" /* ROW */,
      registry
    );
    const uiOptions = getUiOptions3(uiSchema);
    const GridTemplate2 = getTemplate2("GridTemplate", registry, uiOptions);
    return /* @__PURE__ */ jsx3(GridTemplate2, { ...gridProps, "data-testid": _LayoutGridField.TEST_IDS.row, children: this.renderChildren(children) });
  }
  /** Iterates through all the `childrenLayoutGridSchema`, rendering a nested `LayoutGridField` for each item in the
   * list, passing all the props for the current `LayoutGridField` along, updating the `schema` by calling
   * `retrieveSchema()` on it to resolve any `$ref`s. In addition to the updated `schema`, each item in
   * `childrenLayoutGridSchema` is passed as `layoutGridSchema`.
   *
   * @param childrenLayoutGridSchema - The list of strings or objects that represents the configurations for the
   *          children fields
   * @returns - The nested `LayoutGridField`s
   */
  renderChildren(childrenLayoutGridSchema) {
    const { registry, schema: rawSchema, formData } = this.props;
    const { schemaUtils } = registry;
    const schema = schemaUtils.retrieveSchema(rawSchema, formData);
    return childrenLayoutGridSchema.map((layoutGridSchema) => /* @__PURE__ */ createElement(
      _LayoutGridField,
      {
        ...this.props,
        key: `layoutGrid-${hashObject(layoutGridSchema)}`,
        schema,
        layoutGridSchema
      }
    ));
  }
  /** Renders the field described by `gridSchema`. If `gridSchema` is not an object, then is will be assumed
   * to be the dotted-path to the field in the schema. Otherwise, we extract the `name`, and optional `render` and all
   * other props. If `name` does not exist and there is an optional `render`, we return the `render` component with only
   * specified props for that component. If `name` exists, we take the name, the initial & root schemas and the formData
   * and get the destination schema, is required state and optional oneOf/anyOf options for it. If the destination
   * schema was located along with oneOf/anyOf options then a `LayoutMultiSchemaField` will be rendered with the
   * `uiSchema`, `errorSchema`, `idSchema` and `formData` drilled down to the dotted-path field, spreading any other
   * props from `gridSchema` into the `ui:options`. If the destination schema located without any oneOf/anyOf options,
   * then a `SchemaField` will be rendered with the same props as mentioned in the previous sentence. If no destination
   * schema was located, but a custom render component was found, then it will be rendered with many of the non-event
   * handling props. If none of the previous render paths are valid, then a null is returned.
   *
   * @param gridSchema - The string or object that represents the configuration for the grid field
   * @returns - One of `LayoutMultiSchemaField`, `SchemaField`, a custom render component or null, depending
   */
  renderField(gridSchema) {
    const {
      schema: initialSchema,
      uiSchema,
      errorSchema,
      idSchema,
      onBlur,
      onFocus,
      formData,
      readonly,
      registry,
      idSeparator,
      layoutGridSchema,
      // Used to pull this out of otherProps since we don't want to pass it through
      ...otherProps
    } = this.props;
    const { fields: fields2, schemaUtils } = registry;
    const { SchemaField: SchemaField2, LayoutMultiSchemaField: LayoutMultiSchemaField2 } = fields2;
    const uiComponentProps = _LayoutGridField.computeUIComponentPropsFromGridSchema(registry, gridSchema);
    if (uiComponentProps.rendered) {
      return uiComponentProps.rendered;
    }
    const { name, UIComponent, uiProps } = uiComponentProps;
    const {
      schema,
      isRequired,
      isReadonly,
      optionsInfo,
      idSchema: fieldIdSchema
    } = _LayoutGridField.getSchemaDetailsForField(
      schemaUtils,
      name,
      initialSchema,
      formData,
      idSchema,
      idSeparator
    );
    if (schema) {
      const Field = optionsInfo?.hasDiscriminator ? LayoutMultiSchemaField2 : SchemaField2;
      const { fieldUiSchema, uiReadonly } = _LayoutGridField.computeFieldUiSchema(
        name,
        uiProps,
        uiSchema,
        isReadonly,
        readonly
      );
      return /* @__PURE__ */ jsx3(
        Field,
        {
          "data-testid": optionsInfo?.hasDiscriminator ? _LayoutGridField.TEST_IDS.layoutMultiSchemaField : _LayoutGridField.TEST_IDS.field,
          ...otherProps,
          name,
          required: isRequired,
          readonly: uiReadonly,
          schema,
          uiSchema: fieldUiSchema,
          errorSchema: get2(errorSchema, name),
          idSchema: fieldIdSchema,
          idSeparator,
          formData: get2(formData, name),
          onChange: this.onFieldChange(name),
          onBlur,
          onFocus,
          options: optionsInfo?.options,
          registry
        }
      );
    }
    if (UIComponent) {
      return /* @__PURE__ */ jsx3(
        UIComponent,
        {
          "data-testid": _LayoutGridField.TEST_IDS.uiComponent,
          ...otherProps,
          name,
          required: isRequired,
          formData,
          readOnly: !!isReadonly || readonly,
          errorSchema,
          uiSchema,
          schema: initialSchema,
          idSchema,
          idSeparator,
          onBlur,
          onFocus,
          registry,
          ...uiProps
        }
      );
    }
    return null;
  }
  /** Renders the `LayoutGridField`. If there isn't a `layoutGridSchema` prop defined, then try pulling it out of the
   * `uiSchema` via `ui:LayoutGridField`. If `layoutGridSchema` is an object, then check to see if any of the properties
   * match one of the `GridType`s. If so, call the appropriate render function for the type. Otherwise, just call the
   * generic `renderField()` function with the `layoutGridSchema`.
   *
   * @returns - the rendered `LayoutGridField`
   */
  render() {
    const { uiSchema } = this.props;
    let { layoutGridSchema } = this.props;
    const uiOptions = getUiOptions3(uiSchema);
    if (!layoutGridSchema && LAYOUT_GRID_UI_OPTION in uiOptions && isObject3(uiOptions[LAYOUT_GRID_UI_OPTION])) {
      layoutGridSchema = uiOptions[LAYOUT_GRID_UI_OPTION];
    }
    if (isObject3(layoutGridSchema)) {
      if ("ui:row" /* ROW */ in layoutGridSchema) {
        return this.renderRow(layoutGridSchema);
      }
      if ("ui:col" /* COLUMN */ in layoutGridSchema) {
        return this.renderCol(layoutGridSchema);
      }
      if ("ui:columns" /* COLUMNS */ in layoutGridSchema) {
        return this.renderColumns(layoutGridSchema);
      }
      if ("ui:condition" /* CONDITION */ in layoutGridSchema) {
        return this.renderCondition(layoutGridSchema);
      }
    }
    return this.renderField(layoutGridSchema);
  }
};

// src/components/fields/LayoutHeaderField.tsx
import {
  getTemplate as getTemplate3,
  getUiOptions as getUiOptions4,
  titleId
} from "@rjsf/utils";
import { jsx as jsx4 } from "react/jsx-runtime";
function LayoutHeaderField(props) {
  const { idSchema, title, schema, uiSchema, required, registry, name } = props;
  const options = getUiOptions4(uiSchema, registry.globalUiOptions);
  const { title: uiTitle } = options;
  const { title: schemaTitle } = schema;
  const fieldTitle = uiTitle || title || schemaTitle || name;
  if (!fieldTitle) {
    return null;
  }
  const TitleFieldTemplate = getTemplate3(
    "TitleFieldTemplate",
    registry,
    options
  );
  return /* @__PURE__ */ jsx4(
    TitleFieldTemplate,
    {
      id: titleId(idSchema),
      title: fieldTitle,
      required,
      schema,
      uiSchema,
      registry
    }
  );
}

// src/components/fields/LayoutMultiSchemaField.tsx
import { useState, useEffect } from "react";
import {
  ANY_OF_KEY as ANY_OF_KEY2,
  CONST_KEY,
  DEFAULT_KEY,
  ERRORS_KEY,
  getDiscriminatorFieldFromSchema as getDiscriminatorFieldFromSchema2,
  hashObject as hashObject2,
  ID_KEY as ID_KEY2,
  ONE_OF_KEY as ONE_OF_KEY2,
  optionsList as optionsList3,
  PROPERTIES_KEY as PROPERTIES_KEY2,
  getTemplate as getTemplate4,
  getUiOptions as getUiOptions5,
  getWidget as getWidget3
} from "@rjsf/utils";
import get3 from "lodash/get";
import has2 from "lodash/has";
import isEmpty2 from "lodash/isEmpty";
import noop from "lodash/noop";
import omit from "lodash/omit";
import set3 from "lodash/set";
import { jsx as jsx5 } from "react/jsx-runtime";
function getSelectedOption(options, selectorField, value) {
  const defaultValue = "!@#!@$@#$!@$#";
  const schemaOptions = options.map(({ schema }) => schema);
  return schemaOptions.find((option) => {
    const selector = get3(option, [PROPERTIES_KEY2, selectorField]);
    const result = get3(selector, DEFAULT_KEY, get3(selector, CONST_KEY, defaultValue));
    return result === value;
  });
}
function computeEnumOptions(schema, options, schemaUtils, uiSchema, formData) {
  const realOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
  let tempSchema = schema;
  if (has2(schema, ONE_OF_KEY2)) {
    tempSchema = { ...schema, [ONE_OF_KEY2]: realOptions };
  } else if (has2(schema, ANY_OF_KEY2)) {
    tempSchema = { ...schema, [ANY_OF_KEY2]: realOptions };
  }
  const enumOptions = optionsList3(tempSchema, uiSchema);
  if (!enumOptions) {
    throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(tempSchema)}`);
  }
  return enumOptions;
}
function LayoutMultiSchemaField(props) {
  const {
    name,
    baseType,
    disabled = false,
    formData,
    idSchema,
    onBlur,
    onChange,
    options,
    onFocus,
    registry,
    uiSchema,
    schema,
    formContext,
    autofocus,
    readonly,
    required,
    errorSchema,
    hideError = false
  } = props;
  const { widgets: widgets2, schemaUtils, globalUiOptions } = registry;
  const [enumOptions, setEnumOptions] = useState(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
  const id = get3(idSchema, ID_KEY2);
  const discriminator = getDiscriminatorFieldFromSchema2(schema);
  const FieldErrorTemplate2 = getTemplate4("FieldErrorTemplate", registry, options);
  const FieldTemplate2 = getTemplate4("FieldTemplate", registry, options);
  const schemaHash = hashObject2(schema);
  const optionsHash = hashObject2(options);
  const uiSchemaHash = uiSchema ? hashObject2(uiSchema) : "";
  const formDataHash = formData ? hashObject2(formData) : "";
  useEffect(() => {
    setEnumOptions(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
  }, [schemaHash, optionsHash, schemaUtils, uiSchemaHash, formDataHash]);
  const {
    widget = discriminator ? "radio" : "select",
    title = "",
    placeholder = "",
    optionsSchemaSelector: selectorField = discriminator,
    hideError: uiSchemaHideError,
    ...uiOptions
  } = getUiOptions5(uiSchema);
  if (!selectorField) {
    throw new Error("No selector field provided for the LayoutMultiSchemaField");
  }
  const selectedOption = get3(formData, selectorField);
  let optionSchema = get3(enumOptions[0]?.schema, [PROPERTIES_KEY2, selectorField], {});
  const option = getSelectedOption(enumOptions, selectorField, selectedOption);
  optionSchema = optionSchema?.type ? optionSchema : { ...optionSchema, type: option?.type || baseType };
  const Widget = getWidget3(optionSchema, widget, widgets2);
  const hideFieldError = uiSchemaHideError === void 0 ? hideError : Boolean(uiSchemaHideError);
  const rawErrors = get3(errorSchema, [ERRORS_KEY], []);
  const fieldErrorSchema = omit(errorSchema, [ERRORS_KEY]);
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const onOptionChange = (opt) => {
    const newOption = getSelectedOption(enumOptions, selectorField, opt);
    const oldOption = getSelectedOption(enumOptions, selectorField, selectedOption);
    let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
    if (newFormData && newOption) {
      newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
    }
    if (newFormData) {
      set3(newFormData, selectorField, opt);
    }
    onChange(newFormData, [name], void 0, id);
  };
  const widgetOptions = { enumOptions, ...uiOptions };
  const errors = !hideFieldError && rawErrors.length > 0 ? /* @__PURE__ */ jsx5(FieldErrorTemplate2, { idSchema, schema, errors: rawErrors, registry }) : void 0;
  const ignored = (value) => noop;
  return /* @__PURE__ */ jsx5(
    FieldTemplate2,
    {
      id,
      schema,
      label: (title || schema.title) ?? "",
      disabled: disabled || Array.isArray(enumOptions) && isEmpty2(enumOptions),
      uiSchema,
      formContext,
      required,
      readonly: !!readonly,
      registry,
      displayLabel,
      errors,
      onChange,
      onDropPropertyClick: ignored,
      onKeyChange: ignored,
      children: /* @__PURE__ */ jsx5(
        Widget,
        {
          id,
          name,
          schema,
          label: (title || schema.title) ?? "",
          disabled: disabled || Array.isArray(enumOptions) && isEmpty2(enumOptions),
          uiSchema,
          formContext,
          autofocus,
          readonly,
          required,
          registry,
          multiple: false,
          rawErrors,
          hideError: hideFieldError,
          hideLabel: !displayLabel,
          errorSchema: fieldErrorSchema,
          placeholder,
          onChange: onOptionChange,
          onBlur,
          onFocus,
          value: selectedOption,
          options: widgetOptions
        }
      )
    }
  );
}

// src/components/fields/MultiSchemaField.tsx
import { Component as Component2 } from "react";
import get4 from "lodash/get";
import isEmpty3 from "lodash/isEmpty";
import omit2 from "lodash/omit";
import {
  ANY_OF_KEY as ANY_OF_KEY3,
  deepEquals,
  ERRORS_KEY as ERRORS_KEY2,
  getDiscriminatorFieldFromSchema as getDiscriminatorFieldFromSchema3,
  getTemplate as getTemplate5,
  getUiOptions as getUiOptions6,
  getWidget as getWidget4,
  mergeSchemas,
  ONE_OF_KEY as ONE_OF_KEY3,
  TranslatableString as TranslatableString3
} from "@rjsf/utils";
import { jsx as jsx6 } from "react/jsx-runtime";
var AnyOfField = class extends Component2 {
  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(props) {
    super(props);
    const {
      formData,
      options,
      registry: { schemaUtils }
    } = this.props;
    const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
    this.state = {
      retrievedOptions,
      selectedOption: this.getMatchingOption(0, formData, retrievedOptions)
    };
  }
  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
   * currently selected option based on the overall `formData`
   *
   * @param prevProps - The previous `FieldProps` for this template
   * @param prevState - The previous `AnyOfFieldState` for this template
   */
  componentDidUpdate(prevProps, prevState) {
    const { formData, options, idSchema } = this.props;
    const { selectedOption } = this.state;
    let newState = this.state;
    if (!deepEquals(prevProps.options, options)) {
      const {
        registry: { schemaUtils }
      } = this.props;
      const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
      newState = { selectedOption, retrievedOptions };
    }
    if (!deepEquals(formData, prevProps.formData) && idSchema.$id === prevProps.idSchema.$id) {
      const { retrievedOptions } = newState;
      const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);
      if (prevState && matchingOption !== selectedOption) {
        newState = { selectedOption: matchingOption, retrievedOptions };
      }
    }
    if (newState !== this.state) {
      this.setState(newState);
    }
  }
  /** Determines the best matching option for the given `formData` and `options`.
   *
   * @param formData - The new formData
   * @param options - The list of options to choose from
   * @return - The index of the `option` that best matches the `formData`
   */
  getMatchingOption(selectedOption, formData, options) {
    const {
      schema,
      registry: { schemaUtils }
    } = this.props;
    const discriminator = getDiscriminatorFieldFromSchema3(schema);
    const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);
    return option;
  }
  /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
   * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
   * the `onChange` handler.
   *
   * @param option - The new option value being selected
   */
  onOptionChange = (option) => {
    const { selectedOption, retrievedOptions } = this.state;
    const { formData, onChange, registry } = this.props;
    const { schemaUtils } = registry;
    const intOption = option !== void 0 ? parseInt(option, 10) : -1;
    if (intOption === selectedOption) {
      return;
    }
    const newOption = intOption >= 0 ? retrievedOptions[intOption] : void 0;
    const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : void 0;
    let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
    if (newOption) {
      newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
    }
    this.setState({ selectedOption: intOption }, () => {
      onChange(newFormData, [], void 0, this.getFieldId());
    });
  };
  getFieldId() {
    const { idSchema, schema } = this.props;
    return `${idSchema.$id}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`;
  }
  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
   */
  render() {
    const {
      name,
      disabled = false,
      errorSchema = {},
      formContext,
      onBlur,
      onFocus,
      readonly,
      registry,
      schema,
      uiSchema
    } = this.props;
    const { widgets: widgets2, fields: fields2, translateString, globalUiOptions, schemaUtils } = registry;
    const { SchemaField: _SchemaField } = fields2;
    const MultiSchemaFieldTemplate2 = getTemplate5(
      "MultiSchemaFieldTemplate",
      registry,
      globalUiOptions
    );
    const { selectedOption, retrievedOptions } = this.state;
    const {
      widget = "select",
      placeholder,
      autofocus,
      autocomplete,
      title = schema.title,
      ...uiOptions
    } = getUiOptions6(uiSchema, globalUiOptions);
    const Widget = getWidget4({ type: "number" }, widget, widgets2);
    const rawErrors = get4(errorSchema, ERRORS_KEY2, []);
    const fieldErrorSchema = omit2(errorSchema, [ERRORS_KEY2]);
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;
    let optionSchema;
    if (option) {
      const { required } = schema;
      optionSchema = required ? mergeSchemas({ required }, option) : option;
    }
    let optionsUiSchema = [];
    if (ONE_OF_KEY3 in schema && uiSchema && ONE_OF_KEY3 in uiSchema) {
      if (Array.isArray(uiSchema[ONE_OF_KEY3])) {
        optionsUiSchema = uiSchema[ONE_OF_KEY3];
      } else {
        console.warn(`uiSchema.oneOf is not an array for "${title || name}"`);
      }
    } else if (ANY_OF_KEY3 in schema && uiSchema && ANY_OF_KEY3 in uiSchema) {
      if (Array.isArray(uiSchema[ANY_OF_KEY3])) {
        optionsUiSchema = uiSchema[ANY_OF_KEY3];
      } else {
        console.warn(`uiSchema.anyOf is not an array for "${title || name}"`);
      }
    }
    let optionUiSchema = uiSchema;
    if (selectedOption >= 0 && optionsUiSchema.length > selectedOption) {
      optionUiSchema = optionsUiSchema[selectedOption];
    }
    const translateEnum = title ? TranslatableString3.TitleOptionPrefix : TranslatableString3.OptionPrefix;
    const translateParams = title ? [title] : [];
    const enumOptions = retrievedOptions.map((opt, index) => {
      const { title: uiTitle = opt.title } = getUiOptions6(optionsUiSchema[index]);
      return {
        label: uiTitle || translateString(translateEnum, translateParams.concat(String(index + 1))),
        value: index
      };
    });
    const selector = /* @__PURE__ */ jsx6(
      Widget,
      {
        id: this.getFieldId(),
        name: `${name}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`,
        schema: { type: "number", default: 0 },
        onChange: this.onOptionChange,
        onBlur,
        onFocus,
        disabled: disabled || isEmpty3(enumOptions),
        multiple: false,
        rawErrors,
        errorSchema: fieldErrorSchema,
        value: selectedOption >= 0 ? selectedOption : void 0,
        options: { enumOptions, ...uiOptions },
        registry,
        formContext,
        placeholder,
        autocomplete,
        autofocus,
        label: title ?? name,
        hideLabel: !displayLabel,
        readonly
      }
    );
    const optionsSchemaField = optionSchema && optionSchema.type !== "null" && /* @__PURE__ */ jsx6(_SchemaField, { ...this.props, schema: optionSchema, uiSchema: optionUiSchema }) || null;
    return /* @__PURE__ */ jsx6(
      MultiSchemaFieldTemplate2,
      {
        schema,
        registry,
        uiSchema,
        selector,
        optionSchemaField: optionsSchemaField
      }
    );
  }
};
var MultiSchemaField_default = AnyOfField;

// src/components/fields/NumberField.tsx
import { useState as useState2, useCallback as useCallback2 } from "react";
import { asNumber } from "@rjsf/utils";
import { jsx as jsx7 } from "react/jsx-runtime";
var trailingCharMatcherWithPrefix = /\.([0-9]*0)*$/;
var trailingCharMatcher = /[0.]0*$/;
function NumberField(props) {
  const { registry, onChange, formData, value: initialValue } = props;
  const [lastValue, setLastValue] = useState2(initialValue);
  const { StringField: StringField2 } = registry.fields;
  let value = formData;
  const handleChange = useCallback2(
    (value2, path, errorSchema, id) => {
      setLastValue(value2);
      if (`${value2}`.charAt(0) === ".") {
        value2 = `0${value2}`;
      }
      const processed = typeof value2 === "string" && value2.match(trailingCharMatcherWithPrefix) ? asNumber(value2.replace(trailingCharMatcher, "")) : asNumber(value2);
      onChange(processed, path, errorSchema, id);
    },
    [onChange]
  );
  if (typeof lastValue === "string" && typeof value === "number") {
    const re = new RegExp(`^(${String(value).replace(".", "\\.")})?\\.?0*$`);
    if (lastValue.match(re)) {
      value = lastValue;
    }
  }
  return /* @__PURE__ */ jsx7(StringField2, { ...props, formData: value, onChange: handleChange });
}
var NumberField_default = NumberField;

// src/components/fields/ObjectField.tsx
import { Component as Component3 } from "react";
import {
  getTemplate as getTemplate6,
  getUiOptions as getUiOptions7,
  orderProperties,
  TranslatableString as TranslatableString4,
  ADDITIONAL_PROPERTY_FLAG,
  PROPERTIES_KEY as PROPERTIES_KEY3,
  REF_KEY,
  ANY_OF_KEY as ANY_OF_KEY4,
  ONE_OF_KEY as ONE_OF_KEY4
} from "@rjsf/utils";
import Markdown from "markdown-to-jsx";
import get5 from "lodash/get";
import has3 from "lodash/has";
import isObject4 from "lodash/isObject";
import set4 from "lodash/set";
import unset from "lodash/unset";
import { jsx as jsx8, jsxs } from "react/jsx-runtime";
var ObjectField = class extends Component3 {
  /** Set up the initial state */
  state = {
    wasPropertyKeyModified: false,
    additionalProperties: {}
  };
  /** Returns a flag indicating whether the `name` field is required in the object schema
   *
   * @param name - The name of the field to check for required-ness
   * @returns - True if the field `name` is required, false otherwise
   */
  isRequired(name) {
    const { schema } = this.props;
    return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;
  }
  /** Returns the `onPropertyChange` handler for the `name` field. Handles the special case where a user is attempting
   * to clear the data for a field added as an additional property. Calls the `onChange()` handler with the updated
   * formData.
   *
   * @param name - The name of the property
   * @param addedByAdditionalProperties - Flag indicating whether this property is an additional property
   * @returns - The onPropertyChange callback for the `name` property
   */
  onPropertyChange = (name, addedByAdditionalProperties = false) => {
    return (value, path, newErrorSchema, id) => {
      const { onChange } = this.props;
      if (value === void 0 && addedByAdditionalProperties) {
        value = "";
      }
      const changePath = Array.isArray(path) ? path.slice() : [];
      changePath.unshift(name);
      onChange(value, changePath, newErrorSchema, id);
    };
  };
  /** Returns a callback to handle the onDropPropertyClick event for the given `key` which removes the old `key` data
   * and calls the `onChange` callback with it
   *
   * @param key - The key for which the drop callback is desired
   * @returns - The drop property click callback
   */
  onDropPropertyClick = (key) => {
    return (event) => {
      event.preventDefault();
      const { onChange, formData, name } = this.props;
      const copiedFormData = { ...formData };
      unset(copiedFormData, key);
      onChange(copiedFormData, [name]);
    };
  };
  /** Computes the next available key name from the `preferredKey`, indexing through the already existing keys until one
   * that is already not assigned is found.
   *
   * @param preferredKey - The preferred name of a new key
   * @param [formData] - The form data in which to check if the desired key already exists
   * @returns - The name of the next available key from `preferredKey`
   */
  getAvailableKey = (preferredKey, formData) => {
    const { uiSchema, registry } = this.props;
    const { duplicateKeySuffixSeparator = "-" } = getUiOptions7(uiSchema, registry.globalUiOptions);
    let index = 0;
    let newKey = preferredKey;
    while (has3(formData, newKey)) {
      newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;
    }
    return newKey;
  };
  /** Returns a callback function that deals with the rename of a key for an additional property for a schema. That
   * callback will attempt to rename the key and move the existing data to that key, calling `onChange` when it does.
   *
   * @param oldValue - The old value of a field
   * @returns - The key change callback function
   */
  onKeyChange = (oldValue) => {
    return (value) => {
      if (oldValue === value) {
        return;
      }
      const { formData, onChange } = this.props;
      value = this.getAvailableKey(value, formData);
      const newFormData = {
        ...formData
      };
      const newKeys = { [oldValue]: value };
      const keyValues = Object.keys(newFormData).map((key) => {
        const newKey = newKeys[key] || key;
        return { [newKey]: newFormData[key] };
      });
      const renamedObj = Object.assign({}, ...keyValues);
      this.setState({ wasPropertyKeyModified: true });
      onChange(renamedObj, []);
    };
  };
  /** Returns a default value to be used for a new additional schema property of the given `type`
   *
   * @param type - The type of the new additional schema property
   */
  getDefaultValue(type) {
    const {
      registry: { translateString }
    } = this.props;
    switch (type) {
      case "array":
        return [];
      case "boolean":
        return false;
      case "null":
        return null;
      case "number":
        return 0;
      case "object":
        return {};
      case "string":
      default:
        return translateString(TranslatableString4.NewStringDefault);
    }
  }
  /** Handles the adding of a new additional property on the given `schema`. Calls the `onChange` callback once the new
   * default data for that field has been added to the formData.
   *
   * @param schema - The schema element to which the new property is being added
   */
  handleAddClick = (schema) => () => {
    if (!(schema.additionalProperties || schema.patternProperties)) {
      return;
    }
    const { formData, name, onChange, registry } = this.props;
    const newFormData = { ...formData };
    const newKey = this.getAvailableKey("newKey", newFormData);
    if (schema.patternProperties) {
      set4(newFormData, newKey, null);
    } else {
      let type = void 0;
      let constValue = void 0;
      let defaultValue = void 0;
      if (isObject4(schema.additionalProperties)) {
        type = schema.additionalProperties.type;
        constValue = schema.additionalProperties.const;
        defaultValue = schema.additionalProperties.default;
        let apSchema = schema.additionalProperties;
        if (REF_KEY in apSchema) {
          const { schemaUtils } = registry;
          apSchema = schemaUtils.retrieveSchema({ $ref: apSchema[REF_KEY] }, formData);
          type = apSchema.type;
          constValue = apSchema.const;
          defaultValue = apSchema.default;
        }
        if (!type && (ANY_OF_KEY4 in apSchema || ONE_OF_KEY4 in apSchema)) {
          type = "object";
        }
      }
      const newValue = constValue ?? defaultValue ?? this.getDefaultValue(type);
      set4(newFormData, newKey, newValue);
    }
    onChange(newFormData, [name]);
  };
  /** Renders the `ObjectField` from the given props
   */
  render() {
    const {
      schema: rawSchema,
      uiSchema = {},
      formData,
      errorSchema,
      idSchema,
      name,
      required = false,
      disabled,
      readonly,
      hideError,
      idPrefix,
      idSeparator,
      onBlur,
      onFocus,
      registry,
      title
    } = this.props;
    const { fields: fields2, formContext, schemaUtils, translateString, globalUiOptions } = registry;
    const { SchemaField: SchemaField2 } = fields2;
    const schema = schemaUtils.retrieveSchema(rawSchema, formData);
    const uiOptions = getUiOptions7(uiSchema, globalUiOptions);
    const { properties: schemaProperties = {} } = schema;
    const templateTitle = uiOptions.title ?? schema.title ?? title ?? name;
    const description = uiOptions.description ?? schema.description;
    let orderedProperties;
    try {
      const properties = Object.keys(schemaProperties);
      orderedProperties = orderProperties(properties, uiOptions.order);
    } catch (err) {
      return /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsx8("p", { className: "rjsf-config-error", style: { color: "red" }, children: /* @__PURE__ */ jsx8(Markdown, { options: { disableParsingRawHTML: true }, children: translateString(TranslatableString4.InvalidObjectField, [name || "root", err.message]) }) }),
        /* @__PURE__ */ jsx8("pre", { children: JSON.stringify(schema) })
      ] });
    }
    const Template = getTemplate6("ObjectFieldTemplate", registry, uiOptions);
    const templateProps = {
      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
      title: uiOptions.label === false ? "" : templateTitle,
      description: uiOptions.label === false ? void 0 : description,
      properties: orderedProperties.map((name2) => {
        const addedByAdditionalProperties = has3(schema, [PROPERTIES_KEY3, name2, ADDITIONAL_PROPERTY_FLAG]);
        const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name2];
        const hidden = getUiOptions7(fieldUiSchema).widget === "hidden";
        const fieldIdSchema = get5(idSchema, [name2], {});
        return {
          content: /* @__PURE__ */ jsx8(
            SchemaField2,
            {
              name: name2,
              required: this.isRequired(name2),
              schema: get5(schema, [PROPERTIES_KEY3, name2], {}),
              uiSchema: fieldUiSchema,
              errorSchema: get5(errorSchema, name2),
              idSchema: fieldIdSchema,
              idPrefix,
              idSeparator,
              formData: get5(formData, name2),
              formContext,
              wasPropertyKeyModified: this.state.wasPropertyKeyModified,
              onKeyChange: this.onKeyChange(name2),
              onChange: this.onPropertyChange(name2, addedByAdditionalProperties),
              onBlur,
              onFocus,
              registry,
              disabled,
              readonly,
              hideError,
              onDropPropertyClick: this.onDropPropertyClick
            },
            name2
          ),
          name: name2,
          readonly,
          disabled,
          required,
          hidden
        };
      }),
      readonly,
      disabled,
      required,
      idSchema,
      uiSchema,
      errorSchema,
      schema,
      formData,
      formContext,
      registry
    };
    return /* @__PURE__ */ jsx8(Template, { ...templateProps, onAddClick: this.handleAddClick });
  }
};
var ObjectField_default = ObjectField;

// src/components/fields/SchemaField.tsx
import { useCallback as useCallback3, Component as Component4 } from "react";
import {
  ADDITIONAL_PROPERTY_FLAG as ADDITIONAL_PROPERTY_FLAG2,
  descriptionId,
  getSchemaType,
  getTemplate as getTemplate7,
  getUiOptions as getUiOptions8,
  ID_KEY as ID_KEY3,
  mergeObjects as mergeObjects2,
  shouldRender,
  TranslatableString as TranslatableString5,
  UI_OPTIONS_KEY as UI_OPTIONS_KEY2
} from "@rjsf/utils";
import isObject5 from "lodash/isObject";
import omit3 from "lodash/omit";
import { Fragment, jsx as jsx9, jsxs as jsxs2 } from "react/jsx-runtime";
var COMPONENT_TYPES = {
  array: "ArrayField",
  boolean: "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  null: "NullField"
};
function getFieldComponent(schema, uiOptions, idSchema, registry) {
  const field = uiOptions.field;
  const { fields: fields2, translateString } = registry;
  if (typeof field === "function") {
    return field;
  }
  if (typeof field === "string" && field in fields2) {
    return fields2[field];
  }
  const schemaType = getSchemaType(schema);
  const type = Array.isArray(schemaType) ? schemaType[0] : schemaType || "";
  const schemaId = schema.$id;
  let componentName = COMPONENT_TYPES[type];
  if (schemaId && schemaId in fields2) {
    componentName = schemaId;
  }
  if (!componentName && (schema.anyOf || schema.oneOf)) {
    return () => null;
  }
  return componentName in fields2 ? fields2[componentName] : () => {
    const UnsupportedFieldTemplate = getTemplate7(
      "UnsupportedFieldTemplate",
      registry,
      uiOptions
    );
    return /* @__PURE__ */ jsx9(
      UnsupportedFieldTemplate,
      {
        schema,
        idSchema,
        reason: translateString(TranslatableString5.UnknownFieldType, [String(schema.type)]),
        registry
      }
    );
  };
}
function SchemaFieldRender(props) {
  const {
    schema: _schema,
    idSchema: _idSchema,
    uiSchema,
    formData,
    errorSchema,
    idPrefix,
    idSeparator,
    name,
    onChange,
    onKeyChange,
    onDropPropertyClick,
    required,
    registry,
    wasPropertyKeyModified = false
  } = props;
  const { formContext, schemaUtils, globalUiOptions } = registry;
  const uiOptions = getUiOptions8(uiSchema, globalUiOptions);
  const FieldTemplate2 = getTemplate7("FieldTemplate", registry, uiOptions);
  const DescriptionFieldTemplate = getTemplate7(
    "DescriptionFieldTemplate",
    registry,
    uiOptions
  );
  const FieldHelpTemplate2 = getTemplate7("FieldHelpTemplate", registry, uiOptions);
  const FieldErrorTemplate2 = getTemplate7("FieldErrorTemplate", registry, uiOptions);
  const schema = schemaUtils.retrieveSchema(_schema, formData);
  const fieldId = _idSchema[ID_KEY3];
  const idSchema = mergeObjects2(
    schemaUtils.toIdSchema(schema, fieldId, formData, idPrefix, idSeparator),
    _idSchema
  );
  const handleFieldComponentChange = useCallback3(
    (formData2, path, newErrorSchema, id2) => {
      const theId = id2 || fieldId;
      return onChange(formData2, path, newErrorSchema, theId);
    },
    [fieldId, onChange]
  );
  const FieldComponent = getFieldComponent(schema, uiOptions, idSchema, registry);
  const disabled = Boolean(uiOptions.disabled ?? props.disabled);
  const readonly = Boolean(uiOptions.readonly ?? (props.readonly || props.schema.readOnly || schema.readOnly));
  const uiSchemaHideError = uiOptions.hideError;
  const hideError = uiSchemaHideError === void 0 ? props.hideError : Boolean(uiSchemaHideError);
  const autofocus = Boolean(uiOptions.autofocus ?? props.autofocus);
  if (Object.keys(schema).length === 0) {
    return null;
  }
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const { __errors, ...fieldErrorSchema } = errorSchema || {};
  const fieldUiSchema = omit3(uiSchema, ["ui:classNames", "classNames", "ui:style"]);
  if (UI_OPTIONS_KEY2 in fieldUiSchema) {
    fieldUiSchema[UI_OPTIONS_KEY2] = omit3(fieldUiSchema[UI_OPTIONS_KEY2], ["classNames", "style"]);
  }
  const field = /* @__PURE__ */ jsx9(
    FieldComponent,
    {
      ...props,
      onChange: handleFieldComponentChange,
      idSchema,
      schema,
      uiSchema: fieldUiSchema,
      disabled,
      readonly,
      hideError,
      autofocus,
      errorSchema: fieldErrorSchema,
      formContext,
      rawErrors: __errors
    }
  );
  const id = idSchema[ID_KEY3];
  let label;
  if (wasPropertyKeyModified) {
    label = name;
  } else {
    label = ADDITIONAL_PROPERTY_FLAG2 in schema ? name : uiOptions.title || props.schema.title || schema.title || props.title || name;
  }
  const description = uiOptions.description || props.schema.description || schema.description || "";
  const help = uiOptions.help;
  const hidden = uiOptions.widget === "hidden";
  const classNames = ["rjsf-field", `rjsf-field-${getSchemaType(schema)}`];
  if (!hideError && __errors && __errors.length > 0) {
    classNames.push("rjsf-field-error");
  }
  if (uiOptions.classNames) {
    classNames.push(uiOptions.classNames);
  }
  const helpComponent = /* @__PURE__ */ jsx9(
    FieldHelpTemplate2,
    {
      help,
      idSchema,
      schema,
      uiSchema,
      hasErrors: !hideError && __errors && __errors.length > 0,
      registry
    }
  );
  const errorsComponent = hideError || (schema.anyOf || schema.oneOf) && !schemaUtils.isSelect(schema) ? void 0 : /* @__PURE__ */ jsx9(
    FieldErrorTemplate2,
    {
      errors: __errors,
      errorSchema,
      idSchema,
      schema,
      uiSchema,
      registry
    }
  );
  const fieldProps = {
    description: /* @__PURE__ */ jsx9(
      DescriptionFieldTemplate,
      {
        id: descriptionId(id),
        description,
        schema,
        uiSchema,
        registry
      }
    ),
    rawDescription: description,
    help: helpComponent,
    rawHelp: typeof help === "string" ? help : void 0,
    errors: errorsComponent,
    rawErrors: hideError ? void 0 : __errors,
    id,
    label,
    hidden,
    onChange,
    onKeyChange,
    onDropPropertyClick,
    required,
    disabled,
    readonly,
    hideError,
    displayLabel,
    classNames: classNames.join(" ").trim(),
    style: uiOptions.style,
    formContext,
    formData,
    schema,
    uiSchema,
    registry
  };
  const _AnyOfField = registry.fields.AnyOfField;
  const _OneOfField = registry.fields.OneOfField;
  const isReplacingAnyOrOneOf = uiSchema?.["ui:field"] && uiSchema?.["ui:fieldReplacesAnyOrOneOf"] === true;
  return /* @__PURE__ */ jsx9(FieldTemplate2, { ...fieldProps, children: /* @__PURE__ */ jsxs2(Fragment, { children: [
    field,
    schema.anyOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && /* @__PURE__ */ jsx9(
      _AnyOfField,
      {
        name,
        disabled,
        readonly,
        hideError,
        errorSchema,
        formData,
        formContext,
        idPrefix,
        idSchema,
        idSeparator,
        onBlur: props.onBlur,
        onChange: props.onChange,
        onFocus: props.onFocus,
        options: schema.anyOf.map(
          (_schema2) => schemaUtils.retrieveSchema(isObject5(_schema2) ? _schema2 : {}, formData)
        ),
        registry,
        required,
        schema,
        uiSchema
      }
    ),
    schema.oneOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && /* @__PURE__ */ jsx9(
      _OneOfField,
      {
        name,
        disabled,
        readonly,
        hideError,
        errorSchema,
        formData,
        formContext,
        idPrefix,
        idSchema,
        idSeparator,
        onBlur: props.onBlur,
        onChange: props.onChange,
        onFocus: props.onFocus,
        options: schema.oneOf.map(
          (_schema2) => schemaUtils.retrieveSchema(isObject5(_schema2) ? _schema2 : {}, formData)
        ),
        registry,
        required,
        schema,
        uiSchema
      }
    )
  ] }) });
}
var SchemaField = class extends Component4 {
  shouldComponentUpdate(nextProps) {
    const { experimental_componentUpdateStrategy = "customDeep" } = this.props.registry;
    return shouldRender(this, nextProps, this.state, experimental_componentUpdateStrategy);
  }
  render() {
    return /* @__PURE__ */ jsx9(SchemaFieldRender, { ...this.props });
  }
};
var SchemaField_default = SchemaField;

// src/components/fields/StringField.tsx
import { useCallback as useCallback4 } from "react";
import {
  getWidget as getWidget5,
  getUiOptions as getUiOptions9,
  optionsList as optionsList4,
  hasWidget
} from "@rjsf/utils";
import { jsx as jsx10 } from "react/jsx-runtime";
function StringField(props) {
  const {
    schema,
    name,
    uiSchema,
    idSchema,
    formData,
    required,
    disabled = false,
    readonly = false,
    autofocus = false,
    onChange,
    onBlur,
    onFocus,
    registry,
    rawErrors,
    hideError
  } = props;
  const { title, format } = schema;
  const { widgets: widgets2, formContext, schemaUtils, globalUiOptions } = registry;
  const enumOptions = schemaUtils.isSelect(schema) ? optionsList4(schema, uiSchema) : void 0;
  let defaultWidget = enumOptions ? "select" : "text";
  if (format && hasWidget(schema, format, widgets2)) {
    defaultWidget = format;
  }
  const { widget = defaultWidget, placeholder = "", title: uiTitle, ...options } = getUiOptions9(uiSchema);
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const label = uiTitle ?? title ?? name;
  const Widget = getWidget5(schema, widget, widgets2);
  const onWidgetChange = useCallback4(
    (value, errorSchema, id) => {
      return onChange(value, [], errorSchema, id);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsx10(
    Widget,
    {
      options: { ...options, enumOptions },
      schema,
      uiSchema,
      id: idSchema.$id,
      name,
      label,
      hideLabel: !displayLabel,
      hideError,
      value: formData,
      onChange: onWidgetChange,
      onBlur,
      onFocus,
      required,
      disabled,
      readonly,
      formContext,
      autofocus,
      registry,
      placeholder,
      rawErrors
    }
  );
}
var StringField_default = StringField;

// src/components/fields/NullField.tsx
import { useEffect as useEffect2 } from "react";
function NullField(props) {
  const { name, formData, onChange } = props;
  useEffect2(() => {
    if (formData === void 0) {
      onChange(null, [name]);
    }
  }, [name, formData, onChange]);
  return null;
}
var NullField_default = NullField;

// src/components/fields/index.ts
function fields() {
  return {
    AnyOfField: MultiSchemaField_default,
    ArrayField: ArrayField_default,
    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
    BooleanField: BooleanField_default,
    LayoutGridField,
    LayoutHeaderField,
    LayoutMultiSchemaField,
    NumberField: NumberField_default,
    ObjectField: ObjectField_default,
    OneOfField: MultiSchemaField_default,
    SchemaField: SchemaField_default,
    StringField: StringField_default,
    NullField: NullField_default
  };
}
var fields_default = fields;

// src/components/templates/ArrayFieldDescriptionTemplate.tsx
import {
  descriptionId as descriptionId2,
  getTemplate as getTemplate8,
  getUiOptions as getUiOptions10
} from "@rjsf/utils";
import { jsx as jsx11 } from "react/jsx-runtime";
function ArrayFieldDescriptionTemplate(props) {
  const { idSchema, description, registry, schema, uiSchema } = props;
  const options = getUiOptions10(uiSchema, registry.globalUiOptions);
  const { label: displayLabel = true } = options;
  if (!description || !displayLabel) {
    return null;
  }
  const DescriptionFieldTemplate = getTemplate8(
    "DescriptionFieldTemplate",
    registry,
    options
  );
  return /* @__PURE__ */ jsx11(
    DescriptionFieldTemplate,
    {
      id: descriptionId2(idSchema),
      description,
      schema,
      uiSchema,
      registry
    }
  );
}

// src/components/templates/ArrayFieldItemTemplate.tsx
import {
  getTemplate as getTemplate9,
  getUiOptions as getUiOptions11
} from "@rjsf/utils";
import { jsx as jsx12, jsxs as jsxs3 } from "react/jsx-runtime";
function ArrayFieldItemTemplate(props) {
  const { children, className, buttonsProps, hasToolbar, registry, uiSchema } = props;
  const uiOptions = getUiOptions11(uiSchema);
  const ArrayFieldItemButtonsTemplate2 = getTemplate9(
    "ArrayFieldItemButtonsTemplate",
    registry,
    uiOptions
  );
  const btnStyle = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  return /* @__PURE__ */ jsxs3("div", { className, children: [
    /* @__PURE__ */ jsx12("div", { className: hasToolbar ? "col-xs-9" : "col-xs-12", children }),
    hasToolbar && /* @__PURE__ */ jsx12("div", { className: "col-xs-3 array-item-toolbox", children: /* @__PURE__ */ jsx12(
      "div",
      {
        className: "btn-group",
        style: {
          display: "flex",
          justifyContent: "space-around"
        },
        children: /* @__PURE__ */ jsx12(ArrayFieldItemButtonsTemplate2, { ...buttonsProps, style: btnStyle })
      }
    ) })
  ] });
}

// src/components/templates/ArrayFieldItemButtonsTemplate.tsx
import { useMemo } from "react";
import {
  buttonId
} from "@rjsf/utils";
import { Fragment as Fragment2, jsx as jsx13, jsxs as jsxs4 } from "react/jsx-runtime";
function ArrayFieldItemButtonsTemplate(props) {
  const {
    disabled,
    hasCopy,
    hasMoveDown,
    hasMoveUp,
    hasRemove,
    idSchema,
    index,
    onCopyIndexClick,
    onDropIndexClick,
    onReorderClick,
    readonly,
    registry,
    uiSchema
  } = props;
  const { CopyButton: CopyButton2, MoveDownButton: MoveDownButton2, MoveUpButton: MoveUpButton2, RemoveButton: RemoveButton2 } = registry.templates.ButtonTemplates;
  const onCopyClick = useMemo(() => onCopyIndexClick(index), [index, onCopyIndexClick]);
  const onRemoveClick = useMemo(() => onDropIndexClick(index), [index, onDropIndexClick]);
  const onArrowUpClick = useMemo(() => onReorderClick(index, index - 1), [index, onReorderClick]);
  const onArrowDownClick = useMemo(() => onReorderClick(index, index + 1), [index, onReorderClick]);
  return /* @__PURE__ */ jsxs4(Fragment2, { children: [
    (hasMoveUp || hasMoveDown) && /* @__PURE__ */ jsx13(
      MoveUpButton2,
      {
        id: buttonId(idSchema, "moveUp"),
        className: "rjsf-array-item-move-up",
        disabled: disabled || readonly || !hasMoveUp,
        onClick: onArrowUpClick,
        uiSchema,
        registry
      }
    ),
    (hasMoveUp || hasMoveDown) && /* @__PURE__ */ jsx13(
      MoveDownButton2,
      {
        id: buttonId(idSchema, "moveDown"),
        className: "rjsf-array-item-move-down",
        disabled: disabled || readonly || !hasMoveDown,
        onClick: onArrowDownClick,
        uiSchema,
        registry
      }
    ),
    hasCopy && /* @__PURE__ */ jsx13(
      CopyButton2,
      {
        id: buttonId(idSchema, "copy"),
        className: "rjsf-array-item-copy",
        disabled: disabled || readonly,
        onClick: onCopyClick,
        uiSchema,
        registry
      }
    ),
    hasRemove && /* @__PURE__ */ jsx13(
      RemoveButton2,
      {
        id: buttonId(idSchema, "remove"),
        className: "rjsf-array-item-remove",
        disabled: disabled || readonly,
        onClick: onRemoveClick,
        uiSchema,
        registry
      }
    )
  ] });
}

// src/components/templates/ArrayFieldTemplate.tsx
import {
  getTemplate as getTemplate10,
  getUiOptions as getUiOptions12,
  buttonId as buttonId2
} from "@rjsf/utils";
import { jsx as jsx14, jsxs as jsxs5 } from "react/jsx-runtime";
function ArrayFieldTemplate(props) {
  const {
    canAdd,
    className,
    disabled,
    idSchema,
    uiSchema,
    items,
    onAddClick,
    readonly,
    registry,
    required,
    schema,
    title
  } = props;
  const uiOptions = getUiOptions12(uiSchema);
  const ArrayFieldDescriptionTemplate2 = getTemplate10(
    "ArrayFieldDescriptionTemplate",
    registry,
    uiOptions
  );
  const ArrayFieldItemTemplate2 = getTemplate10(
    "ArrayFieldItemTemplate",
    registry,
    uiOptions
  );
  const ArrayFieldTitleTemplate2 = getTemplate10(
    "ArrayFieldTitleTemplate",
    registry,
    uiOptions
  );
  const {
    ButtonTemplates: { AddButton: AddButton2 }
  } = registry.templates;
  return /* @__PURE__ */ jsxs5("fieldset", { className, id: idSchema.$id, children: [
    /* @__PURE__ */ jsx14(
      ArrayFieldTitleTemplate2,
      {
        idSchema,
        title: uiOptions.title || title,
        required,
        schema,
        uiSchema,
        registry
      }
    ),
    /* @__PURE__ */ jsx14(
      ArrayFieldDescriptionTemplate2,
      {
        idSchema,
        description: uiOptions.description || schema.description,
        schema,
        uiSchema,
        registry
      }
    ),
    /* @__PURE__ */ jsx14("div", { className: "row array-item-list", children: items && items.map(({ key, ...itemProps }) => /* @__PURE__ */ jsx14(ArrayFieldItemTemplate2, { ...itemProps }, key)) }),
    canAdd && /* @__PURE__ */ jsx14(
      AddButton2,
      {
        id: buttonId2(idSchema, "add"),
        className: "rjsf-array-item-add",
        onClick: onAddClick,
        disabled: disabled || readonly,
        uiSchema,
        registry
      }
    )
  ] });
}

// src/components/templates/ArrayFieldTitleTemplate.tsx
import {
  getTemplate as getTemplate11,
  getUiOptions as getUiOptions13,
  titleId as titleId2
} from "@rjsf/utils";
import { jsx as jsx15 } from "react/jsx-runtime";
function ArrayFieldTitleTemplate(props) {
  const { idSchema, title, schema, uiSchema, required, registry } = props;
  const options = getUiOptions13(uiSchema, registry.globalUiOptions);
  const { label: displayLabel = true } = options;
  if (!title || !displayLabel) {
    return null;
  }
  const TitleFieldTemplate = getTemplate11(
    "TitleFieldTemplate",
    registry,
    options
  );
  return /* @__PURE__ */ jsx15(
    TitleFieldTemplate,
    {
      id: titleId2(idSchema),
      title,
      required,
      schema,
      uiSchema,
      registry
    }
  );
}

// src/components/templates/BaseInputTemplate.tsx
import { useCallback as useCallback5 } from "react";
import {
  ariaDescribedByIds,
  examplesId,
  getInputProps
} from "@rjsf/utils";
import { Fragment as Fragment3, jsx as jsx16, jsxs as jsxs6 } from "react/jsx-runtime";
function BaseInputTemplate(props) {
  const {
    id,
    name,
    // remove this from ...rest
    value,
    readonly,
    disabled,
    autofocus,
    onBlur,
    onFocus,
    onChange,
    onChangeOverride,
    options,
    schema,
    uiSchema,
    formContext,
    registry,
    rawErrors,
    type,
    hideLabel,
    // remove this from ...rest
    hideError,
    // remove this from ...rest
    ...rest
  } = props;
  if (!id) {
    console.log("No id for", props);
    throw new Error(`no id for props ${JSON.stringify(props)}`);
  }
  const inputProps = {
    ...rest,
    ...getInputProps(schema, type, options)
  };
  let inputValue;
  if (inputProps.type === "number" || inputProps.type === "integer") {
    inputValue = value || value === 0 ? value : "";
  } else {
    inputValue = value == null ? "" : value;
  }
  const _onChange = useCallback5(
    ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2),
    [onChange, options]
  );
  const _onBlur = useCallback5(
    ({ target }) => onBlur(id, target && target.value),
    [onBlur, id]
  );
  const _onFocus = useCallback5(
    ({ target }) => onFocus(id, target && target.value),
    [onFocus, id]
  );
  return /* @__PURE__ */ jsxs6(Fragment3, { children: [
    /* @__PURE__ */ jsx16(
      "input",
      {
        id,
        name: id,
        className: "form-control",
        readOnly: readonly,
        disabled,
        autoFocus: autofocus,
        value: inputValue,
        ...inputProps,
        list: schema.examples ? examplesId(id) : void 0,
        onChange: onChangeOverride || _onChange,
        onBlur: _onBlur,
        onFocus: _onFocus,
        "aria-describedby": ariaDescribedByIds(id, !!schema.examples)
      }
    ),
    Array.isArray(schema.examples) && /* @__PURE__ */ jsx16("datalist", { id: examplesId(id), children: schema.examples.concat(schema.default && !schema.examples.includes(schema.default) ? [schema.default] : []).map((example) => {
      return /* @__PURE__ */ jsx16("option", { value: example }, example);
    }) }, `datalist_${id}`)
  ] });
}

// src/components/templates/ButtonTemplates/SubmitButton.tsx
import { getSubmitButtonOptions } from "@rjsf/utils";
import { jsx as jsx17 } from "react/jsx-runtime";
function SubmitButton({ uiSchema }) {
  const { submitText, norender, props: submitButtonProps = {} } = getSubmitButtonOptions(uiSchema);
  if (norender) {
    return null;
  }
  return /* @__PURE__ */ jsx17("div", { children: /* @__PURE__ */ jsx17("button", { type: "submit", ...submitButtonProps, className: `btn btn-info ${submitButtonProps.className || ""}`, children: submitText }) });
}

// src/components/templates/ButtonTemplates/AddButton.tsx
import { TranslatableString as TranslatableString7 } from "@rjsf/utils";

// src/components/templates/ButtonTemplates/IconButton.tsx
import { TranslatableString as TranslatableString6 } from "@rjsf/utils";
import { jsx as jsx18 } from "react/jsx-runtime";
function IconButton(props) {
  const { iconType = "default", icon, className, uiSchema, registry, ...otherProps } = props;
  return /* @__PURE__ */ jsx18("button", { type: "button", className: `btn btn-${iconType} ${className}`, ...otherProps, children: /* @__PURE__ */ jsx18("i", { className: `glyphicon glyphicon-${icon}` }) });
}
function CopyButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ jsx18(IconButton, { title: translateString(TranslatableString6.CopyButton), ...props, icon: "copy" });
}
function MoveDownButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ jsx18(IconButton, { title: translateString(TranslatableString6.MoveDownButton), ...props, icon: "arrow-down" });
}
function MoveUpButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ jsx18(IconButton, { title: translateString(TranslatableString6.MoveUpButton), ...props, icon: "arrow-up" });
}
function RemoveButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ jsx18(IconButton, { title: translateString(TranslatableString6.RemoveButton), ...props, iconType: "danger", icon: "remove" });
}

// src/components/templates/ButtonTemplates/AddButton.tsx
import { jsx as jsx19 } from "react/jsx-runtime";
function AddButton({
  className,
  onClick,
  disabled,
  registry
}) {
  const { translateString } = registry;
  return /* @__PURE__ */ jsx19("div", { className: "row", children: /* @__PURE__ */ jsx19("p", { className: `col-xs-3 col-xs-offset-9 text-right ${className}`, children: /* @__PURE__ */ jsx19(
    IconButton,
    {
      iconType: "info",
      icon: "plus",
      className: "btn-add col-xs-12",
      title: translateString(TranslatableString7.AddButton),
      onClick,
      disabled,
      registry
    }
  ) }) });
}

// src/components/templates/ButtonTemplates/index.ts
function buttonTemplates() {
  return {
    SubmitButton,
    AddButton,
    CopyButton,
    MoveDownButton,
    MoveUpButton,
    RemoveButton
  };
}
var ButtonTemplates_default = buttonTemplates;

// src/components/RichDescription.tsx
import {
  getTestIds as getTestIds2,
  getUiOptions as getUiOptions14
} from "@rjsf/utils";
import Markdown2 from "markdown-to-jsx";
import { jsx as jsx20 } from "react/jsx-runtime";
var TEST_IDS = getTestIds2();
function RichDescription({ description, registry, uiSchema = {} }) {
  const { globalUiOptions } = registry;
  const uiOptions = getUiOptions14(uiSchema, globalUiOptions);
  if (uiOptions.enableMarkdownInDescription && typeof description === "string") {
    return /* @__PURE__ */ jsx20(Markdown2, { options: { disableParsingRawHTML: true }, "data-testid": TEST_IDS.markdown, children: description });
  }
  return description;
}
RichDescription.TEST_IDS = TEST_IDS;

// src/components/templates/DescriptionField.tsx
import { jsx as jsx21 } from "react/jsx-runtime";
function DescriptionField(props) {
  const { id, description, registry, uiSchema } = props;
  if (!description) {
    return null;
  }
  return /* @__PURE__ */ jsx21("div", { id, className: "field-description", children: /* @__PURE__ */ jsx21(RichDescription, { description, registry, uiSchema }) });
}

// src/components/templates/ErrorList.tsx
import {
  TranslatableString as TranslatableString8
} from "@rjsf/utils";
import { jsx as jsx22, jsxs as jsxs7 } from "react/jsx-runtime";
function ErrorList({
  errors,
  registry
}) {
  const { translateString } = registry;
  return /* @__PURE__ */ jsxs7("div", { className: "panel panel-danger errors", children: [
    /* @__PURE__ */ jsx22("div", { className: "panel-heading", children: /* @__PURE__ */ jsx22("h3", { className: "panel-title", children: translateString(TranslatableString8.ErrorsLabel) }) }),
    /* @__PURE__ */ jsx22("ul", { className: "list-group", children: errors.map((error, i) => {
      return /* @__PURE__ */ jsx22("li", { className: "list-group-item text-danger", children: error.stack }, i);
    }) })
  ] });
}

// src/components/templates/FieldTemplate/FieldTemplate.tsx
import {
  getTemplate as getTemplate12,
  getUiOptions as getUiOptions15
} from "@rjsf/utils";

// src/components/templates/FieldTemplate/Label.tsx
import { jsx as jsx23, jsxs as jsxs8 } from "react/jsx-runtime";
var REQUIRED_FIELD_SYMBOL = "*";
function Label(props) {
  const { label, required, id } = props;
  if (!label) {
    return null;
  }
  return /* @__PURE__ */ jsxs8("label", { className: "control-label", htmlFor: id, children: [
    label,
    required && /* @__PURE__ */ jsx23("span", { className: "required", children: REQUIRED_FIELD_SYMBOL })
  ] });
}

// src/components/templates/FieldTemplate/FieldTemplate.tsx
import { jsx as jsx24, jsxs as jsxs9 } from "react/jsx-runtime";
function FieldTemplate(props) {
  const { id, label, children, errors, help, description, hidden, required, displayLabel, registry, uiSchema } = props;
  const uiOptions = getUiOptions15(uiSchema);
  const WrapIfAdditionalTemplate2 = getTemplate12(
    "WrapIfAdditionalTemplate",
    registry,
    uiOptions
  );
  if (hidden) {
    return /* @__PURE__ */ jsx24("div", { className: "hidden", children });
  }
  return /* @__PURE__ */ jsxs9(WrapIfAdditionalTemplate2, { ...props, children: [
    displayLabel && /* @__PURE__ */ jsx24(Label, { label, required, id }),
    displayLabel && description ? description : null,
    children,
    errors,
    help
  ] });
}

// src/components/templates/FieldTemplate/index.ts
var FieldTemplate_default = FieldTemplate;

// src/components/templates/FieldErrorTemplate.tsx
import { errorId } from "@rjsf/utils";
import { jsx as jsx25 } from "react/jsx-runtime";
function FieldErrorTemplate(props) {
  const { errors = [], idSchema } = props;
  if (errors.length === 0) {
    return null;
  }
  const id = errorId(idSchema);
  return /* @__PURE__ */ jsx25("div", { children: /* @__PURE__ */ jsx25("ul", { id, className: "error-detail bs-callout bs-callout-info", children: errors.filter((elem) => !!elem).map((error, index) => {
    return /* @__PURE__ */ jsx25("li", { className: "text-danger", children: error }, index);
  }) }) });
}

// src/components/templates/FieldHelpTemplate.tsx
import { helpId } from "@rjsf/utils";
import { jsx as jsx26 } from "react/jsx-runtime";
function FieldHelpTemplate(props) {
  const { idSchema, help } = props;
  if (!help) {
    return null;
  }
  const id = helpId(idSchema);
  if (typeof help === "string") {
    return /* @__PURE__ */ jsx26("p", { id, className: "help-block", children: help });
  }
  return /* @__PURE__ */ jsx26("div", { id, className: "help-block", children: help });
}

// src/components/templates/GridTemplate.tsx
import { jsx as jsx27 } from "react/jsx-runtime";
function GridTemplate(props) {
  const { children, column, className, ...rest } = props;
  return /* @__PURE__ */ jsx27("div", { className, ...rest, children });
}

// src/components/templates/MultiSchemaFieldTemplate.tsx
import { jsx as jsx28, jsxs as jsxs10 } from "react/jsx-runtime";
function MultiSchemaFieldTemplate(props) {
  const { selector, optionSchemaField } = props;
  return /* @__PURE__ */ jsxs10("div", { className: "panel panel-default panel-body", children: [
    /* @__PURE__ */ jsx28("div", { className: "form-group", children: selector }),
    optionSchemaField
  ] });
}

// src/components/templates/ObjectFieldTemplate.tsx
import {
  canExpand,
  descriptionId as descriptionId3,
  getTemplate as getTemplate13,
  getUiOptions as getUiOptions16,
  titleId as titleId3,
  buttonId as buttonId3
} from "@rjsf/utils";
import { jsx as jsx29, jsxs as jsxs11 } from "react/jsx-runtime";
function ObjectFieldTemplate(props) {
  const {
    description,
    disabled,
    formData,
    idSchema,
    onAddClick,
    properties,
    readonly,
    registry,
    required,
    schema,
    title,
    uiSchema
  } = props;
  const options = getUiOptions16(uiSchema);
  const TitleFieldTemplate = getTemplate13("TitleFieldTemplate", registry, options);
  const DescriptionFieldTemplate = getTemplate13(
    "DescriptionFieldTemplate",
    registry,
    options
  );
  const {
    ButtonTemplates: { AddButton: AddButton2 }
  } = registry.templates;
  return /* @__PURE__ */ jsxs11("fieldset", { id: idSchema.$id, children: [
    title && /* @__PURE__ */ jsx29(
      TitleFieldTemplate,
      {
        id: titleId3(idSchema),
        title,
        required,
        schema,
        uiSchema,
        registry
      }
    ),
    description && /* @__PURE__ */ jsx29(
      DescriptionFieldTemplate,
      {
        id: descriptionId3(idSchema),
        description,
        schema,
        uiSchema,
        registry
      }
    ),
    properties.map((prop) => prop.content),
    canExpand(schema, uiSchema, formData) && /* @__PURE__ */ jsx29(
      AddButton2,
      {
        id: buttonId3(idSchema, "add"),
        className: "rjsf-object-property-expand",
        onClick: onAddClick(schema),
        disabled: disabled || readonly,
        uiSchema,
        registry
      }
    )
  ] });
}

// src/components/templates/TitleField.tsx
import { jsx as jsx30, jsxs as jsxs12 } from "react/jsx-runtime";
var REQUIRED_FIELD_SYMBOL2 = "*";
function TitleField(props) {
  const { id, title, required } = props;
  return /* @__PURE__ */ jsxs12("legend", { id, children: [
    title,
    required && /* @__PURE__ */ jsx30("span", { className: "required", children: REQUIRED_FIELD_SYMBOL2 })
  ] });
}

// src/components/templates/UnsupportedField.tsx
import { TranslatableString as TranslatableString9 } from "@rjsf/utils";
import Markdown3 from "markdown-to-jsx";
import { jsx as jsx31, jsxs as jsxs13 } from "react/jsx-runtime";
function UnsupportedField(props) {
  const { schema, idSchema, reason, registry } = props;
  const { translateString } = registry;
  let translateEnum = TranslatableString9.UnsupportedField;
  const translateParams = [];
  if (idSchema && idSchema.$id) {
    translateEnum = TranslatableString9.UnsupportedFieldWithId;
    translateParams.push(idSchema.$id);
  }
  if (reason) {
    translateEnum = translateEnum === TranslatableString9.UnsupportedField ? TranslatableString9.UnsupportedFieldWithReason : TranslatableString9.UnsupportedFieldWithIdAndReason;
    translateParams.push(reason);
  }
  return /* @__PURE__ */ jsxs13("div", { className: "unsupported-field", children: [
    /* @__PURE__ */ jsx31("p", { children: /* @__PURE__ */ jsx31(Markdown3, { options: { disableParsingRawHTML: true }, children: translateString(translateEnum, translateParams) }) }),
    schema && /* @__PURE__ */ jsx31("pre", { children: JSON.stringify(schema, null, 2) })
  ] });
}
var UnsupportedField_default = UnsupportedField;

// src/components/templates/WrapIfAdditionalTemplate.tsx
import {
  ADDITIONAL_PROPERTY_FLAG as ADDITIONAL_PROPERTY_FLAG3,
  buttonId as buttonId4,
  TranslatableString as TranslatableString10
} from "@rjsf/utils";
import { jsx as jsx32, jsxs as jsxs14 } from "react/jsx-runtime";
function WrapIfAdditionalTemplate(props) {
  const {
    id,
    classNames,
    style,
    disabled,
    label,
    onKeyChange,
    onDropPropertyClick,
    readonly,
    required,
    schema,
    hideError,
    rawErrors,
    children,
    uiSchema,
    registry
  } = props;
  const { templates: templates2, translateString } = registry;
  const { RemoveButton: RemoveButton2 } = templates2.ButtonTemplates;
  const keyLabel = translateString(TranslatableString10.KeyLabel, [label]);
  const additional = ADDITIONAL_PROPERTY_FLAG3 in schema;
  const classNamesList = ["form-group", classNames];
  if (!hideError && rawErrors && rawErrors.length > 0) {
    classNamesList.push("has-error has-danger");
  }
  const uiClassNames = classNamesList.join(" ").trim();
  if (!additional) {
    return /* @__PURE__ */ jsx32("div", { className: uiClassNames, style, children });
  }
  return /* @__PURE__ */ jsx32("div", { className: uiClassNames, style, children: /* @__PURE__ */ jsxs14("div", { className: "row", children: [
    /* @__PURE__ */ jsx32("div", { className: "col-xs-5 form-additional", children: /* @__PURE__ */ jsxs14("div", { className: "form-group", children: [
      /* @__PURE__ */ jsx32(Label, { label: keyLabel, required, id: `${id}-key` }),
      /* @__PURE__ */ jsx32(
        "input",
        {
          className: "form-control",
          type: "text",
          id: `${id}-key`,
          onBlur: ({ target }) => onKeyChange(target && target.value),
          defaultValue: label
        }
      )
    ] }) }),
    /* @__PURE__ */ jsx32("div", { className: "form-additional form-group col-xs-5", children }),
    /* @__PURE__ */ jsx32("div", { className: "col-xs-2", children: /* @__PURE__ */ jsx32(
      RemoveButton2,
      {
        id: buttonId4(id, "remove"),
        className: "rjsf-object-property-remove btn-block",
        style: { border: "0" },
        disabled: disabled || readonly,
        onClick: onDropPropertyClick(label),
        uiSchema,
        registry
      }
    ) })
  ] }) });
}

// src/components/templates/index.ts
function templates() {
  return {
    ArrayFieldDescriptionTemplate,
    ArrayFieldItemTemplate,
    ArrayFieldItemButtonsTemplate,
    ArrayFieldTemplate,
    ArrayFieldTitleTemplate,
    ButtonTemplates: ButtonTemplates_default(),
    BaseInputTemplate,
    DescriptionFieldTemplate: DescriptionField,
    ErrorListTemplate: ErrorList,
    FieldTemplate: FieldTemplate_default,
    FieldErrorTemplate,
    FieldHelpTemplate,
    GridTemplate,
    MultiSchemaFieldTemplate,
    ObjectFieldTemplate,
    TitleFieldTemplate: TitleField,
    UnsupportedFieldTemplate: UnsupportedField_default,
    WrapIfAdditionalTemplate
  };
}
var templates_default = templates;

// src/components/widgets/AltDateWidget.tsx
import { useCallback as useCallback6, useEffect as useEffect3, useState as useState3 } from "react";
import {
  ariaDescribedByIds as ariaDescribedByIds2,
  dateRangeOptions,
  parseDateString,
  toDateString,
  TranslatableString as TranslatableString11,
  getDateElementProps
} from "@rjsf/utils";
import { jsx as jsx33, jsxs as jsxs15 } from "react/jsx-runtime";
function readyForChange(state) {
  return Object.values(state).every((value) => value !== -1);
}
function DateElement({
  type,
  range,
  value,
  select,
  rootId,
  name,
  disabled,
  readonly,
  autofocus,
  registry,
  onBlur,
  onFocus
}) {
  const id = rootId + "_" + type;
  const { SelectWidget: SelectWidget2 } = registry.widgets;
  return /* @__PURE__ */ jsx33(
    SelectWidget2,
    {
      schema: { type: "integer" },
      id,
      name,
      className: "form-control",
      options: { enumOptions: dateRangeOptions(range[0], range[1]) },
      placeholder: type,
      value,
      disabled,
      readonly,
      autofocus,
      onChange: (value2) => select(type, value2),
      onBlur,
      onFocus,
      registry,
      label: "",
      "aria-describedby": ariaDescribedByIds2(rootId)
    }
  );
}
function AltDateWidget({
  time = false,
  disabled = false,
  readonly = false,
  autofocus = false,
  options,
  id,
  name,
  registry,
  onBlur,
  onFocus,
  onChange,
  value
}) {
  const { translateString } = registry;
  const [state, setState] = useState3(parseDateString(value, time));
  useEffect3(() => {
    setState(parseDateString(value, time));
  }, [time, value]);
  const handleChange = useCallback6(
    (property, value2) => {
      const nextState = {
        ...state,
        [property]: typeof value2 === "undefined" ? -1 : value2
      };
      if (readyForChange(nextState)) {
        onChange(toDateString(nextState, time));
      } else {
        setState(nextState);
      }
    },
    [state, onChange, time]
  );
  const handleSetNow = useCallback6(
    (event) => {
      event.preventDefault();
      if (disabled || readonly) {
        return;
      }
      const nextState = parseDateString((/* @__PURE__ */ new Date()).toJSON(), time);
      onChange(toDateString(nextState, time));
    },
    [disabled, readonly, time, onChange]
  );
  const handleClear = useCallback6(
    (event) => {
      event.preventDefault();
      if (disabled || readonly) {
        return;
      }
      onChange(void 0);
    },
    [disabled, readonly, onChange]
  );
  return /* @__PURE__ */ jsxs15("ul", { className: "list-inline", children: [
    getDateElementProps(
      state,
      time,
      options.yearsRange,
      options.format
    ).map((elemProps, i) => /* @__PURE__ */ jsx33("li", { className: "list-inline-item", children: /* @__PURE__ */ jsx33(
      DateElement,
      {
        rootId: id,
        name,
        select: handleChange,
        ...elemProps,
        disabled,
        readonly,
        registry,
        onBlur,
        onFocus,
        autofocus: autofocus && i === 0
      }
    ) }, i)),
    (options.hideNowButton !== "undefined" ? !options.hideNowButton : true) && /* @__PURE__ */ jsx33("li", { className: "list-inline-item", children: /* @__PURE__ */ jsx33("a", { href: "#", className: "btn btn-info btn-now", onClick: handleSetNow, children: translateString(TranslatableString11.NowLabel) }) }),
    (options.hideClearButton !== "undefined" ? !options.hideClearButton : true) && /* @__PURE__ */ jsx33("li", { className: "list-inline-item", children: /* @__PURE__ */ jsx33("a", { href: "#", className: "btn btn-warning btn-clear", onClick: handleClear, children: translateString(TranslatableString11.ClearLabel) }) })
  ] });
}
var AltDateWidget_default = AltDateWidget;

// src/components/widgets/AltDateTimeWidget.tsx
import { jsx as jsx34 } from "react/jsx-runtime";
function AltDateTimeWidget({
  time = true,
  ...props
}) {
  const { AltDateWidget: AltDateWidget2 } = props.registry.widgets;
  return /* @__PURE__ */ jsx34(AltDateWidget2, { time, ...props });
}
var AltDateTimeWidget_default = AltDateTimeWidget;

// src/components/widgets/CheckboxWidget.tsx
import { useCallback as useCallback7 } from "react";
import {
  ariaDescribedByIds as ariaDescribedByIds3,
  descriptionId as descriptionId4,
  getTemplate as getTemplate14,
  labelValue,
  schemaRequiresTrueValue
} from "@rjsf/utils";
import { jsx as jsx35, jsxs as jsxs16 } from "react/jsx-runtime";
function CheckboxWidget({
  schema,
  uiSchema,
  options,
  id,
  value,
  disabled,
  readonly,
  label,
  hideLabel,
  autofocus = false,
  onBlur,
  onFocus,
  onChange,
  registry
}) {
  const DescriptionFieldTemplate = getTemplate14(
    "DescriptionFieldTemplate",
    registry,
    options
  );
  const required = schemaRequiresTrueValue(schema);
  const handleChange = useCallback7(
    (event) => onChange(event.target.checked),
    [onChange]
  );
  const handleBlur = useCallback7(
    (event) => onBlur(id, event.target.checked),
    [onBlur, id]
  );
  const handleFocus = useCallback7(
    (event) => onFocus(id, event.target.checked),
    [onFocus, id]
  );
  const description = options.description ?? schema.description;
  return /* @__PURE__ */ jsxs16("div", { className: `checkbox ${disabled || readonly ? "disabled" : ""}`, children: [
    !hideLabel && description && /* @__PURE__ */ jsx35(
      DescriptionFieldTemplate,
      {
        id: descriptionId4(id),
        description,
        schema,
        uiSchema,
        registry
      }
    ),
    /* @__PURE__ */ jsxs16("label", { children: [
      /* @__PURE__ */ jsx35(
        "input",
        {
          type: "checkbox",
          id,
          name: id,
          checked: typeof value === "undefined" ? false : value,
          required,
          disabled: disabled || readonly,
          autoFocus: autofocus,
          onChange: handleChange,
          onBlur: handleBlur,
          onFocus: handleFocus,
          "aria-describedby": ariaDescribedByIds3(id)
        }
      ),
      labelValue(/* @__PURE__ */ jsx35("span", { children: label }), hideLabel)
    ] })
  ] });
}
var CheckboxWidget_default = CheckboxWidget;

// src/components/widgets/CheckboxesWidget.tsx
import { useCallback as useCallback8 } from "react";
import {
  ariaDescribedByIds as ariaDescribedByIds4,
  enumOptionsDeselectValue,
  enumOptionsIsSelected,
  enumOptionsSelectValue,
  enumOptionsValueForIndex,
  optionId
} from "@rjsf/utils";
import { jsx as jsx36, jsxs as jsxs17 } from "react/jsx-runtime";
function CheckboxesWidget({
  id,
  disabled,
  options: { inline = false, enumOptions, enumDisabled, emptyValue },
  value,
  autofocus = false,
  readonly,
  onChange,
  onBlur,
  onFocus
}) {
  const checkboxesValues = Array.isArray(value) ? value : [value];
  const handleBlur = useCallback8(
    ({ target }) => onBlur(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)),
    [onBlur, id, enumOptions, emptyValue]
  );
  const handleFocus = useCallback8(
    ({ target }) => onFocus(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)),
    [onFocus, id, enumOptions, emptyValue]
  );
  return /* @__PURE__ */ jsx36("div", { className: "checkboxes", id, children: Array.isArray(enumOptions) && enumOptions.map((option, index) => {
    const checked = enumOptionsIsSelected(option.value, checkboxesValues);
    const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
    const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    const handleChange = (event) => {
      if (event.target.checked) {
        onChange(enumOptionsSelectValue(index, checkboxesValues, enumOptions));
      } else {
        onChange(enumOptionsDeselectValue(index, checkboxesValues, enumOptions));
      }
    };
    const checkbox = /* @__PURE__ */ jsxs17("span", { children: [
      /* @__PURE__ */ jsx36(
        "input",
        {
          type: "checkbox",
          id: optionId(id, index),
          name: id,
          checked,
          value: String(index),
          disabled: disabled || itemDisabled || readonly,
          autoFocus: autofocus && index === 0,
          onChange: handleChange,
          onBlur: handleBlur,
          onFocus: handleFocus,
          "aria-describedby": ariaDescribedByIds4(id)
        }
      ),
      /* @__PURE__ */ jsx36("span", { children: option.label })
    ] });
    return inline ? /* @__PURE__ */ jsx36("label", { className: `checkbox-inline ${disabledCls}`, children: checkbox }, index) : /* @__PURE__ */ jsx36("div", { className: `checkbox ${disabledCls}`, children: /* @__PURE__ */ jsx36("label", { children: checkbox }) }, index);
  }) });
}
var CheckboxesWidget_default = CheckboxesWidget;

// src/components/widgets/ColorWidget.tsx
import { getTemplate as getTemplate15 } from "@rjsf/utils";
import { jsx as jsx37 } from "react/jsx-runtime";
function ColorWidget(props) {
  const { disabled, readonly, options, registry } = props;
  const BaseInputTemplate2 = getTemplate15("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ jsx37(BaseInputTemplate2, { type: "color", ...props, disabled: disabled || readonly });
}

// src/components/widgets/DateWidget.tsx
import { useCallback as useCallback9 } from "react";
import { getTemplate as getTemplate16 } from "@rjsf/utils";
import { jsx as jsx38 } from "react/jsx-runtime";
function DateWidget(props) {
  const { onChange, options, registry } = props;
  const BaseInputTemplate2 = getTemplate16("BaseInputTemplate", registry, options);
  const handleChange = useCallback9((value) => onChange(value || void 0), [onChange]);
  return /* @__PURE__ */ jsx38(BaseInputTemplate2, { type: "date", ...props, onChange: handleChange });
}

// src/components/widgets/DateTimeWidget.tsx
import {
  getTemplate as getTemplate17,
  localToUTC,
  utcToLocal
} from "@rjsf/utils";
import { jsx as jsx39 } from "react/jsx-runtime";
function DateTimeWidget(props) {
  const { onChange, value, options, registry } = props;
  const BaseInputTemplate2 = getTemplate17("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ jsx39(
    BaseInputTemplate2,
    {
      type: "datetime-local",
      ...props,
      value: utcToLocal(value),
      onChange: (value2) => onChange(localToUTC(value2))
    }
  );
}

// src/components/widgets/EmailWidget.tsx
import { getTemplate as getTemplate18 } from "@rjsf/utils";
import { jsx as jsx40 } from "react/jsx-runtime";
function EmailWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate18("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ jsx40(BaseInputTemplate2, { type: "email", ...props });
}

// src/components/widgets/FileWidget.tsx
import { useCallback as useCallback10, useMemo as useMemo2 } from "react";
import {
  dataURItoBlob,
  getTemplate as getTemplate19,
  TranslatableString as TranslatableString12
} from "@rjsf/utils";
import Markdown4 from "markdown-to-jsx";
import { Fragment as Fragment4, jsx as jsx41, jsxs as jsxs18 } from "react/jsx-runtime";
function addNameToDataURL(dataURL, name) {
  if (dataURL === null) {
    return null;
  }
  return dataURL.replace(";base64", `;name=${encodeURIComponent(name)};base64`);
}
function processFile(file) {
  const { name, size, type } = file;
  return new Promise((resolve, reject) => {
    const reader = new window.FileReader();
    reader.onerror = reject;
    reader.onload = (event) => {
      if (typeof event.target?.result === "string") {
        resolve({
          dataURL: addNameToDataURL(event.target.result, name),
          name,
          size,
          type
        });
      } else {
        resolve({
          dataURL: null,
          name,
          size,
          type
        });
      }
    };
    reader.readAsDataURL(file);
  });
}
function processFiles(files) {
  return Promise.all(Array.from(files).map(processFile));
}
function FileInfoPreview({
  fileInfo,
  registry
}) {
  const { translateString } = registry;
  const { dataURL, type, name } = fileInfo;
  if (!dataURL) {
    return null;
  }
  if (["image/jpeg", "image/png"].includes(type)) {
    return /* @__PURE__ */ jsx41("img", { src: dataURL, style: { maxWidth: "100%" }, className: "file-preview" });
  }
  return /* @__PURE__ */ jsxs18(Fragment4, { children: [
    " ",
    /* @__PURE__ */ jsx41("a", { download: `preview-${name}`, href: dataURL, className: "file-download", children: translateString(TranslatableString12.PreviewLabel) })
  ] });
}
function FilesInfo({
  filesInfo,
  registry,
  preview,
  onRemove,
  options
}) {
  if (filesInfo.length === 0) {
    return null;
  }
  const { translateString } = registry;
  const { RemoveButton: RemoveButton2 } = getTemplate19("ButtonTemplates", registry, options);
  return /* @__PURE__ */ jsx41("ul", { className: "file-info", children: filesInfo.map((fileInfo, key) => {
    const { name, size, type } = fileInfo;
    const handleRemove = () => onRemove(key);
    return /* @__PURE__ */ jsxs18("li", { children: [
      /* @__PURE__ */ jsx41(Markdown4, { children: translateString(TranslatableString12.FilesInfo, [name, type, String(size)]) }),
      preview && /* @__PURE__ */ jsx41(FileInfoPreview, { fileInfo, registry }),
      /* @__PURE__ */ jsx41(RemoveButton2, { onClick: handleRemove, registry })
    ] }, key);
  }) });
}
function extractFileInfo(dataURLs) {
  return dataURLs.reduce((acc, dataURL) => {
    if (!dataURL) {
      return acc;
    }
    try {
      const { blob, name } = dataURItoBlob(dataURL);
      return [
        ...acc,
        {
          dataURL,
          name,
          size: blob.size,
          type: blob.type
        }
      ];
    } catch {
      return acc;
    }
  }, []);
}
function FileWidget(props) {
  const { disabled, readonly, required, multiple, onChange, value, options, registry } = props;
  const BaseInputTemplate2 = getTemplate19("BaseInputTemplate", registry, options);
  const handleChange = useCallback10(
    (event) => {
      if (!event.target.files) {
        return;
      }
      processFiles(event.target.files).then((filesInfoEvent) => {
        const newValue = filesInfoEvent.map((fileInfo) => fileInfo.dataURL);
        if (multiple) {
          onChange(value.concat(newValue));
        } else {
          onChange(newValue[0]);
        }
      });
    },
    [multiple, value, onChange]
  );
  const filesInfo = useMemo2(() => extractFileInfo(Array.isArray(value) ? value : [value]), [value]);
  const rmFile = useCallback10(
    (index) => {
      if (multiple) {
        const newValue = value.filter((_, i) => i !== index);
        onChange(newValue);
      } else {
        onChange(void 0);
      }
    },
    [multiple, value, onChange]
  );
  return /* @__PURE__ */ jsxs18("div", { children: [
    /* @__PURE__ */ jsx41(
      BaseInputTemplate2,
      {
        ...props,
        disabled: disabled || readonly,
        type: "file",
        required: value ? false : required,
        onChangeOverride: handleChange,
        value: "",
        accept: options.accept ? String(options.accept) : void 0
      }
    ),
    /* @__PURE__ */ jsx41(
      FilesInfo,
      {
        filesInfo,
        onRemove: rmFile,
        registry,
        preview: options.filePreview,
        options
      }
    )
  ] });
}
var FileWidget_default = FileWidget;

// src/components/widgets/HiddenWidget.tsx
import { jsx as jsx42 } from "react/jsx-runtime";
function HiddenWidget({
  id,
  value
}) {
  return /* @__PURE__ */ jsx42("input", { type: "hidden", id, name: id, value: typeof value === "undefined" ? "" : value });
}
var HiddenWidget_default = HiddenWidget;

// src/components/widgets/PasswordWidget.tsx
import { getTemplate as getTemplate20 } from "@rjsf/utils";
import { jsx as jsx43 } from "react/jsx-runtime";
function PasswordWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate20("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ jsx43(BaseInputTemplate2, { type: "password", ...props });
}

// src/components/widgets/RadioWidget.tsx
import { useCallback as useCallback11 } from "react";
import {
  ariaDescribedByIds as ariaDescribedByIds5,
  enumOptionsIsSelected as enumOptionsIsSelected2,
  enumOptionsValueForIndex as enumOptionsValueForIndex2,
  optionId as optionId2
} from "@rjsf/utils";
import { jsx as jsx44, jsxs as jsxs19 } from "react/jsx-runtime";
function RadioWidget({
  options,
  value,
  required,
  disabled,
  readonly,
  autofocus = false,
  onBlur,
  onFocus,
  onChange,
  id
}) {
  const { enumOptions, enumDisabled, inline, emptyValue } = options;
  const handleBlur = useCallback11(
    ({ target }) => onBlur(id, enumOptionsValueForIndex2(target && target.value, enumOptions, emptyValue)),
    [onBlur, enumOptions, emptyValue, id]
  );
  const handleFocus = useCallback11(
    ({ target }) => onFocus(id, enumOptionsValueForIndex2(target && target.value, enumOptions, emptyValue)),
    [onFocus, enumOptions, emptyValue, id]
  );
  return /* @__PURE__ */ jsx44("div", { className: "field-radio-group", id, role: "radiogroup", children: Array.isArray(enumOptions) && enumOptions.map((option, i) => {
    const checked = enumOptionsIsSelected2(option.value, value);
    const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
    const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    const handleChange = () => onChange(option.value);
    const radio = /* @__PURE__ */ jsxs19("span", { children: [
      /* @__PURE__ */ jsx44(
        "input",
        {
          type: "radio",
          id: optionId2(id, i),
          checked,
          name: id,
          required,
          value: String(i),
          disabled: disabled || itemDisabled || readonly,
          autoFocus: autofocus && i === 0,
          onChange: handleChange,
          onBlur: handleBlur,
          onFocus: handleFocus,
          "aria-describedby": ariaDescribedByIds5(id)
        }
      ),
      /* @__PURE__ */ jsx44("span", { children: option.label })
    ] });
    return inline ? /* @__PURE__ */ jsx44("label", { className: `radio-inline ${disabledCls}`, children: radio }, i) : /* @__PURE__ */ jsx44("div", { className: `radio ${disabledCls}`, children: /* @__PURE__ */ jsx44("label", { children: radio }) }, i);
  }) });
}
var RadioWidget_default = RadioWidget;

// src/components/widgets/RangeWidget.tsx
import { jsx as jsx45, jsxs as jsxs20 } from "react/jsx-runtime";
function RangeWidget(props) {
  const {
    value,
    registry: {
      templates: { BaseInputTemplate: BaseInputTemplate2 }
    }
  } = props;
  return /* @__PURE__ */ jsxs20("div", { className: "field-range-wrapper", children: [
    /* @__PURE__ */ jsx45(BaseInputTemplate2, { type: "range", ...props }),
    /* @__PURE__ */ jsx45("span", { className: "range-view", children: value })
  ] });
}

// src/components/widgets/RatingWidget.tsx
import { useCallback as useCallback12 } from "react";
import { Fragment as Fragment5, jsx as jsx46, jsxs as jsxs21 } from "react/jsx-runtime";
function RatingWidget({
  id,
  value,
  required,
  disabled,
  readonly,
  autofocus,
  onChange,
  onFocus,
  onBlur,
  schema,
  options
}) {
  const { stars = 5, shape = "star" } = options;
  const numStars = schema.maximum ? Math.min(schema.maximum, 5) : Math.min(Math.max(stars, 1), 5);
  const min = schema.minimum || 0;
  const handleStarClick = useCallback12(
    (starValue) => {
      if (!disabled && !readonly) {
        onChange(starValue);
      }
    },
    [onChange, disabled, readonly]
  );
  const handleFocus = useCallback12(
    (event) => {
      if (onFocus) {
        const starValue = Number(event.target.dataset.value);
        onFocus(id, starValue);
      }
    },
    [onFocus, id]
  );
  const handleBlur = useCallback12(
    (event) => {
      if (onBlur) {
        const starValue = Number(event.target.dataset.value);
        onBlur(id, starValue);
      }
    },
    [onBlur, id]
  );
  const getSymbol = (isFilled) => {
    if (shape === "heart") {
      return isFilled ? "\u2665" : "\u2661";
    }
    return isFilled ? "\u2605" : "\u2606";
  };
  return /* @__PURE__ */ jsx46(Fragment5, { children: /* @__PURE__ */ jsxs21(
    "div",
    {
      className: "rating-widget",
      style: {
        display: "inline-flex",
        fontSize: "1.5rem",
        cursor: disabled || readonly ? "default" : "pointer"
      },
      children: [
        [...Array(numStars)].map((_, index) => {
          const starValue = min + index;
          const isFilled = starValue <= value;
          return /* @__PURE__ */ jsx46(
            "span",
            {
              onClick: () => handleStarClick(starValue),
              onFocus: handleFocus,
              onBlur: handleBlur,
              "data-value": starValue,
              tabIndex: disabled || readonly ? -1 : 0,
              role: "radio",
              "aria-checked": starValue === value,
              "aria-label": `${starValue} ${shape === "heart" ? "heart" : "star"}${starValue === 1 ? "" : "s"}`,
              style: {
                color: isFilled ? "#FFD700" : "#ccc",
                padding: "0 0.2rem",
                transition: "color 0.2s",
                userSelect: "none"
              },
              children: getSymbol(isFilled)
            },
            index
          );
        }),
        /* @__PURE__ */ jsx46(
          "input",
          {
            type: "hidden",
            id,
            name: id,
            value: value || "",
            required,
            disabled: disabled || readonly,
            "aria-hidden": "true"
          }
        )
      ]
    }
  ) });
}

// src/components/widgets/SelectWidget.tsx
import { useCallback as useCallback13 } from "react";
import {
  ariaDescribedByIds as ariaDescribedByIds6,
  enumOptionsIndexForValue,
  enumOptionsValueForIndex as enumOptionsValueForIndex3
} from "@rjsf/utils";
import { jsx as jsx47, jsxs as jsxs22 } from "react/jsx-runtime";
function getValue(event, multiple) {
  if (multiple) {
    return Array.from(event.target.options).slice().filter((o) => o.selected).map((o) => o.value);
  }
  return event.target.value;
}
function SelectWidget({
  schema,
  id,
  options,
  value,
  required,
  disabled,
  readonly,
  multiple = false,
  autofocus = false,
  onChange,
  onBlur,
  onFocus,
  placeholder
}) {
  const { enumOptions, enumDisabled, emptyValue: optEmptyVal } = options;
  const emptyValue = multiple ? [] : "";
  const handleFocus = useCallback13(
    (event) => {
      const newValue = getValue(event, multiple);
      return onFocus(id, enumOptionsValueForIndex3(newValue, enumOptions, optEmptyVal));
    },
    [onFocus, id, multiple, enumOptions, optEmptyVal]
  );
  const handleBlur = useCallback13(
    (event) => {
      const newValue = getValue(event, multiple);
      return onBlur(id, enumOptionsValueForIndex3(newValue, enumOptions, optEmptyVal));
    },
    [onBlur, id, multiple, enumOptions, optEmptyVal]
  );
  const handleChange = useCallback13(
    (event) => {
      const newValue = getValue(event, multiple);
      return onChange(enumOptionsValueForIndex3(newValue, enumOptions, optEmptyVal));
    },
    [onChange, multiple, enumOptions, optEmptyVal]
  );
  const selectedIndexes = enumOptionsIndexForValue(value, enumOptions, multiple);
  const showPlaceholderOption = !multiple && schema.default === void 0;
  return /* @__PURE__ */ jsxs22(
    "select",
    {
      id,
      name: id,
      multiple,
      role: "combobox",
      className: "form-control",
      value: typeof selectedIndexes === "undefined" ? emptyValue : selectedIndexes,
      required,
      disabled: disabled || readonly,
      autoFocus: autofocus,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleChange,
      "aria-describedby": ariaDescribedByIds6(id),
      children: [
        showPlaceholderOption && /* @__PURE__ */ jsx47("option", { value: "", children: placeholder }),
        Array.isArray(enumOptions) && enumOptions.map(({ value: value2, label }, i) => {
          const disabled2 = enumDisabled && enumDisabled.indexOf(value2) !== -1;
          return /* @__PURE__ */ jsx47("option", { value: String(i), disabled: disabled2, children: label }, i);
        })
      ]
    }
  );
}
var SelectWidget_default = SelectWidget;

// src/components/widgets/TextareaWidget.tsx
import { useCallback as useCallback14 } from "react";
import { ariaDescribedByIds as ariaDescribedByIds7 } from "@rjsf/utils";
import { jsx as jsx48 } from "react/jsx-runtime";
function TextareaWidget({
  id,
  options = {},
  placeholder,
  value,
  required,
  disabled,
  readonly,
  autofocus = false,
  onChange,
  onBlur,
  onFocus
}) {
  const handleChange = useCallback14(
    ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2),
    [onChange, options.emptyValue]
  );
  const handleBlur = useCallback14(
    ({ target }) => onBlur(id, target && target.value),
    [onBlur, id]
  );
  const handleFocus = useCallback14(
    ({ target }) => onFocus(id, target && target.value),
    [id, onFocus]
  );
  return /* @__PURE__ */ jsx48(
    "textarea",
    {
      id,
      name: id,
      className: "form-control",
      value: value ? value : "",
      placeholder,
      required,
      disabled,
      readOnly: readonly,
      autoFocus: autofocus,
      rows: options.rows,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleChange,
      "aria-describedby": ariaDescribedByIds7(id)
    }
  );
}
TextareaWidget.defaultProps = {
  autofocus: false,
  options: {}
};
var TextareaWidget_default = TextareaWidget;

// src/components/widgets/TextWidget.tsx
import { getTemplate as getTemplate21 } from "@rjsf/utils";
import { jsx as jsx49 } from "react/jsx-runtime";
function TextWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate21("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ jsx49(BaseInputTemplate2, { ...props });
}

// src/components/widgets/TimeWidget.tsx
import { useCallback as useCallback15 } from "react";
import { getTemplate as getTemplate22 } from "@rjsf/utils";
import { jsx as jsx50 } from "react/jsx-runtime";
function TimeWidget(props) {
  const { onChange, options, registry } = props;
  const BaseInputTemplate2 = getTemplate22("BaseInputTemplate", registry, options);
  const handleChange = useCallback15((value) => onChange(value ? `${value}:00` : void 0), [onChange]);
  return /* @__PURE__ */ jsx50(BaseInputTemplate2, { type: "time", ...props, onChange: handleChange });
}

// src/components/widgets/URLWidget.tsx
import { getTemplate as getTemplate23 } from "@rjsf/utils";
import { jsx as jsx51 } from "react/jsx-runtime";
function URLWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate23("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ jsx51(BaseInputTemplate2, { type: "url", ...props });
}

// src/components/widgets/UpDownWidget.tsx
import { getTemplate as getTemplate24 } from "@rjsf/utils";
import { jsx as jsx52 } from "react/jsx-runtime";
function UpDownWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate24("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ jsx52(BaseInputTemplate2, { type: "number", ...props });
}

// src/components/widgets/index.ts
function widgets() {
  return {
    AltDateWidget: AltDateWidget_default,
    AltDateTimeWidget: AltDateTimeWidget_default,
    CheckboxWidget: CheckboxWidget_default,
    CheckboxesWidget: CheckboxesWidget_default,
    ColorWidget,
    DateWidget,
    DateTimeWidget,
    EmailWidget,
    FileWidget: FileWidget_default,
    HiddenWidget: HiddenWidget_default,
    PasswordWidget,
    RadioWidget: RadioWidget_default,
    RangeWidget,
    RatingWidget,
    SelectWidget: SelectWidget_default,
    TextWidget,
    TextareaWidget: TextareaWidget_default,
    TimeWidget,
    UpDownWidget,
    URLWidget
  };
}
var widgets_default = widgets;

// src/getDefaultRegistry.ts
function getDefaultRegistry() {
  return {
    fields: fields_default(),
    templates: templates_default(),
    widgets: widgets_default(),
    rootSchema: {},
    formContext: {},
    translateString: englishStringTranslator
  };
}

// src/components/Form.tsx
import { jsx as jsx53, jsxs as jsxs23 } from "react/jsx-runtime";
var Form = class extends Component5 {
  /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
   * provide any possible type here
   */
  formElement;
  /** The list of pending changes
   */
  pendingChanges = [];
  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
   * state construction.
   *
   * @param props - The initial props for the `Form`
   */
  constructor(props) {
    super(props);
    if (!props.validator) {
      throw new Error("A validator is required for Form functionality to work");
    }
    this.state = this.getStateFromProps(props, props.formData);
    if (this.props.onChange && !deepEquals2(this.state.formData, this.props.formData)) {
      this.props.onChange(this.state);
    }
    this.formElement = createRef();
  }
  /**
   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
   * they are potentially changed.
   *
   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
   * state ready to be applied in `componentDidUpdate`.
   *
   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
   * state update is not necessary.
   *
   * @param prevProps - The previous set of props before the update.
   * @param prevState - The previous state before the update.
   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
   *        with a flag indicating that an update is not necessary.
   */
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (!deepEquals2(this.props, prevProps)) {
      const formDataChangedFields = getChangedFields(this.props.formData, prevProps.formData);
      const stateDataChangedFields = getChangedFields(this.props.formData, this.state.formData);
      const isSchemaChanged = !deepEquals2(prevProps.schema, this.props.schema);
      const isFormDataChanged = formDataChangedFields.length > 0 || !deepEquals2(prevProps.formData, this.props.formData);
      const isStateDataChanged = stateDataChangedFields.length > 0 || !deepEquals2(this.state.formData, this.props.formData);
      const nextState = this.getStateFromProps(
        this.props,
        this.props.formData,
        // If the `schema` has changed, we need to update the retrieved schema.
        // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
        //  match one of the subSchemas, the retrieved schema must be updated.
        isSchemaChanged || isFormDataChanged ? void 0 : this.state.retrievedSchema,
        isSchemaChanged,
        formDataChangedFields,
        // Skip live validation for this request if no form data has changed from the last state
        !isStateDataChanged
      );
      const shouldUpdate = !deepEquals2(nextState, prevState);
      return { nextState, shouldUpdate };
    }
    return { shouldUpdate: false };
  }
  /**
   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
   * not called for the initial render.
   *
   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
   * changes.
   *
   * @param _ - The previous set of props.
   * @param prevState - The previous state of the component before the update.
   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
   */
  componentDidUpdate(_, prevState, snapshot) {
    if (snapshot.shouldUpdate) {
      const { nextState } = snapshot;
      if (!deepEquals2(nextState.formData, this.props.formData) && !deepEquals2(nextState.formData, prevState.formData) && this.props.onChange) {
        this.props.onChange(nextState);
      }
      this.setState(nextState);
    }
  }
  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
   * validation process IF required by the `props`.
   *
   * @param props - The props passed to the `Form`
   * @param inputFormData - The new or current data for the `Form`
   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
   * @param isSchemaChanged - A flag indicating whether the schema has changed.
   * @param formDataChangedFields - The changed fields of `formData`
   * @returns - The new state for the `Form`
   */
  getStateFromProps(props, inputFormData, retrievedSchema, isSchemaChanged = false, formDataChangedFields = [], skipLiveValidate = false) {
    const state = this.state || {};
    const schema = "schema" in props ? props.schema : this.props.schema;
    const validator = "validator" in props ? props.validator : this.props.validator;
    const uiSchema = ("uiSchema" in props ? props.uiSchema : this.props.uiSchema) || {};
    const edit = typeof inputFormData !== "undefined";
    const liveValidate = "liveValidate" in props ? props.liveValidate : this.props.liveValidate;
    const mustValidate = edit && !props.noValidate && liveValidate && !skipLiveValidate;
    const experimental_defaultFormStateBehavior = "experimental_defaultFormStateBehavior" in props ? props.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior;
    const experimental_customMergeAllOf = "experimental_customMergeAllOf" in props ? props.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
    let schemaUtils = state.schemaUtils;
    if (!schemaUtils || schemaUtils.doesSchemaUtilsDiffer(
      validator,
      schema,
      experimental_defaultFormStateBehavior,
      experimental_customMergeAllOf
    )) {
      schemaUtils = createSchemaUtils(
        validator,
        schema,
        experimental_defaultFormStateBehavior,
        experimental_customMergeAllOf
      );
    }
    const rootSchema = schemaUtils.getRootSchema();
    const formData = schemaUtils.getDefaultFormState(rootSchema, inputFormData);
    const _retrievedSchema = this.updateRetrievedSchema(
      retrievedSchema ?? schemaUtils.retrieveSchema(rootSchema, formData)
    );
    const getCurrentErrors = () => {
      if (props.noValidate || isSchemaChanged) {
        return { errors: [], errorSchema: {} };
      } else if (!props.liveValidate) {
        return {
          errors: state.schemaValidationErrors || [],
          errorSchema: state.schemaValidationErrorSchema || {}
        };
      }
      return {
        errors: state.errors || [],
        errorSchema: state.errorSchema || {}
      };
    };
    let errors;
    let errorSchema;
    let schemaValidationErrors = state.schemaValidationErrors;
    let schemaValidationErrorSchema = state.schemaValidationErrorSchema;
    if (mustValidate) {
      const schemaValidation = this.validate(formData, rootSchema, schemaUtils, _retrievedSchema);
      errors = schemaValidation.errors;
      if (retrievedSchema === void 0) {
        errorSchema = schemaValidation.errorSchema;
      } else {
        errorSchema = mergeObjects3(
          this.state?.errorSchema,
          schemaValidation.errorSchema,
          "preventDuplicates"
        );
      }
      schemaValidationErrors = errors;
      schemaValidationErrorSchema = errorSchema;
    } else {
      const currentErrors = getCurrentErrors();
      errors = currentErrors.errors;
      errorSchema = currentErrors.errorSchema;
      if (formDataChangedFields.length > 0) {
        const newErrorSchema = formDataChangedFields.reduce(
          (acc, key) => {
            acc[key] = void 0;
            return acc;
          },
          {}
        );
        errorSchema = schemaValidationErrorSchema = mergeObjects3(
          currentErrors.errorSchema,
          newErrorSchema,
          "preventDuplicates"
        );
      }
    }
    if (props.extraErrors) {
      const merged = validationDataMerge({ errorSchema, errors }, props.extraErrors);
      errorSchema = merged.errorSchema;
      errors = merged.errors;
    }
    const idSchema = schemaUtils.toIdSchema(
      _retrievedSchema,
      uiSchema["ui:rootFieldId"],
      formData,
      props.idPrefix,
      props.idSeparator
    );
    const nextState = {
      schemaUtils,
      schema: rootSchema,
      uiSchema,
      idSchema,
      formData,
      edit,
      errors,
      errorSchema,
      schemaValidationErrors,
      schemaValidationErrorSchema,
      retrievedSchema: _retrievedSchema
    };
    return nextState;
  }
  /** React lifecycle method that is used to determine whether component should be updated.
   *
   * @param nextProps - The next version of the props
   * @param nextState - The next version of the state
   * @returns - True if the component should be updated, false otherwise
   */
  shouldComponentUpdate(nextProps, nextState) {
    const { experimental_componentUpdateStrategy = "customDeep" } = this.props;
    return shouldRender2(this, nextProps, nextState, experimental_componentUpdateStrategy);
  }
  /** Gets the previously raised customValidate errors.
   *
   * @returns the previous customValidate errors
   */
  getPreviousCustomValidateErrors() {
    const { customValidate, uiSchema } = this.props;
    const prevFormData = this.state.formData;
    let customValidateErrors = {};
    if (typeof customValidate === "function") {
      const errorHandler = customValidate(prevFormData, createErrorHandler(prevFormData), uiSchema);
      customValidateErrors = unwrapErrorHandler(errorHandler);
    }
    return customValidateErrors;
  }
  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
   * `schemaUtils` in the state), returning the results.
   *
   * @param formData - The new form data to validate
   * @param schema - The schema used to validate against
   * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
   * @param [retrievedSchema] - An optionally retrieved schema for per
   */
  validate(formData, schema = this.state.schema, altSchemaUtils, retrievedSchema) {
    const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;
    const { customValidate, transformErrors, uiSchema } = this.props;
    const resolvedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);
    return schemaUtils.getValidator().validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);
  }
  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
  renderErrors(registry) {
    const { errors, errorSchema, schema, uiSchema } = this.state;
    const { formContext } = this.props;
    const options = getUiOptions17(uiSchema);
    const ErrorListTemplate = getTemplate25("ErrorListTemplate", registry, options);
    if (errors && errors.length) {
      return /* @__PURE__ */ jsx53(
        ErrorListTemplate,
        {
          errors,
          errorSchema: errorSchema || {},
          schema,
          uiSchema,
          formContext,
          registry
        }
      );
    }
    return null;
  }
  /** Returns the `formData` with only the elements specified in the `fields` list
   *
   * @param formData - The data for the `Form`
   * @param fields - The fields to keep while filtering
   */
  getUsedFormData = (formData, fields2) => {
    if (fields2.length === 0 && typeof formData !== "object") {
      return formData;
    }
    const data = _pick(formData, fields2);
    if (Array.isArray(formData)) {
      return Object.keys(data).map((key) => data[key]);
    }
    return data;
  };
  /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
   *
   * @param pathSchema - The `PathSchema` object for the form
   * @param [formData] - The form data to use while checking for empty objects/arrays
   */
  getFieldNames = (pathSchema, formData) => {
    const getAllPaths = (_obj, acc = [], paths = [[]]) => {
      Object.keys(_obj).forEach((key) => {
        if (typeof _obj[key] === "object") {
          const newPaths = paths.map((path) => [...path, key]);
          if (_obj[key][RJSF_ADDITIONAL_PROPERTIES_FLAG] && _obj[key][NAME_KEY] !== "") {
            acc.push(_obj[key][NAME_KEY]);
          } else {
            getAllPaths(_obj[key], acc, newPaths);
          }
        } else if (key === NAME_KEY && _obj[key] !== "") {
          paths.forEach((path) => {
            const formValue = _get(formData, path);
            if (typeof formValue !== "object" || _isEmpty(formValue) || Array.isArray(formValue) && formValue.every((val) => typeof val !== "object")) {
              acc.push(path);
            }
          });
        }
      });
      return acc;
    };
    return getAllPaths(pathSchema);
  };
  /** Returns the `formData` after filtering to remove any extra data not in a form field
   *
   * @param formData - The data for the `Form`
   * @returns The `formData` after omitting extra data
   */
  omitExtraData = (formData) => {
    const { schema, schemaUtils } = this.state;
    const retrievedSchema = schemaUtils.retrieveSchema(schema, formData);
    const pathSchema = schemaUtils.toPathSchema(retrievedSchema, "", formData);
    const fieldNames = this.getFieldNames(pathSchema, formData);
    return this.getUsedFormData(formData, fieldNames);
  };
  /** Filtering errors based on your retrieved schema to only show errors for properties in the selected branch.
   *
   * @param schemaErrors - The schema errors to filter
   * @param [resolvedSchema] - An optionally resolved schema to use for performance reasons
   * @param [formData] - The formData to help filter errors
   * @private
   */
  filterErrorsBasedOnSchema(schemaErrors, resolvedSchema, formData) {
    const { retrievedSchema, schemaUtils } = this.state;
    const _retrievedSchema = resolvedSchema ?? retrievedSchema;
    const pathSchema = schemaUtils.toPathSchema(_retrievedSchema, "", formData);
    const fieldNames = this.getFieldNames(pathSchema, formData);
    const filteredErrors = _pick(schemaErrors, fieldNames);
    if (resolvedSchema?.type !== "object" && resolvedSchema?.type !== "array") {
      filteredErrors.__errors = schemaErrors.__errors;
    }
    const prevCustomValidateErrors = this.getPreviousCustomValidateErrors();
    const filterPreviousCustomErrors = (errors = [], prevCustomErrors) => {
      if (errors.length === 0) {
        return errors;
      }
      return errors.filter((error) => {
        return !prevCustomErrors.includes(error);
      });
    };
    const filterNilOrEmptyErrors = (errors, previousCustomValidateErrors = {}) => {
      _forEach(errors, (errorAtKey, errorKey) => {
        const prevCustomValidateErrorAtKey = previousCustomValidateErrors[errorKey];
        if (_isNil(errorAtKey) || Array.isArray(errorAtKey) && errorAtKey.length === 0) {
          delete errors[errorKey];
        } else if (isObject6(errorAtKey) && isObject6(prevCustomValidateErrorAtKey) && Array.isArray(prevCustomValidateErrorAtKey?.__errors)) {
          errors[errorKey] = filterPreviousCustomErrors(errorAtKey.__errors, prevCustomValidateErrorAtKey.__errors);
        } else if (typeof errorAtKey === "object" && !Array.isArray(errorAtKey.__errors)) {
          filterNilOrEmptyErrors(errorAtKey, previousCustomValidateErrors[errorKey]);
        }
      });
      return errors;
    };
    return filterNilOrEmptyErrors(filteredErrors, prevCustomValidateErrors);
  }
  /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
   * the array only contains a single pending change.
   *
   * @param newValue - The new form data from a change to a field
   * @param [path] - The path to the change into which to set the formData
   * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
   * @param [id] - The id of the field that caused the change
   */
  onChange = (newValue, path, newErrorSchema, id) => {
    this.pendingChanges.push({ newValue, path, newErrorSchema, id });
    if (this.pendingChanges.length === 1) {
      this.processPendingChange();
    }
  };
  /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
   * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
   * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
   * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
   * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
   * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
   * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
   * specified, with the updated state and the `processPendingChange()` function is called again.
   */
  processPendingChange() {
    if (this.pendingChanges.length === 0) {
      return;
    }
    const { newValue, path, id } = this.pendingChanges[0];
    let { newErrorSchema } = this.pendingChanges[0];
    const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange, idPrefix = "" } = this.props;
    const { formData: oldFormData, schemaUtils, schema, errorSchema } = this.state;
    const isRootPath = !path || path.length === 0 || path.length === 1 && path[0] === idPrefix;
    let retrievedSchema = this.state.retrievedSchema;
    let formData = isRootPath ? newValue : _cloneDeep(oldFormData);
    if (isObject6(formData) || Array.isArray(formData)) {
      if (!isRootPath) {
        _set(formData, path, newValue);
      }
      const newState = this.getStateFromProps(this.props, formData, void 0, void 0, void 0, true);
      formData = newState.formData;
      retrievedSchema = newState.retrievedSchema;
    }
    const mustValidate = !noValidate && liveValidate;
    let state = { formData, schema };
    let newFormData = formData;
    if (omitExtraData === true && liveOmit === true) {
      newFormData = this.omitExtraData(formData);
      state = {
        formData: newFormData
      };
    }
    if (newErrorSchema && !isRootPath) {
      const errorSchemaCopy = _cloneDeep(errorSchema);
      _set(errorSchemaCopy, path, newErrorSchema);
      newErrorSchema = errorSchemaCopy;
    }
    if (mustValidate && this.pendingChanges.length === 1) {
      const schemaValidation = this.validate(newFormData, schema, schemaUtils, retrievedSchema);
      let errors = schemaValidation.errors;
      let errorSchema2 = schemaValidation.errorSchema;
      const schemaValidationErrors = errors;
      const schemaValidationErrorSchema = errorSchema2;
      if (extraErrors) {
        const merged = validationDataMerge(schemaValidation, extraErrors);
        errorSchema2 = merged.errorSchema;
        errors = merged.errors;
      }
      if (newErrorSchema) {
        const filteredErrors = this.filterErrorsBasedOnSchema(newErrorSchema, retrievedSchema, newFormData);
        errorSchema2 = mergeObjects3(errorSchema2, filteredErrors, "preventDuplicates");
      }
      state = {
        formData: newFormData,
        errors,
        errorSchema: errorSchema2,
        schemaValidationErrors,
        schemaValidationErrorSchema
      };
    } else if (!noValidate && newErrorSchema) {
      const errorSchema2 = extraErrors ? mergeObjects3(newErrorSchema, extraErrors, "preventDuplicates") : newErrorSchema;
      state = {
        formData: newFormData,
        errorSchema: errorSchema2,
        errors: toErrorList(errorSchema2)
      };
    }
    this.setState(state, () => {
      if (onChange) {
        onChange({ ...this.state, ...state }, id);
      }
      this.pendingChanges.shift();
      this.processPendingChange();
    });
  }
  /**
   * If the retrievedSchema has changed the new retrievedSchema is returned.
   * Otherwise, the old retrievedSchema is returned to persist reference.
   * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
   *    avoiding the performance cost of recompiling the schema.
   *
   * @param retrievedSchema The new retrieved schema.
   * @returns The new retrieved schema if it has changed, else the old retrieved schema.
   */
  updateRetrievedSchema(retrievedSchema) {
    const isTheSame = deepEquals2(retrievedSchema, this.state?.retrievedSchema);
    return isTheSame ? this.state.retrievedSchema : retrievedSchema;
  }
  /**
   * Callback function to handle reset form data.
   * - Reset all fields with default values.
   * - Reset validations and errors
   *
   */
  reset = () => {
    const { onChange } = this.props;
    const newState = this.getStateFromProps(this.props, void 0);
    const newFormData = newState.formData;
    const state = {
      formData: newFormData,
      errorSchema: {},
      errors: [],
      schemaValidationErrors: [],
      schemaValidationErrorSchema: {}
    };
    this.setState(state, () => onChange && onChange({ ...this.state, ...state }));
  };
  /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
   * was provided.
   *
   * @param id - The unique `id` of the field that was blurred
   * @param data - The data associated with the field that was blurred
   */
  onBlur = (id, data) => {
    const { onBlur } = this.props;
    if (onBlur) {
      onBlur(id, data);
    }
  };
  /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
   * was provided.
   *
   * @param id - The unique `id` of the field that was focused
   * @param data - The data associated with the field that was focused
   */
  onFocus = (id, data) => {
    const { onFocus } = this.props;
    if (onFocus) {
      onFocus(id, data);
    }
  };
  /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
   * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
   * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
   * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
   * back the `onSubmit` callback if it was provided.
   *
   * @param event - The submit HTML form event
   */
  onSubmit = (event) => {
    event.preventDefault();
    if (event.target !== event.currentTarget) {
      return;
    }
    event.persist();
    const { omitExtraData, extraErrors, noValidate, onSubmit } = this.props;
    let { formData: newFormData } = this.state;
    if (omitExtraData === true) {
      newFormData = this.omitExtraData(newFormData);
    }
    if (noValidate || this.validateFormWithFormData(newFormData)) {
      const errorSchema = extraErrors || {};
      const errors = extraErrors ? toErrorList(extraErrors) : [];
      this.setState(
        {
          formData: newFormData,
          errors,
          errorSchema,
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        },
        () => {
          if (onSubmit) {
            onSubmit({ ...this.state, formData: newFormData, status: "submitted" }, event);
          }
        }
      );
    }
  };
  /** Returns the registry for the form */
  getRegistry() {
    const {
      translateString: customTranslateString,
      uiSchema = {},
      experimental_componentUpdateStrategy = "customDeep"
    } = this.props;
    const { schema, schemaUtils } = this.state;
    const { fields: fields2, templates: templates2, widgets: widgets2, formContext, translateString } = getDefaultRegistry();
    return {
      fields: { ...fields2, ...this.props.fields },
      templates: {
        ...templates2,
        ...this.props.templates,
        ButtonTemplates: {
          ...templates2.ButtonTemplates,
          ...this.props.templates?.ButtonTemplates
        }
      },
      widgets: { ...widgets2, ...this.props.widgets },
      rootSchema: schema,
      formContext: this.props.formContext || formContext,
      schemaUtils,
      translateString: customTranslateString || translateString,
      globalUiOptions: uiSchema[UI_GLOBAL_OPTIONS_KEY2],
      experimental_componentUpdateStrategy
    };
  }
  /** Provides a function that can be used to programmatically submit the `Form` */
  submit = () => {
    if (this.formElement.current) {
      const submitCustomEvent = new CustomEvent("submit", {
        cancelable: true
      });
      submitCustomEvent.preventDefault();
      this.formElement.current.dispatchEvent(submitCustomEvent);
      this.formElement.current.requestSubmit();
    }
  };
  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
   *
   * @param error - The error on which to focus
   */
  focusOnError(error) {
    const { idPrefix = "root", idSeparator = "_" } = this.props;
    const { property } = error;
    const path = _toPath(property);
    if (path[0] === "") {
      path[0] = idPrefix;
    } else {
      path.unshift(idPrefix);
    }
    const elementId = path.join(idSeparator);
    let field = this.formElement.current.elements[elementId];
    if (!field) {
      field = this.formElement.current.querySelector(`input[id^="${elementId}"`);
    }
    if (field && field.length) {
      field = field[0];
    }
    if (field) {
      field.focus();
    }
  }
  /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
   * If `onError` is provided, then it will be called with the list of errors.
   *
   * @param formData - The form data to validate
   * @returns - True if the form is valid, false otherwise.
   */
  validateFormWithFormData = (formData) => {
    const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = this.props;
    const { errors: prevErrors } = this.state;
    const schemaValidation = this.validate(formData);
    let errors = schemaValidation.errors;
    let errorSchema = schemaValidation.errorSchema;
    const schemaValidationErrors = errors;
    const schemaValidationErrorSchema = errorSchema;
    const hasError = errors.length > 0 || extraErrors && extraErrorsBlockSubmit;
    if (hasError) {
      if (extraErrors) {
        const merged = validationDataMerge(schemaValidation, extraErrors);
        errorSchema = merged.errorSchema;
        errors = merged.errors;
      }
      if (focusOnFirstError) {
        if (typeof focusOnFirstError === "function") {
          focusOnFirstError(errors[0]);
        } else {
          this.focusOnError(errors[0]);
        }
      }
      this.setState(
        {
          errors,
          errorSchema,
          schemaValidationErrors,
          schemaValidationErrorSchema
        },
        () => {
          if (onError) {
            onError(errors);
          } else {
            console.error("Form validation failed", errors);
          }
        }
      );
    } else if (prevErrors.length > 0) {
      this.setState({
        errors: [],
        errorSchema: {},
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      });
    }
    return !hasError;
  };
  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
   * same way as would happen on form submission.
   *
   * @returns - True if the form is valid, false otherwise.
   */
  validateForm() {
    const { omitExtraData } = this.props;
    let { formData: newFormData } = this.state;
    if (omitExtraData === true) {
      newFormData = this.omitExtraData(newFormData);
    }
    return this.validateFormWithFormData(newFormData);
  }
  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
   * needed along with the submit button or any children of the form.
   */
  render() {
    const {
      children,
      id,
      idPrefix = "",
      idSeparator,
      className = "",
      tagName,
      name,
      method,
      target,
      action,
      autoComplete,
      enctype,
      acceptCharset,
      noHtml5Validate = false,
      disabled,
      readonly,
      formContext,
      showErrorList = "top",
      _internalFormWrapper
    } = this.props;
    const { schema, uiSchema, formData, errorSchema, idSchema } = this.state;
    const registry = this.getRegistry();
    const { SchemaField: _SchemaField } = registry.fields;
    const { SubmitButton: SubmitButton2 } = registry.templates.ButtonTemplates;
    const as = _internalFormWrapper ? tagName : void 0;
    const FormTag = _internalFormWrapper || tagName || "form";
    let { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = getUiOptions17(uiSchema);
    if (disabled) {
      submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };
    }
    const submitUiSchema = { [UI_OPTIONS_KEY3]: { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };
    return /* @__PURE__ */ jsxs23(
      FormTag,
      {
        className: className ? className : "rjsf",
        id,
        name,
        method,
        target,
        action,
        autoComplete,
        encType: enctype,
        acceptCharset,
        noValidate: noHtml5Validate,
        onSubmit: this.onSubmit,
        as,
        ref: this.formElement,
        children: [
          showErrorList === "top" && this.renderErrors(registry),
          /* @__PURE__ */ jsx53(
            _SchemaField,
            {
              name: idPrefix,
              schema,
              uiSchema,
              errorSchema,
              idSchema,
              idPrefix,
              idSeparator,
              formContext,
              formData,
              onChange: this.onChange,
              onBlur: this.onBlur,
              onFocus: this.onFocus,
              registry,
              disabled,
              readonly
            }
          ),
          children ? children : /* @__PURE__ */ jsx53(SubmitButton2, { uiSchema: submitUiSchema, registry }),
          showErrorList === "bottom" && this.renderErrors(registry)
        ]
      }
    );
  }
};

// src/withTheme.tsx
import { forwardRef } from "react";
import { jsx as jsx54 } from "react/jsx-runtime";
function withTheme(themeProps) {
  return forwardRef(
    ({ fields: fields2, widgets: widgets2, templates: templates2, ...directProps }, ref) => {
      fields2 = { ...themeProps?.fields, ...fields2 };
      widgets2 = { ...themeProps?.widgets, ...widgets2 };
      templates2 = {
        ...themeProps?.templates,
        ...templates2,
        ButtonTemplates: {
          ...themeProps?.templates?.ButtonTemplates,
          ...templates2?.ButtonTemplates
        }
      };
      return /* @__PURE__ */ jsx54(
        Form,
        {
          ...themeProps,
          ...directProps,
          fields: fields2,
          widgets: widgets2,
          templates: templates2,
          ref
        }
      );
    }
  );
}

// src/index.ts
var index_default = Form;
export {
  RichDescription,
  index_default as default,
  getDefaultRegistry,
  withTheme
};
//# sourceMappingURL=index.esm.js.map
