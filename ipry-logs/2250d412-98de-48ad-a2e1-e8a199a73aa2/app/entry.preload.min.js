"use strict";

// src/entry.preload.ts
var import_electron = require("electron");

// src/utils/invariant.ts
function invariant(condition, message) {
  if (condition) {
    return;
  }
  throw new Error(typeof message === "function" ? message() : message);
}

// src/entry.preload.ts
var ports = /* @__PURE__ */ new Map();
var webSocket = {
  open: (options) => import_electron.ipcRenderer.invoke("webSocket.open", options),
  close: (options) => import_electron.ipcRenderer.send("webSocket.close", options),
  closeAll: () => import_electron.ipcRenderer.send("webSocket.closeAll"),
  readyState: {
    getCurrent: (options) => import_electron.ipcRenderer.invoke("webSocket.readyState", options)
  },
  event: {
    findMany: (options) => import_electron.ipcRenderer.invoke("webSocket.event.findMany", options),
    send: (options) => import_electron.ipcRenderer.invoke("webSocket.event.send", options)
  }
};
var curl = {
  open: (options) => import_electron.ipcRenderer.invoke("curl.open", options),
  close: (options) => import_electron.ipcRenderer.send("curl.close", options),
  closeAll: () => import_electron.ipcRenderer.send("curl.closeAll"),
  readyState: {
    getCurrent: (options) => import_electron.ipcRenderer.invoke("curl.readyState", options)
  },
  event: {
    findMany: (options) => import_electron.ipcRenderer.invoke("curl.event.findMany", options)
  }
};
var socketIO = {
  open: (options) => import_electron.ipcRenderer.invoke("socketIO.open", options),
  readyState: {
    getCurrent: (options) => import_electron.ipcRenderer.invoke("socketIO.readyState", options)
  },
  close: (options) => import_electron.ipcRenderer.send("socketIO.close", options),
  closeAll: () => import_electron.ipcRenderer.send("socketIO.closeAll"),
  event: {
    findMany: (options) => import_electron.ipcRenderer.invoke("socketIO.event.findMany", options),
    send: (options) => import_electron.ipcRenderer.invoke("socketIO.event.send", options),
    on: (options) => import_electron.ipcRenderer.send("socketIO.event.on", options),
    off: (options) => import_electron.ipcRenderer.send("socketIO.event.off", options)
  }
};
var mcp = {
  connect: (options) => import_electron.ipcRenderer.invoke("mcp.connect", options),
  close: (options) => import_electron.ipcRenderer.invoke("mcp.close", options),
  closeAll: () => import_electron.ipcRenderer.send("mcp.closeAll"),
  authConfirmation: (confirmed) => import_electron.ipcRenderer.send("mcp.authConfirmed", confirmed),
  primitive: {
    listTools: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.listTools", options),
    callTool: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.callTool", options),
    listResources: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.listResources", options),
    listResourceTemplates: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.listResourceTemplates", options),
    readResource: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.readResource", options),
    subscribeResource: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.subscribeResource", options),
    unsubscribeResource: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.unsubscribeResource", options),
    listPrompts: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.listPrompts", options),
    getPrompt: (options) => import_electron.ipcRenderer.invoke("mcp.primitive.getPrompt", options)
  },
  notification: {
    rootListChange: (options) => import_electron.ipcRenderer.invoke("mcp.notification.rootListChange", options)
  },
  readyState: {
    getCurrent: (options) => import_electron.ipcRenderer.invoke("mcp.readyState", options)
  },
  client: {
    responseElicitationRequest: (options) => import_electron.ipcRenderer.send("mcp.client.responseElicitationRequest", options),
    hasRequestResponded: (options) => import_electron.ipcRenderer.invoke("mcp.client.hasRequestResponded", options),
    cancelRequest: (options) => import_electron.ipcRenderer.invoke("mcp.client.cancelRequest", options)
  },
  event: {
    findMany: (options) => import_electron.ipcRenderer.invoke("mcp.event.findMany", options),
    findNotifications: (options) => import_electron.ipcRenderer.invoke("mcp.event.findNotifications", options),
    findPendingEvents: (options) => import_electron.ipcRenderer.invoke("mcp.event.findPendingEvents", options)
  }
};
var grpc = {
  start: (options) => import_electron.ipcRenderer.send("grpc.start", options),
  sendMessage: (options) => import_electron.ipcRenderer.send("grpc.sendMessage", options),
  commit: (options) => import_electron.ipcRenderer.send("grpc.commit", options),
  cancel: (options) => import_electron.ipcRenderer.send("grpc.cancel", options),
  closeAll: () => import_electron.ipcRenderer.send("grpc.closeAll"),
  loadMethods: (options) => import_electron.ipcRenderer.invoke("grpc.loadMethods", options),
  loadMethodsFromReflection: (options) => import_electron.ipcRenderer.invoke("grpc.loadMethodsFromReflection", options)
};
var secretStorage = {
  setSecret: (key, secret) => import_electron.ipcRenderer.invoke("secretStorage.setSecret", key, secret),
  getSecret: (key) => import_electron.ipcRenderer.invoke("secretStorage.getSecret", key),
  deleteSecret: (key) => import_electron.ipcRenderer.invoke("secretStorage.deleteSecret", key),
  encryptString: (raw) => import_electron.ipcRenderer.invoke("secretStorage.encryptString", raw),
  decryptString: (cipherText) => import_electron.ipcRenderer.invoke("secretStorage.decryptString", cipherText)
};
var git = {
  loadGitRepository: (options) => import_electron.ipcRenderer.invoke("git.loadGitRepository", options),
  getGitBranches: (options) => import_electron.ipcRenderer.invoke("git.getGitBranches", options),
  fetchGitRemoteBranches: (options) => import_electron.ipcRenderer.invoke("git.fetchGitRemoteBranches", options),
  gitFetchAction: (options) => import_electron.ipcRenderer.invoke("git.gitFetchAction", options),
  gitLogLoader: (options) => import_electron.ipcRenderer.invoke("git.gitLogLoader", options),
  gitChangesLoader: (options) => import_electron.ipcRenderer.invoke("git.gitChangesLoader", options),
  canPushLoader: (options) => import_electron.ipcRenderer.invoke("git.canPushLoader", options),
  cloneGitRepo: (options) => import_electron.ipcRenderer.invoke("git.cloneGitRepo", options),
  initGitRepoClone: (options) => import_electron.ipcRenderer.invoke("git.initGitRepoClone", options),
  updateGitRepo: (options) => import_electron.ipcRenderer.invoke("git.updateGitRepo", options),
  resetGitRepo: (options) => import_electron.ipcRenderer.invoke("git.resetGitRepo", options),
  commitToGitRepo: (options) => import_electron.ipcRenderer.invoke("git.commitToGitRepo", options),
  commitAndPushToGitRepo: (options) => import_electron.ipcRenderer.invoke("git.commitAndPushToGitRepo", options),
  createNewGitBranch: (options) => import_electron.ipcRenderer.invoke("git.createNewGitBranch", options),
  checkoutGitBranch: (options) => import_electron.ipcRenderer.invoke("git.checkoutGitBranch", options),
  mergeGitBranch: (options) => import_electron.ipcRenderer.invoke("git.mergeGitBranch", options),
  deleteGitBranch: (options) => import_electron.ipcRenderer.invoke("git.deleteGitBranch", options),
  pushToGitRemote: (options) => import_electron.ipcRenderer.invoke("git.pushToGitRemote", options),
  pullFromGitRemote: (options) => import_electron.ipcRenderer.invoke("git.pullFromGitRemote", options),
  continueMerge: (options) => import_electron.ipcRenderer.invoke("git.continueMerge", options),
  discardChanges: (options) => import_electron.ipcRenderer.invoke("git.discardChanges", options),
  abortMerge: () => import_electron.ipcRenderer.invoke("git.abortMerge"),
  gitStatus: (options) => import_electron.ipcRenderer.invoke("git.gitStatus", options),
  diff: () => import_electron.ipcRenderer.invoke("git.diff"),
  multipleCommitToGitRepo: (options) => import_electron.ipcRenderer.invoke("git.multipleCommitToGitRepo", options),
  stageChanges: (options) => import_electron.ipcRenderer.invoke("git.stageChanges", options),
  unstageChanges: (options) => import_electron.ipcRenderer.invoke("git.unstageChanges", options),
  diffFileLoader: (options) => import_electron.ipcRenderer.invoke("git.diffFileLoader", options),
  getRepositoryDirectoryTree: (options) => import_electron.ipcRenderer.invoke("git.getRepositoryDirectoryTree", options),
  migrateLegacyInsomniaFolderToFile: (options) => import_electron.ipcRenderer.invoke("git.migrateLegacyInsomniaFolderToFile", options),
  initSignInToGitHub: () => import_electron.ipcRenderer.invoke("git.initSignInToGitHub"),
  completeSignInToGitHub: (options) => import_electron.ipcRenderer.invoke("git.completeSignInToGitHub", options),
  signOutOfGitHub: () => import_electron.ipcRenderer.invoke("git.signOutOfGitHub"),
  getGitHubRepositories: (options) => import_electron.ipcRenderer.invoke("git.getGitHubRepositories", options),
  getGitHubRepository: (options) => import_electron.ipcRenderer.invoke("git.getGitHubRepository", options),
  initSignInToGitLab: () => import_electron.ipcRenderer.invoke("git.initSignInToGitLab"),
  completeSignInToGitLab: (options) => import_electron.ipcRenderer.invoke("git.completeSignInToGitLab", options),
  signOutOfGitLab: () => import_electron.ipcRenderer.invoke("git.signOutOfGitLab")
};
var llm = {
  getActiveBackend: () => import_electron.ipcRenderer.invoke("llm.getActiveBackend"),
  setActiveBackend: (backend) => import_electron.ipcRenderer.invoke("llm.setActiveBackend", backend),
  clearActiveBackend: () => import_electron.ipcRenderer.invoke("llm.clearActiveBackend"),
  getBackendConfig: (backend) => import_electron.ipcRenderer.invoke("llm.getBackendConfig", backend),
  updateBackendConfig: (backend, config) => import_electron.ipcRenderer.invoke("llm.updateBackendConfig", backend, config),
  getAllConfigurations: () => import_electron.ipcRenderer.invoke("llm.getAllConfigurations"),
  getCurrentConfig: () => import_electron.ipcRenderer.invoke("llm.getCurrentConfig"),
  getAIFeatureEnabled: (feature) => import_electron.ipcRenderer.invoke("llm.getAIFeatureEnabled", feature),
  setAIFeatureEnabled: (feature, enabled) => import_electron.ipcRenderer.invoke("llm.setAIFeatureEnabled", feature, enabled)
};
var main = {
  startExecution: (options) => import_electron.ipcRenderer.send("startExecution", options),
  addExecutionStep: (options) => import_electron.ipcRenderer.send("addExecutionStep", options),
  completeExecutionStep: (options) => import_electron.ipcRenderer.send("completeExecutionStep", options),
  updateLatestStepName: (options) => import_electron.ipcRenderer.send("updateLatestStepName", options),
  getExecution: (options) => import_electron.ipcRenderer.invoke("getExecution", options),
  loginStateChange: () => import_electron.ipcRenderer.send("loginStateChange"),
  restart: () => import_electron.ipcRenderer.send("restart"),
  openInBrowser: (options) => import_electron.ipcRenderer.send("openInBrowser", options),
  openDeepLink: (options) => import_electron.ipcRenderer.send("openDeepLink", options),
  halfSecondAfterAppStart: () => import_electron.ipcRenderer.send("halfSecondAfterAppStart"),
  manualUpdateCheck: () => import_electron.ipcRenderer.send("manualUpdateCheck"),
  backup: () => import_electron.ipcRenderer.invoke("backup"),
  restoreBackup: (options) => import_electron.ipcRenderer.invoke("restoreBackup", options),
  authorizeUserInWindow: (options) => import_electron.ipcRenderer.invoke("authorizeUserInWindow", options),
  authorizeUserInDefaultBrowser: (options) => import_electron.ipcRenderer.invoke("authorizeUserInDefaultBrowser", options),
  onDefaultBrowserOAuthRedirect: (options) => import_electron.ipcRenderer.invoke("onDefaultBrowserOAuthRedirect", options),
  cancelAuthorizationInDefaultBrowser: (options) => import_electron.ipcRenderer.invoke("cancelAuthorizationInDefaultBrowser", options),
  setMenuBarVisibility: (options) => import_electron.ipcRenderer.send("setMenuBarVisibility", options),
  installPlugin: (lookupName, allowScopedPackageNames = false) => import_electron.ipcRenderer.invoke("installPlugin", lookupName, allowScopedPackageNames),
  curlRequest: (options) => import_electron.ipcRenderer.invoke("curlRequest", options),
  cancelCurlRequest: (options) => import_electron.ipcRenderer.send("cancelCurlRequest", options),
  writeFile: (options) => import_electron.ipcRenderer.invoke("writeFile", options),
  insecureReadFile: (options) => import_electron.ipcRenderer.invoke("insecureReadFile", options),
  insecureReadFileWithEncoding: (options) => import_electron.ipcRenderer.invoke("insecureReadFileWithEncoding", options),
  secureReadFile: (options) => import_electron.ipcRenderer.invoke("secureReadFile", options),
  parseImport: (...args) => import_electron.ipcRenderer.invoke("parseImport", ...args),
  readDir: (options) => import_electron.ipcRenderer.invoke("readDir", options),
  readOrCreateDataDir: (options) => import_electron.ipcRenderer.invoke("readOrCreateDataDir", options),
  lintSpec: (options) => import_electron.ipcRenderer.invoke("lintSpec", options),
  on: (channel, listener) => {
    import_electron.ipcRenderer.on(channel, listener);
    return () => import_electron.ipcRenderer.removeListener(channel, listener);
  },
  webSocket,
  socketIO,
  mcp,
  git,
  llm,
  grpc,
  curl,
  secretStorage,
  trackSegmentEvent: (options) => import_electron.ipcRenderer.send("trackSegmentEvent", options),
  trackPageView: (options) => import_electron.ipcRenderer.send("trackPageView", options),
  showNunjucksContextMenu: (options) => import_electron.ipcRenderer.send("show-nunjucks-context-menu", options),
  showContextMenu: (options) => import_electron.ipcRenderer.send("showContextMenu", options),
  database: {
    caCertificate: {
      create: (options) => import_electron.ipcRenderer.invoke("database.caCertificate.create", options)
    }
  },
  hiddenBrowserWindow: {
    runScript: (options) => new Promise(async (resolve, reject) => {
      const isPortAlive = ports.get("hiddenWindowPort") !== void 0;
      await import_electron.ipcRenderer.invoke("open-channel-to-hidden-browser-window", isPortAlive);
      const port = ports.get("hiddenWindowPort");
      invariant(port, "hiddenWindowPort is undefined");
      port.onmessage = (event) => {
        console.log("[preload] received result:", event.data);
        if (event.data.error) {
          reject(new Error(event.data.error));
        }
        resolve(event.data);
      };
      port.postMessage({ ...options, type: "runPreRequestScript" });
    })
  },
  extractJsonFileFromPostmanDataDumpArchive: (archivePath) => import_electron.ipcRenderer.invoke("extractJsonFileFromPostmanDataDumpArchive", archivePath),
  getLocalStorageDataFromFileOrigin: () => import_electron.ipcRenderer.invoke("getLocalStorageDataFromFileOrigin"),
  generateMockRouteDataFromSpec: (openApiSpec, specUrl, specText, modelConfig, useDynamicMockResponses, mockServerAdditionalFiles) => import_electron.ipcRenderer.invoke(
    "generateMockRouteDataFromSpec",
    openApiSpec,
    specUrl,
    specText,
    modelConfig,
    useDynamicMockResponses,
    mockServerAdditionalFiles
  ),
  generateCommitsFromDiff: (input) => import_electron.ipcRenderer.invoke("generateCommitsFromDiff", input)
};
import_electron.ipcRenderer.on("hidden-browser-window-response-listener", (event) => {
  const [port] = event.ports;
  ports.set("hiddenWindowPort", port);
  import_electron.ipcRenderer.invoke("main-window-script-port-ready");
});
var dialog = {
  showOpenDialog: (options) => import_electron.ipcRenderer.invoke("showOpenDialog", options),
  showSaveDialog: (options) => import_electron.ipcRenderer.invoke("showSaveDialog", options)
};
var app = {
  getPath: (options) => import_electron.ipcRenderer.sendSync("getPath", options),
  getAppPath: () => import_electron.ipcRenderer.sendSync("getAppPath")
};
var shell = {
  showItemInFolder: (options) => import_electron.ipcRenderer.send("showItemInFolder", options),
  openPath: (options) => import_electron.ipcRenderer.invoke("openPath", options)
};
var clipboard = {
  readText: () => import_electron.ipcRenderer.sendSync("readText"),
  writeText: (options) => import_electron.ipcRenderer.send("writeText", options),
  clear: () => import_electron.ipcRenderer.send("clear")
};
var webUtils = {
  getPathForFile: (file) => import_electron.webUtils.getPathForFile(file)
};
if (process.contextIsolated) {
  import_electron.contextBridge.exposeInMainWorld("main", main);
  import_electron.contextBridge.exposeInMainWorld("dialog", dialog);
  import_electron.contextBridge.exposeInMainWorld("app", app);
  import_electron.contextBridge.exposeInMainWorld("shell", shell);
  import_electron.contextBridge.exposeInMainWorld("clipboard", clipboard);
  import_electron.contextBridge.exposeInMainWorld("webUtils", webUtils);
} else {
  window.main = main;
  window.dialog = dialog;
  window.app = app;
  window.shell = shell;
  window.clipboard = clipboard;
  window.webUtils = webUtils;
}
//# sourceMappingURL=entry.preload.min.js.map
