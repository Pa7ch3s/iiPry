(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('@rjsf/utils'), require('lodash/cloneDeep'), require('lodash/forEach'), require('lodash/get'), require('lodash/isEmpty'), require('lodash/isNil'), require('lodash/pick'), require('lodash/set'), require('lodash/toPath'), require('lodash/isObject'), require('lodash/uniqueId'), require('react/jsx-runtime'), require('lodash/each'), require('lodash/flatten'), require('lodash/has'), require('lodash/includes'), require('lodash/intersection'), require('lodash/isFunction'), require('lodash/isEqual'), require('lodash/isPlainObject'), require('lodash/isString'), require('lodash/isUndefined'), require('lodash/last'), require('lodash/noop'), require('lodash/omit'), require('markdown-to-jsx'), require('lodash/unset')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', '@rjsf/utils', 'lodash/cloneDeep', 'lodash/forEach', 'lodash/get', 'lodash/isEmpty', 'lodash/isNil', 'lodash/pick', 'lodash/set', 'lodash/toPath', 'lodash/isObject', 'lodash/uniqueId', 'react/jsx-runtime', 'lodash/each', 'lodash/flatten', 'lodash/has', 'lodash/includes', 'lodash/intersection', 'lodash/isFunction', 'lodash/isEqual', 'lodash/isPlainObject', 'lodash/isString', 'lodash/isUndefined', 'lodash/last', 'lodash/noop', 'lodash/omit', 'markdown-to-jsx', 'lodash/unset'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.JSONSchemaForm = {}, global.react, global.utils, global._cloneDeep, global._forEach, global.get2, global.isEmpty, global._isNil, global._pick, global.set, global._toPath, global.isObject, global.uniqueId, global.jsxRuntime, global.each, global.flatten, global.has, global.includes, global.intersection, global.isFunction, global.isEqual, global.isPlainObject, global.isString, global.isUndefined, global.last, global.noop, global.omit3, global.Markdown, global.unset));
})(this, (function (exports, react, utils, _cloneDeep, _forEach, get2, isEmpty, _isNil, _pick, set, _toPath, isObject, uniqueId, jsxRuntime, each, flatten, has, includes, intersection, isFunction, isEqual, isPlainObject, isString, isUndefined, last, noop, omit3, Markdown, unset) { 'use strict';

  // src/components/Form.tsx
  function generateRowId() {
    return uniqueId("rjsf-array-item-");
  }
  function generateKeyedFormData(formData) {
    return !Array.isArray(formData) ? [] : formData.map((item) => {
      return {
        key: generateRowId(),
        item
      };
    });
  }
  function keyedToPlainFormData(keyedFormData) {
    if (Array.isArray(keyedFormData)) {
      return keyedFormData.map((keyedItem) => keyedItem.item);
    }
    return [];
  }
  var ArrayField = class extends react.Component {
    /** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`
     *
     * @param props - The `FieldProps` for this template
     */
    constructor(props) {
      super(props);
      const { formData = [] } = props;
      const keyedFormData = generateKeyedFormData(formData);
      this.state = {
        keyedFormData,
        updatedKeyedFormData: false
      };
    }
    /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It
     * regenerates the keyed form data and returns it
     *
     * @param nextProps - The next set of props data
     * @param prevState - The previous set of state data
     */
    static getDerivedStateFromProps(nextProps, prevState) {
      if (prevState.updatedKeyedFormData) {
        return {
          updatedKeyedFormData: false
        };
      }
      const nextFormData = Array.isArray(nextProps.formData) ? nextProps.formData : [];
      const previousKeyedFormData = prevState.keyedFormData || [];
      const newKeyedFormData = nextFormData.length === previousKeyedFormData.length ? previousKeyedFormData.map((previousKeyedFormDatum, index) => {
        return {
          key: previousKeyedFormDatum.key,
          item: nextFormData[index]
        };
      }) : generateKeyedFormData(nextFormData);
      return {
        keyedFormData: newKeyedFormData
      };
    }
    /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to
     * the description from the schema.items, and finally the string "Item"
     */
    get itemTitle() {
      const { schema, registry } = this.props;
      const { translateString } = registry;
      return get2(
        schema,
        [utils.ITEMS_KEY, "title"],
        get2(schema, [utils.ITEMS_KEY, "description"], translateString(utils.TranslatableString.ArrayItemTitle))
      );
    }
    /** Determines whether the item described in the schema is always required, which is determined by whether any item
     * may be null.
     *
     * @param itemSchema - The schema for the item
     * @return - True if the item schema type does not contain the "null" type
     */
    isItemRequired(itemSchema) {
      if (Array.isArray(itemSchema.type)) {
        return !itemSchema.type.includes("null");
      }
      return itemSchema.type !== "null";
    }
    /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding
     * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the
     * `formData` matches that value, then false is returned, otherwise true is returned.
     *
     * @param formItems - The list of items in the form
     * @returns - True if the item is addable otherwise false
     */
    canAddItem(formItems) {
      const { schema, uiSchema, registry } = this.props;
      let { addable } = utils.getUiOptions(uiSchema, registry.globalUiOptions);
      if (addable !== false) {
        if (schema.maxItems !== void 0) {
          addable = formItems.length < schema.maxItems;
        } else {
          addable = true;
        }
      }
      return addable;
    }
    /** Returns the default form information for an item based on the schema for that item. Deals with the possibility
     * that the schema is fixed and allows additional items.
     */
    _getNewFormDataRow = () => {
      const { schema, registry } = this.props;
      const { schemaUtils } = registry;
      let itemSchema = schema.items;
      if (utils.isFixedItems(schema) && utils.allowAdditionalItems(schema)) {
        itemSchema = schema.additionalItems;
      }
      return schemaUtils.getDefaultFormState(itemSchema);
    };
    /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data
     * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into
     * the state, and then returning `onChange()` with the plain form data converted from the keyed data
     *
     * @param event - The event for the click
     * @param [index] - The optional index at which to add the new data
     */
    _handleAddClick(event, index) {
      if (event) {
        event.preventDefault();
      }
      const { onChange, errorSchema } = this.props;
      const { keyedFormData } = this.state;
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (index === void 0 || i < index) {
            set(newErrorSchema, [i], errorSchema[idx]);
          } else if (i >= index) {
            set(newErrorSchema, [i + 1], errorSchema[idx]);
          }
        }
      }
      const newKeyedFormDataRow = {
        key: generateRowId(),
        item: this._getNewFormDataRow()
      };
      const newKeyedFormData = [...keyedFormData];
      if (index !== void 0) {
        newKeyedFormData.splice(index, 0, newKeyedFormDataRow);
      } else {
        newKeyedFormData.push(newKeyedFormDataRow);
      }
      this.setState(
        {
          keyedFormData: newKeyedFormData,
          updatedKeyedFormData: true
        },
        // add click will pass the empty `path` array to the onChange which adds the appropriate path
        () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
      );
    }
    /** Callback handler for when the user clicks on the add button. Creates a new row of keyed form data at the end of
     * the list, adding it into the state, and then returning `onChange()` with the plain form data converted from the
     * keyed data
     *
     * @param event - The event for the click
     */
    onAddClick = (event) => {
      this._handleAddClick(event);
    };
    /** Callback handler for when the user clicks on the add button on an existing array element. Creates a new row of
     * keyed form data inserted at the `index`, adding it into the state, and then returning `onChange()` with the plain
     * form data converted from the keyed data
     *
     * @param index - The index at which the add button is clicked
     */
    onAddIndexClick = (index) => {
      return (event) => {
        this._handleAddClick(event, index);
      };
    };
    /** Callback handler for when the user clicks on the copy button on an existing array element. Clones the row of
     * keyed form data at the `index` into the next position in the state, and then returning `onChange()` with the plain
     * form data converted from the keyed data
     *
     * @param index - The index at which the copy button is clicked
     */
    onCopyIndexClick = (index) => {
      return (event) => {
        if (event) {
          event.preventDefault();
        }
        const { onChange, errorSchema } = this.props;
        const { keyedFormData } = this.state;
        let newErrorSchema;
        if (errorSchema) {
          newErrorSchema = {};
          for (const idx in errorSchema) {
            const i = parseInt(idx);
            if (i <= index) {
              set(newErrorSchema, [i], errorSchema[idx]);
            } else if (i > index) {
              set(newErrorSchema, [i + 1], errorSchema[idx]);
            }
          }
        }
        const newKeyedFormDataRow = {
          key: generateRowId(),
          item: _cloneDeep(keyedFormData[index].item)
        };
        const newKeyedFormData = [...keyedFormData];
        if (index !== void 0) {
          newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);
        } else {
          newKeyedFormData.push(newKeyedFormDataRow);
        }
        this.setState(
          {
            keyedFormData: newKeyedFormData,
            updatedKeyedFormData: true
          },
          // Copy index will pass the empty `path` array to the onChange which adds the appropriate path
          () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
        );
      };
    };
    /** Callback handler for when the user clicks on the remove button on an existing array element. Removes the row of
     * keyed form data at the `index` in the state, and then returning `onChange()` with the plain form data converted
     * from the keyed data
     *
     * @param index - The index at which the remove button is clicked
     */
    onDropIndexClick = (index) => {
      return (event) => {
        if (event) {
          event.preventDefault();
        }
        const { onChange, errorSchema } = this.props;
        const { keyedFormData } = this.state;
        let newErrorSchema;
        if (errorSchema) {
          newErrorSchema = {};
          for (const idx in errorSchema) {
            const i = parseInt(idx);
            if (i < index) {
              set(newErrorSchema, [i], errorSchema[idx]);
            } else if (i > index) {
              set(newErrorSchema, [i - 1], errorSchema[idx]);
            }
          }
        }
        const newKeyedFormData = keyedFormData.filter((_, i) => i !== index);
        this.setState(
          {
            keyedFormData: newKeyedFormData,
            updatedKeyedFormData: true
          },
          // drop index will pass the empty `path` array to the onChange which adds the appropriate path
          () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
        );
      };
    };
    /** Callback handler for when the user clicks on one of the move item buttons on an existing array element. Moves the
     * row of keyed form data at the `index` to the `newIndex` in the state, and then returning `onChange()` with the
     * plain form data converted from the keyed data
     *
     * @param index - The index of the item to move
     * @param newIndex - The index to where the item is to be moved
     */
    onReorderClick = (index, newIndex) => {
      return (event) => {
        if (event) {
          event.preventDefault();
          event.currentTarget.blur();
        }
        const { onChange, errorSchema } = this.props;
        let newErrorSchema;
        if (errorSchema) {
          newErrorSchema = {};
          for (const idx in errorSchema) {
            const i = parseInt(idx);
            if (i == index) {
              set(newErrorSchema, [newIndex], errorSchema[index]);
            } else if (i == newIndex) {
              set(newErrorSchema, [index], errorSchema[newIndex]);
            } else {
              set(newErrorSchema, [idx], errorSchema[i]);
            }
          }
        }
        const { keyedFormData } = this.state;
        function reOrderArray() {
          const _newKeyedFormData = keyedFormData.slice();
          _newKeyedFormData.splice(index, 1);
          _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);
          return _newKeyedFormData;
        }
        const newKeyedFormData = reOrderArray();
        this.setState(
          {
            keyedFormData: newKeyedFormData
          },
          // reorder click will pass the empty `path` array to the onChange which adds the appropriate path
          () => onChange(keyedToPlainFormData(newKeyedFormData), [], newErrorSchema)
        );
      };
    };
    /** Callback handler used to deal with changing the value of the data in the array at the `index`. Calls the
     * `onChange` callback with the updated form data
     *
     * @param index - The index of the item being changed
     */
    onChangeForIndex = (index) => {
      return (value, path, newErrorSchema, id) => {
        const { onChange } = this.props;
        const changePath = Array.isArray(path) ? path.slice() : [];
        changePath.unshift(index);
        onChange(
          // We need to treat undefined items as nulls to have validation.
          // See https://github.com/tdegrunt/jsonschema/issues/206
          value === void 0 ? null : value,
          changePath,
          newErrorSchema,
          id
        );
      };
    };
    /** Callback handler used to change the value for a checkbox */
    onSelectChange = (value) => {
      const { onChange, idSchema } = this.props;
      onChange(value, [], void 0, idSchema && idSchema.$id);
    };
    /** Helper method to compute item UI schema for both normal and fixed arrays
     * Handles both static object and dynamic function cases
     *
     * @param uiSchema - The parent UI schema containing items definition
     * @param item - The item data
     * @param index - The index of the item
     * @param formContext - The form context
     * @returns The computed UI schema for the item
     */
    computeItemUiSchema(uiSchema, item, index, formContext) {
      if (typeof uiSchema.items === "function") {
        try {
          const result = uiSchema.items(item, index, formContext);
          return result;
        } catch (e) {
          console.error(`Error executing dynamic uiSchema.items function for item at index ${index}:`, e);
          return void 0;
        }
      } else {
        return uiSchema.items;
      }
    }
    /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements
     */
    render() {
      const { schema, uiSchema, idSchema, registry } = this.props;
      const { schemaUtils, translateString } = registry;
      if (!(utils.ITEMS_KEY in schema)) {
        const uiOptions = utils.getUiOptions(uiSchema);
        const UnsupportedFieldTemplate = utils.getTemplate(
          "UnsupportedFieldTemplate",
          registry,
          uiOptions
        );
        return /* @__PURE__ */ jsxRuntime.jsx(
          UnsupportedFieldTemplate,
          {
            schema,
            idSchema,
            reason: translateString(utils.TranslatableString.MissingItems),
            registry
          }
        );
      }
      if (schemaUtils.isMultiSelect(schema)) {
        return this.renderMultiSelect();
      }
      if (utils.isCustomWidget(uiSchema)) {
        return this.renderCustomWidget();
      }
      if (utils.isFixedItems(schema)) {
        return this.renderFixedArray();
      }
      if (schemaUtils.isFilesArray(schema, uiSchema)) {
        return this.renderFiles();
      }
      return this.renderNormalArray();
    }
    /** Renders a normal array without any limitations of length
     */
    renderNormalArray() {
      const {
        schema,
        uiSchema = {},
        errorSchema,
        idSchema,
        name,
        title,
        disabled = false,
        readonly = false,
        autofocus = false,
        required = false,
        registry,
        onBlur,
        onFocus,
        idPrefix,
        idSeparator = "_",
        rawErrors
      } = this.props;
      const { keyedFormData } = this.state;
      const fieldTitle = schema.title || title || name;
      const { schemaUtils, formContext } = registry;
      const uiOptions = utils.getUiOptions(uiSchema);
      const _schemaItems = isObject(schema.items) ? schema.items : {};
      const itemsSchema = schemaUtils.retrieveSchema(_schemaItems);
      const formData = keyedToPlainFormData(this.state.keyedFormData);
      const canAdd = this.canAddItem(formData);
      const arrayProps = {
        canAdd,
        items: keyedFormData.map((keyedItem, index) => {
          const { key, item } = keyedItem;
          const itemCast = item;
          const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);
          const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
          const itemIdPrefix = idSchema.$id + idSeparator + index;
          const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);
          const itemUiSchema = this.computeItemUiSchema(uiSchema, item, index, formContext);
          return this.renderArrayFieldItem({
            key,
            index,
            name: name && `${name}-${index}`,
            title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
            canAdd,
            canMoveUp: index > 0,
            canMoveDown: index < formData.length - 1,
            itemSchema,
            itemIdSchema,
            itemErrorSchema,
            itemData: itemCast,
            itemUiSchema,
            autofocus: autofocus && index === 0,
            onBlur,
            onFocus,
            rawErrors,
            totalItems: keyedFormData.length
          });
        }),
        className: `rjsf-field rjsf-field-array rjsf-field-array-of-${itemsSchema.type}`,
        disabled,
        idSchema,
        uiSchema,
        onAddClick: this.onAddClick,
        readonly,
        required,
        schema,
        title: fieldTitle,
        formContext,
        formData,
        rawErrors,
        registry
      };
      const Template = utils.getTemplate("ArrayFieldTemplate", registry, uiOptions);
      return /* @__PURE__ */ jsxRuntime.jsx(Template, { ...arrayProps });
    }
    /** Renders an array using the custom widget provided by the user in the `uiSchema`
     */
    renderCustomWidget() {
      const {
        schema,
        idSchema,
        uiSchema,
        disabled = false,
        readonly = false,
        autofocus = false,
        required = false,
        hideError,
        placeholder,
        onBlur,
        onFocus,
        formData: items = [],
        registry,
        rawErrors,
        name
      } = this.props;
      const { widgets: widgets2, formContext, globalUiOptions, schemaUtils } = registry;
      const { widget, title: uiTitle, ...options } = utils.getUiOptions(uiSchema, globalUiOptions);
      const Widget = utils.getWidget(schema, widget, widgets2);
      const label = uiTitle ?? schema.title ?? name;
      const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
      return /* @__PURE__ */ jsxRuntime.jsx(
        Widget,
        {
          id: idSchema.$id,
          name,
          multiple: true,
          onChange: this.onSelectChange,
          onBlur,
          onFocus,
          options,
          schema,
          uiSchema,
          registry,
          value: items,
          disabled,
          readonly,
          hideError,
          required,
          label,
          hideLabel: !displayLabel,
          placeholder,
          formContext,
          autofocus,
          rawErrors
        }
      );
    }
    /** Renders an array as a set of checkboxes
     */
    renderMultiSelect() {
      const {
        schema,
        idSchema,
        uiSchema,
        formData: items = [],
        disabled = false,
        readonly = false,
        autofocus = false,
        required = false,
        placeholder,
        onBlur,
        onFocus,
        registry,
        rawErrors,
        name
      } = this.props;
      const { widgets: widgets2, schemaUtils, formContext, globalUiOptions } = registry;
      const itemsSchema = schemaUtils.retrieveSchema(schema.items, items);
      const enumOptions = utils.optionsList(itemsSchema, uiSchema);
      const { widget = "select", title: uiTitle, ...options } = utils.getUiOptions(uiSchema, globalUiOptions);
      const Widget = utils.getWidget(schema, widget, widgets2);
      const label = uiTitle ?? schema.title ?? name;
      const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
      return /* @__PURE__ */ jsxRuntime.jsx(
        Widget,
        {
          id: idSchema.$id,
          name,
          multiple: true,
          onChange: this.onSelectChange,
          onBlur,
          onFocus,
          options: { ...options, enumOptions },
          schema,
          uiSchema,
          registry,
          value: items,
          disabled,
          readonly,
          required,
          label,
          hideLabel: !displayLabel,
          placeholder,
          formContext,
          autofocus,
          rawErrors
        }
      );
    }
    /** Renders an array of files using the `FileWidget`
     */
    renderFiles() {
      const {
        schema,
        uiSchema,
        idSchema,
        name,
        disabled = false,
        readonly = false,
        autofocus = false,
        required = false,
        onBlur,
        onFocus,
        registry,
        formData: items = [],
        rawErrors
      } = this.props;
      const { widgets: widgets2, formContext, globalUiOptions, schemaUtils } = registry;
      const { widget = "files", title: uiTitle, ...options } = utils.getUiOptions(uiSchema, globalUiOptions);
      const Widget = utils.getWidget(schema, widget, widgets2);
      const label = uiTitle ?? schema.title ?? name;
      const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
      return /* @__PURE__ */ jsxRuntime.jsx(
        Widget,
        {
          options,
          id: idSchema.$id,
          name,
          multiple: true,
          onChange: this.onSelectChange,
          onBlur,
          onFocus,
          schema,
          uiSchema,
          value: items,
          disabled,
          readonly,
          required,
          registry,
          formContext,
          autofocus,
          rawErrors,
          label,
          hideLabel: !displayLabel
        }
      );
    }
    /** Renders an array that has a maximum limit of items
     */
    renderFixedArray() {
      const {
        schema,
        uiSchema = {},
        formData = [],
        errorSchema,
        idPrefix,
        idSeparator = "_",
        idSchema,
        name,
        title,
        disabled = false,
        readonly = false,
        autofocus = false,
        required = false,
        registry,
        onBlur,
        onFocus,
        rawErrors
      } = this.props;
      const { keyedFormData } = this.state;
      let { formData: items = [] } = this.props;
      const fieldTitle = schema.title || title || name;
      const uiOptions = utils.getUiOptions(uiSchema);
      const { schemaUtils, formContext } = registry;
      const _schemaItems = isObject(schema.items) ? schema.items : [];
      const itemSchemas = _schemaItems.map(
        (item, index) => schemaUtils.retrieveSchema(item, formData[index])
      );
      const additionalSchema = isObject(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, formData) : null;
      if (!items || items.length < itemSchemas.length) {
        items = items || [];
        items = items.concat(new Array(itemSchemas.length - items.length));
      }
      const canAdd = this.canAddItem(items) && !!additionalSchema;
      const arrayProps = {
        canAdd,
        className: "rjsf-field rjsf-field-array rjsf-field-array-fixed-items",
        disabled,
        idSchema,
        formData,
        items: keyedFormData.map((keyedItem, index) => {
          const { key, item } = keyedItem;
          const itemCast = item;
          const additional = index >= itemSchemas.length;
          const itemSchema = (additional && isObject(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, itemCast) : itemSchemas[index]) || {};
          const itemIdPrefix = idSchema.$id + idSeparator + index;
          const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);
          let itemUiSchema;
          if (additional) {
            itemUiSchema = uiSchema.additionalItems;
          } else {
            if (Array.isArray(uiSchema.items)) {
              itemUiSchema = uiSchema.items[index];
            } else {
              itemUiSchema = this.computeItemUiSchema(uiSchema, item, index, formContext);
            }
          }
          const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
          return this.renderArrayFieldItem({
            key,
            index,
            name: name && `${name}-${index}`,
            title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
            canAdd,
            canRemove: additional,
            canMoveUp: index >= itemSchemas.length + 1,
            canMoveDown: additional && index < items.length - 1,
            itemSchema,
            itemData: itemCast,
            itemUiSchema,
            itemIdSchema,
            itemErrorSchema,
            autofocus: autofocus && index === 0,
            onBlur,
            onFocus,
            rawErrors,
            totalItems: keyedFormData.length
          });
        }),
        onAddClick: this.onAddClick,
        readonly,
        required,
        registry,
        schema,
        uiSchema,
        title: fieldTitle,
        formContext,
        errorSchema,
        rawErrors
      };
      const Template = utils.getTemplate("ArrayFieldTemplate", registry, uiOptions);
      return /* @__PURE__ */ jsxRuntime.jsx(Template, { ...arrayProps });
    }
    /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send
     * back to the `ArrayFieldItemTemplate`.
     *
     * @param props - The props for the individual array item to be rendered
     */
    renderArrayFieldItem(props) {
      const {
        key,
        index,
        name,
        canAdd,
        canRemove = true,
        canMoveUp,
        canMoveDown,
        itemSchema,
        itemData,
        itemUiSchema,
        itemIdSchema,
        itemErrorSchema,
        autofocus,
        onBlur,
        onFocus,
        rawErrors,
        totalItems,
        title
      } = props;
      const { disabled, hideError, idPrefix, idSeparator, readonly, uiSchema, registry, formContext } = this.props;
      const {
        fields: { ArraySchemaField, SchemaField: SchemaField2 },
        globalUiOptions
      } = registry;
      const ItemSchemaField = ArraySchemaField || SchemaField2;
      const { orderable = true, removable = true, copyable = false } = utils.getUiOptions(uiSchema, globalUiOptions);
      const has4 = {
        moveUp: orderable && canMoveUp,
        moveDown: orderable && canMoveDown,
        copy: copyable && canAdd,
        remove: removable && canRemove,
        toolbar: false
      };
      has4.toolbar = Object.keys(has4).some((key2) => has4[key2]);
      return {
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ItemSchemaField,
          {
            name,
            title,
            index,
            schema: itemSchema,
            uiSchema: itemUiSchema,
            formData: itemData,
            formContext,
            errorSchema: itemErrorSchema,
            idPrefix,
            idSeparator,
            idSchema: itemIdSchema,
            required: this.isItemRequired(itemSchema),
            onChange: this.onChangeForIndex(index),
            onBlur,
            onFocus,
            registry,
            disabled,
            readonly,
            hideError,
            autofocus,
            rawErrors
          }
        ),
        buttonsProps: {
          idSchema: itemIdSchema,
          disabled,
          readonly,
          canAdd,
          hasCopy: has4.copy,
          hasMoveUp: has4.moveUp,
          hasMoveDown: has4.moveDown,
          hasRemove: has4.remove,
          index,
          totalItems,
          onAddIndexClick: this.onAddIndexClick,
          onCopyIndexClick: this.onCopyIndexClick,
          onDropIndexClick: this.onDropIndexClick,
          onReorderClick: this.onReorderClick,
          registry,
          schema: itemSchema,
          uiSchema: itemUiSchema
        },
        className: "rjsf-array-item",
        disabled,
        hasToolbar: has4.toolbar,
        index,
        totalItems,
        key,
        readonly,
        registry,
        schema: itemSchema,
        uiSchema: itemUiSchema
      };
    }
  };
  var ArrayField_default = ArrayField;
  function BooleanField(props) {
    const {
      schema,
      name,
      uiSchema,
      idSchema,
      formData,
      registry,
      required,
      disabled,
      readonly,
      hideError,
      autofocus,
      title,
      onChange,
      onFocus,
      onBlur,
      rawErrors
    } = props;
    const { title: schemaTitle } = schema;
    const { widgets: widgets2, formContext, translateString, globalUiOptions } = registry;
    const {
      widget = "checkbox",
      title: uiTitle,
      // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
      label: displayLabel = true,
      enumNames,
      ...options
    } = utils.getUiOptions(uiSchema, globalUiOptions);
    const Widget = utils.getWidget(schema, widget, widgets2);
    const yes = translateString(utils.TranslatableString.YesLabel);
    const no = translateString(utils.TranslatableString.NoLabel);
    let enumOptions;
    const label = uiTitle ?? schemaTitle ?? title ?? name;
    if (Array.isArray(schema.oneOf)) {
      enumOptions = utils.optionsList(
        {
          oneOf: schema.oneOf.map((option) => {
            if (isObject(option)) {
              return {
                ...option,
                title: option.title || (option.const === true ? yes : no)
              };
            }
            return void 0;
          }).filter((o) => o)
          // cast away the error that typescript can't grok is fixed
        },
        uiSchema
      );
    } else {
      const enums = schema.enum ?? [true, false];
      if (!enumNames && enums.length === 2 && enums.every((v) => typeof v === "boolean")) {
        enumOptions = [
          {
            value: enums[0],
            label: enums[0] ? yes : no
          },
          {
            value: enums[1],
            label: enums[1] ? yes : no
          }
        ];
      } else {
        enumOptions = utils.optionsList({ enum: enums }, uiSchema);
      }
    }
    const onWidgetChange = react.useCallback(
      (value, errorSchema, id) => {
        return onChange(value, [], errorSchema, id);
      },
      [onChange]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      Widget,
      {
        options: { ...options, enumOptions },
        schema,
        uiSchema,
        id: idSchema.$id,
        name,
        onChange: onWidgetChange,
        onFocus,
        onBlur,
        label,
        hideLabel: !displayLabel,
        value: formData,
        required,
        disabled,
        readonly,
        hideError,
        registry,
        formContext,
        autofocus,
        rawErrors
      }
    );
  }
  var BooleanField_default = BooleanField;
  var LOOKUP_REGEX = /^\$lookup=(.+)/;
  var LAYOUT_GRID_UI_OPTION = "layoutGrid";
  function getNonNullishValue(value, fallback) {
    return value ?? fallback;
  }
  function isNumericIndex(str) {
    return /^\d+?$/.test(str);
  }
  var LayoutGridField = class _LayoutGridField extends react.PureComponent {
    static defaultProps = {
      layoutGridSchema: void 0
    };
    static TEST_IDS = utils.getTestIds();
    /** Computes the uiSchema for the field with `name` from the `uiProps` and `uiSchema` provided. The field UI Schema
     * will always contain a copy of the global options from the `uiSchema` (so they can be passed down) as well as
     * copying them into the local ui options. When the `forceReadonly` flag is true, then the field UI Schema is
     * updated to make "readonly" be true. When the `schemaReadonly` flag is true AND the field UI Schema does NOT have
     * the flag already provided, then we also make "readonly" true. We always make sure to return the final value of the
     * field UI Schema's "readonly" flag as `uiReadonly` along with the `fieldUiSchema` in the return value.
     *
     * @param field - The name of the field to pull the existing UI Schema for
     * @param uiProps - Any props that should be put into the field's uiSchema
     * @param [uiSchema] - The optional UI Schema from which to get the UI schema for the field
     * @param [schemaReadonly] - Optional flag indicating whether the schema indicates the field is readonly
     * @param [forceReadonly] - Optional flag indicating whether the Form itself is in readonly mode
     */
    static computeFieldUiSchema(field, uiProps, uiSchema, schemaReadonly, forceReadonly) {
      const globalUiOptions = get2(uiSchema, [utils.UI_GLOBAL_OPTIONS_KEY], {});
      const localUiSchema = get2(uiSchema, field);
      const localUiOptions = { ...get2(localUiSchema, [utils.UI_OPTIONS_KEY], {}), ...uiProps, ...globalUiOptions };
      const fieldUiSchema = { ...localUiSchema };
      if (!isEmpty(localUiOptions)) {
        set(fieldUiSchema, [utils.UI_OPTIONS_KEY], localUiOptions);
      }
      if (!isEmpty(globalUiOptions)) {
        set(fieldUiSchema, [utils.UI_GLOBAL_OPTIONS_KEY], globalUiOptions);
      }
      let { readonly: uiReadonly } = utils.getUiOptions(fieldUiSchema);
      if (forceReadonly === true || isUndefined(uiReadonly) && schemaReadonly === true) {
        uiReadonly = true;
        if (has(localUiOptions, utils.READONLY_KEY)) {
          set(fieldUiSchema, [utils.UI_OPTIONS_KEY, utils.READONLY_KEY], true);
        } else {
          set(fieldUiSchema, `ui:${utils.READONLY_KEY}`, true);
        }
      }
      return { fieldUiSchema, uiReadonly };
    }
    /** Given an `operator`, `datum` and `value` determines whether this condition is considered matching. Matching
     * depends on the `operator`. The `datum` and `value` are converted into arrays if they aren't already and then the
     * contents of the two arrays are compared using the `operator`. When `operator` is All, then the two arrays must be
     * equal to match. When `operator` is SOME then the intersection of the two arrays must have at least one value in
     * common to match. When `operator` is NONE then the intersection of the two arrays must not have any values in common
     * to match.
     *
     * @param [operator] - The optional operator for the condition
     * @param [datum] - The optional datum for the condition, this can be an item or a list of items of type unknown
     * @param [value='$0m3tH1nG Un3xP3cT3d'] The optional value for the condition, defaulting to a highly unlikely value
     *        to avoid comparing two undefined elements when `value` was forgotten in the condition definition.
     *        This can be an item or a list of items of type unknown
     * @returns - True if the condition matches, false otherwise
     */
    static conditionMatches(operator, datum, value = "$0m3tH1nG Un3xP3cT3d") {
      const data = flatten([datum]).sort();
      const values = flatten([value]).sort();
      switch (operator) {
        case "all" /* ALL */:
          return isEqual(data, values);
        case "some" /* SOME */:
          return intersection(data, values).length > 0;
        case "none" /* NONE */:
          return intersection(data, values).length === 0;
        default:
          return false;
      }
    }
    /** From within the `layoutGridSchema` finds the `children` and any extra `gridProps` from the object keyed by
     * `schemaKey`. If the `children` contains extra `gridProps` and those props contain a `className` string, try to
     * lookup whether that `className` has a replacement value in the `registry` using the `FORM_CONTEXT_LOOKUP_BASE`.
     * When the `className` value contains multiple classNames separated by a space, the lookup will look for a
     * replacement value for each `className` and combine them into one.
     *
     * @param layoutGridSchema - The GridSchemaType instance from which to obtain the `schemaKey` children and extra props
     * @param schemaKey - A `GridType` value, used to get the children and extra props from within the `layoutGridSchema`
     * @param registry - The `@rjsf` Registry from which to look up `classNames` if they are present in the extra props
     * @returns - An object containing the list of `LayoutGridSchemaType` `children` and any extra `gridProps`
     * @throws - A `TypeError` when the `children` is not an array
     */
    static findChildrenAndProps(layoutGridSchema, schemaKey, registry) {
      let gridProps = {};
      let children = layoutGridSchema[schemaKey];
      if (isPlainObject(children)) {
        const { children: elements, className: toMapClassNames, ...otherProps } = children;
        children = elements;
        if (toMapClassNames) {
          const classes = toMapClassNames.split(" ");
          const className = classes.map((ele) => utils.lookupFromFormContext(registry, ele, ele)).join(" ");
          gridProps = { ...otherProps, className };
        } else {
          gridProps = otherProps;
        }
      }
      if (!Array.isArray(children)) {
        throw new TypeError(`Expected array for "${schemaKey}" in ${JSON.stringify(layoutGridSchema)}`);
      }
      return { children, gridProps };
    }
    /** Generates an idSchema for the `schema` using `@rjsf`'s `toIdSchema` util, passing the `baseIdSchema`'s `$id` value
     * as the id prefix.
     *
     * @param schemaUtils - The `SchemaUtilsType` used to call `toIdSchema`
     * @param schema - The schema to generate the idSchema for
     * @param baseIdSchema - The IdSchema for the base
     * @param formData - The formData to pass the `toIdSchema`
     * @param [idSeparator] - The param to pass into the `toIdSchema` util which will use it to join the `idSchema` paths
     * @returns - The generated `idSchema` for the `schema`
     */
    static getIdSchema(schemaUtils, baseIdSchema, formData, schema = {}, idSeparator) {
      const baseId = get2(baseIdSchema, utils.ID_KEY);
      return schemaUtils.toIdSchema(schema, baseId, formData, baseId, idSeparator);
    }
    /** Computes the `rawSchema` and `idSchema` for a `schema` and a `potentialIndex`. If the `schema` is of type array,
     * has an `ITEMS_KEY` element and `potentialIndex` represents a numeric value, the element at `ITEMS_KEY` is checked
     * to see if it is an array. If it is AND the `potentialIndex`th element is available, it is used as the `rawSchema`,
     * otherwise the last value of the element is used. If it is not, then the element is used as the `rawSchema`. In
     * either case, an `idSchema` is computed for the array index. If the `schema` does not represent an array or the
     * `potentialIndex` is not a numeric value, then `rawSchema` is returned as undefined and given `idSchema` is returned
     * as is.
     *
     * @param schema - The schema to generate the idSchema for
     * @param idSchema - The IdSchema for the schema
     * @param potentialIndex - A string containing a potential index
     * @param [idSeparator] - The param to pass into the `toIdSchema` util which will use it to join the `idSchema` paths
     * @returns - An object containing the `rawSchema` and `idSchema` of an array item, otherwise an undefined `rawSchema`
     */
    static computeArraySchemasIfPresent(schema, idSchema, potentialIndex, idSeparator) {
      let rawSchema;
      if (isNumericIndex(potentialIndex) && schema && schema?.type === "array" && has(schema, utils.ITEMS_KEY)) {
        const index = Number(potentialIndex);
        const items = schema[utils.ITEMS_KEY];
        if (Array.isArray(items)) {
          if (index > items.length) {
            rawSchema = last(items);
          } else {
            rawSchema = items[index];
          }
        } else {
          rawSchema = items;
        }
        idSchema = { [utils.ID_KEY]: `${idSchema[utils.ID_KEY]}${idSeparator ?? "_"}${index}` };
      }
      return { rawSchema, idSchema };
    }
    /** Given a `dottedPath` to a field in the `initialSchema`, iterate through each individual path in the schema until
     * the leaf path is found and returned (along with whether that leaf path `isRequired`) OR no schema exists for an
     * element in the path. If the leaf schema element happens to be a oneOf/anyOf then also return the oneOf/anyOf as
     * `options`.
     *
     * @param schemaUtils - The `SchemaUtilsType` used to call `retrieveSchema`
     * @param dottedPath - The dotted-path to the field for which to get the schema
     * @param initialSchema - The initial schema to start the search from
     * @param formData - The formData, useful for resolving a oneOf/anyOf selection in the path hierarchy
     * @param initialIdSchema - The initial idSchema to start the search from
     * @param [idSeparator] - The param to pass into the `toIdSchema` util which will use it to join the `idSchema` paths
     * @returns - An object containing the destination schema, isRequired and isReadonly flags for the field and options
     *            info if a oneOf/anyOf
     */
    static getSchemaDetailsForField(schemaUtils, dottedPath, initialSchema, formData, initialIdSchema, idSeparator) {
      let rawSchema = initialSchema;
      let idSchema = initialIdSchema;
      const parts = dottedPath.split(".");
      const leafPath = parts.pop();
      let schema = schemaUtils.retrieveSchema(rawSchema, formData);
      let innerData = formData;
      let isReadonly = schema.readOnly;
      parts.forEach((part) => {
        if (has(schema, utils.PROPERTIES_KEY)) {
          rawSchema = get2(schema, [utils.PROPERTIES_KEY, part], {});
          idSchema = get2(idSchema, part, {});
        } else if (schema && (has(schema, utils.ONE_OF_KEY) || has(schema, utils.ANY_OF_KEY))) {
          const xxx = has(schema, utils.ONE_OF_KEY) ? utils.ONE_OF_KEY : utils.ANY_OF_KEY;
          const selectedSchema = schemaUtils.findSelectedOptionInXxxOf(schema, part, xxx, innerData);
          const selectedIdSchema = _LayoutGridField.getIdSchema(
            schemaUtils,
            idSchema,
            formData,
            selectedSchema,
            idSeparator
          );
          rawSchema = get2(selectedSchema, [utils.PROPERTIES_KEY, part], {});
          idSchema = get2(selectedIdSchema, part, {});
        } else {
          const result = _LayoutGridField.computeArraySchemasIfPresent(schema, idSchema, part, idSeparator);
          rawSchema = result.rawSchema ?? {};
          idSchema = result.idSchema;
        }
        innerData = get2(innerData, part, {});
        schema = schemaUtils.retrieveSchema(rawSchema, innerData);
        isReadonly = getNonNullishValue(schema.readOnly, isReadonly);
      });
      let optionsInfo;
      let isRequired = false;
      if (isEmpty(schema)) {
        schema = void 0;
      }
      if (schema && leafPath) {
        if (schema && (has(schema, utils.ONE_OF_KEY) || has(schema, utils.ANY_OF_KEY))) {
          const xxx = has(schema, utils.ONE_OF_KEY) ? utils.ONE_OF_KEY : utils.ANY_OF_KEY;
          schema = schemaUtils.findSelectedOptionInXxxOf(schema, leafPath, xxx, innerData);
          const rawIdSchema = _LayoutGridField.getIdSchema(schemaUtils, idSchema, formData, schema, idSeparator);
          idSchema = utils.mergeObjects(rawIdSchema, idSchema);
        }
        isRequired = schema !== void 0 && Array.isArray(schema.required) && includes(schema.required, leafPath);
        const result = _LayoutGridField.computeArraySchemasIfPresent(schema, idSchema, leafPath, idSeparator);
        if (result.rawSchema) {
          schema = result.rawSchema;
          idSchema = result.idSchema;
        } else {
          schema = get2(schema, [utils.PROPERTIES_KEY, leafPath]);
          schema = schema ? schemaUtils.retrieveSchema(schema) : schema;
          idSchema = get2(idSchema, leafPath, {});
        }
        isReadonly = getNonNullishValue(schema?.readOnly, isReadonly);
        if (schema && (has(schema, utils.ONE_OF_KEY) || has(schema, utils.ANY_OF_KEY))) {
          const xxx = has(schema, utils.ONE_OF_KEY) ? utils.ONE_OF_KEY : utils.ANY_OF_KEY;
          const discriminator = utils.getDiscriminatorFieldFromSchema(schema);
          optionsInfo = { options: schema[xxx], hasDiscriminator: !!discriminator };
        }
      }
      return { schema, isRequired, isReadonly, optionsInfo, idSchema };
    }
    /** Gets the custom render component from the `render`, by either determining that it is either already a function or
     * it is a non-function value that can be used to look up the function in the registry. If no function can be found,
     * null is returned.
     *
     * @param render - The potential render function or lookup name to one
     * @param registry - The `@rjsf` Registry from which to look up `classNames` if they are present in the extra props
     * @returns - Either a render function if available, or null if not
     */
    static getCustomRenderComponent(render, registry) {
      let customRenderer = render;
      if (isString(customRenderer)) {
        customRenderer = utils.lookupFromFormContext(registry, customRenderer);
      }
      if (isFunction(customRenderer)) {
        return customRenderer;
      }
      return null;
    }
    /** Extract the `name`, and optional `render` and all other props from the `gridSchema`. We look up the `render` to
     * see if can be resolved to a UIComponent. If `name` does not exist and there is an optional `render` UIComponent, we
     * set the `rendered` component with only specified props for that component in the object.
     *
     * @param registry - The `@rjsf` Registry from which to look up `classNames` if they are present in the extra props
     * @param gridSchema - The string or object that represents the configuration for the grid field
     * @returns - The UIComponentPropsType computed from the gridSchema
     */
    static computeUIComponentPropsFromGridSchema(registry, gridSchema) {
      let name;
      let UIComponent = null;
      let uiProps = {};
      let rendered;
      if (isString(gridSchema) || isUndefined(gridSchema)) {
        name = gridSchema ?? "";
      } else {
        const { name: innerName = "", render, ...innerProps } = gridSchema;
        name = innerName;
        uiProps = innerProps;
        if (!isEmpty(uiProps)) {
          each(uiProps, (prop, key) => {
            if (isString(prop)) {
              const match = LOOKUP_REGEX.exec(prop);
              if (Array.isArray(match) && match.length > 1) {
                const name2 = match[1];
                uiProps[key] = utils.lookupFromFormContext(registry, name2, name2);
              }
            }
          });
        }
        UIComponent = _LayoutGridField.getCustomRenderComponent(render, registry);
        if (!innerName && UIComponent) {
          rendered = /* @__PURE__ */ jsxRuntime.jsx(UIComponent, { ...innerProps, "data-testid": _LayoutGridField.TEST_IDS.uiComponent });
        }
      }
      return { name, UIComponent, uiProps, rendered };
    }
    /** Constructs an `LayoutGridField` with the given `props`
     *
     * @param props - The `LayoutGridField` for this template
     */
    constructor(props) {
      super(props);
    }
    /** Generates an `onChange` handler for the field associated with the `dottedPath`. This handler will clone and update
     * the `formData` with the new `value` and the `errorSchema` if an `errSchema` is provided. After updating those two
     * elements, they will then be passed on to the `onChange` handler of the `LayoutFieldGrid`.
     *
     * @param dottedPath - The dotted-path to the field for which to generate the onChange handler
     * @returns - The `onChange` handling function for the `dottedPath` field
     */
    onFieldChange = (dottedPath) => {
      return (value, path, errSchema, id) => {
        const { onChange, errorSchema } = this.props;
        let newErrorSchema = errorSchema;
        if (errSchema && errorSchema) {
          newErrorSchema = _cloneDeep(errorSchema);
          set(newErrorSchema, dottedPath, errSchema);
        }
        onChange(value, dottedPath.split("."), newErrorSchema, id);
      };
    };
    /** Renders the `children` of the `GridType.CONDITION` if it passes. The `layoutGridSchema` for the
     * `GridType.CONDITION` is separated into the `children` and other `gridProps`. The `gridProps` are used to extract
     * the `operator`, `field` and `value` of the condition. If the condition matches, then all of the `children` are
     * rendered, otherwise null is returned.
     *
     * @param layoutGridSchema - The string or object that represents the configuration for the grid field
     * @returns - The rendered the children for the `GridType.CONDITION` or null
     */
    renderCondition(layoutGridSchema) {
      const { formData, registry } = this.props;
      const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
        layoutGridSchema,
        "ui:condition" /* CONDITION */,
        registry
      );
      const { operator, field = "", value } = gridProps;
      const fieldData = get2(formData, field, null);
      if (_LayoutGridField.conditionMatches(operator, fieldData, value)) {
        return this.renderChildren(children);
      }
      return null;
    }
    /** Renders a material-ui `GridTemplate` as an item. The `layoutGridSchema` for the `GridType.COLUMN` is separated
     * into the `children` and other `gridProps`. The `gridProps` will be spread onto the outer `GridTemplate`. Inside
     * the `GridTemplate` all the `children` are rendered.
     *
     * @param layoutGridSchema - The string or object that represents the configuration for the grid field
     * @returns - The rendered `GridTemplate` containing the children for the `GridType.COLUMN`
     */
    renderCol(layoutGridSchema) {
      const { registry, uiSchema } = this.props;
      const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
        layoutGridSchema,
        "ui:col" /* COLUMN */,
        registry
      );
      const uiOptions = utils.getUiOptions(uiSchema);
      const GridTemplate2 = utils.getTemplate("GridTemplate", registry, uiOptions);
      return /* @__PURE__ */ jsxRuntime.jsx(GridTemplate2, { column: true, "data-testid": _LayoutGridField.TEST_IDS.col, ...gridProps, children: this.renderChildren(children) });
    }
    /** Renders a material-ui `GridTemplate` as an item. The `layoutGridSchema` for the `GridType.COLUMNS` is separated
     * into the `children` and other `gridProps`. The `children` is iterated on and `gridProps` will be spread onto the
     * outer `GridTemplate`. Each child will have their own rendered `GridTemplate`.
     *
     * @param layoutGridSchema - The string or object that represents the configuration for the grid field
     * @returns - The rendered `GridTemplate` containing the children for the `GridType.COLUMNS`
     */
    renderColumns(layoutGridSchema) {
      const { registry, uiSchema } = this.props;
      const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
        layoutGridSchema,
        "ui:columns" /* COLUMNS */,
        registry
      );
      const uiOptions = utils.getUiOptions(uiSchema);
      const GridTemplate2 = utils.getTemplate("GridTemplate", registry, uiOptions);
      return children.map((child) => /* @__PURE__ */ jsxRuntime.jsx(
        GridTemplate2,
        {
          column: true,
          "data-testid": _LayoutGridField.TEST_IDS.col,
          ...gridProps,
          children: this.renderChildren([child])
        },
        `column-${utils.hashObject(child)}`
      ));
    }
    /** Renders a material-ui `GridTemplate` as a container. The
     * `layoutGridSchema` for the `GridType.ROW` is separated into the `children` and other `gridProps`. The `gridProps`
     * will be spread onto the outer `GridTemplate`. Inside of the `GridTemplate` all of the `children` are rendered.
     *
     * @param layoutGridSchema - The string or object that represents the configuration for the grid field
     * @returns - The rendered `GridTemplate` containing the children for the `GridType.ROW`
     */
    renderRow(layoutGridSchema) {
      const { registry, uiSchema } = this.props;
      const { children, gridProps } = _LayoutGridField.findChildrenAndProps(
        layoutGridSchema,
        "ui:row" /* ROW */,
        registry
      );
      const uiOptions = utils.getUiOptions(uiSchema);
      const GridTemplate2 = utils.getTemplate("GridTemplate", registry, uiOptions);
      return /* @__PURE__ */ jsxRuntime.jsx(GridTemplate2, { ...gridProps, "data-testid": _LayoutGridField.TEST_IDS.row, children: this.renderChildren(children) });
    }
    /** Iterates through all the `childrenLayoutGridSchema`, rendering a nested `LayoutGridField` for each item in the
     * list, passing all the props for the current `LayoutGridField` along, updating the `schema` by calling
     * `retrieveSchema()` on it to resolve any `$ref`s. In addition to the updated `schema`, each item in
     * `childrenLayoutGridSchema` is passed as `layoutGridSchema`.
     *
     * @param childrenLayoutGridSchema - The list of strings or objects that represents the configurations for the
     *          children fields
     * @returns - The nested `LayoutGridField`s
     */
    renderChildren(childrenLayoutGridSchema) {
      const { registry, schema: rawSchema, formData } = this.props;
      const { schemaUtils } = registry;
      const schema = schemaUtils.retrieveSchema(rawSchema, formData);
      return childrenLayoutGridSchema.map((layoutGridSchema) => /* @__PURE__ */ react.createElement(
        _LayoutGridField,
        {
          ...this.props,
          key: `layoutGrid-${utils.hashObject(layoutGridSchema)}`,
          schema,
          layoutGridSchema
        }
      ));
    }
    /** Renders the field described by `gridSchema`. If `gridSchema` is not an object, then is will be assumed
     * to be the dotted-path to the field in the schema. Otherwise, we extract the `name`, and optional `render` and all
     * other props. If `name` does not exist and there is an optional `render`, we return the `render` component with only
     * specified props for that component. If `name` exists, we take the name, the initial & root schemas and the formData
     * and get the destination schema, is required state and optional oneOf/anyOf options for it. If the destination
     * schema was located along with oneOf/anyOf options then a `LayoutMultiSchemaField` will be rendered with the
     * `uiSchema`, `errorSchema`, `idSchema` and `formData` drilled down to the dotted-path field, spreading any other
     * props from `gridSchema` into the `ui:options`. If the destination schema located without any oneOf/anyOf options,
     * then a `SchemaField` will be rendered with the same props as mentioned in the previous sentence. If no destination
     * schema was located, but a custom render component was found, then it will be rendered with many of the non-event
     * handling props. If none of the previous render paths are valid, then a null is returned.
     *
     * @param gridSchema - The string or object that represents the configuration for the grid field
     * @returns - One of `LayoutMultiSchemaField`, `SchemaField`, a custom render component or null, depending
     */
    renderField(gridSchema) {
      const {
        schema: initialSchema,
        uiSchema,
        errorSchema,
        idSchema,
        onBlur,
        onFocus,
        formData,
        readonly,
        registry,
        idSeparator,
        layoutGridSchema,
        // Used to pull this out of otherProps since we don't want to pass it through
        ...otherProps
      } = this.props;
      const { fields: fields2, schemaUtils } = registry;
      const { SchemaField: SchemaField2, LayoutMultiSchemaField: LayoutMultiSchemaField2 } = fields2;
      const uiComponentProps = _LayoutGridField.computeUIComponentPropsFromGridSchema(registry, gridSchema);
      if (uiComponentProps.rendered) {
        return uiComponentProps.rendered;
      }
      const { name, UIComponent, uiProps } = uiComponentProps;
      const {
        schema,
        isRequired,
        isReadonly,
        optionsInfo,
        idSchema: fieldIdSchema
      } = _LayoutGridField.getSchemaDetailsForField(
        schemaUtils,
        name,
        initialSchema,
        formData,
        idSchema,
        idSeparator
      );
      if (schema) {
        const Field = optionsInfo?.hasDiscriminator ? LayoutMultiSchemaField2 : SchemaField2;
        const { fieldUiSchema, uiReadonly } = _LayoutGridField.computeFieldUiSchema(
          name,
          uiProps,
          uiSchema,
          isReadonly,
          readonly
        );
        return /* @__PURE__ */ jsxRuntime.jsx(
          Field,
          {
            "data-testid": optionsInfo?.hasDiscriminator ? _LayoutGridField.TEST_IDS.layoutMultiSchemaField : _LayoutGridField.TEST_IDS.field,
            ...otherProps,
            name,
            required: isRequired,
            readonly: uiReadonly,
            schema,
            uiSchema: fieldUiSchema,
            errorSchema: get2(errorSchema, name),
            idSchema: fieldIdSchema,
            idSeparator,
            formData: get2(formData, name),
            onChange: this.onFieldChange(name),
            onBlur,
            onFocus,
            options: optionsInfo?.options,
            registry
          }
        );
      }
      if (UIComponent) {
        return /* @__PURE__ */ jsxRuntime.jsx(
          UIComponent,
          {
            "data-testid": _LayoutGridField.TEST_IDS.uiComponent,
            ...otherProps,
            name,
            required: isRequired,
            formData,
            readOnly: !!isReadonly || readonly,
            errorSchema,
            uiSchema,
            schema: initialSchema,
            idSchema,
            idSeparator,
            onBlur,
            onFocus,
            registry,
            ...uiProps
          }
        );
      }
      return null;
    }
    /** Renders the `LayoutGridField`. If there isn't a `layoutGridSchema` prop defined, then try pulling it out of the
     * `uiSchema` via `ui:LayoutGridField`. If `layoutGridSchema` is an object, then check to see if any of the properties
     * match one of the `GridType`s. If so, call the appropriate render function for the type. Otherwise, just call the
     * generic `renderField()` function with the `layoutGridSchema`.
     *
     * @returns - the rendered `LayoutGridField`
     */
    render() {
      const { uiSchema } = this.props;
      let { layoutGridSchema } = this.props;
      const uiOptions = utils.getUiOptions(uiSchema);
      if (!layoutGridSchema && LAYOUT_GRID_UI_OPTION in uiOptions && isObject(uiOptions[LAYOUT_GRID_UI_OPTION])) {
        layoutGridSchema = uiOptions[LAYOUT_GRID_UI_OPTION];
      }
      if (isObject(layoutGridSchema)) {
        if ("ui:row" /* ROW */ in layoutGridSchema) {
          return this.renderRow(layoutGridSchema);
        }
        if ("ui:col" /* COLUMN */ in layoutGridSchema) {
          return this.renderCol(layoutGridSchema);
        }
        if ("ui:columns" /* COLUMNS */ in layoutGridSchema) {
          return this.renderColumns(layoutGridSchema);
        }
        if ("ui:condition" /* CONDITION */ in layoutGridSchema) {
          return this.renderCondition(layoutGridSchema);
        }
      }
      return this.renderField(layoutGridSchema);
    }
  };
  function LayoutHeaderField(props) {
    const { idSchema, title, schema, uiSchema, required, registry, name } = props;
    const options = utils.getUiOptions(uiSchema, registry.globalUiOptions);
    const { title: uiTitle } = options;
    const { title: schemaTitle } = schema;
    const fieldTitle = uiTitle || title || schemaTitle || name;
    if (!fieldTitle) {
      return null;
    }
    const TitleFieldTemplate = utils.getTemplate(
      "TitleFieldTemplate",
      registry,
      options
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      TitleFieldTemplate,
      {
        id: utils.titleId(idSchema),
        title: fieldTitle,
        required,
        schema,
        uiSchema,
        registry
      }
    );
  }
  function getSelectedOption(options, selectorField, value) {
    const defaultValue = "!@#!@$@#$!@$#";
    const schemaOptions = options.map(({ schema }) => schema);
    return schemaOptions.find((option) => {
      const selector = get2(option, [utils.PROPERTIES_KEY, selectorField]);
      const result = get2(selector, utils.DEFAULT_KEY, get2(selector, utils.CONST_KEY, defaultValue));
      return result === value;
    });
  }
  function computeEnumOptions(schema, options, schemaUtils, uiSchema, formData) {
    const realOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
    let tempSchema = schema;
    if (has(schema, utils.ONE_OF_KEY)) {
      tempSchema = { ...schema, [utils.ONE_OF_KEY]: realOptions };
    } else if (has(schema, utils.ANY_OF_KEY)) {
      tempSchema = { ...schema, [utils.ANY_OF_KEY]: realOptions };
    }
    const enumOptions = utils.optionsList(tempSchema, uiSchema);
    if (!enumOptions) {
      throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(tempSchema)}`);
    }
    return enumOptions;
  }
  function LayoutMultiSchemaField(props) {
    const {
      name,
      baseType,
      disabled = false,
      formData,
      idSchema,
      onBlur,
      onChange,
      options,
      onFocus,
      registry,
      uiSchema,
      schema,
      formContext,
      autofocus,
      readonly,
      required,
      errorSchema,
      hideError = false
    } = props;
    const { widgets: widgets2, schemaUtils, globalUiOptions } = registry;
    const [enumOptions, setEnumOptions] = react.useState(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
    const id = get2(idSchema, utils.ID_KEY);
    const discriminator = utils.getDiscriminatorFieldFromSchema(schema);
    const FieldErrorTemplate2 = utils.getTemplate("FieldErrorTemplate", registry, options);
    const FieldTemplate2 = utils.getTemplate("FieldTemplate", registry, options);
    const schemaHash = utils.hashObject(schema);
    const optionsHash = utils.hashObject(options);
    const uiSchemaHash = uiSchema ? utils.hashObject(uiSchema) : "";
    const formDataHash = formData ? utils.hashObject(formData) : "";
    react.useEffect(() => {
      setEnumOptions(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
    }, [schemaHash, optionsHash, schemaUtils, uiSchemaHash, formDataHash]);
    const {
      widget = discriminator ? "radio" : "select",
      title = "",
      placeholder = "",
      optionsSchemaSelector: selectorField = discriminator,
      hideError: uiSchemaHideError,
      ...uiOptions
    } = utils.getUiOptions(uiSchema);
    if (!selectorField) {
      throw new Error("No selector field provided for the LayoutMultiSchemaField");
    }
    const selectedOption = get2(formData, selectorField);
    let optionSchema = get2(enumOptions[0]?.schema, [utils.PROPERTIES_KEY, selectorField], {});
    const option = getSelectedOption(enumOptions, selectorField, selectedOption);
    optionSchema = optionSchema?.type ? optionSchema : { ...optionSchema, type: option?.type || baseType };
    const Widget = utils.getWidget(optionSchema, widget, widgets2);
    const hideFieldError = uiSchemaHideError === void 0 ? hideError : Boolean(uiSchemaHideError);
    const rawErrors = get2(errorSchema, [utils.ERRORS_KEY], []);
    const fieldErrorSchema = omit3(errorSchema, [utils.ERRORS_KEY]);
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const onOptionChange = (opt) => {
      const newOption = getSelectedOption(enumOptions, selectorField, opt);
      const oldOption = getSelectedOption(enumOptions, selectorField, selectedOption);
      let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
      if (newFormData && newOption) {
        newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
      }
      if (newFormData) {
        set(newFormData, selectorField, opt);
      }
      onChange(newFormData, [name], void 0, id);
    };
    const widgetOptions = { enumOptions, ...uiOptions };
    const errors = !hideFieldError && rawErrors.length > 0 ? /* @__PURE__ */ jsxRuntime.jsx(FieldErrorTemplate2, { idSchema, schema, errors: rawErrors, registry }) : void 0;
    const ignored = (value) => noop;
    return /* @__PURE__ */ jsxRuntime.jsx(
      FieldTemplate2,
      {
        id,
        schema,
        label: (title || schema.title) ?? "",
        disabled: disabled || Array.isArray(enumOptions) && isEmpty(enumOptions),
        uiSchema,
        formContext,
        required,
        readonly: !!readonly,
        registry,
        displayLabel,
        errors,
        onChange,
        onDropPropertyClick: ignored,
        onKeyChange: ignored,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          Widget,
          {
            id,
            name,
            schema,
            label: (title || schema.title) ?? "",
            disabled: disabled || Array.isArray(enumOptions) && isEmpty(enumOptions),
            uiSchema,
            formContext,
            autofocus,
            readonly,
            required,
            registry,
            multiple: false,
            rawErrors,
            hideError: hideFieldError,
            hideLabel: !displayLabel,
            errorSchema: fieldErrorSchema,
            placeholder,
            onChange: onOptionChange,
            onBlur,
            onFocus,
            value: selectedOption,
            options: widgetOptions
          }
        )
      }
    );
  }
  var AnyOfField = class extends react.Component {
    /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
     *
     * @param props - The `FieldProps` for this template
     */
    constructor(props) {
      super(props);
      const {
        formData,
        options,
        registry: { schemaUtils }
      } = this.props;
      const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
      this.state = {
        retrievedOptions,
        selectedOption: this.getMatchingOption(0, formData, retrievedOptions)
      };
    }
    /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
     * currently selected option based on the overall `formData`
     *
     * @param prevProps - The previous `FieldProps` for this template
     * @param prevState - The previous `AnyOfFieldState` for this template
     */
    componentDidUpdate(prevProps, prevState) {
      const { formData, options, idSchema } = this.props;
      const { selectedOption } = this.state;
      let newState = this.state;
      if (!utils.deepEquals(prevProps.options, options)) {
        const {
          registry: { schemaUtils }
        } = this.props;
        const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
        newState = { selectedOption, retrievedOptions };
      }
      if (!utils.deepEquals(formData, prevProps.formData) && idSchema.$id === prevProps.idSchema.$id) {
        const { retrievedOptions } = newState;
        const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);
        if (prevState && matchingOption !== selectedOption) {
          newState = { selectedOption: matchingOption, retrievedOptions };
        }
      }
      if (newState !== this.state) {
        this.setState(newState);
      }
    }
    /** Determines the best matching option for the given `formData` and `options`.
     *
     * @param formData - The new formData
     * @param options - The list of options to choose from
     * @return - The index of the `option` that best matches the `formData`
     */
    getMatchingOption(selectedOption, formData, options) {
      const {
        schema,
        registry: { schemaUtils }
      } = this.props;
      const discriminator = utils.getDiscriminatorFieldFromSchema(schema);
      const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);
      return option;
    }
    /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
     * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
     * the `onChange` handler.
     *
     * @param option - The new option value being selected
     */
    onOptionChange = (option) => {
      const { selectedOption, retrievedOptions } = this.state;
      const { formData, onChange, registry } = this.props;
      const { schemaUtils } = registry;
      const intOption = option !== void 0 ? parseInt(option, 10) : -1;
      if (intOption === selectedOption) {
        return;
      }
      const newOption = intOption >= 0 ? retrievedOptions[intOption] : void 0;
      const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : void 0;
      let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
      if (newOption) {
        newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
      }
      this.setState({ selectedOption: intOption }, () => {
        onChange(newFormData, [], void 0, this.getFieldId());
      });
    };
    getFieldId() {
      const { idSchema, schema } = this.props;
      return `${idSchema.$id}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`;
    }
    /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
     */
    render() {
      const {
        name,
        disabled = false,
        errorSchema = {},
        formContext,
        onBlur,
        onFocus,
        readonly,
        registry,
        schema,
        uiSchema
      } = this.props;
      const { widgets: widgets2, fields: fields2, translateString, globalUiOptions, schemaUtils } = registry;
      const { SchemaField: _SchemaField } = fields2;
      const MultiSchemaFieldTemplate2 = utils.getTemplate(
        "MultiSchemaFieldTemplate",
        registry,
        globalUiOptions
      );
      const { selectedOption, retrievedOptions } = this.state;
      const {
        widget = "select",
        placeholder,
        autofocus,
        autocomplete,
        title = schema.title,
        ...uiOptions
      } = utils.getUiOptions(uiSchema, globalUiOptions);
      const Widget = utils.getWidget({ type: "number" }, widget, widgets2);
      const rawErrors = get2(errorSchema, utils.ERRORS_KEY, []);
      const fieldErrorSchema = omit3(errorSchema, [utils.ERRORS_KEY]);
      const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
      const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;
      let optionSchema;
      if (option) {
        const { required } = schema;
        optionSchema = required ? utils.mergeSchemas({ required }, option) : option;
      }
      let optionsUiSchema = [];
      if (utils.ONE_OF_KEY in schema && uiSchema && utils.ONE_OF_KEY in uiSchema) {
        if (Array.isArray(uiSchema[utils.ONE_OF_KEY])) {
          optionsUiSchema = uiSchema[utils.ONE_OF_KEY];
        } else {
          console.warn(`uiSchema.oneOf is not an array for "${title || name}"`);
        }
      } else if (utils.ANY_OF_KEY in schema && uiSchema && utils.ANY_OF_KEY in uiSchema) {
        if (Array.isArray(uiSchema[utils.ANY_OF_KEY])) {
          optionsUiSchema = uiSchema[utils.ANY_OF_KEY];
        } else {
          console.warn(`uiSchema.anyOf is not an array for "${title || name}"`);
        }
      }
      let optionUiSchema = uiSchema;
      if (selectedOption >= 0 && optionsUiSchema.length > selectedOption) {
        optionUiSchema = optionsUiSchema[selectedOption];
      }
      const translateEnum = title ? utils.TranslatableString.TitleOptionPrefix : utils.TranslatableString.OptionPrefix;
      const translateParams = title ? [title] : [];
      const enumOptions = retrievedOptions.map((opt, index) => {
        const { title: uiTitle = opt.title } = utils.getUiOptions(optionsUiSchema[index]);
        return {
          label: uiTitle || translateString(translateEnum, translateParams.concat(String(index + 1))),
          value: index
        };
      });
      const selector = /* @__PURE__ */ jsxRuntime.jsx(
        Widget,
        {
          id: this.getFieldId(),
          name: `${name}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`,
          schema: { type: "number", default: 0 },
          onChange: this.onOptionChange,
          onBlur,
          onFocus,
          disabled: disabled || isEmpty(enumOptions),
          multiple: false,
          rawErrors,
          errorSchema: fieldErrorSchema,
          value: selectedOption >= 0 ? selectedOption : void 0,
          options: { enumOptions, ...uiOptions },
          registry,
          formContext,
          placeholder,
          autocomplete,
          autofocus,
          label: title ?? name,
          hideLabel: !displayLabel,
          readonly
        }
      );
      const optionsSchemaField = optionSchema && optionSchema.type !== "null" && /* @__PURE__ */ jsxRuntime.jsx(_SchemaField, { ...this.props, schema: optionSchema, uiSchema: optionUiSchema }) || null;
      return /* @__PURE__ */ jsxRuntime.jsx(
        MultiSchemaFieldTemplate2,
        {
          schema,
          registry,
          uiSchema,
          selector,
          optionSchemaField: optionsSchemaField
        }
      );
    }
  };
  var MultiSchemaField_default = AnyOfField;
  var trailingCharMatcherWithPrefix = /\.([0-9]*0)*$/;
  var trailingCharMatcher = /[0.]0*$/;
  function NumberField(props) {
    const { registry, onChange, formData, value: initialValue } = props;
    const [lastValue, setLastValue] = react.useState(initialValue);
    const { StringField: StringField2 } = registry.fields;
    let value = formData;
    const handleChange = react.useCallback(
      (value2, path, errorSchema, id) => {
        setLastValue(value2);
        if (`${value2}`.charAt(0) === ".") {
          value2 = `0${value2}`;
        }
        const processed = typeof value2 === "string" && value2.match(trailingCharMatcherWithPrefix) ? utils.asNumber(value2.replace(trailingCharMatcher, "")) : utils.asNumber(value2);
        onChange(processed, path, errorSchema, id);
      },
      [onChange]
    );
    if (typeof lastValue === "string" && typeof value === "number") {
      const re = new RegExp(`^(${String(value).replace(".", "\\.")})?\\.?0*$`);
      if (lastValue.match(re)) {
        value = lastValue;
      }
    }
    return /* @__PURE__ */ jsxRuntime.jsx(StringField2, { ...props, formData: value, onChange: handleChange });
  }
  var NumberField_default = NumberField;
  var ObjectField = class extends react.Component {
    /** Set up the initial state */
    state = {
      wasPropertyKeyModified: false,
      additionalProperties: {}
    };
    /** Returns a flag indicating whether the `name` field is required in the object schema
     *
     * @param name - The name of the field to check for required-ness
     * @returns - True if the field `name` is required, false otherwise
     */
    isRequired(name) {
      const { schema } = this.props;
      return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;
    }
    /** Returns the `onPropertyChange` handler for the `name` field. Handles the special case where a user is attempting
     * to clear the data for a field added as an additional property. Calls the `onChange()` handler with the updated
     * formData.
     *
     * @param name - The name of the property
     * @param addedByAdditionalProperties - Flag indicating whether this property is an additional property
     * @returns - The onPropertyChange callback for the `name` property
     */
    onPropertyChange = (name, addedByAdditionalProperties = false) => {
      return (value, path, newErrorSchema, id) => {
        const { onChange } = this.props;
        if (value === void 0 && addedByAdditionalProperties) {
          value = "";
        }
        const changePath = Array.isArray(path) ? path.slice() : [];
        changePath.unshift(name);
        onChange(value, changePath, newErrorSchema, id);
      };
    };
    /** Returns a callback to handle the onDropPropertyClick event for the given `key` which removes the old `key` data
     * and calls the `onChange` callback with it
     *
     * @param key - The key for which the drop callback is desired
     * @returns - The drop property click callback
     */
    onDropPropertyClick = (key) => {
      return (event) => {
        event.preventDefault();
        const { onChange, formData, name } = this.props;
        const copiedFormData = { ...formData };
        unset(copiedFormData, key);
        onChange(copiedFormData, [name]);
      };
    };
    /** Computes the next available key name from the `preferredKey`, indexing through the already existing keys until one
     * that is already not assigned is found.
     *
     * @param preferredKey - The preferred name of a new key
     * @param [formData] - The form data in which to check if the desired key already exists
     * @returns - The name of the next available key from `preferredKey`
     */
    getAvailableKey = (preferredKey, formData) => {
      const { uiSchema, registry } = this.props;
      const { duplicateKeySuffixSeparator = "-" } = utils.getUiOptions(uiSchema, registry.globalUiOptions);
      let index = 0;
      let newKey = preferredKey;
      while (has(formData, newKey)) {
        newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;
      }
      return newKey;
    };
    /** Returns a callback function that deals with the rename of a key for an additional property for a schema. That
     * callback will attempt to rename the key and move the existing data to that key, calling `onChange` when it does.
     *
     * @param oldValue - The old value of a field
     * @returns - The key change callback function
     */
    onKeyChange = (oldValue) => {
      return (value) => {
        if (oldValue === value) {
          return;
        }
        const { formData, onChange } = this.props;
        value = this.getAvailableKey(value, formData);
        const newFormData = {
          ...formData
        };
        const newKeys = { [oldValue]: value };
        const keyValues = Object.keys(newFormData).map((key) => {
          const newKey = newKeys[key] || key;
          return { [newKey]: newFormData[key] };
        });
        const renamedObj = Object.assign({}, ...keyValues);
        this.setState({ wasPropertyKeyModified: true });
        onChange(renamedObj, []);
      };
    };
    /** Returns a default value to be used for a new additional schema property of the given `type`
     *
     * @param type - The type of the new additional schema property
     */
    getDefaultValue(type) {
      const {
        registry: { translateString }
      } = this.props;
      switch (type) {
        case "array":
          return [];
        case "boolean":
          return false;
        case "null":
          return null;
        case "number":
          return 0;
        case "object":
          return {};
        case "string":
        default:
          return translateString(utils.TranslatableString.NewStringDefault);
      }
    }
    /** Handles the adding of a new additional property on the given `schema`. Calls the `onChange` callback once the new
     * default data for that field has been added to the formData.
     *
     * @param schema - The schema element to which the new property is being added
     */
    handleAddClick = (schema) => () => {
      if (!(schema.additionalProperties || schema.patternProperties)) {
        return;
      }
      const { formData, name, onChange, registry } = this.props;
      const newFormData = { ...formData };
      const newKey = this.getAvailableKey("newKey", newFormData);
      if (schema.patternProperties) {
        set(newFormData, newKey, null);
      } else {
        let type = void 0;
        let constValue = void 0;
        let defaultValue = void 0;
        if (isObject(schema.additionalProperties)) {
          type = schema.additionalProperties.type;
          constValue = schema.additionalProperties.const;
          defaultValue = schema.additionalProperties.default;
          let apSchema = schema.additionalProperties;
          if (utils.REF_KEY in apSchema) {
            const { schemaUtils } = registry;
            apSchema = schemaUtils.retrieveSchema({ $ref: apSchema[utils.REF_KEY] }, formData);
            type = apSchema.type;
            constValue = apSchema.const;
            defaultValue = apSchema.default;
          }
          if (!type && (utils.ANY_OF_KEY in apSchema || utils.ONE_OF_KEY in apSchema)) {
            type = "object";
          }
        }
        const newValue = constValue ?? defaultValue ?? this.getDefaultValue(type);
        set(newFormData, newKey, newValue);
      }
      onChange(newFormData, [name]);
    };
    /** Renders the `ObjectField` from the given props
     */
    render() {
      const {
        schema: rawSchema,
        uiSchema = {},
        formData,
        errorSchema,
        idSchema,
        name,
        required = false,
        disabled,
        readonly,
        hideError,
        idPrefix,
        idSeparator,
        onBlur,
        onFocus,
        registry,
        title
      } = this.props;
      const { fields: fields2, formContext, schemaUtils, translateString, globalUiOptions } = registry;
      const { SchemaField: SchemaField2 } = fields2;
      const schema = schemaUtils.retrieveSchema(rawSchema, formData);
      const uiOptions = utils.getUiOptions(uiSchema, globalUiOptions);
      const { properties: schemaProperties = {} } = schema;
      const templateTitle = uiOptions.title ?? schema.title ?? title ?? name;
      const description = uiOptions.description ?? schema.description;
      let orderedProperties;
      try {
        const properties = Object.keys(schemaProperties);
        orderedProperties = utils.orderProperties(properties, uiOptions.order);
      } catch (err) {
        return /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntime.jsx("p", { className: "rjsf-config-error", style: { color: "red" }, children: /* @__PURE__ */ jsxRuntime.jsx(Markdown, { options: { disableParsingRawHTML: true }, children: translateString(utils.TranslatableString.InvalidObjectField, [name || "root", err.message]) }) }),
          /* @__PURE__ */ jsxRuntime.jsx("pre", { children: JSON.stringify(schema) })
        ] });
      }
      const Template = utils.getTemplate("ObjectFieldTemplate", registry, uiOptions);
      const templateProps = {
        // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
        title: uiOptions.label === false ? "" : templateTitle,
        description: uiOptions.label === false ? void 0 : description,
        properties: orderedProperties.map((name2) => {
          const addedByAdditionalProperties = has(schema, [utils.PROPERTIES_KEY, name2, utils.ADDITIONAL_PROPERTY_FLAG]);
          const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name2];
          const hidden = utils.getUiOptions(fieldUiSchema).widget === "hidden";
          const fieldIdSchema = get2(idSchema, [name2], {});
          return {
            content: /* @__PURE__ */ jsxRuntime.jsx(
              SchemaField2,
              {
                name: name2,
                required: this.isRequired(name2),
                schema: get2(schema, [utils.PROPERTIES_KEY, name2], {}),
                uiSchema: fieldUiSchema,
                errorSchema: get2(errorSchema, name2),
                idSchema: fieldIdSchema,
                idPrefix,
                idSeparator,
                formData: get2(formData, name2),
                formContext,
                wasPropertyKeyModified: this.state.wasPropertyKeyModified,
                onKeyChange: this.onKeyChange(name2),
                onChange: this.onPropertyChange(name2, addedByAdditionalProperties),
                onBlur,
                onFocus,
                registry,
                disabled,
                readonly,
                hideError,
                onDropPropertyClick: this.onDropPropertyClick
              },
              name2
            ),
            name: name2,
            readonly,
            disabled,
            required,
            hidden
          };
        }),
        readonly,
        disabled,
        required,
        idSchema,
        uiSchema,
        errorSchema,
        schema,
        formData,
        formContext,
        registry
      };
      return /* @__PURE__ */ jsxRuntime.jsx(Template, { ...templateProps, onAddClick: this.handleAddClick });
    }
  };
  var ObjectField_default = ObjectField;
  var COMPONENT_TYPES = {
    array: "ArrayField",
    boolean: "BooleanField",
    integer: "NumberField",
    number: "NumberField",
    object: "ObjectField",
    string: "StringField",
    null: "NullField"
  };
  function getFieldComponent(schema, uiOptions, idSchema, registry) {
    const field = uiOptions.field;
    const { fields: fields2, translateString } = registry;
    if (typeof field === "function") {
      return field;
    }
    if (typeof field === "string" && field in fields2) {
      return fields2[field];
    }
    const schemaType = utils.getSchemaType(schema);
    const type = Array.isArray(schemaType) ? schemaType[0] : schemaType || "";
    const schemaId = schema.$id;
    let componentName = COMPONENT_TYPES[type];
    if (schemaId && schemaId in fields2) {
      componentName = schemaId;
    }
    if (!componentName && (schema.anyOf || schema.oneOf)) {
      return () => null;
    }
    return componentName in fields2 ? fields2[componentName] : () => {
      const UnsupportedFieldTemplate = utils.getTemplate(
        "UnsupportedFieldTemplate",
        registry,
        uiOptions
      );
      return /* @__PURE__ */ jsxRuntime.jsx(
        UnsupportedFieldTemplate,
        {
          schema,
          idSchema,
          reason: translateString(utils.TranslatableString.UnknownFieldType, [String(schema.type)]),
          registry
        }
      );
    };
  }
  function SchemaFieldRender(props) {
    const {
      schema: _schema,
      idSchema: _idSchema,
      uiSchema,
      formData,
      errorSchema,
      idPrefix,
      idSeparator,
      name,
      onChange,
      onKeyChange,
      onDropPropertyClick,
      required,
      registry,
      wasPropertyKeyModified = false
    } = props;
    const { formContext, schemaUtils, globalUiOptions } = registry;
    const uiOptions = utils.getUiOptions(uiSchema, globalUiOptions);
    const FieldTemplate2 = utils.getTemplate("FieldTemplate", registry, uiOptions);
    const DescriptionFieldTemplate = utils.getTemplate(
      "DescriptionFieldTemplate",
      registry,
      uiOptions
    );
    const FieldHelpTemplate2 = utils.getTemplate("FieldHelpTemplate", registry, uiOptions);
    const FieldErrorTemplate2 = utils.getTemplate("FieldErrorTemplate", registry, uiOptions);
    const schema = schemaUtils.retrieveSchema(_schema, formData);
    const fieldId = _idSchema[utils.ID_KEY];
    const idSchema = utils.mergeObjects(
      schemaUtils.toIdSchema(schema, fieldId, formData, idPrefix, idSeparator),
      _idSchema
    );
    const handleFieldComponentChange = react.useCallback(
      (formData2, path, newErrorSchema, id2) => {
        const theId = id2 || fieldId;
        return onChange(formData2, path, newErrorSchema, theId);
      },
      [fieldId, onChange]
    );
    const FieldComponent = getFieldComponent(schema, uiOptions, idSchema, registry);
    const disabled = Boolean(uiOptions.disabled ?? props.disabled);
    const readonly = Boolean(uiOptions.readonly ?? (props.readonly || props.schema.readOnly || schema.readOnly));
    const uiSchemaHideError = uiOptions.hideError;
    const hideError = uiSchemaHideError === void 0 ? props.hideError : Boolean(uiSchemaHideError);
    const autofocus = Boolean(uiOptions.autofocus ?? props.autofocus);
    if (Object.keys(schema).length === 0) {
      return null;
    }
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const { __errors, ...fieldErrorSchema } = errorSchema || {};
    const fieldUiSchema = omit3(uiSchema, ["ui:classNames", "classNames", "ui:style"]);
    if (utils.UI_OPTIONS_KEY in fieldUiSchema) {
      fieldUiSchema[utils.UI_OPTIONS_KEY] = omit3(fieldUiSchema[utils.UI_OPTIONS_KEY], ["classNames", "style"]);
    }
    const field = /* @__PURE__ */ jsxRuntime.jsx(
      FieldComponent,
      {
        ...props,
        onChange: handleFieldComponentChange,
        idSchema,
        schema,
        uiSchema: fieldUiSchema,
        disabled,
        readonly,
        hideError,
        autofocus,
        errorSchema: fieldErrorSchema,
        formContext,
        rawErrors: __errors
      }
    );
    const id = idSchema[utils.ID_KEY];
    let label;
    if (wasPropertyKeyModified) {
      label = name;
    } else {
      label = utils.ADDITIONAL_PROPERTY_FLAG in schema ? name : uiOptions.title || props.schema.title || schema.title || props.title || name;
    }
    const description = uiOptions.description || props.schema.description || schema.description || "";
    const help = uiOptions.help;
    const hidden = uiOptions.widget === "hidden";
    const classNames = ["rjsf-field", `rjsf-field-${utils.getSchemaType(schema)}`];
    if (!hideError && __errors && __errors.length > 0) {
      classNames.push("rjsf-field-error");
    }
    if (uiOptions.classNames) {
      classNames.push(uiOptions.classNames);
    }
    const helpComponent = /* @__PURE__ */ jsxRuntime.jsx(
      FieldHelpTemplate2,
      {
        help,
        idSchema,
        schema,
        uiSchema,
        hasErrors: !hideError && __errors && __errors.length > 0,
        registry
      }
    );
    const errorsComponent = hideError || (schema.anyOf || schema.oneOf) && !schemaUtils.isSelect(schema) ? void 0 : /* @__PURE__ */ jsxRuntime.jsx(
      FieldErrorTemplate2,
      {
        errors: __errors,
        errorSchema,
        idSchema,
        schema,
        uiSchema,
        registry
      }
    );
    const fieldProps = {
      description: /* @__PURE__ */ jsxRuntime.jsx(
        DescriptionFieldTemplate,
        {
          id: utils.descriptionId(id),
          description,
          schema,
          uiSchema,
          registry
        }
      ),
      rawDescription: description,
      help: helpComponent,
      rawHelp: typeof help === "string" ? help : void 0,
      errors: errorsComponent,
      rawErrors: hideError ? void 0 : __errors,
      id,
      label,
      hidden,
      onChange,
      onKeyChange,
      onDropPropertyClick,
      required,
      disabled,
      readonly,
      hideError,
      displayLabel,
      classNames: classNames.join(" ").trim(),
      style: uiOptions.style,
      formContext,
      formData,
      schema,
      uiSchema,
      registry
    };
    const _AnyOfField = registry.fields.AnyOfField;
    const _OneOfField = registry.fields.OneOfField;
    const isReplacingAnyOrOneOf = uiSchema?.["ui:field"] && uiSchema?.["ui:fieldReplacesAnyOrOneOf"] === true;
    return /* @__PURE__ */ jsxRuntime.jsx(FieldTemplate2, { ...fieldProps, children: /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      field,
      schema.anyOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && /* @__PURE__ */ jsxRuntime.jsx(
        _AnyOfField,
        {
          name,
          disabled,
          readonly,
          hideError,
          errorSchema,
          formData,
          formContext,
          idPrefix,
          idSchema,
          idSeparator,
          onBlur: props.onBlur,
          onChange: props.onChange,
          onFocus: props.onFocus,
          options: schema.anyOf.map(
            (_schema2) => schemaUtils.retrieveSchema(isObject(_schema2) ? _schema2 : {}, formData)
          ),
          registry,
          required,
          schema,
          uiSchema
        }
      ),
      schema.oneOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && /* @__PURE__ */ jsxRuntime.jsx(
        _OneOfField,
        {
          name,
          disabled,
          readonly,
          hideError,
          errorSchema,
          formData,
          formContext,
          idPrefix,
          idSchema,
          idSeparator,
          onBlur: props.onBlur,
          onChange: props.onChange,
          onFocus: props.onFocus,
          options: schema.oneOf.map(
            (_schema2) => schemaUtils.retrieveSchema(isObject(_schema2) ? _schema2 : {}, formData)
          ),
          registry,
          required,
          schema,
          uiSchema
        }
      )
    ] }) });
  }
  var SchemaField = class extends react.Component {
    shouldComponentUpdate(nextProps) {
      const { experimental_componentUpdateStrategy = "customDeep" } = this.props.registry;
      return utils.shouldRender(this, nextProps, this.state, experimental_componentUpdateStrategy);
    }
    render() {
      return /* @__PURE__ */ jsxRuntime.jsx(SchemaFieldRender, { ...this.props });
    }
  };
  var SchemaField_default = SchemaField;
  function StringField(props) {
    const {
      schema,
      name,
      uiSchema,
      idSchema,
      formData,
      required,
      disabled = false,
      readonly = false,
      autofocus = false,
      onChange,
      onBlur,
      onFocus,
      registry,
      rawErrors,
      hideError
    } = props;
    const { title, format } = schema;
    const { widgets: widgets2, formContext, schemaUtils, globalUiOptions } = registry;
    const enumOptions = schemaUtils.isSelect(schema) ? utils.optionsList(schema, uiSchema) : void 0;
    let defaultWidget = enumOptions ? "select" : "text";
    if (format && utils.hasWidget(schema, format, widgets2)) {
      defaultWidget = format;
    }
    const { widget = defaultWidget, placeholder = "", title: uiTitle, ...options } = utils.getUiOptions(uiSchema);
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const label = uiTitle ?? title ?? name;
    const Widget = utils.getWidget(schema, widget, widgets2);
    const onWidgetChange = react.useCallback(
      (value, errorSchema, id) => {
        return onChange(value, [], errorSchema, id);
      },
      [onChange]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      Widget,
      {
        options: { ...options, enumOptions },
        schema,
        uiSchema,
        id: idSchema.$id,
        name,
        label,
        hideLabel: !displayLabel,
        hideError,
        value: formData,
        onChange: onWidgetChange,
        onBlur,
        onFocus,
        required,
        disabled,
        readonly,
        formContext,
        autofocus,
        registry,
        placeholder,
        rawErrors
      }
    );
  }
  var StringField_default = StringField;
  function NullField(props) {
    const { name, formData, onChange } = props;
    react.useEffect(() => {
      if (formData === void 0) {
        onChange(null, [name]);
      }
    }, [name, formData, onChange]);
    return null;
  }
  var NullField_default = NullField;

  // src/components/fields/index.ts
  function fields() {
    return {
      AnyOfField: MultiSchemaField_default,
      ArrayField: ArrayField_default,
      // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
      BooleanField: BooleanField_default,
      LayoutGridField,
      LayoutHeaderField,
      LayoutMultiSchemaField,
      NumberField: NumberField_default,
      ObjectField: ObjectField_default,
      OneOfField: MultiSchemaField_default,
      SchemaField: SchemaField_default,
      StringField: StringField_default,
      NullField: NullField_default
    };
  }
  var fields_default = fields;
  function ArrayFieldDescriptionTemplate(props) {
    const { idSchema, description, registry, schema, uiSchema } = props;
    const options = utils.getUiOptions(uiSchema, registry.globalUiOptions);
    const { label: displayLabel = true } = options;
    if (!description || !displayLabel) {
      return null;
    }
    const DescriptionFieldTemplate = utils.getTemplate(
      "DescriptionFieldTemplate",
      registry,
      options
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      DescriptionFieldTemplate,
      {
        id: utils.descriptionId(idSchema),
        description,
        schema,
        uiSchema,
        registry
      }
    );
  }
  function ArrayFieldItemTemplate(props) {
    const { children, className, buttonsProps, hasToolbar, registry, uiSchema } = props;
    const uiOptions = utils.getUiOptions(uiSchema);
    const ArrayFieldItemButtonsTemplate2 = utils.getTemplate(
      "ArrayFieldItemButtonsTemplate",
      registry,
      uiOptions
    );
    const btnStyle = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold"
    };
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { className, children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: hasToolbar ? "col-xs-9" : "col-xs-12", children }),
      hasToolbar && /* @__PURE__ */ jsxRuntime.jsx("div", { className: "col-xs-3 array-item-toolbox", children: /* @__PURE__ */ jsxRuntime.jsx(
        "div",
        {
          className: "btn-group",
          style: {
            display: "flex",
            justifyContent: "space-around"
          },
          children: /* @__PURE__ */ jsxRuntime.jsx(ArrayFieldItemButtonsTemplate2, { ...buttonsProps, style: btnStyle })
        }
      ) })
    ] });
  }
  function ArrayFieldItemButtonsTemplate(props) {
    const {
      disabled,
      hasCopy,
      hasMoveDown,
      hasMoveUp,
      hasRemove,
      idSchema,
      index,
      onCopyIndexClick,
      onDropIndexClick,
      onReorderClick,
      readonly,
      registry,
      uiSchema
    } = props;
    const { CopyButton: CopyButton2, MoveDownButton: MoveDownButton2, MoveUpButton: MoveUpButton2, RemoveButton: RemoveButton2 } = registry.templates.ButtonTemplates;
    const onCopyClick = react.useMemo(() => onCopyIndexClick(index), [index, onCopyIndexClick]);
    const onRemoveClick = react.useMemo(() => onDropIndexClick(index), [index, onDropIndexClick]);
    const onArrowUpClick = react.useMemo(() => onReorderClick(index, index - 1), [index, onReorderClick]);
    const onArrowDownClick = react.useMemo(() => onReorderClick(index, index + 1), [index, onReorderClick]);
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      (hasMoveUp || hasMoveDown) && /* @__PURE__ */ jsxRuntime.jsx(
        MoveUpButton2,
        {
          id: utils.buttonId(idSchema, "moveUp"),
          className: "rjsf-array-item-move-up",
          disabled: disabled || readonly || !hasMoveUp,
          onClick: onArrowUpClick,
          uiSchema,
          registry
        }
      ),
      (hasMoveUp || hasMoveDown) && /* @__PURE__ */ jsxRuntime.jsx(
        MoveDownButton2,
        {
          id: utils.buttonId(idSchema, "moveDown"),
          className: "rjsf-array-item-move-down",
          disabled: disabled || readonly || !hasMoveDown,
          onClick: onArrowDownClick,
          uiSchema,
          registry
        }
      ),
      hasCopy && /* @__PURE__ */ jsxRuntime.jsx(
        CopyButton2,
        {
          id: utils.buttonId(idSchema, "copy"),
          className: "rjsf-array-item-copy",
          disabled: disabled || readonly,
          onClick: onCopyClick,
          uiSchema,
          registry
        }
      ),
      hasRemove && /* @__PURE__ */ jsxRuntime.jsx(
        RemoveButton2,
        {
          id: utils.buttonId(idSchema, "remove"),
          className: "rjsf-array-item-remove",
          disabled: disabled || readonly,
          onClick: onRemoveClick,
          uiSchema,
          registry
        }
      )
    ] });
  }
  function ArrayFieldTemplate(props) {
    const {
      canAdd,
      className,
      disabled,
      idSchema,
      uiSchema,
      items,
      onAddClick,
      readonly,
      registry,
      required,
      schema,
      title
    } = props;
    const uiOptions = utils.getUiOptions(uiSchema);
    const ArrayFieldDescriptionTemplate2 = utils.getTemplate(
      "ArrayFieldDescriptionTemplate",
      registry,
      uiOptions
    );
    const ArrayFieldItemTemplate2 = utils.getTemplate(
      "ArrayFieldItemTemplate",
      registry,
      uiOptions
    );
    const ArrayFieldTitleTemplate2 = utils.getTemplate(
      "ArrayFieldTitleTemplate",
      registry,
      uiOptions
    );
    const {
      ButtonTemplates: { AddButton: AddButton2 }
    } = registry.templates;
    return /* @__PURE__ */ jsxRuntime.jsxs("fieldset", { className, id: idSchema.$id, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ArrayFieldTitleTemplate2,
        {
          idSchema,
          title: uiOptions.title || title,
          required,
          schema,
          uiSchema,
          registry
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ArrayFieldDescriptionTemplate2,
        {
          idSchema,
          description: uiOptions.description || schema.description,
          schema,
          uiSchema,
          registry
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: "row array-item-list", children: items && items.map(({ key, ...itemProps }) => /* @__PURE__ */ jsxRuntime.jsx(ArrayFieldItemTemplate2, { ...itemProps }, key)) }),
      canAdd && /* @__PURE__ */ jsxRuntime.jsx(
        AddButton2,
        {
          id: utils.buttonId(idSchema, "add"),
          className: "rjsf-array-item-add",
          onClick: onAddClick,
          disabled: disabled || readonly,
          uiSchema,
          registry
        }
      )
    ] });
  }
  function ArrayFieldTitleTemplate(props) {
    const { idSchema, title, schema, uiSchema, required, registry } = props;
    const options = utils.getUiOptions(uiSchema, registry.globalUiOptions);
    const { label: displayLabel = true } = options;
    if (!title || !displayLabel) {
      return null;
    }
    const TitleFieldTemplate = utils.getTemplate(
      "TitleFieldTemplate",
      registry,
      options
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      TitleFieldTemplate,
      {
        id: utils.titleId(idSchema),
        title,
        required,
        schema,
        uiSchema,
        registry
      }
    );
  }
  function BaseInputTemplate(props) {
    const {
      id,
      name,
      // remove this from ...rest
      value,
      readonly,
      disabled,
      autofocus,
      onBlur,
      onFocus,
      onChange,
      onChangeOverride,
      options,
      schema,
      uiSchema,
      formContext,
      registry,
      rawErrors,
      type,
      hideLabel,
      // remove this from ...rest
      hideError,
      // remove this from ...rest
      ...rest
    } = props;
    if (!id) {
      console.log("No id for", props);
      throw new Error(`no id for props ${JSON.stringify(props)}`);
    }
    const inputProps = {
      ...rest,
      ...utils.getInputProps(schema, type, options)
    };
    let inputValue;
    if (inputProps.type === "number" || inputProps.type === "integer") {
      inputValue = value || value === 0 ? value : "";
    } else {
      inputValue = value == null ? "" : value;
    }
    const _onChange = react.useCallback(
      ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2),
      [onChange, options]
    );
    const _onBlur = react.useCallback(
      ({ target }) => onBlur(id, target && target.value),
      [onBlur, id]
    );
    const _onFocus = react.useCallback(
      ({ target }) => onFocus(id, target && target.value),
      [onFocus, id]
    );
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        "input",
        {
          id,
          name: id,
          className: "form-control",
          readOnly: readonly,
          disabled,
          autoFocus: autofocus,
          value: inputValue,
          ...inputProps,
          list: schema.examples ? utils.examplesId(id) : void 0,
          onChange: onChangeOverride || _onChange,
          onBlur: _onBlur,
          onFocus: _onFocus,
          "aria-describedby": utils.ariaDescribedByIds(id, !!schema.examples)
        }
      ),
      Array.isArray(schema.examples) && /* @__PURE__ */ jsxRuntime.jsx("datalist", { id: utils.examplesId(id), children: schema.examples.concat(schema.default && !schema.examples.includes(schema.default) ? [schema.default] : []).map((example) => {
        return /* @__PURE__ */ jsxRuntime.jsx("option", { value: example }, example);
      }) }, `datalist_${id}`)
    ] });
  }
  function SubmitButton({ uiSchema }) {
    const { submitText, norender, props: submitButtonProps = {} } = utils.getSubmitButtonOptions(uiSchema);
    if (norender) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx("button", { type: "submit", ...submitButtonProps, className: `btn btn-info ${submitButtonProps.className || ""}`, children: submitText }) });
  }
  function IconButton(props) {
    const { iconType = "default", icon, className, uiSchema, registry, ...otherProps } = props;
    return /* @__PURE__ */ jsxRuntime.jsx("button", { type: "button", className: `btn btn-${iconType} ${className}`, ...otherProps, children: /* @__PURE__ */ jsxRuntime.jsx("i", { className: `glyphicon glyphicon-${icon}` }) });
  }
  function CopyButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(IconButton, { title: translateString(utils.TranslatableString.CopyButton), ...props, icon: "copy" });
  }
  function MoveDownButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(IconButton, { title: translateString(utils.TranslatableString.MoveDownButton), ...props, icon: "arrow-down" });
  }
  function MoveUpButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(IconButton, { title: translateString(utils.TranslatableString.MoveUpButton), ...props, icon: "arrow-up" });
  }
  function RemoveButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(IconButton, { title: translateString(utils.TranslatableString.RemoveButton), ...props, iconType: "danger", icon: "remove" });
  }
  function AddButton({
    className,
    onClick,
    disabled,
    registry
  }) {
    const { translateString } = registry;
    return /* @__PURE__ */ jsxRuntime.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntime.jsx("p", { className: `col-xs-3 col-xs-offset-9 text-right ${className}`, children: /* @__PURE__ */ jsxRuntime.jsx(
      IconButton,
      {
        iconType: "info",
        icon: "plus",
        className: "btn-add col-xs-12",
        title: translateString(utils.TranslatableString.AddButton),
        onClick,
        disabled,
        registry
      }
    ) }) });
  }

  // src/components/templates/ButtonTemplates/index.ts
  function buttonTemplates() {
    return {
      SubmitButton,
      AddButton,
      CopyButton,
      MoveDownButton,
      MoveUpButton,
      RemoveButton
    };
  }
  var ButtonTemplates_default = buttonTemplates;
  var TEST_IDS = utils.getTestIds();
  function RichDescription({ description, registry, uiSchema = {} }) {
    const { globalUiOptions } = registry;
    const uiOptions = utils.getUiOptions(uiSchema, globalUiOptions);
    if (uiOptions.enableMarkdownInDescription && typeof description === "string") {
      return /* @__PURE__ */ jsxRuntime.jsx(Markdown, { options: { disableParsingRawHTML: true }, "data-testid": TEST_IDS.markdown, children: description });
    }
    return description;
  }
  RichDescription.TEST_IDS = TEST_IDS;
  function DescriptionField(props) {
    const { id, description, registry, uiSchema } = props;
    if (!description) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsx("div", { id, className: "field-description", children: /* @__PURE__ */ jsxRuntime.jsx(RichDescription, { description, registry, uiSchema }) });
  }
  function ErrorList({
    errors,
    registry
  }) {
    const { translateString } = registry;
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "panel panel-danger errors", children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: "panel-heading", children: /* @__PURE__ */ jsxRuntime.jsx("h3", { className: "panel-title", children: translateString(utils.TranslatableString.ErrorsLabel) }) }),
      /* @__PURE__ */ jsxRuntime.jsx("ul", { className: "list-group", children: errors.map((error, i) => {
        return /* @__PURE__ */ jsxRuntime.jsx("li", { className: "list-group-item text-danger", children: error.stack }, i);
      }) })
    ] });
  }
  var REQUIRED_FIELD_SYMBOL = "*";
  function Label(props) {
    const { label, required, id } = props;
    if (!label) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsxs("label", { className: "control-label", htmlFor: id, children: [
      label,
      required && /* @__PURE__ */ jsxRuntime.jsx("span", { className: "required", children: REQUIRED_FIELD_SYMBOL })
    ] });
  }
  function FieldTemplate(props) {
    const { id, label, children, errors, help, description, hidden, required, displayLabel, registry, uiSchema } = props;
    const uiOptions = utils.getUiOptions(uiSchema);
    const WrapIfAdditionalTemplate2 = utils.getTemplate(
      "WrapIfAdditionalTemplate",
      registry,
      uiOptions
    );
    if (hidden) {
      return /* @__PURE__ */ jsxRuntime.jsx("div", { className: "hidden", children });
    }
    return /* @__PURE__ */ jsxRuntime.jsxs(WrapIfAdditionalTemplate2, { ...props, children: [
      displayLabel && /* @__PURE__ */ jsxRuntime.jsx(Label, { label, required, id }),
      displayLabel && description ? description : null,
      children,
      errors,
      help
    ] });
  }

  // src/components/templates/FieldTemplate/index.ts
  var FieldTemplate_default = FieldTemplate;
  function FieldErrorTemplate(props) {
    const { errors = [], idSchema } = props;
    if (errors.length === 0) {
      return null;
    }
    const id = utils.errorId(idSchema);
    return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx("ul", { id, className: "error-detail bs-callout bs-callout-info", children: errors.filter((elem) => !!elem).map((error, index) => {
      return /* @__PURE__ */ jsxRuntime.jsx("li", { className: "text-danger", children: error }, index);
    }) }) });
  }
  function FieldHelpTemplate(props) {
    const { idSchema, help } = props;
    if (!help) {
      return null;
    }
    const id = utils.helpId(idSchema);
    if (typeof help === "string") {
      return /* @__PURE__ */ jsxRuntime.jsx("p", { id, className: "help-block", children: help });
    }
    return /* @__PURE__ */ jsxRuntime.jsx("div", { id, className: "help-block", children: help });
  }
  function GridTemplate(props) {
    const { children, column, className, ...rest } = props;
    return /* @__PURE__ */ jsxRuntime.jsx("div", { className, ...rest, children });
  }
  function MultiSchemaFieldTemplate(props) {
    const { selector, optionSchemaField } = props;
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "panel panel-default panel-body", children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: "form-group", children: selector }),
      optionSchemaField
    ] });
  }
  function ObjectFieldTemplate(props) {
    const {
      description,
      disabled,
      formData,
      idSchema,
      onAddClick,
      properties,
      readonly,
      registry,
      required,
      schema,
      title,
      uiSchema
    } = props;
    const options = utils.getUiOptions(uiSchema);
    const TitleFieldTemplate = utils.getTemplate("TitleFieldTemplate", registry, options);
    const DescriptionFieldTemplate = utils.getTemplate(
      "DescriptionFieldTemplate",
      registry,
      options
    );
    const {
      ButtonTemplates: { AddButton: AddButton2 }
    } = registry.templates;
    return /* @__PURE__ */ jsxRuntime.jsxs("fieldset", { id: idSchema.$id, children: [
      title && /* @__PURE__ */ jsxRuntime.jsx(
        TitleFieldTemplate,
        {
          id: utils.titleId(idSchema),
          title,
          required,
          schema,
          uiSchema,
          registry
        }
      ),
      description && /* @__PURE__ */ jsxRuntime.jsx(
        DescriptionFieldTemplate,
        {
          id: utils.descriptionId(idSchema),
          description,
          schema,
          uiSchema,
          registry
        }
      ),
      properties.map((prop) => prop.content),
      utils.canExpand(schema, uiSchema, formData) && /* @__PURE__ */ jsxRuntime.jsx(
        AddButton2,
        {
          id: utils.buttonId(idSchema, "add"),
          className: "rjsf-object-property-expand",
          onClick: onAddClick(schema),
          disabled: disabled || readonly,
          uiSchema,
          registry
        }
      )
    ] });
  }
  var REQUIRED_FIELD_SYMBOL2 = "*";
  function TitleField(props) {
    const { id, title, required } = props;
    return /* @__PURE__ */ jsxRuntime.jsxs("legend", { id, children: [
      title,
      required && /* @__PURE__ */ jsxRuntime.jsx("span", { className: "required", children: REQUIRED_FIELD_SYMBOL2 })
    ] });
  }
  function UnsupportedField(props) {
    const { schema, idSchema, reason, registry } = props;
    const { translateString } = registry;
    let translateEnum = utils.TranslatableString.UnsupportedField;
    const translateParams = [];
    if (idSchema && idSchema.$id) {
      translateEnum = utils.TranslatableString.UnsupportedFieldWithId;
      translateParams.push(idSchema.$id);
    }
    if (reason) {
      translateEnum = translateEnum === utils.TranslatableString.UnsupportedField ? utils.TranslatableString.UnsupportedFieldWithReason : utils.TranslatableString.UnsupportedFieldWithIdAndReason;
      translateParams.push(reason);
    }
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "unsupported-field", children: [
      /* @__PURE__ */ jsxRuntime.jsx("p", { children: /* @__PURE__ */ jsxRuntime.jsx(Markdown, { options: { disableParsingRawHTML: true }, children: translateString(translateEnum, translateParams) }) }),
      schema && /* @__PURE__ */ jsxRuntime.jsx("pre", { children: JSON.stringify(schema, null, 2) })
    ] });
  }
  var UnsupportedField_default = UnsupportedField;
  function WrapIfAdditionalTemplate(props) {
    const {
      id,
      classNames,
      style,
      disabled,
      label,
      onKeyChange,
      onDropPropertyClick,
      readonly,
      required,
      schema,
      hideError,
      rawErrors,
      children,
      uiSchema,
      registry
    } = props;
    const { templates: templates2, translateString } = registry;
    const { RemoveButton: RemoveButton2 } = templates2.ButtonTemplates;
    const keyLabel = translateString(utils.TranslatableString.KeyLabel, [label]);
    const additional = utils.ADDITIONAL_PROPERTY_FLAG in schema;
    const classNamesList = ["form-group", classNames];
    if (!hideError && rawErrors && rawErrors.length > 0) {
      classNamesList.push("has-error has-danger");
    }
    const uiClassNames = classNamesList.join(" ").trim();
    if (!additional) {
      return /* @__PURE__ */ jsxRuntime.jsx("div", { className: uiClassNames, style, children });
    }
    return /* @__PURE__ */ jsxRuntime.jsx("div", { className: uiClassNames, style, children: /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: "col-xs-5 form-additional", children: /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntime.jsx(Label, { label: keyLabel, required, id: `${id}-key` }),
        /* @__PURE__ */ jsxRuntime.jsx(
          "input",
          {
            className: "form-control",
            type: "text",
            id: `${id}-key`,
            onBlur: ({ target }) => onKeyChange(target && target.value),
            defaultValue: label
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: "form-additional form-group col-xs-5", children }),
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: "col-xs-2", children: /* @__PURE__ */ jsxRuntime.jsx(
        RemoveButton2,
        {
          id: utils.buttonId(id, "remove"),
          className: "rjsf-object-property-remove btn-block",
          style: { border: "0" },
          disabled: disabled || readonly,
          onClick: onDropPropertyClick(label),
          uiSchema,
          registry
        }
      ) })
    ] }) });
  }

  // src/components/templates/index.ts
  function templates() {
    return {
      ArrayFieldDescriptionTemplate,
      ArrayFieldItemTemplate,
      ArrayFieldItemButtonsTemplate,
      ArrayFieldTemplate,
      ArrayFieldTitleTemplate,
      ButtonTemplates: ButtonTemplates_default(),
      BaseInputTemplate,
      DescriptionFieldTemplate: DescriptionField,
      ErrorListTemplate: ErrorList,
      FieldTemplate: FieldTemplate_default,
      FieldErrorTemplate,
      FieldHelpTemplate,
      GridTemplate,
      MultiSchemaFieldTemplate,
      ObjectFieldTemplate,
      TitleFieldTemplate: TitleField,
      UnsupportedFieldTemplate: UnsupportedField_default,
      WrapIfAdditionalTemplate
    };
  }
  var templates_default = templates;
  function readyForChange(state) {
    return Object.values(state).every((value) => value !== -1);
  }
  function DateElement({
    type,
    range,
    value,
    select,
    rootId,
    name,
    disabled,
    readonly,
    autofocus,
    registry,
    onBlur,
    onFocus
  }) {
    const id = rootId + "_" + type;
    const { SelectWidget: SelectWidget2 } = registry.widgets;
    return /* @__PURE__ */ jsxRuntime.jsx(
      SelectWidget2,
      {
        schema: { type: "integer" },
        id,
        name,
        className: "form-control",
        options: { enumOptions: utils.dateRangeOptions(range[0], range[1]) },
        placeholder: type,
        value,
        disabled,
        readonly,
        autofocus,
        onChange: (value2) => select(type, value2),
        onBlur,
        onFocus,
        registry,
        label: "",
        "aria-describedby": utils.ariaDescribedByIds(rootId)
      }
    );
  }
  function AltDateWidget({
    time = false,
    disabled = false,
    readonly = false,
    autofocus = false,
    options,
    id,
    name,
    registry,
    onBlur,
    onFocus,
    onChange,
    value
  }) {
    const { translateString } = registry;
    const [state, setState] = react.useState(utils.parseDateString(value, time));
    react.useEffect(() => {
      setState(utils.parseDateString(value, time));
    }, [time, value]);
    const handleChange = react.useCallback(
      (property, value2) => {
        const nextState = {
          ...state,
          [property]: typeof value2 === "undefined" ? -1 : value2
        };
        if (readyForChange(nextState)) {
          onChange(utils.toDateString(nextState, time));
        } else {
          setState(nextState);
        }
      },
      [state, onChange, time]
    );
    const handleSetNow = react.useCallback(
      (event) => {
        event.preventDefault();
        if (disabled || readonly) {
          return;
        }
        const nextState = utils.parseDateString((/* @__PURE__ */ new Date()).toJSON(), time);
        onChange(utils.toDateString(nextState, time));
      },
      [disabled, readonly, time, onChange]
    );
    const handleClear = react.useCallback(
      (event) => {
        event.preventDefault();
        if (disabled || readonly) {
          return;
        }
        onChange(void 0);
      },
      [disabled, readonly, onChange]
    );
    return /* @__PURE__ */ jsxRuntime.jsxs("ul", { className: "list-inline", children: [
      utils.getDateElementProps(
        state,
        time,
        options.yearsRange,
        options.format
      ).map((elemProps, i) => /* @__PURE__ */ jsxRuntime.jsx("li", { className: "list-inline-item", children: /* @__PURE__ */ jsxRuntime.jsx(
        DateElement,
        {
          rootId: id,
          name,
          select: handleChange,
          ...elemProps,
          disabled,
          readonly,
          registry,
          onBlur,
          onFocus,
          autofocus: autofocus && i === 0
        }
      ) }, i)),
      (options.hideNowButton !== "undefined" ? !options.hideNowButton : true) && /* @__PURE__ */ jsxRuntime.jsx("li", { className: "list-inline-item", children: /* @__PURE__ */ jsxRuntime.jsx("a", { href: "#", className: "btn btn-info btn-now", onClick: handleSetNow, children: translateString(utils.TranslatableString.NowLabel) }) }),
      (options.hideClearButton !== "undefined" ? !options.hideClearButton : true) && /* @__PURE__ */ jsxRuntime.jsx("li", { className: "list-inline-item", children: /* @__PURE__ */ jsxRuntime.jsx("a", { href: "#", className: "btn btn-warning btn-clear", onClick: handleClear, children: translateString(utils.TranslatableString.ClearLabel) }) })
    ] });
  }
  var AltDateWidget_default = AltDateWidget;
  function AltDateTimeWidget({
    time = true,
    ...props
  }) {
    const { AltDateWidget: AltDateWidget2 } = props.registry.widgets;
    return /* @__PURE__ */ jsxRuntime.jsx(AltDateWidget2, { time, ...props });
  }
  var AltDateTimeWidget_default = AltDateTimeWidget;
  function CheckboxWidget({
    schema,
    uiSchema,
    options,
    id,
    value,
    disabled,
    readonly,
    label,
    hideLabel,
    autofocus = false,
    onBlur,
    onFocus,
    onChange,
    registry
  }) {
    const DescriptionFieldTemplate = utils.getTemplate(
      "DescriptionFieldTemplate",
      registry,
      options
    );
    const required = utils.schemaRequiresTrueValue(schema);
    const handleChange = react.useCallback(
      (event) => onChange(event.target.checked),
      [onChange]
    );
    const handleBlur = react.useCallback(
      (event) => onBlur(id, event.target.checked),
      [onBlur, id]
    );
    const handleFocus = react.useCallback(
      (event) => onFocus(id, event.target.checked),
      [onFocus, id]
    );
    const description = options.description ?? schema.description;
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: `checkbox ${disabled || readonly ? "disabled" : ""}`, children: [
      !hideLabel && description && /* @__PURE__ */ jsxRuntime.jsx(
        DescriptionFieldTemplate,
        {
          id: utils.descriptionId(id),
          description,
          schema,
          uiSchema,
          registry
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsxs("label", { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "input",
          {
            type: "checkbox",
            id,
            name: id,
            checked: typeof value === "undefined" ? false : value,
            required,
            disabled: disabled || readonly,
            autoFocus: autofocus,
            onChange: handleChange,
            onBlur: handleBlur,
            onFocus: handleFocus,
            "aria-describedby": utils.ariaDescribedByIds(id)
          }
        ),
        utils.labelValue(/* @__PURE__ */ jsxRuntime.jsx("span", { children: label }), hideLabel)
      ] })
    ] });
  }
  var CheckboxWidget_default = CheckboxWidget;
  function CheckboxesWidget({
    id,
    disabled,
    options: { inline = false, enumOptions, enumDisabled, emptyValue },
    value,
    autofocus = false,
    readonly,
    onChange,
    onBlur,
    onFocus
  }) {
    const checkboxesValues = Array.isArray(value) ? value : [value];
    const handleBlur = react.useCallback(
      ({ target }) => onBlur(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)),
      [onBlur, id, enumOptions, emptyValue]
    );
    const handleFocus = react.useCallback(
      ({ target }) => onFocus(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)),
      [onFocus, id, enumOptions, emptyValue]
    );
    return /* @__PURE__ */ jsxRuntime.jsx("div", { className: "checkboxes", id, children: Array.isArray(enumOptions) && enumOptions.map((option, index) => {
      const checked = utils.enumOptionsIsSelected(option.value, checkboxesValues);
      const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
      const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
      const handleChange = (event) => {
        if (event.target.checked) {
          onChange(utils.enumOptionsSelectValue(index, checkboxesValues, enumOptions));
        } else {
          onChange(utils.enumOptionsDeselectValue(index, checkboxesValues, enumOptions));
        }
      };
      const checkbox = /* @__PURE__ */ jsxRuntime.jsxs("span", { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "input",
          {
            type: "checkbox",
            id: utils.optionId(id, index),
            name: id,
            checked,
            value: String(index),
            disabled: disabled || itemDisabled || readonly,
            autoFocus: autofocus && index === 0,
            onChange: handleChange,
            onBlur: handleBlur,
            onFocus: handleFocus,
            "aria-describedby": utils.ariaDescribedByIds(id)
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("span", { children: option.label })
      ] });
      return inline ? /* @__PURE__ */ jsxRuntime.jsx("label", { className: `checkbox-inline ${disabledCls}`, children: checkbox }, index) : /* @__PURE__ */ jsxRuntime.jsx("div", { className: `checkbox ${disabledCls}`, children: /* @__PURE__ */ jsxRuntime.jsx("label", { children: checkbox }) }, index);
    }) });
  }
  var CheckboxesWidget_default = CheckboxesWidget;
  function ColorWidget(props) {
    const { disabled, readonly, options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "color", ...props, disabled: disabled || readonly });
  }
  function DateWidget(props) {
    const { onChange, options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    const handleChange = react.useCallback((value) => onChange(value || void 0), [onChange]);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "date", ...props, onChange: handleChange });
  }
  function DateTimeWidget(props) {
    const { onChange, value, options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx(
      BaseInputTemplate2,
      {
        type: "datetime-local",
        ...props,
        value: utils.utcToLocal(value),
        onChange: (value2) => onChange(utils.localToUTC(value2))
      }
    );
  }
  function EmailWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "email", ...props });
  }
  function addNameToDataURL(dataURL, name) {
    if (dataURL === null) {
      return null;
    }
    return dataURL.replace(";base64", `;name=${encodeURIComponent(name)};base64`);
  }
  function processFile(file) {
    const { name, size, type } = file;
    return new Promise((resolve, reject) => {
      const reader = new window.FileReader();
      reader.onerror = reject;
      reader.onload = (event) => {
        if (typeof event.target?.result === "string") {
          resolve({
            dataURL: addNameToDataURL(event.target.result, name),
            name,
            size,
            type
          });
        } else {
          resolve({
            dataURL: null,
            name,
            size,
            type
          });
        }
      };
      reader.readAsDataURL(file);
    });
  }
  function processFiles(files) {
    return Promise.all(Array.from(files).map(processFile));
  }
  function FileInfoPreview({
    fileInfo,
    registry
  }) {
    const { translateString } = registry;
    const { dataURL, type, name } = fileInfo;
    if (!dataURL) {
      return null;
    }
    if (["image/jpeg", "image/png"].includes(type)) {
      return /* @__PURE__ */ jsxRuntime.jsx("img", { src: dataURL, style: { maxWidth: "100%" }, className: "file-preview" });
    }
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      " ",
      /* @__PURE__ */ jsxRuntime.jsx("a", { download: `preview-${name}`, href: dataURL, className: "file-download", children: translateString(utils.TranslatableString.PreviewLabel) })
    ] });
  }
  function FilesInfo({
    filesInfo,
    registry,
    preview,
    onRemove,
    options
  }) {
    if (filesInfo.length === 0) {
      return null;
    }
    const { translateString } = registry;
    const { RemoveButton: RemoveButton2 } = utils.getTemplate("ButtonTemplates", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx("ul", { className: "file-info", children: filesInfo.map((fileInfo, key) => {
      const { name, size, type } = fileInfo;
      const handleRemove = () => onRemove(key);
      return /* @__PURE__ */ jsxRuntime.jsxs("li", { children: [
        /* @__PURE__ */ jsxRuntime.jsx(Markdown, { children: translateString(utils.TranslatableString.FilesInfo, [name, type, String(size)]) }),
        preview && /* @__PURE__ */ jsxRuntime.jsx(FileInfoPreview, { fileInfo, registry }),
        /* @__PURE__ */ jsxRuntime.jsx(RemoveButton2, { onClick: handleRemove, registry })
      ] }, key);
    }) });
  }
  function extractFileInfo(dataURLs) {
    return dataURLs.reduce((acc, dataURL) => {
      if (!dataURL) {
        return acc;
      }
      try {
        const { blob, name } = utils.dataURItoBlob(dataURL);
        return [
          ...acc,
          {
            dataURL,
            name,
            size: blob.size,
            type: blob.type
          }
        ];
      } catch {
        return acc;
      }
    }, []);
  }
  function FileWidget(props) {
    const { disabled, readonly, required, multiple, onChange, value, options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    const handleChange = react.useCallback(
      (event) => {
        if (!event.target.files) {
          return;
        }
        processFiles(event.target.files).then((filesInfoEvent) => {
          const newValue = filesInfoEvent.map((fileInfo) => fileInfo.dataURL);
          if (multiple) {
            onChange(value.concat(newValue));
          } else {
            onChange(newValue[0]);
          }
        });
      },
      [multiple, value, onChange]
    );
    const filesInfo = react.useMemo(() => extractFileInfo(Array.isArray(value) ? value : [value]), [value]);
    const rmFile = react.useCallback(
      (index) => {
        if (multiple) {
          const newValue = value.filter((_, i) => i !== index);
          onChange(newValue);
        } else {
          onChange(void 0);
        }
      },
      [multiple, value, onChange]
    );
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        BaseInputTemplate2,
        {
          ...props,
          disabled: disabled || readonly,
          type: "file",
          required: value ? false : required,
          onChangeOverride: handleChange,
          value: "",
          accept: options.accept ? String(options.accept) : void 0
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        FilesInfo,
        {
          filesInfo,
          onRemove: rmFile,
          registry,
          preview: options.filePreview,
          options
        }
      )
    ] });
  }
  var FileWidget_default = FileWidget;
  function HiddenWidget({
    id,
    value
  }) {
    return /* @__PURE__ */ jsxRuntime.jsx("input", { type: "hidden", id, name: id, value: typeof value === "undefined" ? "" : value });
  }
  var HiddenWidget_default = HiddenWidget;
  function PasswordWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "password", ...props });
  }
  function RadioWidget({
    options,
    value,
    required,
    disabled,
    readonly,
    autofocus = false,
    onBlur,
    onFocus,
    onChange,
    id
  }) {
    const { enumOptions, enumDisabled, inline, emptyValue } = options;
    const handleBlur = react.useCallback(
      ({ target }) => onBlur(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)),
      [onBlur, enumOptions, emptyValue, id]
    );
    const handleFocus = react.useCallback(
      ({ target }) => onFocus(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)),
      [onFocus, enumOptions, emptyValue, id]
    );
    return /* @__PURE__ */ jsxRuntime.jsx("div", { className: "field-radio-group", id, role: "radiogroup", children: Array.isArray(enumOptions) && enumOptions.map((option, i) => {
      const checked = utils.enumOptionsIsSelected(option.value, value);
      const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
      const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
      const handleChange = () => onChange(option.value);
      const radio = /* @__PURE__ */ jsxRuntime.jsxs("span", { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "input",
          {
            type: "radio",
            id: utils.optionId(id, i),
            checked,
            name: id,
            required,
            value: String(i),
            disabled: disabled || itemDisabled || readonly,
            autoFocus: autofocus && i === 0,
            onChange: handleChange,
            onBlur: handleBlur,
            onFocus: handleFocus,
            "aria-describedby": utils.ariaDescribedByIds(id)
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("span", { children: option.label })
      ] });
      return inline ? /* @__PURE__ */ jsxRuntime.jsx("label", { className: `radio-inline ${disabledCls}`, children: radio }, i) : /* @__PURE__ */ jsxRuntime.jsx("div", { className: `radio ${disabledCls}`, children: /* @__PURE__ */ jsxRuntime.jsx("label", { children: radio }) }, i);
    }) });
  }
  var RadioWidget_default = RadioWidget;
  function RangeWidget(props) {
    const {
      value,
      registry: {
        templates: { BaseInputTemplate: BaseInputTemplate2 }
      }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "field-range-wrapper", children: [
      /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "range", ...props }),
      /* @__PURE__ */ jsxRuntime.jsx("span", { className: "range-view", children: value })
    ] });
  }
  function RatingWidget({
    id,
    value,
    required,
    disabled,
    readonly,
    autofocus,
    onChange,
    onFocus,
    onBlur,
    schema,
    options
  }) {
    const { stars = 5, shape = "star" } = options;
    const numStars = schema.maximum ? Math.min(schema.maximum, 5) : Math.min(Math.max(stars, 1), 5);
    const min = schema.minimum || 0;
    const handleStarClick = react.useCallback(
      (starValue) => {
        if (!disabled && !readonly) {
          onChange(starValue);
        }
      },
      [onChange, disabled, readonly]
    );
    const handleFocus = react.useCallback(
      (event) => {
        if (onFocus) {
          const starValue = Number(event.target.dataset.value);
          onFocus(id, starValue);
        }
      },
      [onFocus, id]
    );
    const handleBlur = react.useCallback(
      (event) => {
        if (onBlur) {
          const starValue = Number(event.target.dataset.value);
          onBlur(id, starValue);
        }
      },
      [onBlur, id]
    );
    const getSymbol = (isFilled) => {
      if (shape === "heart") {
        return isFilled ? "\u2665" : "\u2661";
      }
      return isFilled ? "\u2605" : "\u2606";
    };
    return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsxs(
      "div",
      {
        className: "rating-widget",
        style: {
          display: "inline-flex",
          fontSize: "1.5rem",
          cursor: disabled || readonly ? "default" : "pointer"
        },
        children: [
          [...Array(numStars)].map((_, index) => {
            const starValue = min + index;
            const isFilled = starValue <= value;
            return /* @__PURE__ */ jsxRuntime.jsx(
              "span",
              {
                onClick: () => handleStarClick(starValue),
                onFocus: handleFocus,
                onBlur: handleBlur,
                "data-value": starValue,
                tabIndex: disabled || readonly ? -1 : 0,
                role: "radio",
                "aria-checked": starValue === value,
                "aria-label": `${starValue} ${shape === "heart" ? "heart" : "star"}${starValue === 1 ? "" : "s"}`,
                style: {
                  color: isFilled ? "#FFD700" : "#ccc",
                  padding: "0 0.2rem",
                  transition: "color 0.2s",
                  userSelect: "none"
                },
                children: getSymbol(isFilled)
              },
              index
            );
          }),
          /* @__PURE__ */ jsxRuntime.jsx(
            "input",
            {
              type: "hidden",
              id,
              name: id,
              value: value || "",
              required,
              disabled: disabled || readonly,
              "aria-hidden": "true"
            }
          )
        ]
      }
    ) });
  }
  function getValue(event, multiple) {
    if (multiple) {
      return Array.from(event.target.options).slice().filter((o) => o.selected).map((o) => o.value);
    }
    return event.target.value;
  }
  function SelectWidget({
    schema,
    id,
    options,
    value,
    required,
    disabled,
    readonly,
    multiple = false,
    autofocus = false,
    onChange,
    onBlur,
    onFocus,
    placeholder
  }) {
    const { enumOptions, enumDisabled, emptyValue: optEmptyVal } = options;
    const emptyValue = multiple ? [] : "";
    const handleFocus = react.useCallback(
      (event) => {
        const newValue = getValue(event, multiple);
        return onFocus(id, utils.enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));
      },
      [onFocus, id, multiple, enumOptions, optEmptyVal]
    );
    const handleBlur = react.useCallback(
      (event) => {
        const newValue = getValue(event, multiple);
        return onBlur(id, utils.enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));
      },
      [onBlur, id, multiple, enumOptions, optEmptyVal]
    );
    const handleChange = react.useCallback(
      (event) => {
        const newValue = getValue(event, multiple);
        return onChange(utils.enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));
      },
      [onChange, multiple, enumOptions, optEmptyVal]
    );
    const selectedIndexes = utils.enumOptionsIndexForValue(value, enumOptions, multiple);
    const showPlaceholderOption = !multiple && schema.default === void 0;
    return /* @__PURE__ */ jsxRuntime.jsxs(
      "select",
      {
        id,
        name: id,
        multiple,
        role: "combobox",
        className: "form-control",
        value: typeof selectedIndexes === "undefined" ? emptyValue : selectedIndexes,
        required,
        disabled: disabled || readonly,
        autoFocus: autofocus,
        onBlur: handleBlur,
        onFocus: handleFocus,
        onChange: handleChange,
        "aria-describedby": utils.ariaDescribedByIds(id),
        children: [
          showPlaceholderOption && /* @__PURE__ */ jsxRuntime.jsx("option", { value: "", children: placeholder }),
          Array.isArray(enumOptions) && enumOptions.map(({ value: value2, label }, i) => {
            const disabled2 = enumDisabled && enumDisabled.indexOf(value2) !== -1;
            return /* @__PURE__ */ jsxRuntime.jsx("option", { value: String(i), disabled: disabled2, children: label }, i);
          })
        ]
      }
    );
  }
  var SelectWidget_default = SelectWidget;
  function TextareaWidget({
    id,
    options = {},
    placeholder,
    value,
    required,
    disabled,
    readonly,
    autofocus = false,
    onChange,
    onBlur,
    onFocus
  }) {
    const handleChange = react.useCallback(
      ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2),
      [onChange, options.emptyValue]
    );
    const handleBlur = react.useCallback(
      ({ target }) => onBlur(id, target && target.value),
      [onBlur, id]
    );
    const handleFocus = react.useCallback(
      ({ target }) => onFocus(id, target && target.value),
      [id, onFocus]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      "textarea",
      {
        id,
        name: id,
        className: "form-control",
        value: value ? value : "",
        placeholder,
        required,
        disabled,
        readOnly: readonly,
        autoFocus: autofocus,
        rows: options.rows,
        onBlur: handleBlur,
        onFocus: handleFocus,
        onChange: handleChange,
        "aria-describedby": utils.ariaDescribedByIds(id)
      }
    );
  }
  TextareaWidget.defaultProps = {
    autofocus: false,
    options: {}
  };
  var TextareaWidget_default = TextareaWidget;
  function TextWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { ...props });
  }
  function TimeWidget(props) {
    const { onChange, options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    const handleChange = react.useCallback((value) => onChange(value ? `${value}:00` : void 0), [onChange]);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "time", ...props, onChange: handleChange });
  }
  function URLWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "url", ...props });
  }
  function UpDownWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate2 = utils.getTemplate("BaseInputTemplate", registry, options);
    return /* @__PURE__ */ jsxRuntime.jsx(BaseInputTemplate2, { type: "number", ...props });
  }

  // src/components/widgets/index.ts
  function widgets() {
    return {
      AltDateWidget: AltDateWidget_default,
      AltDateTimeWidget: AltDateTimeWidget_default,
      CheckboxWidget: CheckboxWidget_default,
      CheckboxesWidget: CheckboxesWidget_default,
      ColorWidget,
      DateWidget,
      DateTimeWidget,
      EmailWidget,
      FileWidget: FileWidget_default,
      HiddenWidget: HiddenWidget_default,
      PasswordWidget,
      RadioWidget: RadioWidget_default,
      RangeWidget,
      RatingWidget,
      SelectWidget: SelectWidget_default,
      TextWidget,
      TextareaWidget: TextareaWidget_default,
      TimeWidget,
      UpDownWidget,
      URLWidget
    };
  }
  var widgets_default = widgets;

  // src/getDefaultRegistry.ts
  function getDefaultRegistry() {
    return {
      fields: fields_default(),
      templates: templates_default(),
      widgets: widgets_default(),
      rootSchema: {},
      formContext: {},
      translateString: utils.englishStringTranslator
    };
  }
  var Form = class extends react.Component {
    /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
     * provide any possible type here
     */
    formElement;
    /** The list of pending changes
     */
    pendingChanges = [];
    /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
     * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
     * state construction.
     *
     * @param props - The initial props for the `Form`
     */
    constructor(props) {
      super(props);
      if (!props.validator) {
        throw new Error("A validator is required for Form functionality to work");
      }
      this.state = this.getStateFromProps(props, props.formData);
      if (this.props.onChange && !utils.deepEquals(this.state.formData, this.props.formData)) {
        this.props.onChange(this.state);
      }
      this.formElement = react.createRef();
    }
    /**
     * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
     * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
     * they are potentially changed.
     *
     * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
     * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
     * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
     * state ready to be applied in `componentDidUpdate`.
     *
     * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
     * state update is not necessary.
     *
     * @param prevProps - The previous set of props before the update.
     * @param prevState - The previous state before the update.
     * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
     *        with a flag indicating that an update is not necessary.
     */
    getSnapshotBeforeUpdate(prevProps, prevState) {
      if (!utils.deepEquals(this.props, prevProps)) {
        const formDataChangedFields = utils.getChangedFields(this.props.formData, prevProps.formData);
        const stateDataChangedFields = utils.getChangedFields(this.props.formData, this.state.formData);
        const isSchemaChanged = !utils.deepEquals(prevProps.schema, this.props.schema);
        const isFormDataChanged = formDataChangedFields.length > 0 || !utils.deepEquals(prevProps.formData, this.props.formData);
        const isStateDataChanged = stateDataChangedFields.length > 0 || !utils.deepEquals(this.state.formData, this.props.formData);
        const nextState = this.getStateFromProps(
          this.props,
          this.props.formData,
          // If the `schema` has changed, we need to update the retrieved schema.
          // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
          //  match one of the subSchemas, the retrieved schema must be updated.
          isSchemaChanged || isFormDataChanged ? void 0 : this.state.retrievedSchema,
          isSchemaChanged,
          formDataChangedFields,
          // Skip live validation for this request if no form data has changed from the last state
          !isStateDataChanged
        );
        const shouldUpdate = !utils.deepEquals(nextState, prevState);
        return { nextState, shouldUpdate };
      }
      return { shouldUpdate: false };
    }
    /**
     * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
     * not called for the initial render.
     *
     * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
     * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
     * changes.
     *
     * @param _ - The previous set of props.
     * @param prevState - The previous state of the component before the update.
     * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
     */
    componentDidUpdate(_, prevState, snapshot) {
      if (snapshot.shouldUpdate) {
        const { nextState } = snapshot;
        if (!utils.deepEquals(nextState.formData, this.props.formData) && !utils.deepEquals(nextState.formData, prevState.formData) && this.props.onChange) {
          this.props.onChange(nextState);
        }
        this.setState(nextState);
      }
    }
    /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
     * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
     * validation process IF required by the `props`.
     *
     * @param props - The props passed to the `Form`
     * @param inputFormData - The new or current data for the `Form`
     * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
     * @param isSchemaChanged - A flag indicating whether the schema has changed.
     * @param formDataChangedFields - The changed fields of `formData`
     * @returns - The new state for the `Form`
     */
    getStateFromProps(props, inputFormData, retrievedSchema, isSchemaChanged = false, formDataChangedFields = [], skipLiveValidate = false) {
      const state = this.state || {};
      const schema = "schema" in props ? props.schema : this.props.schema;
      const validator = "validator" in props ? props.validator : this.props.validator;
      const uiSchema = ("uiSchema" in props ? props.uiSchema : this.props.uiSchema) || {};
      const edit = typeof inputFormData !== "undefined";
      const liveValidate = "liveValidate" in props ? props.liveValidate : this.props.liveValidate;
      const mustValidate = edit && !props.noValidate && liveValidate && !skipLiveValidate;
      const experimental_defaultFormStateBehavior = "experimental_defaultFormStateBehavior" in props ? props.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior;
      const experimental_customMergeAllOf = "experimental_customMergeAllOf" in props ? props.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
      let schemaUtils = state.schemaUtils;
      if (!schemaUtils || schemaUtils.doesSchemaUtilsDiffer(
        validator,
        schema,
        experimental_defaultFormStateBehavior,
        experimental_customMergeAllOf
      )) {
        schemaUtils = utils.createSchemaUtils(
          validator,
          schema,
          experimental_defaultFormStateBehavior,
          experimental_customMergeAllOf
        );
      }
      const rootSchema = schemaUtils.getRootSchema();
      const formData = schemaUtils.getDefaultFormState(rootSchema, inputFormData);
      const _retrievedSchema = this.updateRetrievedSchema(
        retrievedSchema ?? schemaUtils.retrieveSchema(rootSchema, formData)
      );
      const getCurrentErrors = () => {
        if (props.noValidate || isSchemaChanged) {
          return { errors: [], errorSchema: {} };
        } else if (!props.liveValidate) {
          return {
            errors: state.schemaValidationErrors || [],
            errorSchema: state.schemaValidationErrorSchema || {}
          };
        }
        return {
          errors: state.errors || [],
          errorSchema: state.errorSchema || {}
        };
      };
      let errors;
      let errorSchema;
      let schemaValidationErrors = state.schemaValidationErrors;
      let schemaValidationErrorSchema = state.schemaValidationErrorSchema;
      if (mustValidate) {
        const schemaValidation = this.validate(formData, rootSchema, schemaUtils, _retrievedSchema);
        errors = schemaValidation.errors;
        if (retrievedSchema === void 0) {
          errorSchema = schemaValidation.errorSchema;
        } else {
          errorSchema = utils.mergeObjects(
            this.state?.errorSchema,
            schemaValidation.errorSchema,
            "preventDuplicates"
          );
        }
        schemaValidationErrors = errors;
        schemaValidationErrorSchema = errorSchema;
      } else {
        const currentErrors = getCurrentErrors();
        errors = currentErrors.errors;
        errorSchema = currentErrors.errorSchema;
        if (formDataChangedFields.length > 0) {
          const newErrorSchema = formDataChangedFields.reduce(
            (acc, key) => {
              acc[key] = void 0;
              return acc;
            },
            {}
          );
          errorSchema = schemaValidationErrorSchema = utils.mergeObjects(
            currentErrors.errorSchema,
            newErrorSchema,
            "preventDuplicates"
          );
        }
      }
      if (props.extraErrors) {
        const merged = utils.validationDataMerge({ errorSchema, errors }, props.extraErrors);
        errorSchema = merged.errorSchema;
        errors = merged.errors;
      }
      const idSchema = schemaUtils.toIdSchema(
        _retrievedSchema,
        uiSchema["ui:rootFieldId"],
        formData,
        props.idPrefix,
        props.idSeparator
      );
      const nextState = {
        schemaUtils,
        schema: rootSchema,
        uiSchema,
        idSchema,
        formData,
        edit,
        errors,
        errorSchema,
        schemaValidationErrors,
        schemaValidationErrorSchema,
        retrievedSchema: _retrievedSchema
      };
      return nextState;
    }
    /** React lifecycle method that is used to determine whether component should be updated.
     *
     * @param nextProps - The next version of the props
     * @param nextState - The next version of the state
     * @returns - True if the component should be updated, false otherwise
     */
    shouldComponentUpdate(nextProps, nextState) {
      const { experimental_componentUpdateStrategy = "customDeep" } = this.props;
      return utils.shouldRender(this, nextProps, nextState, experimental_componentUpdateStrategy);
    }
    /** Gets the previously raised customValidate errors.
     *
     * @returns the previous customValidate errors
     */
    getPreviousCustomValidateErrors() {
      const { customValidate, uiSchema } = this.props;
      const prevFormData = this.state.formData;
      let customValidateErrors = {};
      if (typeof customValidate === "function") {
        const errorHandler = customValidate(prevFormData, utils.createErrorHandler(prevFormData), uiSchema);
        customValidateErrors = utils.unwrapErrorHandler(errorHandler);
      }
      return customValidateErrors;
    }
    /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
     * `schemaUtils` in the state), returning the results.
     *
     * @param formData - The new form data to validate
     * @param schema - The schema used to validate against
     * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
     * @param [retrievedSchema] - An optionally retrieved schema for per
     */
    validate(formData, schema = this.state.schema, altSchemaUtils, retrievedSchema) {
      const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;
      const { customValidate, transformErrors, uiSchema } = this.props;
      const resolvedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);
      return schemaUtils.getValidator().validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);
    }
    /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
    renderErrors(registry) {
      const { errors, errorSchema, schema, uiSchema } = this.state;
      const { formContext } = this.props;
      const options = utils.getUiOptions(uiSchema);
      const ErrorListTemplate = utils.getTemplate("ErrorListTemplate", registry, options);
      if (errors && errors.length) {
        return /* @__PURE__ */ jsxRuntime.jsx(
          ErrorListTemplate,
          {
            errors,
            errorSchema: errorSchema || {},
            schema,
            uiSchema,
            formContext,
            registry
          }
        );
      }
      return null;
    }
    /** Returns the `formData` with only the elements specified in the `fields` list
     *
     * @param formData - The data for the `Form`
     * @param fields - The fields to keep while filtering
     */
    getUsedFormData = (formData, fields2) => {
      if (fields2.length === 0 && typeof formData !== "object") {
        return formData;
      }
      const data = _pick(formData, fields2);
      if (Array.isArray(formData)) {
        return Object.keys(data).map((key) => data[key]);
      }
      return data;
    };
    /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
     *
     * @param pathSchema - The `PathSchema` object for the form
     * @param [formData] - The form data to use while checking for empty objects/arrays
     */
    getFieldNames = (pathSchema, formData) => {
      const getAllPaths = (_obj, acc = [], paths = [[]]) => {
        Object.keys(_obj).forEach((key) => {
          if (typeof _obj[key] === "object") {
            const newPaths = paths.map((path) => [...path, key]);
            if (_obj[key][utils.RJSF_ADDITIONAL_PROPERTIES_FLAG] && _obj[key][utils.NAME_KEY] !== "") {
              acc.push(_obj[key][utils.NAME_KEY]);
            } else {
              getAllPaths(_obj[key], acc, newPaths);
            }
          } else if (key === utils.NAME_KEY && _obj[key] !== "") {
            paths.forEach((path) => {
              const formValue = get2(formData, path);
              if (typeof formValue !== "object" || isEmpty(formValue) || Array.isArray(formValue) && formValue.every((val) => typeof val !== "object")) {
                acc.push(path);
              }
            });
          }
        });
        return acc;
      };
      return getAllPaths(pathSchema);
    };
    /** Returns the `formData` after filtering to remove any extra data not in a form field
     *
     * @param formData - The data for the `Form`
     * @returns The `formData` after omitting extra data
     */
    omitExtraData = (formData) => {
      const { schema, schemaUtils } = this.state;
      const retrievedSchema = schemaUtils.retrieveSchema(schema, formData);
      const pathSchema = schemaUtils.toPathSchema(retrievedSchema, "", formData);
      const fieldNames = this.getFieldNames(pathSchema, formData);
      return this.getUsedFormData(formData, fieldNames);
    };
    /** Filtering errors based on your retrieved schema to only show errors for properties in the selected branch.
     *
     * @param schemaErrors - The schema errors to filter
     * @param [resolvedSchema] - An optionally resolved schema to use for performance reasons
     * @param [formData] - The formData to help filter errors
     * @private
     */
    filterErrorsBasedOnSchema(schemaErrors, resolvedSchema, formData) {
      const { retrievedSchema, schemaUtils } = this.state;
      const _retrievedSchema = resolvedSchema ?? retrievedSchema;
      const pathSchema = schemaUtils.toPathSchema(_retrievedSchema, "", formData);
      const fieldNames = this.getFieldNames(pathSchema, formData);
      const filteredErrors = _pick(schemaErrors, fieldNames);
      if (resolvedSchema?.type !== "object" && resolvedSchema?.type !== "array") {
        filteredErrors.__errors = schemaErrors.__errors;
      }
      const prevCustomValidateErrors = this.getPreviousCustomValidateErrors();
      const filterPreviousCustomErrors = (errors = [], prevCustomErrors) => {
        if (errors.length === 0) {
          return errors;
        }
        return errors.filter((error) => {
          return !prevCustomErrors.includes(error);
        });
      };
      const filterNilOrEmptyErrors = (errors, previousCustomValidateErrors = {}) => {
        _forEach(errors, (errorAtKey, errorKey) => {
          const prevCustomValidateErrorAtKey = previousCustomValidateErrors[errorKey];
          if (_isNil(errorAtKey) || Array.isArray(errorAtKey) && errorAtKey.length === 0) {
            delete errors[errorKey];
          } else if (utils.isObject(errorAtKey) && utils.isObject(prevCustomValidateErrorAtKey) && Array.isArray(prevCustomValidateErrorAtKey?.__errors)) {
            errors[errorKey] = filterPreviousCustomErrors(errorAtKey.__errors, prevCustomValidateErrorAtKey.__errors);
          } else if (typeof errorAtKey === "object" && !Array.isArray(errorAtKey.__errors)) {
            filterNilOrEmptyErrors(errorAtKey, previousCustomValidateErrors[errorKey]);
          }
        });
        return errors;
      };
      return filterNilOrEmptyErrors(filteredErrors, prevCustomValidateErrors);
    }
    /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
     * the array only contains a single pending change.
     *
     * @param newValue - The new form data from a change to a field
     * @param [path] - The path to the change into which to set the formData
     * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
     * @param [id] - The id of the field that caused the change
     */
    onChange = (newValue, path, newErrorSchema, id) => {
      this.pendingChanges.push({ newValue, path, newErrorSchema, id });
      if (this.pendingChanges.length === 1) {
        this.processPendingChange();
      }
    };
    /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
     * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
     * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
     * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
     * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
     * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
     * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
     * specified, with the updated state and the `processPendingChange()` function is called again.
     */
    processPendingChange() {
      if (this.pendingChanges.length === 0) {
        return;
      }
      const { newValue, path, id } = this.pendingChanges[0];
      let { newErrorSchema } = this.pendingChanges[0];
      const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange, idPrefix = "" } = this.props;
      const { formData: oldFormData, schemaUtils, schema, errorSchema } = this.state;
      const isRootPath = !path || path.length === 0 || path.length === 1 && path[0] === idPrefix;
      let retrievedSchema = this.state.retrievedSchema;
      let formData = isRootPath ? newValue : _cloneDeep(oldFormData);
      if (utils.isObject(formData) || Array.isArray(formData)) {
        if (!isRootPath) {
          set(formData, path, newValue);
        }
        const newState = this.getStateFromProps(this.props, formData, void 0, void 0, void 0, true);
        formData = newState.formData;
        retrievedSchema = newState.retrievedSchema;
      }
      const mustValidate = !noValidate && liveValidate;
      let state = { formData, schema };
      let newFormData = formData;
      if (omitExtraData === true && liveOmit === true) {
        newFormData = this.omitExtraData(formData);
        state = {
          formData: newFormData
        };
      }
      if (newErrorSchema && !isRootPath) {
        const errorSchemaCopy = _cloneDeep(errorSchema);
        set(errorSchemaCopy, path, newErrorSchema);
        newErrorSchema = errorSchemaCopy;
      }
      if (mustValidate && this.pendingChanges.length === 1) {
        const schemaValidation = this.validate(newFormData, schema, schemaUtils, retrievedSchema);
        let errors = schemaValidation.errors;
        let errorSchema2 = schemaValidation.errorSchema;
        const schemaValidationErrors = errors;
        const schemaValidationErrorSchema = errorSchema2;
        if (extraErrors) {
          const merged = utils.validationDataMerge(schemaValidation, extraErrors);
          errorSchema2 = merged.errorSchema;
          errors = merged.errors;
        }
        if (newErrorSchema) {
          const filteredErrors = this.filterErrorsBasedOnSchema(newErrorSchema, retrievedSchema, newFormData);
          errorSchema2 = utils.mergeObjects(errorSchema2, filteredErrors, "preventDuplicates");
        }
        state = {
          formData: newFormData,
          errors,
          errorSchema: errorSchema2,
          schemaValidationErrors,
          schemaValidationErrorSchema
        };
      } else if (!noValidate && newErrorSchema) {
        const errorSchema2 = extraErrors ? utils.mergeObjects(newErrorSchema, extraErrors, "preventDuplicates") : newErrorSchema;
        state = {
          formData: newFormData,
          errorSchema: errorSchema2,
          errors: utils.toErrorList(errorSchema2)
        };
      }
      this.setState(state, () => {
        if (onChange) {
          onChange({ ...this.state, ...state }, id);
        }
        this.pendingChanges.shift();
        this.processPendingChange();
      });
    }
    /**
     * If the retrievedSchema has changed the new retrievedSchema is returned.
     * Otherwise, the old retrievedSchema is returned to persist reference.
     * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
     *    avoiding the performance cost of recompiling the schema.
     *
     * @param retrievedSchema The new retrieved schema.
     * @returns The new retrieved schema if it has changed, else the old retrieved schema.
     */
    updateRetrievedSchema(retrievedSchema) {
      const isTheSame = utils.deepEquals(retrievedSchema, this.state?.retrievedSchema);
      return isTheSame ? this.state.retrievedSchema : retrievedSchema;
    }
    /**
     * Callback function to handle reset form data.
     * - Reset all fields with default values.
     * - Reset validations and errors
     *
     */
    reset = () => {
      const { onChange } = this.props;
      const newState = this.getStateFromProps(this.props, void 0);
      const newFormData = newState.formData;
      const state = {
        formData: newFormData,
        errorSchema: {},
        errors: [],
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      };
      this.setState(state, () => onChange && onChange({ ...this.state, ...state }));
    };
    /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
     * was provided.
     *
     * @param id - The unique `id` of the field that was blurred
     * @param data - The data associated with the field that was blurred
     */
    onBlur = (id, data) => {
      const { onBlur } = this.props;
      if (onBlur) {
        onBlur(id, data);
      }
    };
    /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
     * was provided.
     *
     * @param id - The unique `id` of the field that was focused
     * @param data - The data associated with the field that was focused
     */
    onFocus = (id, data) => {
      const { onFocus } = this.props;
      if (onFocus) {
        onFocus(id, data);
      }
    };
    /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
     * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
     * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
     * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
     * back the `onSubmit` callback if it was provided.
     *
     * @param event - The submit HTML form event
     */
    onSubmit = (event) => {
      event.preventDefault();
      if (event.target !== event.currentTarget) {
        return;
      }
      event.persist();
      const { omitExtraData, extraErrors, noValidate, onSubmit } = this.props;
      let { formData: newFormData } = this.state;
      if (omitExtraData === true) {
        newFormData = this.omitExtraData(newFormData);
      }
      if (noValidate || this.validateFormWithFormData(newFormData)) {
        const errorSchema = extraErrors || {};
        const errors = extraErrors ? utils.toErrorList(extraErrors) : [];
        this.setState(
          {
            formData: newFormData,
            errors,
            errorSchema,
            schemaValidationErrors: [],
            schemaValidationErrorSchema: {}
          },
          () => {
            if (onSubmit) {
              onSubmit({ ...this.state, formData: newFormData, status: "submitted" }, event);
            }
          }
        );
      }
    };
    /** Returns the registry for the form */
    getRegistry() {
      const {
        translateString: customTranslateString,
        uiSchema = {},
        experimental_componentUpdateStrategy = "customDeep"
      } = this.props;
      const { schema, schemaUtils } = this.state;
      const { fields: fields2, templates: templates2, widgets: widgets2, formContext, translateString } = getDefaultRegistry();
      return {
        fields: { ...fields2, ...this.props.fields },
        templates: {
          ...templates2,
          ...this.props.templates,
          ButtonTemplates: {
            ...templates2.ButtonTemplates,
            ...this.props.templates?.ButtonTemplates
          }
        },
        widgets: { ...widgets2, ...this.props.widgets },
        rootSchema: schema,
        formContext: this.props.formContext || formContext,
        schemaUtils,
        translateString: customTranslateString || translateString,
        globalUiOptions: uiSchema[utils.UI_GLOBAL_OPTIONS_KEY],
        experimental_componentUpdateStrategy
      };
    }
    /** Provides a function that can be used to programmatically submit the `Form` */
    submit = () => {
      if (this.formElement.current) {
        const submitCustomEvent = new CustomEvent("submit", {
          cancelable: true
        });
        submitCustomEvent.preventDefault();
        this.formElement.current.dispatchEvent(submitCustomEvent);
        this.formElement.current.requestSubmit();
      }
    };
    /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
     * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
     * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
     *
     * @param error - The error on which to focus
     */
    focusOnError(error) {
      const { idPrefix = "root", idSeparator = "_" } = this.props;
      const { property } = error;
      const path = _toPath(property);
      if (path[0] === "") {
        path[0] = idPrefix;
      } else {
        path.unshift(idPrefix);
      }
      const elementId = path.join(idSeparator);
      let field = this.formElement.current.elements[elementId];
      if (!field) {
        field = this.formElement.current.querySelector(`input[id^="${elementId}"`);
      }
      if (field && field.length) {
        field = field[0];
      }
      if (field) {
        field.focus();
      }
    }
    /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
     * If `onError` is provided, then it will be called with the list of errors.
     *
     * @param formData - The form data to validate
     * @returns - True if the form is valid, false otherwise.
     */
    validateFormWithFormData = (formData) => {
      const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = this.props;
      const { errors: prevErrors } = this.state;
      const schemaValidation = this.validate(formData);
      let errors = schemaValidation.errors;
      let errorSchema = schemaValidation.errorSchema;
      const schemaValidationErrors = errors;
      const schemaValidationErrorSchema = errorSchema;
      const hasError = errors.length > 0 || extraErrors && extraErrorsBlockSubmit;
      if (hasError) {
        if (extraErrors) {
          const merged = utils.validationDataMerge(schemaValidation, extraErrors);
          errorSchema = merged.errorSchema;
          errors = merged.errors;
        }
        if (focusOnFirstError) {
          if (typeof focusOnFirstError === "function") {
            focusOnFirstError(errors[0]);
          } else {
            this.focusOnError(errors[0]);
          }
        }
        this.setState(
          {
            errors,
            errorSchema,
            schemaValidationErrors,
            schemaValidationErrorSchema
          },
          () => {
            if (onError) {
              onError(errors);
            } else {
              console.error("Form validation failed", errors);
            }
          }
        );
      } else if (prevErrors.length > 0) {
        this.setState({
          errors: [],
          errorSchema: {},
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        });
      }
      return !hasError;
    };
    /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
     * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
     * same way as would happen on form submission.
     *
     * @returns - True if the form is valid, false otherwise.
     */
    validateForm() {
      const { omitExtraData } = this.props;
      let { formData: newFormData } = this.state;
      if (omitExtraData === true) {
        newFormData = this.omitExtraData(newFormData);
      }
      return this.validateFormWithFormData(newFormData);
    }
    /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
     * needed along with the submit button or any children of the form.
     */
    render() {
      const {
        children,
        id,
        idPrefix = "",
        idSeparator,
        className = "",
        tagName,
        name,
        method,
        target,
        action,
        autoComplete,
        enctype,
        acceptCharset,
        noHtml5Validate = false,
        disabled,
        readonly,
        formContext,
        showErrorList = "top",
        _internalFormWrapper
      } = this.props;
      const { schema, uiSchema, formData, errorSchema, idSchema } = this.state;
      const registry = this.getRegistry();
      const { SchemaField: _SchemaField } = registry.fields;
      const { SubmitButton: SubmitButton2 } = registry.templates.ButtonTemplates;
      const as = _internalFormWrapper ? tagName : void 0;
      const FormTag = _internalFormWrapper || tagName || "form";
      let { [utils.SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = utils.getUiOptions(uiSchema);
      if (disabled) {
        submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };
      }
      const submitUiSchema = { [utils.UI_OPTIONS_KEY]: { [utils.SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };
      return /* @__PURE__ */ jsxRuntime.jsxs(
        FormTag,
        {
          className: className ? className : "rjsf",
          id,
          name,
          method,
          target,
          action,
          autoComplete,
          encType: enctype,
          acceptCharset,
          noValidate: noHtml5Validate,
          onSubmit: this.onSubmit,
          as,
          ref: this.formElement,
          children: [
            showErrorList === "top" && this.renderErrors(registry),
            /* @__PURE__ */ jsxRuntime.jsx(
              _SchemaField,
              {
                name: idPrefix,
                schema,
                uiSchema,
                errorSchema,
                idSchema,
                idPrefix,
                idSeparator,
                formContext,
                formData,
                onChange: this.onChange,
                onBlur: this.onBlur,
                onFocus: this.onFocus,
                registry,
                disabled,
                readonly
              }
            ),
            children ? children : /* @__PURE__ */ jsxRuntime.jsx(SubmitButton2, { uiSchema: submitUiSchema, registry }),
            showErrorList === "bottom" && this.renderErrors(registry)
          ]
        }
      );
    }
  };
  function withTheme(themeProps) {
    return react.forwardRef(
      ({ fields: fields2, widgets: widgets2, templates: templates2, ...directProps }, ref) => {
        fields2 = { ...themeProps?.fields, ...fields2 };
        widgets2 = { ...themeProps?.widgets, ...widgets2 };
        templates2 = {
          ...themeProps?.templates,
          ...templates2,
          ButtonTemplates: {
            ...themeProps?.templates?.ButtonTemplates,
            ...templates2?.ButtonTemplates
          }
        };
        return /* @__PURE__ */ jsxRuntime.jsx(
          Form,
          {
            ...themeProps,
            ...directProps,
            fields: fields2,
            widgets: widgets2,
            templates: templates2,
            ref
          }
        );
      }
    );
  }

  // src/index.ts
  var index_default = Form;

  exports.RichDescription = RichDescription;
  exports.default = index_default;
  exports.getDefaultRegistry = getDefaultRegistry;
  exports.withTheme = withTheme;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
